!> *******************************************************************
!! PROGRAM DYNAC
!! THIS SOFTWARE WAS ORIGINALLY PRODUCED AT CERN/PS, CEN/SACLAY
!!
!! @version V8R0
!! @date 16-Dec-2025
!!
!! Modified and maintained by :
!! Eugene Tanke                     
!!
!! THIS SOFTWARE WAS ORIGINALLY PRODUCED AT CERN/PS AND CEN/SACLAY
!! @author the late P. LAPOSTOLLE  CONSULTANT (Paris, France)													 
!! @author          S. VALERO      CONSULTANT (Strassbourg, France)
!! @author          E. TANKE       SCKCEN (Mol, Belgium)
!!
!< *******************************************************************
MODULE DynacConstants
!---------------------------------------------------------------------
!  Module containing definitions of constants needed by DYNAC
!---------------------------------------------------------------------
!   use, intrinsic :: ISO_FORTRAN_ENV, only : real64
   INTEGER, PARAMETER :: iptsz=10000002, maxcell1=3000
!  COMMON /CONSTA/ VL, PI, XMAT, RPEL, QST, FPREC
   REAL(8), PARAMETER :: VL=2.99792458D10, PI=4.D0*ATAN(1.D0)
!   REAL(8), PARAMETER :: RPEL=28.17938D-14
   REAL(8), PARAMETER :: RPEL=28.17938D-14, FPREC=epsilon(PI)
   
!  common/const/pi2,sqpi,pwtpi,sqpi2,sq2pi
   REAL(8), PARAMETER :: pi2=pi*pi, sqpi=(pi/2.D0)**(1.5D0), pwtpi=(2.D0*pi)**(1.5D0)
   REAL(8), PARAMETER :: sqpi2=sqrt(pi/2.D0), sq2pi=sqrt(2.D0*pi)
!  COMMON/RADIA/TRT,RMOY,XINTF,CRAE
!  CRAE    : classical electron radius (cm)
   REAL(8), PARAMETER :: CRAE=2.81793910D-13, XINTF =0.86967D0
   
!  common/randu/ck(15),kmax
!  randu(j):contains the Chebitcheff coefficients Ck in table 20.
!  kmax is the total number of these coefficients(from 1)
   REAL(8) ck(15)
   DATA ck/.98933556D0,-.68838689D0,.28191718D0, &
          -.66389307D-01,.87406854D-02,-.59534602D-03, &
           .16300617D-04, 0.D0, 0.D0, 0.D0, 0.D0, 0.D0, &
          0.D0, 0.D0, 0.D0/
             
   INTEGER kmax             
   DATA kmax/7/
END MODULE DynacConstants
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMgrot
!---------------------------------------------------------------------
!  Module replacing common grot 
!---------------------------------------------------------------------
!  common/grot/rzot,izrot
   REAL(8) rzot
   LOGICAL izrot
END MODULE mCOMgrot
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMfrmacc
!---------------------------------------------------------------------
!  Module replacing common frmacc 
!---------------------------------------------------------------------
!  common/frmacc/fracc
   LOGICAL fracc
END MODULE mCOMfrmacc
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMisxpyp
!---------------------------------------------------------------------
!  Module replacing common isxpyp 
!---------------------------------------------------------------------
!  common/isxpyp/iflag
   INTEGER iflag
END MODULE mCOMisxpyp
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMtwcst
!---------------------------------------------------------------------
!  Module replacing common twcst 
!---------------------------------------------------------------------
!  COMMON/twcst/epsil
   REAL(8) epsil
END MODULE mCOMtwcst
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMnewref
!---------------------------------------------------------------------
!  Module replacing common newref 
!---------------------------------------------------------------------
!  common/newref/dephas,dewref,iref,irefw
   REAL(8) dephas,dewref
   INTEGER iref,irefw
END MODULE mCOMnewref
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMradia
!---------------------------------------------------------------------
!  Module replacing common radia 
!---------------------------------------------------------------------
!  COMMON/RADIA/TRT,RMOY
   REAL(8) TRT,RMOY
END MODULE mCOMradia
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMalin
!---------------------------------------------------------------------
!  Module replacing common ALIN 
!---------------------------------------------------------------------
!  COMMON/ALIN/XL,YL,XPL,YPL
   REAL(8) XL,YL,XPL,YPL
END MODULE mCOMalin
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMelq
!---------------------------------------------------------------------
!  Module replacing common ELQ 
!---------------------------------------------------------------------
!  COMMON/ELQ/inisk
   INTEGER inisk
END MODULE mCOMelq
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMpaths
!---------------------------------------------------------------------
!  Module replacing common paths 
!---------------------------------------------------------------------
!  common/paths/dpath
   character(len=256) :: dpath
END MODULE mCOMpaths
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMfiles
!---------------------------------------------------------------------
!  Module replacing common files 
!---------------------------------------------------------------------
! common/files/mcselect,mc
   LOGICAL mcselect
   character(len=2) :: mc       
END MODULE mCOMfiles
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMzones
!---------------------------------------------------------------------
!  Module replacing common zones 
!---------------------------------------------------------------------
!  common/zones/frms(6),nzone
   REAL(8) frms(6)
   INTEGER nzone
END MODULE mCOMzones
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMapel
!---------------------------------------------------------------------
!  Module replacing common apel 
!---------------------------------------------------------------------
!  common/apel/iapel
   INTEGER iapel
END MODULE mCOMapel
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMosys
!---------------------------------------------------------------------
!  Module replacing common osys 
!---------------------------------------------------------------------
!  common/osys/opsys,sepchar
   character(len=7) :: opsys       
   character(len=1) :: sepchar             
END MODULE mCOMosys
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMqfkd
!---------------------------------------------------------------------
!  Module replacing common qfkd 
!---------------------------------------------------------------------
!  common/qfkd/ityq
   LOGICAL ityq
END MODULE mCOMqfkd
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMrec
!---------------------------------------------------------------------
!  Module replacing common rec 
!---------------------------------------------------------------------
!  common/rec/irec
   INTEGER irec
END MODULE mCOMrec
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMdplt
!---------------------------------------------------------------------
!  Module replacing common DPLT 
!---------------------------------------------------------------------
!  COMMON/DPLT/ZDEB,ZFIN,YWMAX,YPMAX,RMSN
   REAL(8) ZDEB,ZFIN,YWMAX,YPMAX,RMSN
END MODULE mCOMdplt
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMprof
!---------------------------------------------------------------------
!  Module replacing common prof 
!---------------------------------------------------------------------
!  common/prof/car
   character(len=80) :: car
END MODULE mCOMprof
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMtranrs
!---------------------------------------------------------------------
!  Module replacing common tranrs 
!---------------------------------------------------------------------
!  common/tranrs/SA11,SA12,SA21,SA22,SACT11,SACT12,SACT21,SACT22
   REAL(8) SA11,SA12,SA21,SA22,SACT11,SACT12,SACT21,SACT22
END MODULE mCOMtranrs
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMblvl
!---------------------------------------------------------------------
!  Module replacing common blvl 
!---------------------------------------------------------------------
!  common/blvl/bflvl
   REAL(8) bflvl
END MODULE mCOMblvl
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMttfcb
!---------------------------------------------------------------------
!  Module replacing common TTFCB 
!---------------------------------------------------------------------
!  COMMON/TTFCB/T3K,T4K,S3K,S4K
   REAL(8) T3K,T4K,S3K,S4K
END MODULE mCOMttfcb
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMsole
!---------------------------------------------------------------------
!  Module replacing common SOLE
!---------------------------------------------------------------------
!  COMMON/SOLE/L,KL,KO
   REAL(8) L,KL,KO
END MODULE mCOMsole
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMslq
!---------------------------------------------------------------------
!  Module replacing common SLQ 
!---------------------------------------------------------------------
!  COMMON/SLQ/L,KSO,KQO
   REAL(8) L,KSO,KQO
END MODULE mCOMslq
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMedef
!---------------------------------------------------------------------
!  Module replacing common edef 
!---------------------------------------------------------------------
!  common /edef/avb,drad,kx2,ky2,l
   REAL(8) avb,drad,kx2,ky2,l
END MODULE mCOMedef
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMcorec
!---------------------------------------------------------------------
!  Module replacing common corec 
!---------------------------------------------------------------------
!  common/corec/tref1
   REAL(8) tref1
END MODULE mCOMcorec
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMqskew
!---------------------------------------------------------------------
!  Module replacing common qskew 
!---------------------------------------------------------------------
!  common/qskew/qtwist,iqrand,itwist,iaqu
   REAL(8) qtwist
   INTEGER iqrand,iaqu
   LOGICAL ITWIST
END MODULE mCOMqskew
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMkcell
!---------------------------------------------------------------------
!  Module replacing common kcell 
!---------------------------------------------------------------------
!  common/kcell/avrg(15)
   REAL(8) avrg(15)
END MODULE mCOMkcell
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMstep
!---------------------------------------------------------------------
!  Module replacing common step 
!---------------------------------------------------------------------
!  common/step/istep
   INTEGER istep
END MODULE mCOMstep
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMxitrd3
!---------------------------------------------------------------------
!  Module replacing common xitrd3 
!---------------------------------------------------------------------
!  common/xitrd3/bcour1(15),bcour2(15),tr3dw(15),tr3ph(15),t0tr3d(15)
   REAL(8) bcour1(15),bcour2(15),tr3dw(15),tr3ph(15),t0tr3d(15)
END MODULE mCOMxitrd3
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMsphi
!---------------------------------------------------------------------
!  Module replacing common sphi 
!---------------------------------------------------------------------
!  common/sphi/tcour1(15),tcour2(15)
   REAL(8) tcour1(15),tcour2(15)
END MODULE mCOMsphi
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMelec
!---------------------------------------------------------------------
!  Module replacing common elec 
!---------------------------------------------------------------------
!  common/elec/jelec
   LOGICAL jelec
END MODULE mCOMelec
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMtestref
!---------------------------------------------------------------------
!  Module replacing common TESTREF 
!---------------------------------------------------------------------
!  common/TESTREF/trefs,ddw
   REAL(8) trefs,ddw
END MODULE mCOMtestref
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMxposi
!---------------------------------------------------------------------
!  Module replacing common xposi 
!---------------------------------------------------------------------
!  common/xposi/xpost(10),xlce(2),xpax(2),iscx(2)
   REAL(8) xpost(10),xlce(2),xpax(2)
   INTEGER iscx(2)
END MODULE mCOMxposi
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMbonda
!---------------------------------------------------------------------
!  Module replacing common bonda 
!---------------------------------------------------------------------
!  common/bonda/cbx(500),bbx(500),ablx(500),cby(500),bby(500),ably(500)
   REAL(8) cbx(500),bbx(500),ablx(500),cby(500),bby(500),ably(500)
END MODULE mCOMbonda
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMrms_prfl
!---------------------------------------------------------------------
!  Module replacing common rms_prfl 
!---------------------------------------------------------------------
!  common/rms_prfl/npt,npf
   INTEGER npt,npf
END MODULE mCOMrms_prfl
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMrfqwdst
!---------------------------------------------------------------------
!  Module replacing common rfqwdst 
!---------------------------------------------------------------------
!  common/rfqwdst/rfqwfil,rfqirec,rfqiflg,iwcl(20),nrwc,iflgr,rfqmidcell,rfqmaecell
   character(len=256) :: rfqwfil
   logical rfqmidcell,rfqmaecell
   INTEGER rfqirec,rfqiflg,iwcl(20),nrwc,iflgr
END MODULE mCOMrfqwdst
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMtrfq
!---------------------------------------------------------------------
!  Module replacing common trfq 
!---------------------------------------------------------------------
!  common/trfq/icour,ncell
   INTEGER icour,ncell
END MODULE mCOMtrfq
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMcavdata
!---------------------------------------------------------------------
!  Module replacing common cavdata 
!---------------------------------------------------------------------
!  common/cavdata/cavprt
   character(len=512), dimension(15) :: cavprt       
END MODULE mCOMcavdata
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMchafui
!---------------------------------------------------------------------
!  Module replacing common CHAFUI 
!---------------------------------------------------------------------
!   COMMON/CHAFUI/ XE,XS,CE(MCOEF),CS(MCOEF),QCE(MCOEF),QCS(MCOEF)
!   PARAMETER(MCOEF=6)  
   REAL(8) XE,XS,CE(6),CS(6),QCE(6),QCS(6)
END MODULE mCOMchafui
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMmultpl
!---------------------------------------------------------------------
!  Module replacing common MULTPL 
!---------------------------------------------------------------------
!   COMMON/MULTPL/ BM(MPOL),DLE(MPOL),DLS(MPOL),DI(MPOL,MCOEF),DS(MPOL,MCOEF),RTB(MPOL)
!   COMMON/MULTPL/ BM(MPOL),DLE(MPOL),DLS(MPOL),DE(MPOL,MCOEF),DS(MPOL,MCOEF),RTB(MPOL)
!   PARAMETER(MPOL=10)  
!   PARAMETER(MCOEF=6)  
   REAL(8) BM(10),DLE(10),DLS(10),DI(10,6),DS(10,6),RTB(10)
END MODULE mCOMmultpl
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMmultpe
!---------------------------------------------------------------------
!  Module replacing common MULTPE 
!---------------------------------------------------------------------
!   COMMON/MULTPE/ EM(MPOL),QLE(MPOL),QLS(MPOL),QI(MPOL,MCOEF),QS(MPOL,MCOEF),RTQ(MPOL)
!   PARAMETER(MPOL=10)  
!   PARAMETER(MCOEF=6)  
   REAL(8) EM(10),QLE(10),QLS(10),QI(10,6),QS(10,6),RTQ(10)
END MODULE mCOMmultpe
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE mCOMwfchamp
!---------------------------------------------------------------------
!  Module replacing common WFCHAMP 
!---------------------------------------------------------------------
!   COMMON/WFCHAMP/ BZ0(5,5), EZ0(5,5)
   REAL(8) BZ0(5,5), EZ0(5,5)
END MODULE mCOMwfchamp
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m_h_t_h1_t1
!---------------------------------------------------------------------
!  Module containing definitions for RESTAY and ETGAP 
!---------------------------------------------------------------------
!  COMMON/gaus13/H(13),T(13)
   REAL(8) H(13),T(13)
   DATA H /.040484004D0,.092121499D0,.138873510D0,.178145981D0, &
               .207816048D0,.226283180D0,.232551553D0,.226283180D0, &
               .207816048D0,.178145981D0,.138873510D0,.092121499D0, &
               .040484004D0/
   DATA T /-.984183055D0,-.917598399D0,-.801578091D0, &
               -.642349339D0,-.448492751D0,-.230458316D0, 0.D0, &
                .230458316D0, .448492751D0, .642349339D0,  .801578091D0, &
                .917598399D0, .984183055D0/
!  common/gaus17/H1(17),T1(17)
   REAL(8) H1(17),T1(17)
   DATA H1 /-.990575473D0,-.950675522D0,-.880239154D0, &
                -.781514004D0,-.657671159D0,-.512690537D0, &
                -.351231763D0,-.178484181D0,  0.D0, &
                 .178484181D0, .351231763D0,.512690537D0, &
                 .657671159D0, .781514004D0,.880239154D0, &
                 .950675522D0, .990575473D0/
   DATA T1 /.024148303D0,.055459529D0,.085036148D0, &
                .111883847D0,.135136368D0,.154045761D0, &
                .168004102D0,.176562705D0,.179446470D0, &
                .176562705D0,.168004102D0,.154045761D0, &
                .135136368D0,.111883847D0,.085036148D0, &
                .055459529D0,.024148303D0/
END MODULE m_h_t_h1_t1
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4trace3d
!---------------------------------------------------------------------
!  Module containing definitions for TRACE3D related stuff
!---------------------------------------------------------------------
   USE DynacConstants, ONLY : maxcell1
!   common/trace3d/trace3h,trace3t,tif,kt3h,kt3t,fid
   character(len=128) :: trace3h(100),trace3t(maxcell1),tif,tifa,tifb
   INTEGER kt3h, kt3t
   REAL(8) fid
!   common/t3dfld/fldctr,zend,T3D
   REAL(8) fldctr(15),zend(15)
   logical T3D,xiset
!   common/trace3e/tracebi(6),traceei(3)
   REAL(8) tracebi(6),traceei(3)
!  itout corresponds to TRACE3D input file
   INTEGER, PARAMETER :: itout=48
END MODULE m4trace3d
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4chase
!---------------------------------------------------------------------
!  Module containing definitions for CHASE related stuff
!---------------------------------------------------------------------
   USE DynacConstants, ONLY : iptsz
!       common/etchas/fractx,fracty,fractl
   REAL(8) fractx,fracty,fractl
!       COMMON/etcha1/ichas(iptsz),chexmin(10),chexmax(10),chasit
!   INTEGER ichas(iptsz)
   INTEGER, allocatable ::  ichas(:)
   REAL(8) chexmin(10),chexmax(10)
   LOGICAL CHASIT
!       common/etcha3/ichxyz(iptsz)
!   INTEGER ichxyz(iptsz)
   INTEGER, allocatable ::  ichxyz(:)   
!   common/pool/zl(iptsz),ipin(iptsz)
!   REAL(8) zl(iptsz)
   REAL(8), allocatable ::  zl(:)   
!   INTEGER ipin(iptsz)
   INTEGER, allocatable ::  ipin(:)   
END MODULE m4chase
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4beam
!---------------------------------------------------------------------
!  Module containing definitions for beam related stuff
!---------------------------------------------------------------------
   USE DynacConstants, ONLY : iptsz
!   COMMON/DYN/TREF,VREF
   REAL(8) TREF,VREF
!   common/faisc/f(10,iptsz),imax,ngood
   REAL(8), allocatable ::  f(:,:)
   INTEGER imax,ngood
!   common/objet/fo(9,iptsz),imaxo
   REAL(8), allocatable ::  fo(:,:)
   INTEGER imaxo
!   COMMON/HISTO/CENTRE(6)
   REAL(8) CENTRE(6)
!   COMMON/QMOYEN/QMOY
   REAL(8) QMOY
!   COMMON/RIGID/BORO
   REAL(8) BORO
!   common/etcom/cog(8),exten(17),fd(iptsz)
!   REAL(8) cog(8),exten(17),fd(iptsz)
   REAL(8) cog(8),exten(36)
   REAL(8), allocatable ::  fd(:)
!   COMMON/DYNI/VREFI,TREFI,FHINIT,ACPT
   REAL(8) VREFI,TREFI,FHINIT
   logical acpt
!   common/tof/tofini
   REAL(8) tofini
   REAL(8) QST, XMAT
!   common/fcont/scseprms,ifcont
   REAL(8) scseprms
   logical ifcont
! halo parameter in for H, V and L planes
   REAL(8) halox,haloy,haloz           
! 4d emittance (covers H and V planes)
   REAL(8) emit4d           
END MODULE m4beam
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4beam2
!---------------------------------------------------------------------
!  Module containing additional definitions for beam related stuff
!---------------------------------------------------------------------
   USE DynacConstants, ONLY : iptsz
!   COMMON /COM4/CORD(IPTSZ,6)
!   REAL(8) CORD(IPTSZ,6)
   REAL(8), allocatable ::  CORD(:,:)
!   common/ranec1/dummy(6)
   REAL(8) dummy(6)
!   COMMON/newtlt/twissa(3),itwiss
   REAL(8) twissa(3)
   INTEGER itwiss
!   common/ragau/ntir
   INTEGER ntir
!   common/disttype/bindst   
   logical bindst         
END MODULE m4beam2
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4mcs
!---------------------------------------------------------------------
!  Module containing definitions for the multiple charge state case
!---------------------------------------------------------------------
!   common/mcs/imcs,ncstat,cstat(20)
   REAL(8) cstat(20)
   INTEGER imcs,ncstat
!   common/strip/atm,qs,atms,ths,qop,sqst(20),anp,nqst
   REAL(8) atm,qs,atms,ths,qop,sqst(20),anp
   INTEGER nqst
!   common/cgtof/charm(20),cgtdv(20),nbch(20),netac
   REAL(8) charm(20),cgtdv(20)
   INTEGER nbch(20),netac
END MODULE m4mcs
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4input
!---------------------------------------------------------------------
!  Module containing definitions needed for input files
!---------------------------------------------------------------------
!   common/tapes/in,ifile,meta,ierr
   INTEGER in,ifile,meta,ierr
END MODULE m4input
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4output
!---------------------------------------------------------------------
!  Module containing definitions needed for output files
!---------------------------------------------------------------------
   USE DynacConstants, ONLY : maxcell1
!   COMMON/DAVCOM/dav1(maxcell1,40),davtot,iitem(maxcell1),idav
   REAL(8) dav1(maxcell1,40),davtot
   INTEGER iitem(maxcell1),idav
!   common/speda/dave,idave
   INTEGER idave
   logical dave  
!   common/dmp/dmpdat(14)
   REAL(8) dmpdat(14) 
END MODULE m4output
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4cavs
!---------------------------------------------------------------------
!  Module containing definitions needed for cavities
!---------------------------------------------------------------------
!   TRANSIT TIME COEFFICIENTS
!   COMMON/TTFC/TK,T1K,T2K,SK,S1K,S2K,FH
   REAL(8) TK,T1K,T2K,SK,S1K,S2K,FH
!   COMMON/COMPT/NRRES,NRTRE,NRBUNC,NRDBUN
   INTEGER NRRES,NRTRE,NRBUNC,NRDBUN
!   common/compt1/ndtl,ncavmc,ncavnm
   INTEGER ndtl,ncavmc,ncavnm   
END MODULE m4cavs
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4cavs2
!---------------------------------------------------------------------
!  Module containing additional definitions needed for cavities
!---------------------------------------------------------------------
!   common/aerp/vphase,vfield,ierpf
   REAL(8) vphase,vfield
   INTEGER ierpf
END MODULE m4cavs2
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4numcavs
!---------------------------------------------------------------------
!  Module containing definitions needed for cavities (num. method)
!---------------------------------------------------------------------
!       common/cavnum1/xnh,xpas,fmult,npt
   REAL(8) xnh,xpas,fmult
   INTEGER npt
!       common/cavnum2/b0,b1,b2,b3,b4,b5
   REAL(8) b0,b1,b2,b3,b4,b5
!       common/cavnum3/bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
   REAL(8) bgt0,bgt1,bgt2,bgt3,bgt4,bgt5
!       common/cavnum4/bge0,bge1,bge2,bge3,bge4,bge5
   REAL(8) bge0,bge1,bge2,bge3,bge4,bge5
!       common/cavnum5/tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
   REAL(8) tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
!       common/cavnum6/fpos0,fpos1,fpos2,fpos3,fpos4,fpos5       
   REAL(8) fpos0,fpos1,fpos2,fpos3,fpos4,fpos5       
!       common/cavnum7/sspl0,sspl1,sspl2,sspl3,sspl4,sspl5       
   REAL(8) sspl0,sspl1,sspl2,sspl3,sspl4,sspl5
END MODULE m4numcavs
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4cavsc
!---------------------------------------------------------------------
!  Module containing definitions needed for CAVSC
!---------------------------------------------------------------------
!   parameter (maxcell=3000)
   INTEGER, PARAMETER :: maxcell=3000
!   COMMON/TTFS/DYNT(MAXCELL),DYNTP(MAXCELL),DYNTPP(MAXCELL), &
!               DYNE0(MAXCELL),DYNPH(MAXCELL),DYNLG(MAXCELL),FHPAR,NC

   REAL(8) DYNT(MAXCELL),DYNTP(MAXCELL),DYNTPP(MAXCELL), &
           DYNE0(MAXCELL),DYNPH(MAXCELL),DYNLG(MAXCELL),FHPAR
   INTEGER NC
END MODULE m4cavsc
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4gap
!---------------------------------------------------------------------
!  Module containing definitions needed for GAP etc
!---------------------------------------------------------------------
!   COMMON/TYPL1/YH1K0,YH1K1,YP1K1,YP1K2,YH1K00,YH1K01,YP1K01, &
!                YP1K02,YH10,YH11,YP11,YP12
   REAL(8) YH1K0,YH1K1,YP1K1,YP1K2,YH1K00,YH1K01,YP1K01, &
                 YP1K02,YH10,YH11,YP11,YP12
!   COMMON/TYPL2/YH2K0,YH2K1,YP2K1,YP2K2,YH2K00,YH2K01,YP2K01, &
!                YP2K02,YH20,YH21,YP21,YP22
   REAL(8) YH2K0,YH2K1,YP2K1,YP2K2,YH2K00,YH2K01,YP2K01, &
                 YP2K02,YH20,YH21,YP21,YP22
!   COMMON/TYPI1/YE1K0,YE1K1,YE1K2,YE1KC0,YE1KC1,YE1KC2, &
!                YE10,YE11,YE12
   REAL(8) YE1K0,YE1K1,YE1K2,YE1KC0,YE1KC1,YE1KC2,YE10,YE11,YE12
!   COMMON/TYPI2/YE2K0,YE2K1,YE2K2,YE2KC0,YE2KC1,YE2KC2, &
!                YE20,YE21,YE22
   REAL(8) YE2K0,YE2K1,YE2K2,YE2KC0,YE2KC1,YE2KC2,YE20,YE21,YE22
!   COMMON/TYPLP1/YH1P1,YH2P1,HAPI,HBPI
   REAL(8) YH1P1,YH2P1,HAPI,HBPI
!   COMMON/TYPLP2/HAPPI,HBPPI
   REAL(8) HAPPI,HBPPI
!   COMMON/TYPLPK/YH10PK,YH11PK,YH20PK,YH21PK
   REAL(8) YH10PK,YH11PK,YH20PK,YH21PK
!   COMMON/TYPJ/YFSK0,YFSK1,YFSK2,YFSP0,YFSP1,YFSP2, &
!               YFSKC0,YFSKC1,YFSKC2,YFSCK0,YFSCK1,YFSCK2, &
!               YFSCP0,YFSCP1,YFSCP2,YFS0,YFS1,YFS2
   REAL(8) YFSK0,YFSK1,YFSK2,YFSP0,YFSP1,YFSP2,YFSKC0,YFSKC1,YFSKC2, &
           YFSCK0,YFSCK1,YFSCK2,YFSCP0,YFSCP1,YFSCP2,YFS0,YFS1,YFS2
!   COMMON/TYPM/YNSK0,YNSK1,YNSK2,YNSP0,YNSP1,YNSP2, &
!               YNSK0C,YNSK1C,YNSK2C,YNS0,YNS1,YNS2
   REAL(8) YNSK0,YNSK1,YNSK2,YNSP0,YNSP1,YNSP2,YNSK0C,YNSK1C,YNSK2C, &
           YNS0,YNS1,YNS2
!   COMMON/THAD2/H0AKI,H0AKIM,H0AKM,H0BKI,H0BKIM,H0BKM, &
!                H1AKI,H1AKIM,H1AKM,H1BKI,H1BKIM,H1BKM
   REAL(8) H0AKI,H0AKIM,H0AKM,H0BKI,H0BKIM,H0BKM,H1AKI,H1AKIM,H1AKM, &
           H1BKI,H1BKIM,H1BKM
END MODULE m4gap
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4gap2
!---------------------------------------------------------------------
!  Module containing additional definitions needed for GAP etc
!---------------------------------------------------------------------
!   COMMON/JACOB/GAKS,GAPS
   REAL(8) GAKS,GAPS
!   COMMON/POSI/IST
   INTEGER IST
!   common/appel/irstay,ilost,iavp,ispcel
   LOGICAL irstay,iavp,ispcel
   INTEGER ilost    
END MODULE m4gap2
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4gap3
!---------------------------------------------------------------------
!  Module containing additional definitions needed for GAP etc
!---------------------------------------------------------------------
!   common/pstpla/tstp
   REAL(8) tstp
END MODULE m4gap3
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4gapiter
!---------------------------------------------------------------------
!  Module containing additional definitions needed for GAP etc
!---------------------------------------------------------------------
!   common/iter1/DXDKI,DPHII,PHI,DKMSKE,DKMSPHI,RETPH,XKMI,XKM, &
!                DXK00,TKE,T1KE,SKE,S1KE,PHIWC,XK1I,XK1II,XK2II
   REAL(8) DXDKI,DPHII,PHI,DKMSKE,DKMSPHI,RETPH,XKMI,XKM, &
                 DXK00,TKE,T1KE,SKE,S1KE,PHIWC,XK1I,XK1II,XK2II
!   common/iterco/YH11T,YH1K1T,YH1K01T,YH10PKT,YH11PKT,YH1P1T, &
!                  H1AKIT,H1AKIMT,H1AKMT,HAPIT,HAPPIT
   REAL(8) YH11T,YH1K1T,YH1K01T,YH10PKT,YH11PKT,YH1P1T, &
                   H1AKIT,H1AKIMT,H1AKMT,HAPIT,HAPPIT
!   common/itersi/YH21T,YH2K1T,YH2K01T,YH2P1T,YH20PKT,YH21PKT, &
!                  H1BKIT,H1BKIMT,H1BKMT,HBPIT,HBPPIT
   REAL(8) YH21T,YH2K1T,YH2K01T,YH2P1T,YH20PKT,YH21PKT, &
                   H1BKIT,H1BKIMT,H1BKMT,HBPIT,HBPPIT
END MODULE m4gapiter
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4rfq
!---------------------------------------------------------------------
!  Module containing definitions needed for an RFQ
!---------------------------------------------------------------------
!   common/rf1ptq/tvolt,avolt,fph,mlc,nceltot
   REAL(8) tvolt,avolt,fph
   INTEGER mlc,nceltot
!   common/rf2ptq/rfq1(500),rfq2(500),rfq3(500),rfq4(500),rfq6(500) &
!                ,rfq7(500),rfq8(500),rfq9(500)
   REAL(8) rfq1(500),rfq2(500),rfq3(500),rfq4(500),rfq6(500),rfq7(500),rfq8(500),rfq9(500)
!   common/rf5ptq/tdvolt,rfq10(500),rfq11(500),rfq12(500)
   REAL(8) tdvolt,rfq10(500),rfq11(500),rfq12(500)
!   common/rfq4ptq/rfq21(500),rfq22(500),rfq23(500),rfq25(500),ipol(500)        
   REAL(8) rfq21(500),rfq22(500),rfq23(500),rfq25(500)          
!   common/rfq3ptq/itype(500),ipari(500),evens,evenr
   INTEGER itype(500),ipari(500),ipol(500)
   LOGICAL evens,evenr
END MODULE m4rfq
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4spacecharge
!---------------------------------------------------------------------
!  Module containing definitions needed for space charge
!---------------------------------------------------------------------
   USE DynacConstants, ONLY : iptsz
!   COMMON/SC3/BEAMC,SCDIST,SCE10,CPLM,ECT,APL,ICHAES,ISCSP
   REAL(8) BEAMC,SCDIST,SCE10,CPLM,ECT,APL
   LOGICAL ICHAES
   INTEGER ISCSP
!   common/posc/xpsc
   REAL(8) xpsc
!   COMMON/DCSPA/IESP
   LOGICAL iesp
END MODULE m4spacecharge
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4plots
!---------------------------------------------------------------------
!  Module containing definitions needed for plots
!---------------------------------------------------------------------
!   COMMON/PLTPRF/SPRFX(3000),SPRFY(3000),SPRFL(3000),SPRFW(3000), &
!                 SPRFP(3000),SPRNG(3000),PRLAB(3000),IPRF,ELNAM(3000)
   REAL(8) SPRFX(3000),SPRFY(3000),SPRFL(3000),SPRFW(3000)
   REAL(8) SPRFP(3000),SPRNG(3000)   
   INTEGER IPRF,idflio(1000),nodflocs,idflg
   character(len=8) :: PRLAB(3000)
!   common/dflocations/dflnames(1000),idflio(1000),nodflocs,idflg   
!   COMMON/NAMECOM/uden      
   character(len=80) :: ELNAM(3000),uden,dflnames(1000)    
!   COMMON/GRPARM/GLIM(4,2),GLIM1(4,2),GLIM2(4,2),PATITL, &
!                 ngraphs(100),idwdp,igrprm,ngrafs
   REAL(8) GLIM(4,2),GLIM1(4,2),GLIM2(4,2)
   character(len=80) :: patitl
   INTEGER ngraphs(100),idwdp,igrprm,ngrafs 
!   common/pltprf1/sprww(3000),eprfw(3000),eprnx(3000),eprny(3000), &
!                  sprfz(3000)
   REAL(8) sprww(3000),eprfw(3000),eprnx(3000),eprny(3000),sprfz(3000)
!   common/pltprf2/sxmn(3000),sxmx(3000),symn(3000),symx(3000), &
!                  stmn(3000),stmx(3000),spmn(3000),spmx(3000), &
!                  swmn(3000),swmx(3000),disprx(3000),dispry(3000), &
!                  dispcx(3000),dispcy(3000),sdwbeam(3000),swref(3000), &
!                  stref(3000),stcog(3000),sxbar(3000),sybar(3000), &
!                  twax(3000),twbx(3000),tway(3000),twby(3000), &
!                  twaz(3000),twbz(3000),sprft(3000), &
!                  aaperx(3000),aapery(3000),aaperr(3000)
   REAL(8) sxmn(3000),sxmx(3000),symn(3000),symx(3000),stmn(3000),stmx(3000), &
           spmn(3000),spmx(3000),swmn(3000),swmx(3000),disprx(3000),dispry(3000), &
           dispcx(3000),dispcy(3000),sdwbeam(3000),swref(3000), &
           stref(3000),stcog(3000),sxbar(3000),sybar(3000), &
           twax(3000),twbx(3000),tway(3000),twby(3000),twaz(3000),twbz(3000), &
           sprft(3000),aaperx(3000),aapery(3000),aaperr(3000), &
           shalox(3000),shaloy(3000),shaloz(3000),semit4d(3000)
END MODULE m4plots
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4scheff
!---------------------------------------------------------------------
!  Module containing definitions needed for scheff
!---------------------------------------------------------------------
!   common/rcshef/sce(20)
   REAL(8) sce(20)
!   common/stsc/beami,wavel,freq,btazero,frrms,fzrms,nr,nz
   REAL(8) beami,wavel,freq,btazero,frrms,fzrms
   INTEGER nr,nz
!   common/stsc1/beams,im1,im2,im3,nr1,nz1,nq
   REAL(8) beams
   INTEGER im1,im2,im3,nr1,nz1,nq
!   common/fldcom/ rp, zp,pl,opt,nip
   REAL(8) rp,zp,pl,opt
   INTEGER nip
END MODULE m4scheff
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4scheff2
!---------------------------------------------------------------------
!  Module containing additional definitions needed for scheff
!---------------------------------------------------------------------
!   common/bg/bsc,gsc,phis,wsync
   REAL(8) bsc,gsc,phis,wsync
!   common/spacech1/ rm(21), zm(41), rs(20), ers(16800), &
!                    ezs(16800), ez(861), aa(800), rssq(20), zzs(41),&
!                    er(861),rss(20), ismax(40), iemax(41)
   REAL(8) rm(21),zm(41),rs(20),ers(16800),ezs(16800),ez(861), &
           aa(800),rssq(20),zzs(41),er(861),rss(20)
   INTEGER ismax(40),iemax(41)   
!   common/conti/irfqp
   LOGICAL irfqp
END MODULE m4scheff2
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4scherm
!---------------------------------------------------------------------
!  Module containing definitions needed for scherm
!---------------------------------------------------------------------
!       COMMON/HERMT/AFXT(22),AFYT(22),AFZT(22)
   REAL(8) AFXT(22),AFYT(22),AFZT(22)
!       COMMON/HERMD/AFXM(20),AFYM(20),AFZM(20)
   REAL(8) AFXM(20),AFYM(20),AFZM(20)
!       COMMON/HERMR/AFXR(20),AFYR(20),AFZR(20)
   REAL(8) AFXR(20),AFYR(20),AFZR(20)
END MODULE m4scherm
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4scherm2
!---------------------------------------------------------------------
!  Module containing definitions needed for scherm
!---------------------------------------------------------------------
!       COMMON/SIZT/XRMS,YRMS,ZRMS
   REAL(8) XRMS,YRMS,ZRMS
!       COMMON/SIZP/XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2,IMAXD
   REAL(8) XRMS1,YRMS1,ZRMS1,XRMS2,YRMS2,ZRMS2
   INTEGER IMAXD
!       COMMON/SIZR/XRMS3,YRMS3,ZRMS3,ZCGR3
   REAL(8) XRMS3,YRMS3,ZRMS3,ZCGR3
END MODULE m4scherm2
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4scherm3
!---------------------------------------------------------------------
!  Module containing definitions needed for scherm
!---------------------------------------------------------------------
!       COMMON/CGRMS/xsum,ysum,zsum
   REAL(8) xsum,ysum,zsum
!       COMMON/INTGRT/ex,ey,ez
   REAL(8) ex,ey,ez
!   COMMON/NPART/IMAXR
   INTEGER IMAXR   
END MODULE m4scherm3
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4hersc
!---------------------------------------------------------------------
!  Module containing definitions needed for hersc
!---------------------------------------------------------------------
!       common/rms/rms(3,50),s1,s2,s3
   REAL(8) rms(3,50),s1,s2,s3
!       common/partcl/x,y,z
   REAL(8) x,y,z
!       common/cars3/exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
!         exs3=exp(-s3*s3/2),abs3=abs(s3),isgns3=sign s3,s32=s3*s3
!         pwas3=as3**(2(it1+it2+it3)+1)
   REAL(8) exs3,exs2,exs1,as3,sgns3,s32,pwas3,pw3as3
END MODULE m4hersc
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4hersc2
!---------------------------------------------------------------------
!  Module containing definitions needed for hersc
!---------------------------------------------------------------------
!       common/gauss1/absg(40),wg(40),igaus
   REAL(8) absg(40),wg(40)
   INTEGER igaus
!       common/circu/co(40,50),sn(40,50),blam(40,100)
   REAL(8) co(40,50),sn(40,50),blam(40,100)
!       common/comtab/hsint(40,2,60),sqblam(40),s3pw(15)
   REAL(8) hsint(40,2,60),sqblam(40),s3pw(15)
END MODULE m4hersc2
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4hersc3
!---------------------------------------------------------------------
!  Module containing definitions needed for hersc
!---------------------------------------------------------------------
!       common/herfun/hs1(60),hs2(60),hs3(60)
   REAL(8) hs1(60),hs2(60),hs3(60)
!       common/ftsk/stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
   REAL(8) stc1i(8,8,40),stc1p(8,8,40),stc2i(8,8),stc2p(8,8)
!       common/ftth/makti,maktp
   LOGICAL makti,maktp
END MODULE m4hersc3
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4hersc4
!---------------------------------------------------------------------
!  Module containing definitions needed for hersc
!---------------------------------------------------------------------
!       common/hass/carg(100),sarg(100),argip(100)
   REAL(8) carg(100),sarg(100),argip(100)
!       common/fssk/sstci(8,8),sstcp(8,8)
   REAL(8) sstci(8,8),sstcp(8,8)
!       common/fsth/maksi,maksp
   LOGICAL maksi,maksp
END MODULE m4hersc4
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4hersc5
!---------------------------------------------------------------------
!  Module containing definitions needed for hersc
!---------------------------------------------------------------------
!       common/uvtab/epsi1(40,40),epsi2(40,40),akpcc(40,40), &
!                  akpcs(40,40),akpsc(40,40),akpss(40,40)
   REAL(8) epsi1(40,40),epsi2(40,40),akpcc(40,40),akpcs(40,40),akpsc(40,40),akpss(40,40)
!       common/expmod/ragp(40,100),ragm1(40,40)
   REAL(8) ragp(40,100),ragm1(40,40)
!       common/uvint/arcc(40,40),arcs(40,40),arsc(40,40), &
!                    arss(40,40),cs(40)
   REAL(8) arcc(40,40),arcs(40,40),arsc(40,40),arss(40,40),cs(40)
END MODULE m4hersc5
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4hersc6
!---------------------------------------------------------------------
!  Module containing definitions needed for hersc
!---------------------------------------------------------------------
!       common/coef/a(30,30,30),xrmsz,yrmsz,zrmsz
!       common/coef/a(30,30,30),xa,xb,xc
   REAL(8) a(30,30,30),xrmsz,yrmsz,zrmsz
!       common/ind/lmax,mmax,nmax
   INTEGER lmax,mmax,nmax
!       common/indin/lmaxi,mmaxi,nmaxxi
   INTEGER lmaxi,mmaxi,nmaxxi
END MODULE m4hersc6
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4hersc7
!---------------------------------------------------------------------
!  Module containing definitions needed for hersc
!---------------------------------------------------------------------
!   common/hcgrms/xcdg,ycdg,zcdg,hect,eps
   REAL(8) xcdg,ycdg,zcdg,hect,eps
!   common/indttal/lmnt
   INTEGER lmnt
!   common/field/ex,ey,ez
   REAL(8) ex,ey,ez
!   common/facrms/fxrms,fyrms,fzrms
   REAL(8) fxrms,fyrms,fzrms
!   common/rcoef/rdcf
   REAL(8) rdcf
END MODULE m4hersc7
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4hersc8
!---------------------------------------------------------------------
!  Module containing definitions needed for hersc
!---------------------------------------------------------------------
!   common/macro/ratei
   REAL(8) ratei
!   common/nume/nuelm
   INTEGER nuelm
END MODULE m4hersc8
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4tmatrix
!---------------------------------------------------------------------
!  Module containing definitions needed for transport matrices
!---------------------------------------------------------------------
!   COMMON /BLOC11/ R(6,6), T(6,6,6)
   REAL(8) R(6,6), T(6,6,6)
!   COMMON/SECDR/ISEOR
   LOGICAL ISEOR
END MODULE m4tmatrix
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4RESTAY
!---------------------------------------------------------------------
!  Module containing definitions needed for RESTAY and functions
!  called by RESTAY
!---------------------------------------------------------------------
!   common/cell/yf(10000),xf(10000),xlim(15),flength,fhc,att, &
!               npoint(15),ncell
!   common/fcv/jsav
   REAL(8) yf(10000),xf(10000),xlim(15),flength,fhc,att
   INTEGER npoint(15),ncell,jsav
END MODULE m4RESTAY
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4RESTAYfun
!---------------------------------------------------------------------
!  Module containing additinal definitions needed for RESTAY and 
!  functions called by RESTAY and MHB
!---------------------------------------------------------------------
!   COMMON/FUNC/A(200),YLG,ATTE,NCEL,NHARM
!   common/rfield/ifield
   REAL(8) A(200),YLG,ATTE
   INTEGER NCEL,NHARM
   LOGICAL ifield
END MODULE m4RESTAYfun
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4MHBfun
!---------------------------------------------------------------------
!  Module containing additinal definitions needed for RESTAY and 
!  functions called by RESTAY
!---------------------------------------------------------------------
!   common/buspe/ampl(5),phz(5),ifreq
   REAL(8) ampl(5),phz(5)
   INTEGER ifreq
END MODULE m4MHBfun
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4SPLfun
!---------------------------------------------------------------------
!  Module containing definitions needed for spline functions
!---------------------------------------------------------------------
!   COMMON /SPL/   X(4000),   Y(4000),S(5000),P(5000),Q(5000)
!   COMMON /SPL/XSPL(4000),YSPL(4000),S(5000),P(5000),Q(5000)
   REAL(8) XSPL(4000),YSPL(4000),S(5000),P(5000),Q(5000)
END MODULE m4SPLfun
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4SPFFfun
!---------------------------------------------------------------------
!  Module containing definitions needed for spline functions
!---------------------------------------------------------------------
!   COMMON /SPFF/  X(400),   Y(400), S(500), P(500), Q(500)
!   common/spff/xspf(400),yspf(400),sf(500),pf(500),qf(500)
   REAL(8) XSPF(400),YSPF(400),SF(500),PF(500),QF(500)
END MODULE m4SPFFfun
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4rfqFBINT
!---------------------------------------------------------------------
!  Module containing definitions needed for RFQ cpardyn
!---------------------------------------------------------------------
!   common/fbint/thet(16),cthet(16),c3thet(16),c4thet(16),c5thet(16)
   REAL(8) thet(16),cthet(16),c3thet(16),c4thet(16),c5thet(16)
END MODULE m4rfqFBINT
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4gaprestay
!---------------------------------------------------------------------
!  Module containing definitions needed for ETGAP and RESTAY
!---------------------------------------------------------------------
!   COMMON/BEDYCP/PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2, &
!                  AA,BB,CC,DD,EE,PCREST,SQCTTF
   REAL(8) PHSLIP,EQVL,ASDL,PEQVL,PAVPH,XKP1,XKP2, &
           AA,BB,CC,DD,EE,PCREST,SQCTTF
END MODULE m4gaprestay
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4restayMIDGAP
!---------------------------------------------------------------------
!  Module containing definitions needed for RESTAY
!---------------------------------------------------------------------
!   COMMON/MIDGAP/ENMIL,VAPMI
   REAL(8) ENMIL,VAPMI
!   COMMON/AZMTCH/DLG,XMCPH,XMCE
   REAL(8) DLG,XMCPH,XMCE
!   COMMON/AZLIST/ICONT,IPRIN
   REAL(8) ICONT,IPRIN   
END MODULE m4restayMIDGAP
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4aimalv
!---------------------------------------------------------------------
!  Module containing definitions needed for AIMALV
!---------------------------------------------------------------------
!   common/isector/nsector,nsprint
! allow plotting the beam after sector nsprint 
   INTEGER nsector,nsprint
!   COMMON /BLOC21/ BE, APB(2), LAYL, LAYX, RABT
   REAL(8) BE, APB(2), RABT, LAYL, LAYX
!    COMMON /BLOC23/ H, DEVI, NB, BDB,L
   REAL(8) H, DEVI, BDB, NB, L
!    COMMON/PORO/IROT1,IROT2
   LOGICAL IROT1,IROT2
!    COMMON/RAYSHY/IRAYSH
   LOGICAL IRAYSH   
END MODULE m4aimalv
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4QSEX
!---------------------------------------------------------------------
!  Module containing definitions needed for quad  sextupole
!---------------------------------------------------------------------
!   COMMON/QSEX/L,KQ2,KS2
   REAL(8) L,KQ2,KS2
END MODULE m4QSEX
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4herFACTscher
!---------------------------------------------------------------------
!  Definitions for factorial function called by HERSC and SCHERM
!---------------------------------------------------------------------
!   common/factor/fpir(40,40),fect(30)
   REAL(8) fpir(40,40),fect(30)
END MODULE m4herFACTscher
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4HermiteFun
!---------------------------------------------------------------------
!  Definitions for Hermite related functions
!---------------------------------------------------------------------
!   common/sgsk/sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
   REAL(8) sgp3(30),sgi3(30),sgrp(30,30),sgri(30,30)
!   common/sgpth/mksgi,mksgp
   logical mksgi,mksgp
END MODULE m4HermiteFun
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4DEGHERM
!---------------------------------------------------------------------
!  Definitions for SCHERM related functions
!---------------------------------------------------------------------
!   COMMON/DEGHERM/NMAZ,NMAZR,NMAXY
   INTEGER NMAZ,NMAZR,NMAXY
END MODULE m4DEGHERM
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4HERMRR
!---------------------------------------------------------------------
!  Definitions for SCHERM related functions
!---------------------------------------------------------------------
!   COMMON/HERMRR/AFXRR(20),AFYRR(20),AFZRR(20)
   REAL(8) AFXRR(20),AFYRR(20),AFZRR(20)
!   COMMON/ELCG/XCGD,YCGD,ZCGD,XCGR,YCGR,ZCGR
   REAL(8) XCGD,YCGD,ZCGD,XCGR,YCGR,ZCGR
END MODULE m4HERMRR
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4STIS
!---------------------------------------------------------------------
!  Definitions replacing STIS common
!---------------------------------------------------------------------
!   CCOMMON/STIS/suryth,surzph,enedep,ecogde,TESTCA
   REAL(8) suryth,surzph,enedep,ecogde,TESTCA
END MODULE m4STIS
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4TILT
!---------------------------------------------------------------------
!  Definitions for TILT related functions
!---------------------------------------------------------------------
!   COMMON/TILT/TIPHA,TIX,TIY,SHIFW,SHIFP
   REAL(8) TIPHA,TIX,TIY,SHIFW,SHIFP
END MODULE m4TILT
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4FENE
!---------------------------------------------------------------------
!  Definitions replacing FENE common
!---------------------------------------------------------------------
!    COMMON/FENE/WDISP,WPHAS,WX,WY,RLIM,IFW
   REAL(8) WDISP,WPHAS,WX,WY,RLIM
   INTEGER IFW
END MODULE m4FENE
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4ITVOLE
!---------------------------------------------------------------------
!  Definitions replacing ITVOLE and tofev commons
!---------------------------------------------------------------------
!    COMMON/ITVOLE/ITVOL,IMAMIN
   LOGICAL ITVOL,IMAMIN
!    common/tofev/ttvols
   REAL(8) ttvols
!    COMMON/SHIF/DTIPH,SHIFT
   REAL(8) DTIPH
   LOGICAL SHIFT   
END MODULE m4ITVOLE
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4short
!---------------------------------------------------------------------
!  Definitions for "dynac.short" output file
!---------------------------------------------------------------------
   USE DynacConstants, ONLY : maxcell1
!    common/davprtc/shortl
   character(len=80) :: shortl
!    common/cptemit/xltot(maxcell1),nbemit
   REAL(8) xltot(maxcell1)
   INTEGER nbemit
!    common/shortlc/davprt
   character(len=80), dimension(maxcell1) :: davprt
END MODULE m4short
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4wforsc
!---------------------------------------------------------------------
!  Additional definitions for space charge
!---------------------------------------------------------------------
   USE DynacConstants, ONLY : iptsz
!    COMMON/CDEK/DWP(iptsz)
!   REAL(8) DWP(iptsz)
   REAL(8), allocatable ::  DWP(:)
!    COMMON/CMPTE/IELL
   INTEGER IELL
END MODULE m4wforsc
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4wienn
!---------------------------------------------------------------------
!  Definitions for Wien filters (numerical)
!---------------------------------------------------------------------
!   COMMON/CDF/LST
   INTEGER LST 
!   COMMON/CHAVE/ B(5,3),V(5,3),E(5,3)
   REAL(8) B(5,3),V(5,3),E(5,3)
!   COMMON/TYPFLD/ KFLD,MG,LC,ML,ZSYM
   INTEGER KFLD,MG,LC,ML
   LOGICAL ZSYM
!   COMMON/ORDRES/ KORD,IRD,IDS,IDB,IDE,IDZ
   INTEGER KORD,IRD,IDS,IDB,IDE,IDZ
END MODULE m4wienn
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4wiena1
!---------------------------------------------------------------------
!  Additional definitions for Wien filters
!---------------------------------------------------------------------
!   COMMON/WFCONST/CL9,CL,QE        
   REAL(8) CL9,CL,QE
END MODULE m4wiena1
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4wienn1
!---------------------------------------------------------------------
!  Additional definitions for Wien filter (numerical)
!---------------------------------------------------------------------
!   COMMON/wiennum/wiendat(100)
   REAL(8) wiendat(100)
!   COMMON/TRNSF/ XFE,XFS
   REAL(8) XFE,XFS
END MODULE m4wienn1
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4wienn2
!---------------------------------------------------------------------
!  Additional definitions for Wien filter (numerical)
!---------------------------------------------------------------------
!   COMMON/TRAJ/ R1,T1,Z1,P1,A1,TAR,IT
!   COMMON/TRAJ/ Y, T, Z, P, X, TAR,IT
   REAL(8) Y, T, Z, P, X, TAR
   INTEGER IT
!   COMMON/WFRIGID/ DPREF,HDPRF,DP,QBR,BRI
   REAL(8) DPREF,HDPRF,DP,QBR,BRI
END MODULE m4wienn2
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4wienn3
!---------------------------------------------------------------------
!  Additional definitions for Wien filter (numerical)
!---------------------------------------------------------------------
!   COMMON/D3BXYZ/ D3BX(27), D3BY(27), D3BZ(27)
!   COMMON/D3BXYZ/ D3BX(3,3,3), D3BY(3,3,3), D3BZ(3,3,3)
   REAL(8) D3BX(3,3,3), D3BY(3,3,3), D3BZ(3,3,3)
!   COMMON/D4BXYZ/ D4BX(81) ,D4BY(81) ,D4BZ(81)
!   COMMON/D4BXYZ/ D4BX(3,3,3,3) ,D4BY(3,3,3,3) ,D4BZ(3,3,3,3)
   REAL(8) D4BX(3,3,3,3) ,D4BY(3,3,3,3) ,D4BZ(3,3,3,3)
!   COMMON/DDEXYZ/ DE(9),DDE(27)
!   COMMON/DDEXYZ/ DE(3,3),DDE(3,3,3)
   REAL(8) DE(3,3),DDE(3,3,3)
!   COMMON/D3EXYZ/ D3EX(27), D3EY(27), D3EZ(27)
!   COMMON/D3EXYZ/ D3EX(3,3,3), D3EY(3,3,3), D3EZ(3,3,3)
   REAL(8) D3EX(3,3,3), D3EY(3,3,3), D3EZ(3,3,3)
!   COMMON/D4EXYZ/ D4EX(81), D4EY(81), D4EZ(81)
!   COMMON/D4EXYZ/ D4EX(3,3,3,3) ,D4EY(3,3,3,3) ,D4EZ(3,3,3,3)
   REAL(8) D4EX(3,3,3,3) ,D4EY(3,3,3,3) ,D4EZ(3,3,3,3)
!   COMMON/DDBXYZ/ DB(9),DDB(27)
!   COMMON/DDBXYZ/ DB(3,3),DDB(3,3,3)
   REAL(8) DB(3,3),DDB(3,3,3)
END MODULE m4wienn3
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4wienn4
!---------------------------------------------------------------------
!  Additional definitions for Wien filter (numerical)
!---------------------------------------------------------------------
!   COMMON/AIM/ AE,AT,AS,RM,XI,XF,EN,EB1,EB2,EG1,EG2
!   COMMON/AIM/ BO,RO,FG,GF,XI,XF,EN,EB1,EB2,EG1,EG2
   REAL(8) BO,RO,FG,GF,XI,XF,EN,EB1,EB2,EG1,EG2
!   COMMON/INTEG/ PAS,DXI,XLIM,XCE,YCE,ALE,XCS,YCS,ALS
   REAL(8) PAS,DXI,XLIM,XCE,YCE,ALE,XCS,YCS,ALS
END MODULE m4wienn4
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4wienn5
!---------------------------------------------------------------------
!  Additional definitions for Wien filter (numerical)
!---------------------------------------------------------------------
!   COMMON/DEPL/ XF(3),DXF(3),DQBRO,DTAR
   REAL(8) XF(3),DXF(3),DQBRO,DTAR
!   COMMON/VITES/ U(18),DQBR(6),DDT(6)
!   COMMON/VITES/ U(6,3),DQBR(6),DDT(6)
   REAL(8) U(6,3),DQBR(6),DDT(6)
!   COMMON/CNTRLB/ XSTP,DIVB,ALAPL(4),RTN(3)
   REAL(8) XSTP,DIVB,ALAPL(4),RTN(3)
!   COMMON/WFWEDGES/WDGE, WDGS, FINTE, FINTS, GAPE, GAPS, WEDGE, WEDGS
   REAL(8) WDGE, WDGS, FINTE, FINTS, GAPE, GAPS
   LOGICAL WEDGE, WEDGS
!   COMMON/EFBS/ AFB(2), BFB(2), CFB(2), IFB
   REAL(8) AFB(2), BFB(2), CFB(2)
   INTEGER IFB
!   COMMON/DROITE/ CA(9),SA(9),CM(9),IDRT
!   COMMON/DROITE/ AM(9),BM(9),CM(9),IDRT   
   REAL(8) AM(9),BBM(9),CM(9)
   INTEGER IDRT
END MODULE m4wienn5
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4ble
!---------------------------------------------------------------------
!  Additional definitions for beam line elements
!---------------------------------------------------------------------
!   common/rander/ialin
!   common/femt/iemgrw,iemqesg
   LOGICAL ialin,iemgrw
   INTEGER iemqesg
   CHARACTER(len=1) :: cr
END MODULE m4ble
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4prtcls
!---------------------------------------------------------------------
!  Additional definitions for beam line elements
!---------------------------------------------------------------------
   USE DynacConstants, ONLY : iptsz
!   COMMON/DIMENS/zcp(iptsz),xcp(iptsz),ycp(iptsz)
! used by HERSC and SCHERM
!   REAL(8) zcp(iptsz),xcp(iptsz),ycp(iptsz)
   REAL(8), allocatable ::  zcp(:),xcp(:),ycp(:)   
!   COMMON/part/xc(iptsz),yc(iptsz),zc(iptsz)
!   REAL(8) xc(iptsz),yc(iptsz),zc(iptsz)
   REAL(8), allocatable ::  xc(:),yc(:),zc(:)   
!   COMMON/BEAMSA/FS(7,iptsz)
!   REAL(8) FS(7,iptsz)
   REAL(8), allocatable ::  FS(:,:)   
END MODULE m4prtcls
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE m4histos
!---------------------------------------------------------------------
!  Definitions for histograms
!---------------------------------------------------------------------
!   USE DynacConstants, ONLY : iptsz
!   common/hist/xpos(200),xn(200),ypos(200),yn(200), &
!               zpos(200),zn(200),ixt,iyt,izt
   REAL(8) xpos(200),xn(200),ypos(200),yn(200),zpos(200),zn(200)
   INTEGER ixt,iyt,izt
  
!   common/hist1/xps(200),xpn(200),yps(200),ypn(200), &
!               zps(200),zpn(200),ixpt,iypt,izpt
   REAL(8) xps(200),xpn(200),yps(200),ypn(200),zps(200),zpn(200)
   INTEGER ixpt,iypt,izpt
END MODULE m4histos
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE fun4histo
!---------------------------------------------------------------------
!  Module containing supporting function for histogram routine
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! FUNCTION ipos(xmin,xmax,x,nbin)
!! Find which histogram bin x falls in
!< *******************************************************************
   INTEGER FUNCTION ipos(xmin,xmax,x,nbin)
   IMPLICIT NONE
   REAL(8) xmin,xmax,x,frac
   INTEGER nbin
   if(xmax.gt.xmin) then
     if(x.lt.xmin) then
       ipos=0
     else if(x.gt.xmax) then
       ipos=nbin+1
     else if(x.lt.xmax) then
       frac=(x-xmin)/(xmax-xmin)
       ipos=int(frac*DBLE(nbin))+1
     else
       ipos=nbin
     end if
   else
     if(x.lt.xmax) then
       ipos=0
     else if(x.gt.xmin) then
       ipos=nbin+1
     else if(x.lt.xmin) then
       frac=(x-xmin)/(xmax-xmin)
       ipos=int(frac*DBLE(nbin))+1
     else
       ipos=nbin
     end if
   end if
   END FUNCTION ipos
END MODULE fun4histo
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE sub4hist2d
!---------------------------------------------------------------------
!  Module containing supporting subroutine for YTZP2D and COMP2D
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! SUBROUTINE hist2d(n,x,y,xmin,xmax,ymin,ymax,nx,ny,array)
!! Bin array of values into a 2D grid
!! Inputs:
!! n=number of values to bin
!! x, y = input arrays
!! xmin,xmax,ymin,ymax= extrema in input array
!! mask_in = type logical (optional)
!! nx, ny = number of bins in the 2D histogram
!!
!! Output:
!! array = histogrammed data in form of array
!< *******************************************************************
   SUBROUTINE hist2d(n,xx,yy,xmin,xmax,ymin,ymax,nx,ny,array)
   USE DynacConstants, ONLY: iptsz
   USE fun4histo
   IMPLICIT NONE
   INTEGER i,j,n,nx,ny,ix,iy
!   REAL(8) x(iptsz),y(iptsz),xmin,xmax,ymin,ymax
   REAL(8), allocatable, intent(in) ::  xx(:),yy(:)
   REAL(8) xmin,xmax,ymin,ymax
   REAL(8) array(100,100)
!*******************************************************************
!   if (.not. allocated(x)) allocate(x(iptsz))
!   if (.not. allocated(y)) allocate(y(iptsz))
! initialize the array
   do i=1,100
     do j=1,100
       array(i,j)=0.D0
     enddo
   enddo
   do i=1,n
      ix=ipos(xmin,xmax,xx(i),nx)
      iy=ipos(ymin,ymax,yy(i),ny)
      if(ix.ge.1.and.ix.le.nx) then
         if(iy.ge.1.and.iy.le.ny) then
            array(ix,iy) = array(ix,iy) + 1.D0
         endif
      endif
   enddo
!   deallocate(x)
!   deallocate(y)
   END SUBROUTINE hist2d
END MODULE sub4hist2d   
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE fun4restay
!---------------------------------------------------------------------
!  Module containing supporting functions for RESTAY
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! FUNCTION ta0(betr,nrc)
!! Transit time factor t(k) (single cell)
!< *******************************************************************
   REAL(8) FUNCTION ta0(betr,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   ar=0.D0
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   DO I=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     AR=AR+T1(I)*RFONC*COS(XK*XC)
   enddo
   ta0=ar*(xc2-xc1)
   END FUNCTION ta0
!> *******************************************************************
!! FUNCTION ta1(betr,nrc)
!! Transit time factor dT(k)/dk (single cell)
!< *******************************************************************
   REAL(8) FUNCTION ta1(betr,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   ar=0.D0
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   do i=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     AR=AR-T1(I)*XC*RFONC*SIN(XK*XC)
   enddo
   ta1=ar*(xc2-xc1)
   END FUNCTION ta1
!> *******************************************************************
!! FUNCTION ta2(betr,nrc)
!! Transit time factor d2T(k)/dk2 (single cell)
!< *******************************************************************
   REAL(8) FUNCTION ta2(betr,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   ar=0.D0
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   do i=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     AR=AR-T1(I)*XC*XC*RFONC*COS(XK*XC)
   enddo
   TA2=AR*(XC2-XC1)
   END FUNCTION ta2
!> *******************************************************************
!! FUNCTION ta3(betr,nrc)
!! Transit time factor d3T(k)/dk3 (single cell)
!< *******************************************************************
   REAL(8) FUNCTION ta3(betr,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   ar=0.D0
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   do i=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     AR=AR+T1(I)*XC*XC*XC*RFONC*SIN(XK*XC)
   enddo
   TA3=AR*(XC2-XC1)
   END FUNCTION ta3
!> *******************************************************************
!! FUNCTION ta4(betr,nrc)
!! Transit time factor d4T(k)/dk4 (single cell)
!< *******************************************************************
   REAL(8) FUNCTION ta4(betr,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   ar=0.D0
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   do i=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     AR=AR+T1(I)*XC**4*RFONC*COS(XK*XC)
   enddo
   TA4=AR*(XC2-XC1)
   END FUNCTION ta4
!> *******************************************************************
!! FUNCTION ta5(betr,nrc)
!! Transit time factor d5T(k)/dk5 (single cell)
!< *******************************************************************
   REAL(8) FUNCTION ta5(betr,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   ar=0.D0
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   do i=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     AR=AR-T1(I)*XC**5*RFONC*SIN(XK*XC)
   enddo
   TA5=AR*(XC2-XC1)
   END FUNCTION ta5
!> *******************************************************************
!! FUNCTION sb0(BETR,nrc)
!! Transit time factor s(k) (single cell)
!< *******************************************************************
   REAL(8) FUNCTION sb0(BETR,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,br,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   br=0.D0
   DO I=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     BR=BR+T1(I)*RFONC*SIN(XK*XC)
   enddo
   SB0=BR*(XC2-XC1)
   END FUNCTION sb0
!> *******************************************************************
!! FUNCTION sb1(BETR,nrc)
!! Transit time factor dS(k)/dk (single cell)
!< *******************************************************************
   REAL(8) FUNCTION sb1(BETR,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,br,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   br=0.D0
   DO I=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     BR=BR+T1(I)*XC*RFONC*COS(XK*XC)
   enddo
   SB1=BR*(XC2-XC1)
   END FUNCTION sb1
!> *******************************************************************
!! FUNCTION sb2(BETR,nrc)
!! Transit time factor d2S(k)/dk2 (single cell)
!< *******************************************************************
   REAL(8) FUNCTION sb2(BETR,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,br,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   br=0.D0
   DO I=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     BR=BR-T1(I)*XC*XC*RFONC*SIN(XK*XC)
   enddo
   SB2=BR*(XC2-XC1)
   END FUNCTION sb2
!> *******************************************************************
!! FUNCTION sb3(BETR,nrc)
!! Transit time factor d3S(k)/dk3 (single cell)
!< *******************************************************************
   REAL(8) FUNCTION sb3(BETR,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,br,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   br=0.D0
   DO I=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     BR=BR-T1(I)*XC*XC*XC*RFONC*COS(XK*XC)
   enddo
   SB3=BR*(XC2-XC1)
   END FUNCTION sb3
!> *******************************************************************
!! FUNCTION sb4(BETR,nrc)
!! Transit time factor d4S(k)/dk5 (single cell)
!< *******************************************************************
   REAL(8) FUNCTION sb4(BETR,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,br,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   br=0.D0
   do i=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     BR=BR+T1(I)*XC**4*RFONC*SIN(XK*XC)
   enddo
   SB4=BR*(XC2-XC1)
   END FUNCTION sb4
!> *******************************************************************
!! FUNCTION sb5(BETR,nrc)
!! Transit time factor d5S(k)/dk5 (single cell)
!< *******************************************************************
   REAL(8) FUNCTION sb5(BETR,nrc)
   USE DynacConstants
   USE m_h_t_h1_t1
   USE m4RESTAY, ONLY: xlim,fhc
   IMPLICIT NONE
   REAL(8) betr,br,rfonc,xc,xc1,xc2,xk
   INTEGER nrc,i
   xk=fhc*2.D0*pi/(betr*vl)
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   br=0.D0
   DO I=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     BR=BR+T1(I)*XC**5*RFONC*COS(XK*XC)
   enddo
   SB5=BR*(XC2-XC1)
   END FUNCTION sb5
!> *******************************************************************
!! FUNCTION fone(Z)
!! Electromagnetic field at the longitudinal point (z,0)
!! The field harmonics are  stored in  A(200)
!< *******************************************************************
   REAL(8) FUNCTION fone(Z)
   USE DynacConstants
   USE m4cavs
   USE m4RESTAYfun, ONLY: A,YLG,NHARM   
   IMPLICIT NONE
   REAL(8) Z,XL
   INTEGER J
   FONE=0.D0
   DO J=1,NHARM
     XL=PI*DBLE(J-1)/YLG
     FONE=FONE+A(J)*cos(XL*Z)
   enddo
   END FUNCTION fone
!> *******************************************************************
!! FUNCTION tta0(betr)
!! Transit time factor t(k) (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tta0(betr)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tta0=0.D0
     do i=1,ncell
       tta0=tta0+ta0(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tta0=0.D0
     ar=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         AR=AR+H(I)*RFONC*COS(XK*XC)
       enddo
       AR=AR*(XC2-XC1)
       TTA0=TTA0+AR
       AR=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tta0
!> *******************************************************************
!! FUNCTION tta1(BETR)
!! Transit time factor dT(k)/dk (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tta1(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tta1=0.D0
     do i=1,ncell
       tta1=tta1+ta1(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tta1=0.D0
     ar=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         AR=AR-H(I)*XC*RFONC*SIN(XK*XC)
       enddo
       AR=AR*(XC2-XC1)
       TTA1=TTA1+AR
       AR=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tta1
!> *******************************************************************
!! FUNCTION tta2(BETR)
!! Transit time factor d2T(k)/dk2 (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tta2(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tta2=0.D0
     do i=1,ncell
       tta2=tta2+ta2(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tta2=0.D0
     ar=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         AR=AR-H(I)*XC*XC*RFONC*COS(XK*XC)
       enddo
       AR=AR*(XC2-XC1)
       TTA2=TTA2+AR
       AR=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tta2
!> *******************************************************************
!! FUNCTION tta3(BETR)
!! Transit time factor d3T(k)/dk2 (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tta3(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tta3=0.D0
     do i=1,ncell
       tta3=tta3+ta3(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tta3=0.D0
     ar=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         AR=AR+H(I)*XC*XC*XC*RFONC*SIN(XK*XC)
       enddo
       AR=AR*(XC2-XC1)
       TTA3=TTA3+AR
       AR=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tta3
!> *******************************************************************
!! FUNCTION tta4(BETR)
!! Transit time factor d4T(k)/dk4 (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tta4(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tta4=0.D0
     do i=1,ncell
       tta4=tta4+ta4(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tta4=0.D0
     ar=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         AR=AR+H(I)*XC**4*RFONC*COS(XK*XC)
       enddo
       AR=AR*(XC2-XC1)
       TTA4=TTA4+AR
       AR=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tta4
!> *******************************************************************
!! FUNCTION tta5(BETR)
!! Transit time factor d5T(k)/dk5 (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tta5(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,ar,rfonc,xc,xc1,xc2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tta5=0.D0
     do i=1,ncell
       tta5=tta5+ta5(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tta5=0.D0
     ar=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         AR=AR-H(I)*XC**5*RFONC*SIN(XK*XC)
       enddo
       AR=AR*(XC2-XC1)
       TTA5=TTA5+AR
       AR=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tta5
!> *******************************************************************
!! FUNCTION tsb0(BETR)
!! Transit time factor s(k) (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tsb0(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,br,RFONC,XC,XC1,XC2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tsb0=0.D0
     do i=1,ncell
       tsb0=tsb0+sb0(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tsb0=0.D0
     br=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
           RFONC= FONE(XC)
         BR=BR+H(I)*RFONC*SIN(XK*XC)
       enddo
       BR=BR*(XC2-XC1)
       tsb0=tsb0+br
       br=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tsb0
!> *******************************************************************
!! FUNCTION tsb1(BETR)
!! Transit time factor ds(k)/dk (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tsb1(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,br,RFONC,XC,XC1,XC2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tsb1=0.D0
     do i=1,ncell
       tsb1=tsb1+sb1(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tsb1=0.D0
     br=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         BR=BR+H(I)*XC*RFONC*COS(XK*XC)
       enddo
       BR=BR*(XC2-XC1)
       tsb1=tsb1+br
       br=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tsb1
!> *******************************************************************
!! FUNCTION tsb2(BETR)
!! Transit time factor d2S(k)/dk2 (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tsb2(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,br,RFONC,XC,XC1,XC2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tsb2=0.D0
     do i=1,ncell
       tsb2=tsb2+sb2(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tsb2=0.D0
     br=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         BR=BR-H(I)*XC*XC*RFONC*SIN(XK*XC)
       enddo
       BR=BR*(XC2-XC1)
       tsb2=tsb2+br
       br=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tsb2
!> *******************************************************************
!! FUNCTION tsb3(BETR)
!! Transit time factor d3S(k)/dk3 (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION tsb3(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,br,RFONC,XC,XC1,XC2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tsb3=0.D0
     do i=1,ncell
       tsb3=tsb3+sb3(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tsb3=0.D0
     br=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         BR=BR-H(I)*XC*XC*XC*RFONC*COS(XK*XC)
       enddo
       BR=BR*(XC2-XC1)
       tsb3=tsb3+br
       br=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tsb3
!> *******************************************************************
!! FUNCTION tsb4(BETR)
!! Transit time factor d4S(k)/dk5 (multi cells)
!< *******************************************************************
   REAL(8) FUNCTION tsb4(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T 
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,br,RFONC,XC,XC1,XC2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tsb4=0.D0
     do i=1,ncell
       tsb4=tsb4+sb4(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tsb4=0.D0
     br=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         BR=BR+H(I)*XC**4*RFONC*SIN(XK*XC)
       enddo
       BR=BR*(XC2-XC1)
       tsb4=tsb4+br
       br=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tsb4
!> *******************************************************************
!! FUNCTION tsb5(BETR)
!! Transit time factor d5S(k)/dk5
!< *******************************************************************
   REAL(8) FUNCTION tsb5(BETR)
   USE DynacConstants
   USE m4cavs
   USE m_h_t_h1_t1, ONLY: H,T
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) betr,br,RFONC,XC,XC1,XC2,xk
   INTEGER i,ipas
   REAL(8) xmin(15)
   if(ifield) then
     tsb5=0.D0
     do i=1,ncell
       tsb5=tsb5+sb5(betr,i)
     enddo
   else
     xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     tsb5=0.D0
     br=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2))EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         BR=BR+H(I)*XC**5*RFONC*COS(XK*XC)
       enddo
       BR=BR*(XC2-XC1)
       tsb5=tsb5+br
       br=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION tsb5
!> *******************************************************************
!! FUNCTION fcav(xc,nrc)
!! electromagnetic field  at the position xc
!< *******************************************************************
   REAL(8) FUNCTION fcav(xc,nrc)
   USE DynacConstants, ONLY: fprec
   USE m4RESTAY   
   IMPLICIT NONE
   REAL(8) a,b,XC,tk
   INTEGER nrc,j,k
   fcav=0.D0
   if(nrc.eq.1) then
     j=1
   else
     j=jsav
   endif
   do k=1,npoint(nrc)
     tk=xc-xf(j)
!     if(tk.eq.0.)then
     if(abs(tk).le.fprec)then
       fcav=yf(j)
       exit
     endif
     if(tk.lt. 0.D0) then
       a=(xc-xf(j-1))/(xf(j)-xf(j-1))
       b=(xf(j)-xc)/(xf(j)-xf(j-1))
       fcav=b*yf(j-1)+a*yf(j)
       exit
     endif
     j=j+1
   enddo
   jsav=j
   END FUNCTION fcav
END MODULE fun4restay   
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE fun4mhb
!---------------------------------------------------------------------
!  Module containing supporting functions for MHB
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! FUNCTION xf1
!! energy gain over the step
!< *******************************************************************
   REAL(8) FUNCTION xf1(ico,rphas,t0,t5)
   USE DynacConstants, ONLY: vl,pi,rpel
   USE m4cavs, ONLY: fh
   USE m4numcavs, ONLY: xpas,b0,b1,b2,b3,b4,b5,tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
   USE m4MHBfun
   IMPLICIT NONE
   REAL(8) rphas,t0,t5
   REAL(8) cco,b01,b12,b23,b34,b45,fhi,phzi,t1,t2,t3,t4,tspl,tspli
   REAL(8) xspl0,xspl1,xspl2,xspl3,xspl4,xspl5
   INTEGER ico
   INTEGER i
   xf1=0.D0
   b01=(b0+b1)/2.D0
   b12=(b1+b2)/2.D0
   b23=(b2+b3)/2.D0
   b34=(b3+b4)/2.D0
   b45=(b4+b5)/2.D0
   t1=t0+xpas/(5.D0*b01*vl)
   t2=t1+xpas/(5.D0*b12*vl)
   t3=t2+xpas/(5.D0*b23*vl)
   t4=t3+xpas/(5.D0*b34*vl)
   t5=t4+xpas/(5.D0*b45*vl)
   tspl=0.D0
   do i=1,ifreq
     fhi=fh*DBLE(i)
     phzi=phz(i)+rphas*fhi
! --- rphas = phase particle - phase reference
! --- ico flag
! ----  if ico = 1 ---> coupling terms R and RP (see equations)
     cco=1.D0
     if(ico.ne.0) cco=DBLE(i)
     xspl0=cos(fhi*t0+phzi)*tspl0
     xspl1=cos(fhi*t1+phzi)*tspl1
     xspl2=cos(fhi*t2+phzi)*tspl2
     xspl3=cos(fhi*t3+phzi)*tspl3
     xspl4=cos(fhi*t4+phzi)*tspl4
     xspl5=cos(fhi*t5+phzi)*tspl5
     tspli=19.D0*xspl0+75.D0*xspl1+50.D0*xspl2+50.D0*xspl3+75.D0*xspl4 &
       +19.D0*xspl5
     tspli=xpas/288.D0 * tspli*ampl(i)*cco*cco
     tspl=tspl+tspli
   enddo
   xf1=tspl
   END FUNCTION xf1
!> *******************************************************************
!> *******************************************************************
!! FUNCTION xf2
!! coupling terms in R and R' (energy gain)
!< *******************************************************************
   REAL(8) FUNCTION xf2(rphas,t0)
   USE DynacConstants, ONLY: vl,pi,rpel
   USE m4cavs, ONLY: fh
   USE m4numcavs, ONLY: xpas,b0,b1,b2,b3,b4,b5,tspl1,tspl2,tspl3,tspl4,tspl5
   USE m4MHBfun
   IMPLICIT NONE
   REAL(8) rphas,t0
   REAL(8) b01,b12,b23,b34,b45,fhi,phzi,t1,t2,t3,t4,t5,tspl,tspli
   REAL(8) xspl1,xspl2,xspl3,xspl4,xspl5
   INTEGER i
   b01=(b0+b1)/2.D0
   b12=(b1+b2)/2.D0
   b23=(b2+b3)/2.D0
   b34=(b3+b4)/2.D0
   b45=(b4+b5)/2.D0
   t1=t0+xpas/(5.D0*b01*vl)
   t2=t1+xpas/(5.D0*b12*vl)
   t3=t2+xpas/(5.D0*b23*vl)
   t4=t3+xpas/(5.D0*b34*vl)
   t5=t4+xpas/(5.D0*b45*vl)
   tspl=0.D0
   do i =1,ifreq
     fhi=fh*DBLE(i)
     phzi=phz(i)+rphas*fhi
     xspl1=cos(fhi*t1+phz(i))*tspl1
     xspl2=cos(fhi*t2+phz(i))*tspl2
     xspl3=cos(fhi*t3+phz(i))*tspl3
     xspl4=cos(fhi*t4+phz(i))*tspl4
     xspl5=cos(fhi*t5+phz(i))*tspl5
     tspli=15.D0*xspl1+20.D0*xspl2+30.D0*xspl3+60.D0*xspl4+19.D0*xspl5
     tspli=xpas/288.D0 * tspli*ampl(i)*DBLE(i)*DBLE(i)
     tspl=tspl+tspli
   enddo
   xf2=tspl
   END FUNCTION xf2
!> *******************************************************************
!! FUNCTION xjf1
!! transverse motion field dE/dt
!< *******************************************************************
   REAL(8) FUNCTION xjf1(rphas,t0)
   USE DynacConstants, ONLY: vl,pi,rpel
   USE m4cavs, ONLY: fh
   USE m4numcavs
   USE m4MHBfun
   IMPLICIT NONE
   REAL(8) rphas,t0
   REAL(8) b01,b12,b23,b34,b45,fhi,phzi,t1,t2,t3,t4,t5,tspl,tspli
   REAL(8) xspl0,xspl1,xspl2,xspl3,xspl4,xspl5
   INTEGER i
! --- the field is read from the disk
   xjf1=0.D0
   b01=(b0+b1)/2.D0
   b12=(b1+b2)/2.D0
   b23=(b2+b3)/2.D0
   b34=(b3+b4)/2.D0
   b45=(b4+b5)/2.D0
   t1=t0+xpas/(5.D0*b01*vl)
   t2=t1+xpas/(5.D0*b12*vl)
   t3=t2+xpas/(5.D0*b23*vl)
   t4=t3+xpas/(5.D0*b34*vl)
   t5=t4+xpas/(5.D0*b45*vl)
   tspl=0.D0
   do i =1,ifreq
     fhi=fh*DBLE(i)
     phzi=phz(i)+rphas*fhi
     xspl0=-fhi*sin(fhi*t0+phzi)*tspl0/bgt0
     xspl1=-fhi*sin(fhi*t1+phzi)*tspl1/bgt1
     xspl2=-fhi*sin(fhi*t2+phzi)*tspl2/bgt2
     xspl3=-fhi*sin(fhi*t3+phzi)*tspl3/bgt3
     xspl4=-fhi*sin(fhi*t4+phzi)*tspl4/bgt4
     xspl5=-fhi*sin(fhi*t5+phzi)*tspl5/bgt5
     tspli=19.D0*xspl0+75.D0*xspl1+50.D0*xspl2+50.D0*xspl3+75.D0*xspl4 &
       +19.D0*xspl5
     tspli=xpas/288.D0 * tspli*ampl(i)
     tspl=tspl+tspli
   enddo
   xjf1= tspl
   END FUNCTION xjf1
!> *******************************************************************
!! FUNCTION xjf2
!! transverse motion field dE/dt
!< *******************************************************************
   REAL(8) FUNCTION xjf2(rphas,t0)
   USE DynacConstants, ONLY: vl,pi,rpel
   USE m4cavs, ONLY: fh
   USE m4numcavs
   USE m4MHBfun
   IMPLICIT NONE
   REAL(8) rphas,t0
   REAL(8) b01,b12,b23,b34,b45,fhi,phzi,t1,t2,t3,t4,t5,tspl,tspli
   REAL(8) xspl1,xspl2,xspl3,xspl4,xspl5
   INTEGER i
   xjf2=0.D0
   b01=(b0+b1)/2.D0
   b12=(b1+b2)/2.D0
   b23=(b2+b3)/2.D0
   b34=(b3+b4)/2.D0
   b45=(b4+b5)/2.D0
   t1=t0+xpas/(5.D0*b01*vl)
   t2=t1+xpas/(5.D0*b12*vl)
   t3=t2+xpas/(5.D0*b23*vl)
   t4=t3+xpas/(5.D0*b34*vl)
   t5=t4+xpas/(5.D0*b45*vl)
   tspl=0.D0
   do i =1,ifreq
     fhi=fh*DBLE(i)
     phzi=phz(i)+rphas*fhi
     xspl1=-fhi*sin(fhi*t1+phzi)*tspl1/bgt1
     xspl2=-fhi*sin(fhi*t2+phzi)*tspl2/bgt2
     xspl3=-fhi*sin(fhi*t3+phzi)*tspl3/bgt3
     xspl4=-fhi*sin(fhi*t4+phzi)*tspl4/bgt4
     xspl5=-fhi*sin(fhi*t5+phzi)*tspl5/bgt5
     tspli=15.D0*xspl1+20.D0*xspl2+30.D0*xspl3 &
            +60.D0*xspl4+19.D0*xspl5
     tspli=xpas/288.D0 * tspli*ampl(i)
     tspl=tspl+tspli
   enddo
   xjf2=tspl
   END FUNCTION xjf2
!> *******************************************************************
!! FUNCTION spta0
!! Special Transit time factor t(k) (single cell)
!< *******************************************************************
   REAL(8) FUNCTION spta0(xkitr,nrc)
   USE DynacConstants, ONLY: vl,pi,rpel
   USE m_h_t_h1_t1, ONLY: H1,T1
   USE fun4restay, ONLY: fcav
   USE m4RESTAY
   IMPLICIT NONE
   REAL(8) xkitr
   REAL(8) ar,rfonc,xc,xc1,xc2
   INTEGER i
   INTEGER nrc
! ---       xk=fhc*2.D0*pi/(betr*vl)
   ar=0.D0
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   DO I=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     AR=AR+T1(I)*RFONC*COS(XKitr*XC)
   enddo
   spta0=ar*(xc2-xc1)
   END FUNCTION spta0
!> *******************************************************************
!! FUNCTION sptta0(xkitr)
!! Special Transit time factor t(k) (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION sptta0(xkitr)
   USE DynacConstants, ONLY: vl,pi,rpel
   USE m_h_t_h1_t1, ONLY: H,T
   USE fun4restay, ONLY: fone
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) xkitr
   REAL(8) ar,rfonc,xc,xc1,xc2,fprec
   INTEGER i,ipas
   REAL(8)  xmin(15)
   fprec=epsilon(xmin(1))
   if(ifield) then
     sptta0=0.D0
     do i=1,ncell
       sptta0=sptta0+spta0(xkitr,i)
     enddo
     return
   else
! -----         xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     sptta0=0.D0
     ar=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2)) EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         AR=AR+H(I)*RFONC*COS(XKITR*XC)
       enddo
       AR=AR*(XC2-XC1)
       SPTTA0=SPTTA0+AR
       AR=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION sptta0
!> *******************************************************************
!! FUNCTION spsb0(xk,nrc)
!! Special Transit time factor s(k) (single cell)
!< *******************************************************************
   REAL(8) FUNCTION spsb0(xkitr,nrc)
   USE DynacConstants, ONLY: vl,pi,rpel
   USE m_h_t_h1_t1, ONLY: H1,T1
   USE fun4restay, ONLY: fcav
   USE m4RESTAY, ONLY: xlim
   IMPLICIT NONE
   REAL(8) xkitr
   INTEGER nrc
   REAL(8) br,rfonc,xc,xc1,xc2
   INTEGER i
   xc1=xlim(nrc)
   xc2=xlim(nrc+1)
   br=0.D0
   DO I=1,17
     XC= (XC2+XC1)/2.D0+(XC2-XC1)*H1(I)/2.D0
     rfonc=fcav(xc,nrc)
     BR=BR+T1(I)*RFONC*SIN(XKITR*XC)
   enddo
   SPSB0=BR*(XC2-XC1)
   END FUNCTION spsb0
!> *******************************************************************
!! FUNCTION sptsb0(xkitr)
!! Special Transit time factor s(k) (multi-cells)
!< *******************************************************************
   REAL(8) FUNCTION sptsb0(xkitr)
   USE DynacConstants, ONLY: vl,pi,rpel
   USE m_h_t_h1_t1, ONLY: H,T
   USE fun4restay, ONLY: fone
   USE m4RESTAY, ONLY: ncell
   USE m4RESTAYfun   
   IMPLICIT NONE
   REAL(8) xkitr
   REAL(8) br,rfonc,xc,xc1,xc2,fprec
   INTEGER i,ipas
   REAL(8) xmin(15)
   fprec=epsilon(xmin(1))
   if(ifield) then
     sptsb0=0.D0
     do i=1,ncell
       sptsb0=sptsb0+spsb0(xkitr,i)
     enddo
     return
   else
! ---       xk=fh/(betr*vl)
     xmin(1)=0.D0
     do i=2,ncel+2
       xmin(i)=0.D0
     enddo
     do i=2,ncel+1
       xmin(i)=ylg*DBLE(i-1)/DBLE(ncel)
     enddo
     ipas=1
     sptsb0=0.D0
     br=0.D0
     xc1=0.D0
     xc2=0.D0
     DO
       if(abs(xmin(ipas+1)).le.fprec .or. ipas.gt.(ncel+2)) EXIT
       do i=1,13
         xc1=xmin(ipas)
         xc2=xmin(ipas+1)
         XC= (XC2+XC1)/2.D0+(XC2-XC1)*T(I)/2.D0
         RFONC= FONE(XC)
         BR=BR+H(I)*RFONC*SIN(XKITR*XC)
       enddo
       BR=BR*(XC2-XC1)
       sptsb0=sptsb0+br
       br=0.D0
       IPAS=IPAS+1
     ENDDO
   endif
   END FUNCTION sptsb0
!> *******************************************************************
END MODULE fun4mhb
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE fun4rfq
!---------------------------------------------------------------------
!  Module containing supporting functions for RFQPTQ
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! FUNCTION bint(n,z)
!! ---  integral representation of modified Bessel functions
!!      n integer order    z argument
!< *******************************************************************
   REAL(8) FUNCTION bint(n,z)
   USE DynacConstants
   USE m4rfqFBINT
   IMPLICIT NONE
!   REAL(8) ui(16),wi(16),z,thet,fln,cthet,fonc
   REAL(8) wi(16),z,fln,fonc
   INTEGER i,j,n
!  GAUSS n=16 de -1. a 1
!   DATA (UI(J),J=1,16)/-.9894009D0,-.9445750D0,-.8656312D0,-.7554044D0, &
!         -.6178762D0,-.4580168D0,-.2816036D0,-.0950125D0, &
!          .0950125D0,.2816036D0,.4580168D0,.6178762D0,.7554044D0,.8656312D0, &
!          .9445750D0,.9894009D0/
   DATA (WI(J),J=1,16)/.0271524D0,.0622535D0,.0951585D0,.1246288D0, &
         .1495960D0,.1691565D0,.1826034D0,.1894506D0,.1894506D0,.1826034D0, &
         .1691565D0,.1495960D0,.1246288D0,.0951585D0,.0622535D0,.0271524D0/
! theta values for use by function bint prepared in cpardyn	   
   bint=0.D0
!   fln=DBLE(n)
   select case (n)
     CASE (0)   
       do i=1,16
         fonc=exp(cthet(i)*z)
         bint=bint+fonc*wi(i)
       enddo
     CASE (1)
       do i=1,16
         fonc=exp(cthet(i)*z)*cthet(i)
         bint=bint+fonc*wi(i)
       enddo
     CASE (3)
       do i=1,16
         fonc=exp(cthet(i)*z)*c3thet(i)
         bint=bint+fonc*wi(i)
       enddo
     CASE (4)
       do i=1,16
         fonc=exp(cthet(i)*z)*c4thet(i)
         bint=bint+fonc*wi(i)
       enddo
     CASE (5)
       do i=1,16
         fonc=exp(cthet(i)*z)*c5thet(i)
         bint=bint+fonc*wi(i)
       enddo
     CASE DEFAULT
       fln=DBLE(n) 
       do i=1,16
!         thet=pi/2.D0*(1.D0+ui(i))
!         cthet=cos(thet)
         fonc=exp(cthet(i)*z)*cos(fln*thet(i))
         bint=bint+fonc*wi(i)
       enddo
     end select
   bint=bint/2.D0
   END FUNCTION bint
!> *******************************************************************
!! FUNCTION bints(n,z)
!! ---  series representation of modified Bessel functions
!!      n integer order    z argument
!< *******************************************************************
   REAL(8) FUNCTION bints(n,z)
   IMPLICIT NONE
   REAL(8) z,z2,z3,z4,z5,z6,z8,zh,zh2,zh4,bint
   INTEGER n  
       bint=0.D0
       z2=z*z
       select case (n)
         CASE (0)
           z4=z2*z2
           z6=z4*z2
           z8=z6*z2
!           bint=1.D0+z2/4.D0+z4/64.D0+z6/2304.D0
           bint=1.D0+z2/4.D0+z4/64.D0+z6/2304.D0+z8/147456.D0
         CASE (1)
           z3=z2*z
           z5=z3*z2
           bint=z/2.D0+z3/16.D0+z5/384.D0
         CASE (2)
! not used		 
           write(6,*)
           write(6,*) "ERROR: Bessel function I2 not yet implemented in function bints"
           stop
         CASE (3)
           z3=z2*z
           z5=z3*z2
           bint=z3/48.D0+z5/768.D0
         CASE (4)
           zh=z/2.D0
           zh2=zh*zh
           zh4=zh2*zh2
           bint=zh4/24.D0 + zh4*zh2/120.D0 + zh4*zh4/1440.D0
         CASE (5)
           z3=z2*z
           z5=z3*z2
           bint=z5/3840.D0
       end select
       bints=bint
       return
       END FUNCTION bints   
!> *******************************************************************
!! FUNCTION slope(N,XV)
!! first derivative of the spline function
!< *******************************************************************
   REAL(8) FUNCTION slope(N,XV)
   USE m4SPLfun
   IMPLICIT NONE
   REAL(8) XV,AVX,DDX,DGX,xtvi
   INTEGER N,i
   do i=2,n
     xtvi=xv-xspl(i)
     if(xtvi .LE. 0.D0) EXIT
   enddo
   if(xtvi .ge. 0.D0) then
     I=I-1
     AVX=XSPL(I+1)-XSPL(I)
     SLOPE=S(I+1)*AVX/3.D0+S(I)*AVX/6.D0+(YSPL(I+1)-YSPL(I))/AVX
   else
     I=I-1
     DGX=XV-XSPL(I)
     DDX=XSPL(I+1)-XV
     AVX=XSPL(I+1)-XSPL(I)
     SLOPE=-(S(I)*DDX*DDX)/(2.D0*AVX)+(S(I+1)*DGX*DGX)/(2.D0*AVX) &
            +((YSPL(I+1)-YSPL(I))/AVX)-(AVX*(S(I+1)-S(I))/6.D0)
   endif
   END FUNCTION slope   
!> *******************************************************************
!! FUNCTION spline (N,XV)
!! SPLINE FUNCTION
!< *******************************************************************
   REAL(8) FUNCTION spline(N,XV)
   USE m4SPLfun
   IMPLICIT NONE
   REAL(8) XV,xtv1,fprec,AVX,DDX,DGX,xtvi,xtvn
   INTEGER N,i
   spline=yspl(1)
   xtv1=xv-xspl(1)
   fprec=epsilon(xtv1)
   if(xtv1.lt. 0.D0) then
     SPLINE=YSPL(1)+((YSPL(2)-YSPL(1))/(XSPL(2)-XSPL(1))-S(2)*(XSPL(2)-XSPL(1))/6.D0) &
            *(XV-XSPL(1))
     return
   endif
   if(abs(xtv1).le.fprec) then
     SPLINE=YSPL(1)
     return
   endif
   if(xtv1.gt. 0.D0) then
     xtvn=xv-xspl(n)
     if(abs(xtvn).le.fprec) then
       SPLINE=YSPL(N)
       return
     endif
     if(xtvn.gt. 0.D0) then
       SPLINE=YSPL(N)+((YSPL(N)-YSPL(N-1))/ &
             (XSPL(N)-XSPL(N-1))+S(N-1)*(XSPL(N)-XSPL(N-1))/6.D0)*(XV-XSPL(N))
       return
     endif
     if(xtvn.lt. 0.D0) then
       do i=2,n
         xtvi=xv-xspl(i)
         if(xtvi .LE. 0.D0) EXIT
       enddo
       if(xtvi .ge. 0.D0) then
         spline=yspl(i)
       else
         I=I-1
         DGX=XV-XSPL(I)
         DDX=XSPL(I+1)-XV
         AVX=XSPL(I+1)-XSPL(I)
         SPLINE=S(I)*DDX**3/(6.D0*AVX)+S(I+1)*DGX**3/(6.D0*AVX) &
      +(YSPL(I+1)/AVX-S(I+1)*AVX/6.D0)*DGX+(YSPL(I)/AVX-S(I)*AVX/6.D0)*DDX
       endif
     endif
   endif
   END FUNCTION spline
!> *******************************************************************
!! FUNCTION splinf (N,XV)
!! SPLINE FUNCTION
!< *******************************************************************
   REAL(8) FUNCTION splinf(N,XV)
   USE m4SPFFfun
   IMPLICIT NONE
   REAL(8) XV,xtv1,fprec,AVX,DDX,DGX,xtvi,xtvn
   INTEGER N,i
   splinf=YSPF(1)
   xtv1=xv-XSPF(1)
   fprec=epsilon(xtv1)
   if(xtv1.lt. 0.D0) then
     SPLINF=YSPF(1)+((YSPF(2)-YSPF(1))/(XSPF(2)-XSPF(1))-SF(2)*(XSPF(2)-XSPF(1))/6.D0) &
            *(XV-XSPF(1))
     return
   endif
   if(abs(xtv1).le.fprec) then
     SPLINF=YSPF(1)
     return
   endif
   if(xtv1.gt. 0.D0) then
     xtvn=xv-XSPF(n)
     if(abs(xtvn).le.fprec) then
       SPLINF=YSPF(N)
       return
     endif
     if(xtvn.gt. 0.D0) then
       SPLINF=YSPF(N)+((YSPF(N)-YSPF(N-1))/ &
             (XSPF(N)-XSPF(N-1))+SF(N-1)*(XSPF(N)-XSPF(N-1))/6.D0)*(XV-XSPF(N))
       return
     endif
     if(xtvn.lt. 0.D0) then
       do i=2,n
         xtvi=xv-XSPF(i)
         if(xtvi .LE. 0.D0) EXIT
       enddo
       if(xtvi .ge. 0.D0) then
         splinf=YSPF(i)
       else
         I=I-1
         DGX=XV-XSPF(I)
         DDX=XSPF(I+1)-XV
         AVX=XSPF(I+1)-XSPF(I)
         SPLINF=SF(I)*DDX**3/(6.D0*AVX)+SF(I+1)*DGX**3/(6.D0*AVX) &
     +(YSPF(I+1)/AVX-SF(I+1)*AVX/6.D0)*DGX+(YSPF(I)/AVX-SF(I)*AVX/6.D0)*DDX
       endif
     endif
   endif
   END FUNCTION splinf
END MODULE fun4rfq   
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE fun4cavnum
!  Module containing supporting functions for CAVNUM
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! FUNCTION xi1(phi0,t0,t5)
!! energy gain over the step
!< *******************************************************************
   REAL(8) FUNCTION xi1(phi0,t0,t5)
   USE DynacConstants
   USE m4cavs
   USE m4numcavs, ONLY: xpas,b0,b1,b2,b3,b4,b5,tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
   IMPLICIT NONE
   REAL(8) phi0,t0,t1,t2,t3,t4,t5,xfac,b01,b12,b23,b34,b45
   REAL(8) xspl0,xspl1,xspl2,xspl3,xspl4,xspl5,tspl
   xfac=xpas/(2.5D0*vl)
   b01=b0+b1
   b12=b1+b2
   b23=b2+b3
   b34=b3+b4
   b45=b4+b5
   t1=t0+xfac/b01
   t2=t1+xfac/b12
   t3=t2+xfac/b23
   t4=t3+xfac/b34
   t5=t4+xfac/b45
   xspl0=cos(fh*t0+phi0)*tspl0
   xspl1=cos(fh*t1+phi0)*tspl1
   xspl2=cos(fh*t2+phi0)*tspl2
   xspl3=cos(fh*t3+phi0)*tspl3
   xspl4=cos(fh*t4+phi0)*tspl4
   xspl5=cos(fh*t5+phi0)*tspl5
   tspl=19.D0*xspl0+75.D0*xspl1+50.D0*xspl2+50.D0*xspl3+75.D0*xspl4+19.D0*xspl5
   xi1=xpas/288.D0 * tspl
   END FUNCTION xi1
!> *******************************************************************
!! FUNCTION xi2(phi0,t0)
!! coupling terms in R and R' (energy gain)
!< *******************************************************************
   REAL(8) FUNCTION xi2(phi0,t0)
   USE DynacConstants
   USE m4cavs
   USE m4numcavs, ONLY: xpas,b0,b1,b2,b3,b4,b5,tspl1,tspl2,tspl3,tspl4,tspl5
   IMPLICIT NONE
   REAL(8) phi0,t0,t1,t2,t3,t4,t5,xfac,b01,b12,b23,b34,b45
   REAL(8) xspl1,xspl2,xspl3,xspl4,xspl5,tspl
   xfac=xpas/(2.5D0*vl)
   b01=b0+b1
   b12=b1+b2
   b23=b2+b3
   b34=b3+b4
   b45=b4+b5
   t1=t0+xfac/b01
   t2=t1+xfac/b12
   t3=t2+xfac/b23
   t4=t3+xfac/b34
   t5=t4+xfac/b45
!old       xspl0=cos(fh*t0+phi0)*tspl0
   xspl1=cos(fh*t1+phi0)*tspl1
   xspl2=cos(fh*t2+phi0)*tspl2
   xspl3=cos(fh*t3+phi0)*tspl3
   xspl4=cos(fh*t4+phi0)*tspl4
   xspl5=cos(fh*t5+phi0)*tspl5
   tspl=15.D0*xspl1+20.D0*xspl2+30.D0*xspl3+60.D0*xspl4+19.D0*xspl5
   xi2=xpas*xpas/288.D0 * tspl
   END FUNCTION xi2
!> *******************************************************************
!! FUNCTION xj1(phi0,t0)
!! transverse motion field dE/dt
!< *******************************************************************
   REAL(8) FUNCTION xj1(phi0,t0)
   USE DynacConstants
   USE m4cavs
   USE m4numcavs
   IMPLICIT NONE
   REAL(8) phi0,t0,t1,t2,t3,t4,t5,xfac,b01,b12,b23,b34,b45
   REAL(8) xspl0,xspl1,xspl2,xspl3,xspl4,xspl5,tspl
! --- the field is read from disk
   xfac=xpas/(2.5D0*vl)
   b01=b0+b1
   b12=b1+b2
   b23=b2+b3
   b34=b3+b4
   b45=b4+b5
   t1=t0+xfac/b01
   t2=t1+xfac/b12
   t3=t2+xfac/b23
   t4=t3+xfac/b34
   t5=t4+xfac/b45
   xspl0=-fh*sin(fh*t0+phi0)*tspl0/bgt0
   xspl1=-fh*sin(fh*t1+phi0)*tspl1/bgt1
   xspl2=-fh*sin(fh*t2+phi0)*tspl2/bgt2
   xspl3=-fh*sin(fh*t3+phi0)*tspl3/bgt3
   xspl4=-fh*sin(fh*t4+phi0)*tspl4/bgt4
   xspl5=-fh*sin(fh*t5+phi0)*tspl5/bgt5
   tspl=19.D0*xspl0+75.D0*xspl1+50.D0*xspl2+50.D0*xspl3+75.D0*xspl4+19.D0*xspl5
   xj1=xpas/288.D0 * tspl
   END FUNCTION xj1
!> *******************************************************************
!! FUNCTION xj2(phi0,t0)
!! transverse motion field dE/dt
!< *******************************************************************
   REAL(8) FUNCTION xj2(phi0,t0)
   USE DynacConstants
   USE m4cavs
   USE m4numcavs
   IMPLICIT NONE
   REAL(8) phi0,t0,t1,t2,t3,t4,t5,xfac,b01,b12,b23,b34,b45
   REAL(8) xspl1,xspl2,xspl3,xspl4,xspl5,tspl
   xfac=xpas/(2.5D0*vl)
   b01=b0+b1
   b12=b1+b2
   b23=b2+b3
   b34=b3+b4
   b45=b4+b5
   t1=t0+xfac/b01
   t2=t1+xfac/b12
   t3=t2+xfac/b23
   t4=t3+xfac/b34
   t5=t4+xfac/b45
   xspl1=-fh*sin(fh*t1+phi0)*tspl1/bgt1
   xspl2=-fh*sin(fh*t2+phi0)*tspl2/bgt2
   xspl3=-fh*sin(fh*t3+phi0)*tspl3/bgt3
   xspl4=-fh*sin(fh*t4+phi0)*tspl4/bgt4
   xspl5=-fh*sin(fh*t5+phi0)*tspl5/bgt5
   tspl=15.D0*xspl1+20.D0*xspl2+30.D0*xspl3+60.D0*xspl4+19.D0*xspl5
   xj2=xpas*xpas/288.D0 * tspl
   END FUNCTION xj2
!> *******************************************************************
!! FUNCTION xe21(phi0,t0)
!! transverse motion field E*E
!< *******************************************************************
   REAL(8) FUNCTION xe21(phi0,t0)
   USE DynacConstants
   USE m4cavs
   USE m4numcavs
   IMPLICIT NONE
   REAL(8) phi0,t0,t1,t2,t3,t4,t5,b01,b12,b23,b34,b45
   REAL(8) xspl0,xspl1,xspl2,xspl3,xspl4,xspl5,tspl
   b01=b0+b1
   b12=b1+b2
   b23=b2+b3
   b34=b3+b4
   b45=b4+b5
   t1=t0+xpas/(2.5D0*b01*vl)
   t2=t1+xpas/(2.5D0*b12*vl)
   t3=t2+xpas/(2.5D0*b23*vl)
   t4=t3+xpas/(2.5D0*b34*vl)
   t5=t4+xpas/(2.5D0*b45*vl)
   xspl0=cos(fh*t0+phi0)*tspl0
   xspl1=cos(fh*t1+phi0)*tspl1
   xspl2=cos(fh*t2+phi0)*tspl2
   xspl3=cos(fh*t3+phi0)*tspl3
   xspl4=cos(fh*t4+phi0)*tspl4
   xspl5=cos(fh*t5+phi0)*tspl5
   xspl0=xspl0*xspl0*bge0
   xspl1=xspl1*xspl1*bge1
   xspl2=xspl2*xspl2*bge2
   xspl3=xspl3*xspl3*bge3
   xspl4=xspl4*xspl4*bge4
   xspl5=xspl5*xspl5*bge5
   tspl=19.D0*xspl0+75.D0*xspl1+50.D0*xspl2+50.D0*xspl3+75.D0*xspl4+19.D0*xspl5
   xe21=xpas/288.D0 * tspl
   END FUNCTION xe21
!> *******************************************************************
!! FUNCTION xe22(phi0,t0)
!! transverse motion for field E*E
!< *******************************************************************
   REAL(8) FUNCTION xe22(phi0,t0)
   USE DynacConstants
   USE m4cavs
   USE m4numcavs
   USE m4SPLfun
   IMPLICIT NONE
   REAL(8) phi0,t0,t1,t2,t3,t4,t5,b01,b12,b23,b34,b45
   REAL(8) xspl1,xspl2,xspl3,xspl4,xspl5,tspl
   b01=b0+b1
   b12=b1+b2
   b23=b2+b3
   b34=b3+b4
   b45=b4+b5
   t1=t0+xpas/(2.5D0*b01*vl)
   t2=t1+xpas/(2.5D0*b12*vl)
   t3=t2+xpas/(2.5D0*b23*vl)
   t4=t3+xpas/(2.5D0*b34*vl)
   t5=t4+xpas/(2.5D0*b45*vl)
   xspl1=cos(fh*t1+phi0)*tspl1
   xspl2=cos(fh*t2+phi0)*tspl2
   xspl3=cos(fh*t3+phi0)*tspl3
   xspl4=cos(fh*t4+phi0)*tspl4
   xspl5=cos(fh*t4+phi0)*tspl5
   xspl1=xspl1*xspl1*bge1
   xspl2=xspl2*xspl2*bge2
   xspl3=xspl3*xspl3*bge3
   xspl4=xspl4*xspl4*bge4
   xspl5=xspl5*xspl5*bge5
   tspl=15.D0*xspl1+20.D0*xspl2+30.D0*xspl3+60.D0*xspl4+19.D0*xspl5
   xe22=xpas*xpas/288.D0 * tspl
   END FUNCTION xe22
END MODULE fun4cavnum   
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE fun4cavscmc
!---------------------------------------------------------------------
!  Module containing supporting functions for CAVSC and CAVMC
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! FUNCTION xitl0(GAMI,GAMS,BETR,SAPHI,QQC)
!! called by RESTAY and ETGAP  dynamics computations
!< *******************************************************************
   REAL(8) FUNCTION xitl0(GAMI,GAMS,BETR,SAPHI,QQC)
   USE DynacConstants
   USE m4cavs
   USE m4beam, ONLY: xmat
   USE m4gaprestay
   IMPLICIT NONE
   REAL(8) GAMI,GAMS,BETR,SAPHI,QQC
   REAL(8) FH0,CGI,BETI,BETS,XK1,XK2,XKM,TILTA2,XKC1,XKC2,CCL1,CCL2,DAZ0,DAZ1
   REAL(8) DBZ0,DBZ1,DDL1,DDL2,DGZ0,DGZ1,EEL1,EEL2,PHIT0,PHIT10,PHIT11,GIT
   REAL(8) XK11,XK22
   INTEGER I
   FH0=FH/VL
   CGI=QQC/XMAT
   BETI=SQRT(1.D0-1.D0/(GAMI*GAMI))
   BETS=SQRT(1.D0-1.D0/(GAMS*GAMS))
   XK1=FH0/BETI
   XK2=FH0/BETS
   XKM=FH0/BETR
   TILTA2=PHSLIP/(2.D0*EQVL)
   PAVPH=1.D0/10.D0*(XK1- XK2)*EQVL &
   +(XK1-XKM)*ASDL
   XKC1=-FH0/(BETI**3 * GAMI**3)
   XKC2=-FH0/(BETS**3 * GAMS**3)
   DO I=1,2
     PHIT10=SAPHI-PHSLIP/2.D0+PAVPH
     DAZ0=COS(PHIT10)*TILTA2
     DBZ0=SIN(PHIT10)*TILTA2
     DGZ0=CGI*(TK*DAZ0-SK*DBZ0)
     DGZ0=DGZ0/SIN(PHSLIP/2.D0)
     XKP1=XKC1*DGZ0
     PHIT11=SAPHI+PHSLIP/2.D0+PAVPH
     DAZ1=COS(PHIT11)*TILTA2
     DBZ1=SIN(PHIT11)*TILTA2
     DGZ1=CGI*(TK*DAZ1-SK*DBZ1)
     DGZ1=DGZ1/SIN(PHSLIP/2.D0)
     XKP2=XKC2*DGZ1
     PAVPH=1.D0/10.D0*(XK1- XK2)*EQVL+(XK1-XKM)*ASDL
     PAVPH=PAVPH+(XKP1+XKP2)*EQVL**2 / 120.D0
   ENDDO
   XK11=XK1-XKM
   XK22=XK2-XKM
   AA=XK11
   BB=XKP1/2.D0
   CCL1=-(4.D0*XK22+6.D0*XK11)/(EQVL**2)
   CCL2=-(3.D0/2.D0*XKP1-XKP2/2.D0)/EQVL
   CC=CCL1+CCL2
   DDL1=(7.D0*XK22+8.D0*XK11)/(EQVL**3)
   DDL2=(3.D0/2.D0*XKP1-XKP2)/(EQVL**2)
   DD=DDL1+DDL2
   EEL1=-(3.D0*XK22+3.D0*XK11)/(EQVL**4)
   EEL2=-(XKP1/2.D0-XKP2/2.D0)/(EQVL**3)
   EE=EEL1+EEL2
   PHIT0=SAPHI+PAVPH
   GIT = CGI * ( &
   TK*COS(PHIT0)-SK*SIN(PHIT0))
   XITL0=GAMI+GIT
   END FUNCTION xitl0
!> *******************************************************************
!! FUNCTION xitl2(GAMI,GAMS,SAPHI,QQC)
!! called by RESTAY and ETGAP
!! INTEGRAL of S ( EZG * Z/(BETA*GAMA)**3  *DZ)
!! PHASE JUMP
!< *******************************************************************
   REAL(8) FUNCTION xitl2(GAMI,GAMS,SAPHI,QQC)
   USE DynacConstants
   USE m4cavs
   USE m4beam, ONLY: xmat
   USE m4gaprestay
   IMPLICIT NONE
   REAL(8) GAMI,GAMS,SAPHI,QQC
   REAL(8) FH0,CGI,BETI,BETS,TILTA2
   REAL(8) PHIT0,GIT
   REAL(8) BI,DAZ,DBZ,DGZ,EZ,GI,PHIT1,XCC,XCC1,XINT
   INTEGER I
   REAL(8) H(8),T(8)
   DATA H /.101228536D0,.222381034D0,.313706646D0,.362683783D0, &
    .362683783D0,.313706646D0,.222381034D0,.101228536D0/
   DATA T /-.960289856D0,-.796666477D0,-.525532409D0, &
    -.183434642D0,.183434642D0,.525532409D0, &
    .796666477D0,.960289856D0/
   FH0=FH/VL
   CGI=QQC/XMAT
   XITL2=0.D0
   BETI=SQRT(1.D0-1.D0/(GAMI*GAMI))
   BETS=SQRT(1.D0-1.D0/(GAMS*GAMS))
!   XK1=FH0/BETI
!   XK2=FH0/BETS
!   XKM=FH0/BETR
   TILTA2=PHSLIP/(2.D0*EQVL)
   DO I=1,8
     XCC= EQVL*(1.D0+T(I))/2.D0
     PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.D0*EQVL)+PAVPH
     GIT = CGI * (TK*COS(PHIT0)-SK*SIN(PHIT0))
     GI=GAMI+GIT * SIN(XCC*TILTA2)/SIN(PHSLIP/2.D0)
     BI=SQRT(1.D0-1.D0/(GI*GI))
     PHIT1=PHIT0+XCC*PHSLIP/(2.D0*EQVL)
     DAZ=COS(PHIT1)*TILTA2
     DBZ=SIN(PHIT1)*TILTA2
     DGZ=CGI*(TK*DAZ-SK*DBZ)
     DGZ=DGZ/SIN(PHSLIP/2.D0)
     EZ = XMAT/QQC * DGZ
     XINT=1.D0/(BI*GI)
     XCC1=XCC+ASDL
     XITL2=XITL2+H(I)*XINT**3 *XCC1*EZ
   ENDDO
   XITL2=XITL2/2.D0 *EQVL
   END FUNCTION xitl2
!> *******************************************************************
!! FUNCTION xitl3(GAMI,GAMS,BETR,NIT,SAPHI,QQC)
!! called by RESTAY and ETGAP
!! INTEGRAL  S ( EZG * Z/(BETA*GAMA)**3  *DZ)
!! PHASE AND ENERGY AT THE MIDDLE OF THE GAP
!< *******************************************************************
   REAL(8) FUNCTION xitl3(GAMI,GAMS,BETR,NIT,SAPHI,QQC)
   USE DynacConstants
   USE m4cavs
   USE m4beam, ONLY: xmat
   USE m_h_t_h1_t1, ONLY: H,T
   USE m4gaprestay
   USE m4restayMIDGAP, ONLY: ENMIL,VAPMI
   IMPLICIT NONE
   REAL(8) GAMI,GAMS,BETR,SAPHI,QQC
   REAL(8) FH0,CGI,BETI,BETS,TILTA2
   REAL(8) PHIT0,GIT,XK1,XK11,XKM
   REAL(8) BI,DAZ,DBZ,DGZ,EZ,GI,PHIT1,XCC,XCC1,XINT
   INTEGER I,NIT
   FH0=FH/VL
   CGI=QQC/XMAT
   XITL3=0.D0
   BETI=SQRT(1.D0-1.D0/(GAMI*GAMI))
   BETS=SQRT(1.D0-1.D0/(GAMS*GAMS))
   XK1=FH0/BETI
!   XK2=FH0/BETS
   XKM=FH0/BETR
   XK11=XK1-XKM
   TILTA2=PHSLIP/(2.D0*EQVL)
   DO I=1,13
     XCC= EQVL*(1.D0+T(I))/2.D0
     PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.D0*EQVL)+PAVPH
     GIT = CGI * (TK*COS(PHIT0)-SK*SIN(PHIT0))
     GI=GAMI+GIT * SIN(XCC*TILTA2)/SIN(PHSLIP/2.D0)
     BI=SQRT(1.D0-1.D0/(GI*GI))
     PHIT1=PHIT0+XCC*PHSLIP/(2.D0*EQVL)
     DAZ=COS(PHIT1)*TILTA2
     DBZ=SIN(PHIT1)*TILTA2
     DGZ=CGI*(TK*DAZ-SK*DBZ)
     DGZ=DGZ/SIN(PHSLIP/2.D0)
     EZ = XMAT/QQC * DGZ
     XINT=1.D0/(BI*GI)
     XCC1=XCC+ASDL
     XITL3=XITL3+H(I)*XINT**3 *XCC1*EZ
!  ENERGY AND PHASE AT THE MIDDLE OF THE GAP
     IF(NIT.EQ.3.AND.I.EQ.7) THEN
!      ENMIL=XMAT*(GI-GAMI)
       ENMIL=XMAT*(GI-1.D0)
       VAPMI=(XK11*ASDL+SAPHI+XKM*XCC1+AA*XCC+ &
       BB*XCC*XCC+CC*XCC**3+DD*XCC**4+EE*XCC**5)*180.D0/pi
     ENDIF
   ENDDO
   XITL3=XITL3/2.D0 *EQVL
   END FUNCTION xitl3
!> *******************************************************************
!! FUNCTION gamci(PHI,PCRESI,GAMI,IST,QSC)
!! called by RESTAY and ETGAP
!! CURRENT GAMMA VALUE (the POSITION IS GIVEN BY IST)
!< *******************************************************************
   REAL(8) FUNCTION gamci(PHI,PCRESI,GAMI,IST,QSC)
   USE DynacConstants
   USE m4cavs
   USE m4beam, ONLY: xmat
   USE m_h_t_h1_t1, ONLY: h1  
   USE m4gaprestay
   IMPLICIT NONE
   REAL(8) PHI,PCRESI,GAMI,QSC
   INTEGER IST
   REAL(8) TILTA2,CGI,XCC,PHIT0,GIT,GIS
   INTEGER I
   GAMCI=0.D0
   IF(IST.GT.17) RETURN
   CGI=QSC/XMAT
   TILTA2=PHSLIP/(2.D0*EQVL)
   I=IST
   XCC= EQVL*(1.D0+H1(I))/2.D0
   PHIT0=PHI-PHSLIP*(EQVL-XCC)/(2.D0*EQVL)
!  Function GAMMA (Z)
   IF(abs(PHSLIP).GT.fprec) THEN
     GIT = CGI * SQCTTF*COS(PHIT0-PCRESI)/PHSLIP
     GIS =  SIN(XCC*TILTA2)
   ELSE
     GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
     GIS =  XCC/(2.D0*EQVL)
   ENDIF
   GAMCI=GAMI+GIT * GIS
   END FUNCTION gamci
END MODULE fun4cavscmc
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE fun4scherm
!---------------------------------------------------------------------
!  Module containing supporting functions for SCHERM
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! FUNCTION codsy(BB,CC,DD,EE,KAP)
!! specific function called by SCHERM
!< *******************************************************************
   REAL(8) FUNCTION codsy(BB,CC,DD,EE,KAP)
   USE m_h_t_h1_t1, ONLY: H,T  
   USE m4scherm2
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) BB,CC,DD,EE
   INTEGER KAP
   REAL(8) FF,Z,DENDIFR,ZZ,Z1,ZS
   INTEGER I,K
   CODSY=0.D0
   K=KAP-1
   FF=2.D0*EE-CC
   DO I=1,13
     DENDIFR=0.D0
     Z= (CC+FF)/2.D0+(CC-FF)*T(I)/2.D0
     IF(Z.GE.FF.AND.Z.LT.EE) THEN
       ZS=2.D0*EE-Z
       Z1=DD+BB-ZS
       IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
       IF(ZS.GE.BB) &
       DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
     ENDIF
     IF(Z.GE.EE) THEN
       IF(Z.LT.BB) DENDIFR=DENSZ(NMAZ,Z,0)
       Z1=DD+BB-Z
       IF(Z.GE.BB) &
       DENDIFR=DENSZ(NMAZ,Z,0)-DENSZ(NMAZ,Z1,0)
     ENDIF
     IF(DENDIFR.lt. 0.D0) DENDIFR=0.D0
     ZZ=Z-EE
!    ZRMS2(EFFECTIF)=ZRMS2(CALCULE)*ZRMS
     ZZ=ZZ/ZRMS2
     CODSY=CODSY+H(I)*HERM(2*K,ZZ)*DENDIFR
   ENDDO
   CODSY=CODSY*(CC-FF)/2.D0
   END FUNCTION codsy
!> *******************************************************************
!! FUNCTION codif(BB,CC,DD,EE,EE1,KAP)
!! specific function called by SCHERM
!< *******************************************************************
   REAL(8) FUNCTION codif(BB,CC,DD,EE,EE1,KAP)
   USE m_h_t_h1_t1, ONLY: H,T  
   USE m4scherm2
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) BB,CC,DD,EE,EE1
   INTEGER KAP
   REAL(8) FF,FF1,Z,DENDIFR,ZZ,Z1,ZS
   INTEGER I,K
   CODIF=0.D0
   K=KAP-1
   FF=2.D0*EE1-EE
   FF1=2.D0*EE-CC
   DENDIFR=0.D0
   DO I=1,13
     Z=(EE+FF)/2.D0+(EE-FF)*T(I)/2.D0
     IF(Z.LE.FF1) DENDIFR=DENSZ(NMAZ,Z,0)
     IF(Z .GE.FF1)  THEN
       ZS=2.D0*EE-Z
       Z1=DD+BB-ZS
       IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
       IF(ZS.GE.BB) &
         DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
       DENDIFR=DENSZ(NMAZ,Z,0)-DENDIFR
     endif
     IF(Z.gt. 0.D0) dendifr=0.D0
     IF(DENDIFR.lt. 0.D0) DENDIFR=0.D0
     ZZ=Z-EE1
!    ZRMS2(EFFECTIF)=ZRMS2(CALCULE)*ZRMS
     ZZ=ZZ/ZRMS3
     CODIF=CODIF+H(I)*HERM(2*K,ZZ)*DENDIFR
   ENDDO
   CODIF=-CODIF*FF/2.D0
   END FUNCTION codif
!> *******************************************************************
!! FUNCTION varia(BB,CC,DD,EE)
!! specific function called by SCHERM
!< *******************************************************************
   REAL(8) FUNCTION varia(BB,CC,DD,EE)
   USE m_h_t_h1_t1, ONLY: H,T  
   USE m4scherm2
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) BB,CC,DD,EE
   REAL(8) FF,Z,DENDIFR,ZZ,Z1,ZS,CODI1,CODI2
   INTEGER I
   VARIA=0.D0
   CODI1=0.D0
   CODI2=0.D0
   FF=2.D0*EE-CC
   DO I=1,13
     DENDIFR=0.D0
     Z= (CC+FF)/2.D0+(CC-FF)*T(I)/2.D0
     IF(Z.GE.FF.AND.Z.LT.EE) THEN
       ZS=2.D0*EE-Z
       Z1=DD+BB-ZS
       IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
       IF(ZS.GE.BB) &
       DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
     ENDIF
     IF(Z.GE.EE) THEN
       IF(Z.LT.BB) DENDIFR=DENSZ(NMAZ,Z,0)
       Z1=DD+BB-Z
       IF(Z.GE.BB) &
       DENDIFR=DENSZ(NMAZ,Z,0)-DENSZ(NMAZ,Z1,0)
     ENDIF
     ZZ=Z-EE
     IF(DENDIFR.lt. 0.D0) DENDIFR=0.D0
     CODI1=CODI1+H(I)*ZZ*ZZ*DENDIFR
     CODI2=CODI2+H(I)*DENDIFR
   ENDDO
   VARIA=CODI1/CODI2
   END FUNCTION varia
!> *******************************************************************
!! FUNCTION variz(BB,CC,DD,EE,EE1)
!! specific function called by SCHERM
!< *******************************************************************
   REAL(8) FUNCTION variz(BB,CC,DD,EE,EE1)
   USE m_h_t_h1_t1, ONLY: H,T  
   USE m4scherm2
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) BB,CC,DD,EE,EE1
   REAL(8) FF,FF1,Z,DENDIFR,ZZ,Z1,ZS,CODI1,CODI2
   INTEGER I
   VARIZ=0.D0
   CODI1=0.D0
   CODI2=0.D0
   FF=2.D0*EE1-EE
   FF1=2.D0*EE-CC
   DO I=1,13
     DENDIFR=0.D0
     Z= (EE+FF)/2.D0+(EE-FF)*T(I)/2.D0
     IF(Z.LE.FF1) DENDIFR=DENSZ(NMAZ,Z,0)
     IF(Z .GE.FF1)  THEN
       ZS=2.D0*EE-Z
       Z1=DD+BB-ZS
       IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
       IF(ZS.GE.BB) &
       DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
       DENDIFR=DENSZ(NMAZ,Z,0)-DENDIFR
     endif
     IF(Z.Gt.EE) dendifr=0.D0
     IF(DENDIFR.lt. 0.D0) DENDIFR=0.D0
     ZZ=Z-EE1
     CODI1=CODI1+H(I)*ZZ*ZZ*DENDIFR
     CODI2=CODI2+H(I)*DENDIFR
   ENDDO
   VARIZ=CODI1/CODI2
   END FUNCTION variz
!> *******************************************************************
!! FUNCTION grz(AA,BB,CC,DD,EE)
!! specific function called by SCHERM
!< *******************************************************************
   REAL(8) FUNCTION grz(AA,BB,CC,DD,EE)
   USE m_h_t_h1_t1, ONLY: H,T  
   USE m4scherm2
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) AA,BB,CC,DD,EE
   REAL(8) Z,GS,GZ,dif
   INTEGER I
   GRZ=0.D0
   GZ=0.D0
   GS=0.D0
   DO I=1,13
     Z= (EE+AA)/2.D0+(EE-AA)*T(I)/2.D0
     dif=dendir(z,aa,bb,cc,dd,ee)
     if(dif.lt. 0.D0)dif=0.D0
     GZ=GZ+H(I)*Z*DIF
     GS=GS+H(I)*DIF
   ENDDO
   IF(GS .LE. 0.D0) GRZ=0.D0
   IF(GS.gt. 0.D0) GRZ=GZ/GS
   END FUNCTION grz
!> *******************************************************************
!! FUNCTION dendir(Z,AA,BB,CC,DD,EE)
!! Specific function called by SCHERM
!! Calculate the value (nt(z)-nm(z))
!< *******************************************************************
   REAL(8) FUNCTION dendir(Z,AA,BB,CC,DD,EE)
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) Z,AA,BB,CC,DD,EE
   REAL(8) FF,Z1,ZS,DENDIFR
   DENDIR=0.D0
   FF=2.D0*EE-CC
   IF(Z.LT.AA)DENDIR=0.D0
   IF(Z.GE.AA.AND.Z.LT.FF) DENDIR=DENSZ(NMAZ,Z,0)
   IF(Z.GE.FF.AND.Z.LT.EE) THEN
     ZS=2.D0*EE-Z
     Z1=DD+BB-ZS
     DENDIFR=0.D0
     IF(ZS.LT.BB) DENDIFR=DENSZ(NMAZ,ZS,0)
     IF(ZS.GE.BB) &
       DENDIFR=DENSZ(NMAZ,ZS,0)-DENSZ(NMAZ,Z1,0)
     DENDIR=DENSZ(NMAZ,Z,0)-DENDIFR
   ENDIF
   IF(Z.GE.EE) DENDIR=0.D0
   END FUNCTION dendir
!> *******************************************************************
!! FUNCTION dendif(Z,AA,BB,CC,DD)
!! Specific function called by SCHERM
!! Calculate the value (nt(z)-nm(z))
!< *******************************************************************
   REAL(8) FUNCTION dendif(Z,AA,BB,CC,DD)
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) Z,AA,BB,CC,DD
   REAL(8) Z1
   DENDIF=0.D0
   IF(Z.LT.AA)DENDIF=0.D0
   IF(Z.GE.AA.AND.Z.LT.BB) DENDIF=DENSZ(NMAZ,Z,0)
   IF(Z.GE.BB.AND.Z.LT.CC) THEN
     Z1=DD+BB-Z
     DENDIF=DENSZ(NMAZ,Z,0)-DENSZ(NMAZ,Z1,0)
   ENDIF
   IF(Z.GE.CC) DENDIF=0.D0
   END FUNCTION dendif
!> *******************************************************************
!! FUNCTION drxyz(M,XYZ,IRECA)
!! Specific function called by SCHERM
!! Calculate the derivatives of:(n(x)+n(y)+n(z))/3
!!      IRECA=0 : for the first ellipse
!!      IRECA=1 : for the second ellipse
!!      IRECA=2 : for the third ellipse
!< *******************************************************************
   REAL(8) FUNCTION drxyz(M,XYZ,IRECA)
   USE DynacConstants, ONLY: PI
   USE m4scherm
   USE m4scherm2
   USE m4HERMRR, ONLY: AFXRR,AFYRR,AFZRR
   IMPLICIT NONE
   REAL(8) XYZ
   INTEGER M,IRECA
   REAL(8) DERIV1,DERIV2,fe,axyz,DXXYZ,DYXYZ,DZXYZ
   INTEGER K,KAP,KAH,MSTO
   DERIV1=0.D0
   DERIV2=0.D0
   IF(ABS(XYZ).GT.13.D0) XYZ=13.D0
   fe=EXP(-XYZ*XYZ/2.D0)
   axyz=ABS(xyz)
   MSTO=M
   DO K=2,M
     KAP=K-1
     KAH=2*KAP-1
     IF(IRECA.EQ.0) THEN
       DXXYZ=fe*DBLE(KAP)*AFXM(K)*HERS(KAH,axyz)
       DYXYZ=fe*DBLE(KAP)*AFYM(K)*HERS(KAH,axyz)
       DZXYZ=fe*DBLE(KAP)*AFZM(K)*HERS(KAH,axyz)
       DERIV1=DERIV1+(DXXYZ+DYXYZ+DZXYZ)
     ENDIF
     IF(IRECA.EQ.1) THEN
       DXXYZ=fe*DBLE(KAP)*AFXR(K)*HERS(KAH,axyz)
       DYXYZ=fe*DBLE(KAP)*AFYR(K)*HERS(KAH,axyz)
       DZXYZ=fe*DBLE(KAP)*AFZR(K)*HERS(KAH,axyz)
       DERIV1=DERIV1+(DXXYZ+DYXYZ+DZXYZ)
     ENDIF
     IF(IRECA.EQ.2) THEN
       DXXYZ=fe*DBLE(KAP)*AFXRR(K)*HERS(KAH,axyz)
       DYXYZ=fe*DBLE(KAP)*AFYRR(K)*HERS(KAH,axyz)
       DZXYZ=fe*DBLE(KAP)*AFZRR(K)*HERS(KAH,axyz)
       DERIV1=DERIV1+(DXXYZ+DYXYZ+DZXYZ)
     ENDIF
   ENDDO
   DO K=1,M
     KAP=2*(K-1)
     IF(IRECA.EQ.0) THEN
       DXXYZ=-fe*AFXM(K)*HERM(KAP,XYZ)
       DYXYZ=-fe*AFYM(K)*HERM(KAP,XYZ)
       DZXYZ=-fe*AFZM(K)*HERM(KAP,XYZ)
       DERIV2=DERIV2+0.5D0*(DXXYZ+DYXYZ+DZXYZ)
     ENDIF
     IF(IRECA.EQ.1) THEN
       DXXYZ=-fe*AFXR(K)*HERM(KAP,XYZ)
       DYXYZ=-fe*AFYR(K)*HERM(KAP,XYZ)
       DZXYZ=-fe*AFZR(K)*HERM(KAP,XYZ)
       DERIV2=DERIV2+0.5D0*(DXXYZ+DYXYZ+DZXYZ)
     ENDIF
     IF(IRECA.EQ.2) THEN
       DXXYZ=-fe*AFXRR(K)*HERM(KAP,XYZ)
       DYXYZ=-fe*AFYRR(K)*HERM(KAP,XYZ)
       DZXYZ=-fe*AFZRR(K)*HERM(KAP,XYZ)
       DERIV2=DERIV2+0.5D0*(DXXYZ+DYXYZ+DZXYZ)
     ENDIF
   ENDDO
   DRXYZ=-(DERIV1+DERIV2)/(3.D0*PI)
   M=MSTO
   END FUNCTION drxyz
!> *******************************************************************
!! FUNCTION hers(M,X)
!! Specific Hermite polynomials called by the function DRXYZ
!< *******************************************************************
   REAL(8) FUNCTION hers(M,X)
   IMPLICIT NONE
   REAL(8) X
   INTEGER M
   REAL(8) XM1
   INTEGER K,M1
   REAL(8) HE(30)
   IF(M.EQ.1) THEN
     HERS=1.D0
   ELSEIF(M.EQ.3) THEN
     HERS=X*X-3.D0
   ELSE
     HE(1)=1.D0
     HE(2)=X*X-3.D0
     XM1=DBLE((M+1)/2)+.01D0
     M1=INT(XM1)-2
     DO K=1,M1
       HE(K+2)=HERM(2*(K+2)-2,ABS(X))-DBLE(2*(K+2)-2)*HE(K+1)
     ENDDO
     HERS=HE(M1+2)
   ENDIF   
   END FUNCTION hers
!> *******************************************************************
!! FUNCTION fact(m)
!! FACTORIAL of M
!< *******************************************************************
   REAL(8) FUNCTION fact(m)
   IMPLICIT NONE
   INTEGER K,M
   FACT=1.D0
   IF(M.EQ.0) RETURN
   DO  K=1,M
     FACT=FACT*DBLE(K)
   ENDDO
   END FUNCTION fact
!> *******************************************************************
!! FUNCTION snzt(CC,DD)
!! specific function called by SCHERM
!< *******************************************************************
   REAL(8) FUNCTION snzt(CC,DD)
   USE m4scherm2
   USE m_h_t_h1_t1, ONLY: H1,T1  
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) CC,DD
   REAL(8) DENZ,Z
   INTEGER i
   SNZT=0.D0
   DO I=1,17
     Z= (CC+DD)/2.D0+(DD-CC)*H1(I)/2.D0
     DENZ=DENSZ(NMAZ,Z,0)
     IF(DENZ.lt. 0.D0) DENZ=0.D0
     SNZT=SNZT+T1(I)*DENZ
   ENDDO
   SNZT=SNZT*(DD-CC)/2.D0
   END FUNCTION snzt
!> *******************************************************************
!! FUNCTION snzd(cc,dd)
!! specific function called by SCHERM
!< *******************************************************************
   REAL(8) FUNCTION snzd(cc,dd)
   USE m4scherm2
   USE m_h_t_h1_t1, ONLY: H1,T1  
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) CC,DD
   REAL(8) DENZ,Z,ZZ
   INTEGER i
   SNZD=0.D0
   DO I=1,17
     Z= (CC+DD)/2.D0+(DD-CC)*H1(I)/2.D0
     DENZ=DENSZ(NMAZ,Z,0)
     IF(DENZ.lt. 0.D0) EXIT
     ZZ=(Z-CC)
     SNZD=SNZD+T1(I)*DENZ
   ENDDO
   SNZD=SNZD*(DD-CC)
   END FUNCTION snzd
!> *******************************************************************
!! FUNCTION vaprz(CC,DD)
!! specific function called by SCHERM
!< *******************************************************************
   REAL(8) FUNCTION vaprz(CC,DD)
   USE m4scherm2
   USE m_h_t_h1_t1, ONLY: H1,T1  
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) CC,DD
   REAL(8) DENZ,Z,ZZ,VAR1,VAR2
   INTEGER i
   VAPRZ=0.D0
   VAR1=0.D0
   VAR2=0.D0
   DO I=1,17
     Z= (CC+DD)/2.D0+(DD-CC)*H1(I)/2.D0
     DENZ=DENSZ(NMAZ,Z,0)
     IF(DENZ.lt. 0.D0) EXIT
     ZZ=(Z-CC)
     VAR1=VAR1+T1(I)*ZZ*ZZ*DENZ
     VAR2=VAR2+T1(I)*DENZ
   ENDDO
   VAPRZ=VAR1/VAR2
   END FUNCTION vaprz
!> *******************************************************************
!! FUNCTION prinz(CC,DD,KAP,ZRMSS1)
!! specific function called by SCHERM
!< *******************************************************************
   REAL(8) FUNCTION prinz(CC,DD,KAP,ZRMSS1)
   USE m4scherm2
   USE m_h_t_h1_t1, ONLY: H1,T1  
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) CC,DD,ZRMSS1
   INTEGER KAP
   REAL(8) DENZ,Z,ZZ
   INTEGER i,k
   PRINZ=0.D0
   K=KAP-1
   DO I=1,17
     DENZ=0.D0
     Z= (CC+DD)/2.D0+(DD-CC)*H1(I)/2.D0
     DENZ=DENSZ(NMAZ,Z,0)
     IF(DENZ.lt. 0.D0) EXIT
     ZZ=(Z-CC)/ZRMSS1
     PRINZ=PRINZ+T1(I)*HERM(2*K,ZZ)*DENZ
   ENDDO
   PRINZ=PRINZ*(DD-CC)/2.D0
   END FUNCTION prinz
!> *******************************************************************
!! SUBROUTINE rchsom(ZI,ZF,NMAZ)
!! specific function called by SCHERM
!! Look for the top of the partial distributions
!< *******************************************************************
   SUBROUTINE rchsom(ZI,ZF,NMAZ)
   IMPLICIT NONE
   REAL(8) ZI,ZF
   INTEGER NMAZ
   REAL(8) XPZ,ZTEST,Z1,Z2,T1,T2
!*******************************************************************
   XPZ=ABS((ZF-ZI))/400.D0
   DO
     ZTEST=ABS(ZF-ZI)
     IF(ZTEST.LE.XPZ) EXIT
     Z1=(ZF+ZI)/2.D0
     Z2=(Z1+ZI)/2.D0
     T1=DENSZ(NMAZ,Z1,0)
     T2=DENSZ(NMAZ,Z2,0)
!    new interval: Z2,ZF
     IF(T1.GT.T2) ZI=Z2
!    new interval  : ZI,Z1
     IF(T1.LT.T2) ZF=Z1
   ENDDO
   END SUBROUTINE rchsom
!> *******************************************************************
!! SUBROUTINE rchsor(AA,BB,CC,DD,ZS)
!! specific function called by SCHERM
!! Look for the top of the partial distributions
!< *******************************************************************
   SUBROUTINE rchsor(AA,BB,CC,DD,ZS)
   IMPLICIT NONE
   REAL(8) AA,BB,CC,DD,ZS
   REAL(8) ZI,ZF,XPZ,Z1,Z2,T1,T2,ZTEST
!*******************************************************************
   ZI=AA
   ZF=CC
   XPZ=ABS((ZF-ZI))/400.D0
   DO
     ZTEST=ABS(ZF-ZI)
     IF(ZTEST.LE.XPZ) EXIT
     Z1=(ZF+ZI)/2.D0
     Z2=(Z1+ZI)/2.D0
     T1=DENDIF(Z1,AA,BB,CC,DD)
     T2=DENDIF(Z2,AA,BB,CC,DD)
!    NEW INTERVAL : Z2,ZF
     IF(T1.GT.T2) ZI=Z2
!    NEW INTERVAL : ZI,Z1
     IF(T1.LT.T2) ZF=Z1
   ENDDO
   ZS=(ZI+ZF)/2.D0
   END SUBROUTINE rchsor
!> *******************************************************************
!! FUNCTION herm(M,X)
!! Hermite polynomials
!< *******************************************************************
   REAL(8) FUNCTION herm(M,X)
   IMPLICIT NONE
   REAL(8) X
   INTEGER M,K,M1
   REAL(8) HE(30)
!*******************************************************************
   IF(M.EQ.0) THEN
     HERM=1.D0
     RETURN
   ENDIF
   IF(M.EQ.1) THEN
     HERM=X
     RETURN
   ENDIF
   HE(1)=1.D0
   HE(2)=X
   M1=M-1
   DO K=1,M1
     HE(K+2)=X*HE(K+1)-DBLE(K)*HE(K)
   ENDDO
   HERM=HE(M+1)
   END FUNCTION herm
!> *******************************************************************
!! FUNCTION densz(M,Z,IRECA)
!! called by SCHERM
!! Look for the distribution in z position
!< *******************************************************************
   REAL(8) FUNCTION densz(M,Z,IRECA)
   USE m4scherm
   USE m4DEGHERM
   IMPLICIT NONE
   REAL(8) Z
   INTEGER M,IRECA
   INTEGER K,KAP
!*******************************************************************
   DENSZ=0.D0
   DO K=1,M
     KAP=K-1
     IF(IRECA.EQ.0) DENSZ=DENSZ+EXP(-Z*Z/2.D0)*AFZT(K)*HERM(KAP,Z)
     IF(IRECA.EQ.2) DENSZ=DENSZ+EXP(-Z*Z/2.D0)*AFZM(K)*HERM(2*KAP,Z)
     IF(IRECA.EQ.3) DENSZ=DENSZ+EXP(-Z*Z/2.D0)*AFZR(K)*HERM(2*KAP,Z)
   ENDDO
   END FUNCTION densz
!> *******************************************************************
!! FUNCTION eppp(it1,it2,it3)
!! E(2it3,2it2,2it1)   table 77-a-1
!< *******************************************************************
   REAL(8) FUNCTION eppp(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   IMPLICIT NONE
   REAL(8) sgn1,sgn2
   REAL(8) fprec,e1,e2,pcas3,rint,scum,wsng
   INTEGER it1,it2,it3  
   INTEGER isgnw,ipar,ipt12,ipt22,ipt212,isgn1,k,kj
!*******************************************************************
   eppp=0.D0
   isgnw=4*(it2+it1)+5*it3
   ipar=isgnw-2*(isgnw/2)
   wsng=-1.D0
   if(ipar.eq.0)wsng=1.D0
   eppp=wsng*pi2*exs3*rms(3,3)
   eppp=eppp*(tppp(it1,it2,it3)+sppp(it1,it2,it3))
   eppp=eppp-8.D0*wsng*rms(3,3)*sqpi*sgppp(it1,it2,it3)
   fprec=epsilon(s3)
   if(abs(s3).gt.fprec) then
     sgn1=-1.D0
     sgn2=1.D0
     isgn1=3*(it1+it2)+4*it3
     ipar=isgn1-2*(isgn1/2)
     if(ipar.eq.0) then
       sgn1=1.D0
       sgn2=-1.D0
     endif
     ipt12=2*it1+1
     ipt22=2*it2+1
     ipt212=2*(it1+it2)
     rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
     e1=2.D0*sgn1*pi2*pwas3*rint*uppp(it1,it2,it3)
     scum=0.D0
     kj=1
     pcas3=pwas3
     do k=1,kmax,2
       scum=scum+ck(k)*pcas3*vppp(kj)
       kj=kj+1
       pcas3=pcas3*s32
     enddo
     e2=scum*sgn2*2.D0*pi2*rint*exs3
     eppp=eppp+e1+e2
   endif
   END FUNCTION eppp
!> *******************************************************************
!! FUNCTION epip(it1,it2,it3)
!! E(2it3,2it2+1,2it1)  table 77-a-2
!< *******************************************************************
   REAL(8) FUNCTION epip(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sgn1,sgn2
   REAL(8) fprec,e1,e2,pcas3,rint,scum,wsng,pwas31
   INTEGER it1,it2,it3  
   INTEGER isgnw,ipar,ipt12,ipt22,ipt212,isgn1,k,kj
   epip=0.D0
   isgnw=4*(it2+it1)+5*it3+2
   ipar=isgnw-2*(isgnw/2)
   wsng=-1.D0
   if(ipar.eq.0)wsng=1.D0
   epip=wsng*pi2*exs3*rms(3,3)
   epip=epip*(tpip(it1,it2,it3)+spip(it1,it2,it3))
   epip=epip-8.D0*wsng*rms(3,3)*sqpi*sgpip(it1,it2,it3)
   fprec=epsilon(s3)
   if(abs(s3).gt.fprec) then
     pwas31=pwas3*as3
     sgn1=-1.D0
     sgn2=1.D0
     isgn1=3*(it1+it2)+4*it3+2
     ipar=isgn1-2*(isgn1/2)
     if(ipar.eq.0) then
       sgn1=1.D0
       sgn2=-1.D0
     endif
     ipt12=2*it1+1
     ipt22=2*it2+2
     ipt212=2*(it1+it2)+1
     rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
     e1=2.D0*sgn1*pi2*pwas31*rint*upip(it1,it2,it3)
     scum=0.D0
     kj=1
     pcas3=pwas31
     do k=1,kmax,2
       scum=scum+ck(k)*pcas3*vpip(kj)
       kj=kj+1
       pcas3=pcas3*s32
     enddo
     e2=scum*sgn2*2.D0*pi2*rint*exs3
     epip=epip+(e1+e2)
   endif
   END FUNCTION epip
!> *******************************************************************
!! FUNCTION eppi(it1,it2,it3)
!! E(2it3,2it2,2it1+1) table 77-a-2
!< *******************************************************************
   REAL(8) FUNCTION eppi(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sgn1,sgn2
   REAL(8) fprec,e1,e2,pcas3,rint,scum,wsng,xsgn1,pwas31,pari
   INTEGER it1,it2,it3  
   INTEGER isgnw,ipar,ipt12,ipt22,ipt212,isgn1,k,kj
   eppi=0.D0
   isgnw=4*(it2+it1)+5*it3+2
   ipar=isgnw-2*(isgnw/2)
   wsng=-1.D0
   if(ipar.eq.0)wsng=1.D0
   eppi=wsng*pi2*exs3*rms(3,3)
   eppi=eppi*(tppi(it1,it2,it3)+sppi(it1,it2,it3))
   eppi=eppi-8.D0*wsng*rms(3,3)*sqpi*sgppi(it1,it2,it3)
   fprec=epsilon(s3)
   if(abs(s3).gt.fprec) then
     pwas31=pwas3*as3
     sgn1=-1.D0
     sgn2=1.D0
     isgn1=3*(it1+it2)+4*it3+2
     xsgn1=DBLE(isgn1)
     pari=xsgn1-2.D0*DBLE(int(xsgn1/2.D0+0.0001D0))
     if(abs(pari).le.fprec) then
       sgn1=1.D0
       sgn2=-1.D0
     endif
     ipt12=2*it1+2
     ipt22=2*it2+1
     ipt212=2*(it1+it2)+1
     rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
     e1=2.D0*sgn1*pi2*pwas31*rint*uppi(it1,it2,it3)
     scum=0.D0
     kj=1
     pcas3=pwas31
     do k=1,kmax,2
       scum=scum+ck(k)*pcas3*vppi(kj)
       kj=kj+1
       pcas3=pcas3*s32
     enddo
     e2=scum*sgn2*2.D0*pi2*rint*exs3
     eppi=eppi+(e1+e2)
   endif
   END FUNCTION eppi
!> *******************************************************************
!! FUNCTION epii(it1,it2,it3)
!! E(2*it3,2*it2+1,2*it1+1) table 77-a-1
!< *******************************************************************
   REAL(8) FUNCTION epii(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sgn1,sgn2
   REAL(8) fprec,e1,e2,pcas3,rint,scum,wsng,pwas31
   INTEGER it1,it2,it3  
   INTEGER isgnw,ipar,ipt12,ipt22,ipt212,isgn1,k,kj
   epii=0.D0
   isgnw=4*(it2+it1)+5*it3+4
   ipar=isgnw-2*(isgnw/2)
   wsng=-1.D0
   if(ipar.eq.0)wsng=1.D0
   epii=wsng*pi2*exs3*rms(3,3)
   epii=epii*(tpii(it1,it2,it3)+spii(it1,it2,it3))
   epii=epii-8.D0*wsng*rms(3,3)*sqpi*sgpii(it1,it2,it3)
   fprec=epsilon(s3)
   if(abs(s3).gt.fprec) then
     pwas31=pwas3*s32
     sgn1=-1.D0
     sgn2=1.D0
     isgn1=3*(it1+it2)+4*it3+4
     ipar=isgn1-2*(isgn1/2)
     if(ipar.eq.0) then
       sgn1=1.D0
       sgn2=-1.D0
     endif
     ipt12=2*it1+2
     ipt22=2*it2+2
     ipt212=2*(it1+it2+1)
     rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
     e1=2.D0*sgn1*pi2*pwas31*rint*upii(it1,it2,it3)
     scum=0.D0
     kj=1
     pcas3=pwas31
     do k=1,kmax,2
       scum=scum+ck(k)*pcas3*vpii(kj)
       kj=kj+1
       pcas3=pcas3*s32
     enddo
     e2=scum*sgn2*2.D0*pi2*rint*exs3
     epii=epii+e1+e2
   endif
   END FUNCTION epii
!> *******************************************************************
!! FUNCTION eipp(it1,it2,it3)
!! E(2it3+1,2it2,2it1) table 77-b-2
!< *******************************************************************
   REAL(8) FUNCTION eipp(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sgn1,sgn2
   REAL(8) fprec,e1,e2,pcas3,rint,scum,wsng,pwas31
   INTEGER it1,it2,it3  
   INTEGER isgnw,ipar,ipt12,ipt22,ipt212,isgn1,k,kj
   eipp=0.D0
   isgnw=4*(it2+it1)+5*it3+3
   ipar=isgnw-2*(isgnw/2)
   wsng=-1.D0
   if(ipar.eq.0)wsng=1.D0
   eipp=wsng*sgns3*pi2*exs3*rms(3,3)
   eipp=eipp*(tipp(it1,it2,it3)+sipp(it1,it2,it3))
   eipp=eipp+8.D0*wsng*rms(3,3)*sqpi*sgipp(it1,it2,it3)
   fprec=epsilon(s3)
   if(abs(s3).gt.fprec) then
     pwas31=pwas3*as3
     sgn1=-1.D0
     sgn2=1.D0
     isgn1=3*(it1+it2)+4*it3+3
     ipar=isgn1-2*(isgn1/2)
     if(ipar.eq.0) then
       sgn1=1.D0
       sgn2=-1.D0
     endif
     ipt12=2*it1+1
     ipt22=2*it2+1
     ipt212=2*(it1+it2)
     rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
     e1=2.D0*sgn1*pi2*pwas31*rint*uipp(it1,it2,it3)*sgns3
     scum=0.D0
     kj=1
     pcas3=pwas31
     do k=1,kmax,2
       scum=scum+ck(k)*pcas3*vipp(kj)
       kj=kj+1
       pcas3=pcas3*s32
     enddo
     e2=scum*sgn2*2.D0*pi2*rint*exs3*sgns3
     eipp=eipp-(e1+e2)
   endif
   END FUNCTION eipp
!> *******************************************************************
!! FUNCTION eiip(it1,it2,it3)
!! E(2it3+1,2it2+1,2it1)  table 77-b-1
!< *******************************************************************
   REAL(8) FUNCTION eiip(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sgn1,sgn2
   REAL(8) fprec,e1,e2,pcas3,rint,scum,wsng,pwas31
   INTEGER it1,it2,it3  
   INTEGER isgnw,ipar,ipt12,ipt22,ipt212,isgn1,k,kj
   eiip=0.D0
   isgnw=4*(it2+it1)+5*it3+5
   ipar=isgnw-2*(isgnw/2)
   wsng=-1.D0
   if(ipar.eq.0)wsng=1.D0
   eiip=wsng*sgns3*pi2*exs3*rms(3,3)
   eiip=eiip*(tiip(it1,it2,it3)+siip(it1,it2,it3))
   eiip=eiip+8.D0*wsng*rms(3,3)*sqpi*sgiip(it1,it2,it3)
   fprec=epsilon(s3)
   if(abs(s3).gt.fprec) then
     pwas31=pwas3*s32
     sgn1=-1.D0
     sgn2=1.D0
     isgn1=3*(it1+it2)+4*it3+5
     ipar=isgn1-2*(isgn1/2)
     if(ipar.eq.0) then
       sgn1=1.D0
       sgn2=-1.D0
     endif
     ipt12=2*it1+1
     ipt22=2*it2+2
     ipt212=2*(it1+it2)+1
     rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
     e1=2.D0*sgn1*pi2*pwas31*rint*uiip(it1,it2,it3)*sgns3
     scum=0.D0
     kj=1
     pcas3=pwas31
     do k=1,kmax,2
       scum=scum+ck(k)*pcas3*viip(kj)
       kj=kj+1
       pcas3=pcas3*s32
     enddo
     e2=scum*sgn2*2.D0*pi2*rint*exs3*sgns3
     eiip=eiip-(e1+e2)
   endif
   END FUNCTION eiip
!> *******************************************************************
!! FUNCTION eipi(it1,it2,it3)
!! E(2*it3+1,2*it2,2*it1+1)  table 77-b-1
!< *******************************************************************
   REAL(8) FUNCTION eipi(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sgn1,sgn2
   REAL(8) fprec,e1,e2,pcas3,rint,scum,wsng,pwas31
   INTEGER it1,it2,it3  
   INTEGER isgnw,ipar,ipt12,ipt22,ipt212,isgn1,k,kj
   eipi=0.D0
   isgnw=4*(it2+it1)+5*it3+5
   ipar=isgnw-2*(isgnw/2)
   wsng=-1.D0
   if(ipar.eq.0)wsng=1.D0
   eipi=wsng*sgns3*pi2*exs3*rms(3,3)
   eipi=eipi*(tipi(it1,it2,it3)+sipi(it1,it2,it3))
   eipi=eipi+8.D0*wsng*rms(3,3)*sqpi*sgipi(it1,it2,it3)
   fprec=epsilon(s3)
   if(abs(s3).gt.fprec) then
     pwas31=pwas3*s32
     sgn1=-1.D0
     sgn2=1.D0
     isgn1=3*(it1+it2)+4*it3+5
     ipar=isgn1-2*(isgn1/2)
     if(ipar.eq.0) then
       sgn1=1.D0
       sgn2=-1.D0
     endif
     ipt12=2*it1+2
     ipt22=2*it2+1
     ipt212=2*(it1+it2)+1
     rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
     e1=2.D0*sgn1*pi2*pwas31*rint*uipi(it1,it2,it3)*sgns3
     scum=0.D0
     kj=1
     pcas3=pwas31
     do k=1,kmax,2
       scum=scum+ck(k)*pcas3*vipi(kj)
       kj=kj+1
       pcas3=pcas3*s32
     enddo
     e2=scum*sgn2*2.D0*pi2*rint*exs3*sgns3
     eipi=eipi-(e1+e2)
   endif
   END FUNCTION eipi
!> *******************************************************************
!! FUNCTION eiii(it1,it2,it3)
!! E(2*it3+1,2*it2+1,2*it1+1) table 77-b-2
!< *******************************************************************
   REAL(8) FUNCTION eiii(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sgn1,sgn2
   REAL(8) fprec,e1,e2,pcas3,rint,scum,wsng,pwas31
   INTEGER it1,it2,it3  
   INTEGER isgnw,ipar,ipt12,ipt22,ipt212,isgn1,k,kj
   eiii=0.D0
   isgnw=4*(it2+it1)+5*it3+5
   ipar=isgnw-2*(isgnw/2)
   wsng=-1.D0
   if(ipar.eq.0)wsng=1.D0
   eiii=wsng*sgns3*pi2*exs3*rms(3,3)
   eiii=eiii*(tiii(it1,it2,it3)+siii(it1,it2,it3))
   eiii=eiii+8.D0*wsng*rms(3,3)*sqpi*sgiii(it1,it2,it3)
   fprec=epsilon(s3)
   if(abs(s3).gt.fprec) then
     pwas31=pwas3*s32*as3
     sgn1=-1.D0
     sgn2=1.D0
     isgn1=3*(it1+it2)+4*it3+5
     ipar=isgn1-2*(isgn1/2)
     if(ipar.eq.0) then
       sgn1=1.D0
       sgn2=-1.D0
     endif
     ipt12=2*it1+2
     ipt22=2*it2+2
     ipt212=2*(it1+it2)+2
     rint=rms(1,ipt12+1)*rms(2,ipt22+1)/rms(3,ipt212+1)
     e1=2.D0*sgn1*pi2*pwas31*rint*uiii(it1,it2,it3)*sgns3
     scum=0.D0
     kj=1
     pcas3=pwas31
     do k=1,kmax,2
       scum=scum+ck(k)*pcas3*viii(kj)
       kj=kj+1
       pcas3=pcas3*s32
     enddo
     e2=scum*sgn2*2.D0*pi2*rint*exs3*sgns3
     eiii=eiii-(e1+e2)
   endif
   END FUNCTION eiii
!> *******************************************************************
!! FUNCTION tipp(it1,it2,it3)
!! Part of W**(2t3+1,2t2,2t1)  table 61-b
!! with T(2t3+1,2t2,2t1,j1)    table 41
!< *******************************************************************
   REAL(8) FUNCTION tipp(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc3
   IMPLICIT NONE
! *******************************************************************
   REAL(8) stoc,tt,tt1,xsj1
   INTEGER it1,it2,it3  
   INTEGER kk,j1,m,it3j1,mm,mm1,it23jm,j1km,jj1,jm1,k,km1,it1m
   tipp=0.D0
   if(.not.makti) then
     makti=.true.
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       xsj1=1.D0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1
!     term T(2t3+1,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
     do m=1,it3j1+1
           mm1=m-1
           stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
           stc1i(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+1)
           mm=mm+1
         enddo
!       s3pw(j1km+1)=as3**j1km
         stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
         stc2i(kk,jj1)=2.D0*fpar(km1,2*jm1)*stoc
         tt1=tt1+tt*stc2i(kk,jj1)
         xsj1=-xsj1
         jm1=jm1+1
         jj1=jj1+1
       enddo
       tipp=tt1*ck(k)+tipp
       kk=kk+1
     enddo
   else
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1
!    term T(2t3+1,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+1)
           mm1=mm1+1
         enddo
         tt1=tt1+tt*stc2i(kk,jj1)
         jm1=jm1+1
         jj1=jj1+1
       enddo
       tipp=tt1*ck(k)+tipp
       kk=kk+1
     enddo
   endif
   END FUNCTION tipp
!> *******************************************************************
!! FUNCTION tiip(it1,it2,it3)
!! part of W**(2t3+1,2t2+1,2t1)  table 61-b
!! with  T(2t3+1,2t2+1,2t1,j1)   table 41
!< *******************************************************************
   REAL(8) FUNCTION tiip(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc3
   IMPLICIT NONE
! *******************************************************************
   REAL(8) stoc,tt,tt1,xsj1
   INTEGER it1,it2,it3  
   INTEGER kk,j1,m,it3j1,mm,mm1,it23jm,j1km,jj1,jm1,k,km1,it1m
   tiip=0.D0
   if(.not.makti) then
     makti=.true.
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       xsj1=1.D0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
           stc1i(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+1)
           mm=mm+1
         enddo
!  s3pw(j1km+1)=as3**j1km
         stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
         stc2i(kk,jj1)=2.D0*fpar(km1,2*jm1)*stoc
         tt1=tt1+tt*stc2i(kk,jj1)
         xsj1=-xsj1
         jm1=jm1+1
         jj1=jj1+1
       enddo
       tiip=tt1*ck(k)+tiip
       kk=kk+1
     enddo
   else
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1
!   term T(2t3+1,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+1)
           mm=mm+1
         enddo
         tt1=tt1+tt*stc2i(kk,jj1)
         jm1=jm1+1
         jj1=jj1+1
       enddo
       tiip=tt1*ck(k)+tiip
       kk=kk+1
     enddo
   endif
   END FUNCTION tiip
!> *******************************************************************
!! FUNCTION tipi(it1,it2,it3)
!! part of W**(2t3+1,2t2,2t1+1) in table 61-b
!! with T(2t3+1,2t2,2t1+1,j1)   in table 41
!< *******************************************************************
   REAL(8) FUNCTION tipi(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc3
   IMPLICIT NONE
! *******************************************************************
   REAL(8) stoc,tt,tt1,xsj1
   INTEGER it1,it2,it3  
   INTEGER kk,j1,m,it3j1,mm,mm1,it23jm,j1km,jj1,jm1,k,km1,it1m
   tipi=0.D0
   if(.not.makti) then
     makti=.true.
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       xsj1=1.D0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1
!   term T(2t3+1,2t2+1,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
           stc1i(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
           mm=mm+1
         enddo
!  s3pw(j1km+1)=as3**j1km
         stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
         stc2i(kk,jj1)=2.D0*fpar(km1,2*jm1)*stoc
         tt1=tt1+tt*stc2i(kk,jj1)
         xsj1=-xsj1
         jm1=jm1+1
         jj1=jj1+1
       enddo
       tipi=tt1*ck(k)+tipi
       kk=kk+1
     enddo
   else
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1
!   term T(2t3+1,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
           mm=mm+1
         enddo
         tt1=tt1+tt*stc2i(kk,jj1)
         jm1=jm1+1
         jj1=jj1+1
       enddo
       tipi=tt1*ck(k)+tipi
       kk=kk+1
     enddo
   endif
   END FUNCTION tipi
!> *******************************************************************
!! FUNCTION tiii(it1,it2,it3)
!! part of W**(2t3+1,2t2+1,2t1+1) in table 61-b
!! with T(2t3+1,2t2+1,2t1+1,j1)   in table 41
!< *******************************************************************
   REAL(8) FUNCTION tiii(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc3
   IMPLICIT NONE
! *******************************************************************
   REAL(8) stoc,tt,tt1,xsj1
   INTEGER it1,it2,it3  
   INTEGER kk,j1,m,it3j1,mm,mm1,it23jm,j1km,jj1,jm1,k,km1,it1m
   tiii=0.D0
   if(.not.makti) then
     makti=.true.
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       xsj1=1.D0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1
!   term T(2t3+1,2t2+1,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
           stc1i(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+2)
           mm=mm+1
         enddo
!  s3pw(j1km+1)=as3**j1km
         stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
         stc2i(kk,jj1)=2.D0*fpar(km1,2*jm1)*stoc
         tt1=tt1+tt*stc2i(kk,jj1)
         xsj1=-xsj1
         jm1=jm1+1
         jj1=jj1+1
       enddo
       tiii=tt1*ck(k)+tiii
       kk=kk+1
     enddo
   else
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1
!   term T(2t3+1,2t2+1,2t1+1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1i(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+2)
           mm1=mm1+1
         enddo
         tt1=tt1+tt*stc2i(kk,jj1)
         jm1=jm1+1
         jj1=jj1+1
       enddo
       tiii=tt1*ck(k)+tiii
       kk=kk+1
     enddo
   endif
   END FUNCTION tiii
!> *******************************************************************
!! FUNCTION tppp(it1,it2,it3)
!! part of W**(2t3,2t2,2t1) in table 61-a
!! with  T(2t3,2t2,2t1,j1)  in table 41
!< *******************************************************************
   REAL(8) FUNCTION tppp(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc3
   IMPLICIT NONE
! *******************************************************************
   REAL(8) stoc,tt,tt1,xsj1
   INTEGER it1,it2,it3  
   INTEGER kk,j1,m,it3j1,mm,mm1,it23jm,j1km,jj1,jm1,k,km1,it1m
   tppp=0.D0
   if(.not.maktp) then
     maktp=.true.
     kk=1
     do k=2,kmax,2
       km1=k-1
       xsj1=1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1-1
!  j1km must be always greather or equal to zero
         if(j1km.lt.0) EXIT
!  T(2t3,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
           stc1p(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+1)
           mm=mm+1
         enddo
!  s3pw(j1km+1)=as3**j1km
         stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
         stc2p(kk,jj1)=2.D0*fpar(km1,2*jm1+1)*stoc
         tt1=tt1+tt*stc2p(kk,jj1)
         xsj1=-xsj1
         jm1=jm1+1
         jj1=jj1+1
       enddo
       if(j1km.ge.0) then
         tppp=tt1*ck(k)+tppp
         kk=kk+1
       endif
     enddo
   else
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1-1
!   j1km must be always greather or equal to zero
         if(j1km.lt.0) EXIT
!  T(2t3,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+1)
           mm=mm+1
         enddo
         tt1=tt1+tt*stc2p(kk,jj1)
         jm1=jm1+1
         jj1=jj1+1
       enddo
       if(j1km.ge.0) then
         tppp=tt1*ck(k)+tppp
         kk=kk+1
       endif
     enddo
   endif
   END FUNCTION tppp
!> *******************************************************************
!! FUNCTION tpip(it1,it2,it3)
!! the part of W**(2t3,2t2,2t1+1) in table 61-a
!! with T(2t3,2t2,2t1+1,j1)       in table 41
!< *******************************************************************
   REAL(8) FUNCTION tpip(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc3
   IMPLICIT NONE
! *******************************************************************
   REAL(8) stoc,tt,tt1,xsj1
   INTEGER it1,it2,it3  
   INTEGER kk,j1,m,it3j1,mm,mm1,it23jm,j1km,jj1,jm1,k,km1,it1m
   tpip=0.D0
   if(.not.maktp) then
     maktp=.true.
     kk=1
     do k=2,kmax,2
       km1=k-1
       xsj1=1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1-1
!   j1km must be always greather or equal to zero
         if(j1km.lt.0) EXIT
!   T(2t3,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
           stc1p(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+1)
           mm=mm+1
         enddo
!   s3pw(j1km+1)=as3**j1km
         stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
         stc2p(kk,jj1)=2.D0*fpar(km1,2*jm1+1)*stoc
         tt1=tt1+tt*stc2p(kk,jj1)
         xsj1=-xsj1
         jm1=jm1+1
         jj1=jj1+1
       enddo
       if(j1km.ge.0) then
         tpip=tt1*ck(k)+tpip
         kk=kk+1
       endif
     enddo
   else
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1-1
!  j1km must be always greather or equal to zero
         if(j1km.lt.0) EXIT
!   T(2t3,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+1)
           mm=mm+1
         enddo
         tt1=tt1+tt*stc2p(kk,jj1)
         jm1=jm1+1
         jj1=jj1+1
       enddo
       if(j1km.ge.0) then
         tpip=tt1*ck(k)+tpip
         kk=kk+1
       endif
     enddo
   endif
   END FUNCTION tpip
!> *******************************************************************
!! FUNCTION tppi(it1,it2,it3)
!! part of W**(2t3,2t2,2t1+1) in table 61-a
!! with T(2t3,2t2,2t1+1,j1)   in table 41
!< *******************************************************************
   REAL(8) FUNCTION tppi(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc3
   IMPLICIT NONE
! *******************************************************************
   REAL(8) stoc,tt,tt1,xsj1
   INTEGER it1,it2,it3  
   INTEGER kk,j1,m,it3j1,mm,mm1,it23jm,j1km,jj1,jm1,k,km1,it1m
   tppi=0.D0
   if(.not.maktp) then
     maktp=.true.
     kk=1
     do k=2,kmax,2
       km1=k-1
       xsj1=1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1-1
!   j1km must be always greather or equal to zero
         if(j1km.lt.0) EXIT
!   T(2t3,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
           stc1p(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
           mm=mm+1
         enddo
!   s3pw(j1km+1)=as3**j1km
         stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
         stc2p(kk,jj1)=2.D0*fpar(km1,2*jm1+1)*stoc
         tt1=tt1+tt*stc2p(kk,jj1)
         xsj1=-xsj1
         jm1=jm1+1
         jj1=jj1+1
       enddo
       if(j1km.ge.0) then
         tppi=tt1*ck(k)+tppi
         kk=kk+1
       endif
     enddo
   else
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1-1
!   j1km must be always greather or equal to zero
         if(j1km.lt.0) EXIT
!   T(2t3,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
           mm=mm+1
         enddo
         tt1=tt1+tt*stc2p(kk,jj1)
         jm1=jm1+1
         jj1=jj1+1
       enddo
       if(j1km.ge.0) then
         tppi=tt1*ck(k)+tppi
         kk=kk+1
       endif
     enddo
   endif
   END FUNCTION tppi
!> *******************************************************************
!! FUNCTION tpii(it1,it2,it3)
!! part of W**(2t3,2t2+1,2t1+1) in table 61-a
!! with T(2t3,2t2+1,2t1+1,j1)   in table 41
!< *******************************************************************
   REAL(8) FUNCTION tpii(it1,it2,it3)
   USE DynacConstants, ONLY: ck,kmax,pi2,sqpi,pwtpi,sqpi2,sq2pi
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc3
   IMPLICIT NONE
! *******************************************************************
   REAL(8) stoc,tt,tt1,xsj1
   INTEGER it1,it2,it3  
   INTEGER kk,j1,m,it3j1,mm,mm1,it23jm,j1km,jj1,jm1,k,km1,it1m
   tpii=0.D0
   if(.not.maktp) then
     maktp=.true.
     kk=1
     do k=2,kmax,2
       km1=k-1
       xsj1=1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1-1
!   j1km must be always greather or equal to zero
         if(j1km.lt.0) EXIT
!   T(2t3,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           stoc=rms(1,2*mm1+1)*rms(2,2*(it3j1-mm1)+1)
           stc1p(kk,jj1,mm)=fpar(it3j1,mm1)/stoc
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+2)*hs1(it1m+2)
           mm=mm+1
         enddo
!   s3pw(j1km+1)=as3**j1km
         stoc=rms(3,2*it3j1+1)*s3pw(j1km+1)*xsj1
         stc2p(kk,jj1)=2.D0*fpar(km1,2*jm1+1)*stoc
         tt1=tt1+tt*stc2p(kk,jj1)
         xsj1=-xsj1
         jm1=jm1+1
         jj1=jj1+1
       enddo
       if(j1km.ge.0) then
         tpii=tt1*ck(k)+tpii
         kk=kk+1
       endif
     enddo
   else
     kk=1
     do k=2,kmax,2
       km1=k-1
       tt1=0.D0
       jm1=0
       jj1=1
       do j1=1,km1,2
         j1km=km1-2*jm1-1
!   j1km must be always greather or equal to zero
         if(j1km.lt.0) EXIT
!   T(2t3,2t2,2t1,j1) in table 41
         it3j1=it3+jm1
         tt=0.D0
         mm=1
         do m=1,it3j1+1
           mm1=m-1
           it23jm=2*(it2+it3+jm1-mm1)
           it1m=2*(it1+mm1)
           tt=tt+stc1p(kk,jj1,mm)*hs2(it23jm+1)*hs1(it1m+2)
           mm=mm+1
         enddo
         tt1=tt1+tt*stc2p(kk,jj1)
         jm1=jm1+1
         jj1=jj1+1
       enddo
       if(j1km.ge.0) then
         tpii=tt1*ck(k)+tpii
         kk=kk+1
       endif
     enddo
   endif
   END FUNCTION tpii
!> *******************************************************************
!! FUNCTION sipp(it1,it2,it3)
!! second part of W**(2t3+1,2t2,2t1) in table 61-b
!! with S(2t3+1,2t2,2t1,j1)  in table 70-b
!< *******************************************************************
   REAL(8) FUNCTION sipp(it1,it2,it3)
   USE DynacConstants
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc4
   IMPLICIT NONE
! *******************************************************************
   REAL(8) tt,tt1,xsj1
   REAL(8) base,bsp,htm0,htp0,stock
   INTEGER i1123j1,i2123j1,it12p,it1p,it2p
   INTEGER it1,it2,it3  
   INTEGER kk,j1,j1km,jj1,jm1,k,km1
   INTEGER ig,jj2
   sipp=0.D0
   it1p=2*it1+1
   it2p=2*it2+1
   it12p=2*(it1+it2+1)+1
   bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
   kk=1
   do k=1,kmax,2
     xsj1=-1.D0
     km1=k-1
     tt1=0.D0
     jm1=0
     jj2=1
     do j1=1,km1,2
       jj1=2*jm1+1
       j1km=km1-jj1
         if(j1km.lt.0) EXIT
!  S(2t3+1,2t2,2t1,j1) computation
!  Gauss quadrature in table 70-b
       i1123j1=it1+it2+it3+jm1+1
       i2123j1=2*i1123j1
       tt=0.D0
       do ig=1,igaus
! Hermite functions are in the table hsint(ig,,ind )
!   caution!! !! in the table hsint the indice ind is starting from 1
!              i2123j1 is starting from zero
         base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
         htm0=hsint(ig,2,i2123j1+1)
         htp0=hsint(ig,1,i2123j1+1)
         tt=tt+base/sqblam(ig)*(htm0+htp0)
       enddo
       if(.not.maksi) then
!   s3pw(j1km+1)=as3**j1km
         stock=2.D0*xsj1*s3pw(j1km+1)
         sstci(kk,jj2)=fpar(km1,jj1)*stock
         xsj1=-xsj1
       endif
       tt1=sstci(kk,jj2)*tt+tt1
       jj2=jj2+1
       jm1=jm1+1
     enddo
     if(j1km.ge.0) then
       sipp=sipp+tt1*ck(k)
       kk=kk+1
!  enddo from k (k=1,kmax+1)
     endif
   enddo
   sipp=sipp*bsp
   maksi=.true.
   END FUNCTION sipp
!> *******************************************************************
!! FUNCTION siip(it1,it2,it3)
!! W**(2t3+1,2t2+1,2t1)       in table 61-b
!! with S(2t3+1,2t2+1,2t1,j1) in table 70-b
!< *******************************************************************
   REAL(8) FUNCTION siip(it1,it2,it3)
   USE DynacConstants
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc4, ONLY: sstci,maksi
   IMPLICIT NONE
! *******************************************************************
   REAL(8) tt,tt1,xsj1
   REAL(8) base,bsp,htm0,htp0,stock
   INTEGER i1123j1,i2123j1,it12p,it1p,it2p
   INTEGER it1,it2,it3  
   INTEGER kk,j1,j1km,jj1,jm1,k,km1
   INTEGER ig,jj2
   siip=0.D0
   it1p=2*it1+1
   it2p=2*it2+2
   it12p=2*(it1+it2+2)
   bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
   kk=1
   do k=1,kmax,2
     xsj1=-1.D0
     km1=k-1
     tt1=0.D0
     jm1=0
     jj2=1
     do j1=1,km1,2
       jj1=2*jm1+1
       j1km=km1-jj1
         if(j1km.lt.0) EXIT
!   S(2t3+1,2t2,2t1,j1) computation
!   Gauss quadrature in table 70-b
       i1123j1=it1+it2+it3+jm1+2
       i2123j1=2*i1123j1-1
       tt=0.D0
       do ig=1,igaus
! Hermite functions
         base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
         htm0=hsint(ig,2,i2123j1+1)
         htp0=hsint(ig,1,i2123j1+1)
         tt=tt+base*(htp0-htm0)
       enddo
       if(.not.maksi) then
!   s3pw(j1km+1)=as3**j1km
         stock=2.D0*xsj1*s3pw(j1km+1)
         sstci(kk,jj2)=fpar(km1,jj1)*stock
         xsj1=-xsj1
       endif
       tt1=sstci(kk,jj2)*tt+tt1
       jj2=jj2+1
       jm1=jm1+1
     enddo
     if(j1km.ge.0) then
       siip=siip+tt1*ck(k)
       kk=kk+1
     endif
!  enddo from k (k=1,kmax+1)
   enddo
   siip=siip*bsp
   maksi=.true.
   END FUNCTION siip
!> *******************************************************************
!! FUNCTION sipi(it1,it2,it3)
!! part of W**(2t3+1,2t2,2t1+1)     in table 61-b
!! with S(2t3+1,2t2,2t1+1,j1) given in table 70-b
!< *******************************************************************
   REAL(8) FUNCTION sipi(it1,it2,it3)
   USE DynacConstants
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc4, ONLY: sstci,maksi
   IMPLICIT NONE
! *******************************************************************
   REAL(8) tt,tt1,xsj1
   REAL(8) base,bsp,htm0,htp0,stock
   INTEGER i1123j1,i2123j1,it12p,it1p,it2p
   INTEGER it1,it2,it3  
   INTEGER kk,j1,j1km,jj1,jm1,k,km1
   INTEGER ig,jj2
   sipi=0.D0
   it1p=2*it1+2
   it2p=2*it2+1
   it12p=2*(it1+it2+2)
   bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
   kk=1
   do k=1,kmax,2
     xsj1=-1.D0
     km1=k-1
     tt1=0.D0
     jm1=0
     jj2=1
     do j1=1,km1,2
       jj1=2*jm1+1
       j1km=km1-jj1
         if(j1km.lt.0) EXIT
!   S(2t3+1,2t2,2t1,j1) computation
!   Gauss quadrature in table 70-b
       i1123j1=it1+it2+it3+jm1+2
       i2123j1=2*i1123j1-1
       tt=0.D0
       do ig=1,igaus
! Hermite functions
         base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
         htm0=hsint(ig,2,i2123j1+1)
         htp0=hsint(ig,1,i2123j1+1)
         tt=tt+base*(htp0+htm0)
       enddo
       if(.not.maksi) then
!   s3pw(j1km+1)=as3**j1km
         stock=2.D0*xsj1*s3pw(j1km+1)
         sstci(kk,jj2)=fpar(km1,jj1)*stock
         xsj1=-xsj1
       endif
       tt1=sstci(kk,jj2)*tt+tt1
       jj2=jj2+1
       jm1=jm1+1
     enddo
     if(j1km.ge.0) then
       sipi=sipi+tt1*ck(k)
       kk=kk+1
     endif
!  enddo from k (k=1,kmax+1)
   enddo
   sipi=sipi*bsp
   maksi=.true.
   END FUNCTION sipi
!> *******************************************************************
!! FUNCTION siii(it1,it2,it3)
!! part of W**(2t3+1,2t2+1,2t1+1) in table 61-b
!! with S(2t3+1,2t2+1,2t1+1,j1)   in table 70-b
!< *******************************************************************
   REAL(8) FUNCTION siii(it1,it2,it3)
   USE DynacConstants
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc4, ONLY: sstci,maksi
  IMPLICIT NONE
! *******************************************************************
   REAL(8) tt,tt1,xsj1
   REAL(8) base,bsp,htm0,htp0,stock
   INTEGER i1123j1,i2123j1,it12p,it1p,it2p
   INTEGER it1,it2,it3  
   INTEGER kk,j1,j1km,jj1,jm1,k,km1
   INTEGER ig,jj2
   siii=0.D0
   it1p=2*it1+2
   it2p=2*it2+2
   it12p=2*(it1+it2+2)+1
   bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
   kk=1
   do k=1,kmax,2
     xsj1=-1.D0
     km1=k-1
     tt1=0.D0
     jm1=0
     jj2=1
     do j1=1,km1,2
       jj1=2*jm1+1
       j1km=km1-jj1
       if(j1km.lt.0) EXIT
!   S(2t3+1,2t2,2t1,j1) computation
!    Gauss quadrature in table 70-b
       i1123j1=it1+it2+it3+jm1+2
       i2123j1=2*i1123j1
       tt=0.D0
       do ig=1,igaus
! Hermite functions
         base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
         htm0=hsint(ig,2,i2123j1+1)
         htp0=hsint(ig,1,i2123j1+1)
         tt=tt+base*(htm0-htp0)/sqblam(ig)
       enddo
       if(.not.maksi) then
!   s3pw(j1km+1)=as3**j1km
         stock=2.D0*xsj1*s3pw(j1km+1)
         sstci(kk,jj2)=fpar(km1,jj1)*stock
         xsj1=-xsj1
       endif
       tt1=sstci(kk,jj2)*tt+tt1
       jj2=jj2+1
       jm1=jm1+1
     enddo
     if(j1km.ge.0) then
       siii=siii+tt1*ck(k)
       kk=kk+1
     endif
!  enddo from k (k=1,kmax+1)
   enddo
   siii=-siii*bsp
   maksi=.true.
   END FUNCTION siii
!> *******************************************************************
!! FUNCTION sppp(it1,it2,it3)
!! part of W**(2t3,2t2,2t1)     in table 61-a
!! with S(2t3,2t2,2t1,j1) given in table 70-a
!< *******************************************************************
   REAL(8) FUNCTION sppp(it1,it2,it3)
   USE DynacConstants
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc4, ONLY: sstcp,maksp
   IMPLICIT NONE
! *******************************************************************
   REAL(8) tt,tt1,xsj1
   REAL(8) base,bsp,htm0,htp0,stock
   INTEGER i1123j1,i2123j1,it12p,it1p,it2p
   INTEGER it1,it2,it3  
   INTEGER kk,j1,j1km,jj1,jm1,k,km1
   INTEGER ig
   sppp=0.D0
   it1p=2*it1+1
   it2p=2*it2+1
   it12p=2*(it1+it2+1)+1
   bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
   kk=1
   do k=1,kmax,2
     km1=k-1
     xsj1=1
     tt1=0.D0
     jj1=1
     do j1=1,k
       jm1=j1-1
       j1km=km1-2*jm1
       if(j1km.lt.0) EXIT
!   j1km must be always greather or equal to zero
!    Gauss quadrature in table 70-a
       i1123j1=it1+it2+it3+jm1
       i2123j1=2*i1123j1
       tt=0.D0
       do ig=1,igaus
! Hermite functions
         base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1)
         htm0=hsint(ig,2,i2123j1+1)
         htp0=hsint(ig,1,i2123j1+1)
         tt=tt+base*(htm0+htp0)/sqblam(ig)
       enddo
       if(.not.maksp) then
!   s3pw(j1km+1)=as3**j1km
         stock=2.D0*xsj1*s3pw(j1km+1)
         sstcp(kk,jj1)=fpar(km1,2*jm1)*stock
         xsj1=-xsj1
       endif
       tt1=sstcp(kk,jj1)*tt+tt1
!  enddo from  j1
       jj1=jj1+1
     enddo
     sppp=sppp+tt1*ck(k)
     kk=kk+1
!  enddo from k (k=1,kmax+1)
   enddo
   sppp=sppp*bsp
   maksp=.true.
   END FUNCTION sppp
!> *******************************************************************
!! FUNCTION spip(it1,it2,it3)
!! part of W**(2t3,2t2,2t1+1)     in table 61-a
!! with S(2t3,2t2,2t1+1,j1) given in table 70-a
!< *******************************************************************
   REAL(8) FUNCTION spip(it1,it2,it3)
   USE DynacConstants
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc4, ONLY: sstcp,maksp
   IMPLICIT NONE
! *******************************************************************
   REAL(8) tt,tt1,xsj1
   REAL(8) base,bsp,htm0,htp0,stock
   INTEGER i1123j1,i2123j1,it12p,it1p,it2p
   INTEGER it1,it2,it3  
   INTEGER kk,j1,j1km,jj1,jm1,k,km1
   INTEGER ig
   spip=0.D0
   it1p=2*it1+1
   it2p=2*it2+2
   it12p=2*(it1+it2+1)+2
   bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
   kk=1
   do k=1,kmax,2
     km1=k-1
     xsj1=1
     tt1=0.D0
     jj1=1
     do j1=1,k
       jm1=j1-1
       j1km=km1-2*jm1
       if(j1km.lt.0) EXIT
!     j1km must be always greather or equal to zero
!    Gauss quadrature in table 70-a
       i1123j1=it1+it2+it3+jm1
       i2123j1=2*i1123j1+1
       tt=0.D0
       do ig=1,igaus
! Hermite functions
         base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1+1)
         htm0=hsint(ig,2,i2123j1+1)
         htp0=hsint(ig,1,i2123j1+1)
         tt=tt+base*(htp0-htm0)
       enddo
       if(.not.maksp) then
!   s3pw(j1km+1)=as3**j1km
         stock=2.D0*xsj1*s3pw(j1km+1)
         sstcp(kk,jj1)=fpar(km1,2*jm1)*stock
         xsj1=-xsj1
       endif
       tt1=sstcp(kk,jj1)*tt+tt1
!  enddo from  j1
       jj1=jj1+1
     enddo
     spip=spip+tt1*ck(k)
     kk=kk+1
!  enddo from k (k=1,kmax+1)
   enddo
   spip=spip*bsp
   maksp=.true.
   END FUNCTION spip
!> *******************************************************************
!! FUNCTION sppi(it1,it2,it3)
!! part of W**(2t3,2t2,2t1+1)     in table 61-a
!! with S(2t3,2t2,2t1+1,j1) given in table 70-a
!< *******************************************************************
   REAL(8) FUNCTION sppi(it1,it2,it3)
   USE DynacConstants
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc4, ONLY: sstcp,maksp
   IMPLICIT NONE
! *******************************************************************
   REAL(8) tt,tt1,xsj1
   REAL(8) base,bsp,htm0,htp0,stock
   INTEGER i1123j1,i2123j1,it12p,it1p,it2p
   INTEGER it1,it2,it3  
   INTEGER kk,j1,j1km,jj1,jm1,k,km1
   INTEGER ig
   sppi=0.D0
   it1p=2*it1+2
   it2p=2*it2+1
   it12p=2*(it1+it2+1)+2
   bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
   kk=1
   do k=1,kmax,2
     km1=k-1
     xsj1=1.D0
     tt1=0.D0
     jj1=1
     do j1=1,k
       jm1=j1-1
       j1km=km1-2*jm1
!    j1km must be always greather or equal to zero
       if(j1km.lt.0) EXIT
!     Gauss quadrature in table 70-a
       i1123j1=it1+it2+it3+jm1
       i2123j1=2*i1123j1+1
       tt=0.D0
       do ig=1,igaus
! Hermite functions
         base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1+1)
         htm0=hsint(ig,2,i2123j1+1)
         htp0=hsint(ig,1,i2123j1+1)
         tt=tt+base*(htm0+htp0)
       enddo
       if(.not.maksp) then
!   s3pw(j1km+1)=as3**j1km
         stock=2.D0*xsj1*s3pw(j1km+1)
         sstcp(kk,jj1)=fpar(km1,2*jm1)*stock
         xsj1=-xsj1
       endif
       tt1=sstcp(kk,jj1)*tt+tt1
!  enddo from  j1
       jj1=jj1+1
     enddo
     sppi=sppi+tt1*ck(k)
     kk=kk+1
!  enddo from k (k=1,kmax+1)
   enddo
   sppi=sppi*bsp
   maksp=.true.
   END FUNCTION sppi
!> *******************************************************************
!! FUNCTION spii(it1,it2,it3)
!! part of W**(2t3,2t2,2t1+1)       in table 61-a
!! with S(2t3,2t2+1,2t1+1,j1) given in table 70-a
!< *******************************************************************
   REAL(8) FUNCTION spii(it1,it2,it3)
   USE DynacConstants
!           pi2=pi*pi, sqpi=(pi/2)**3/2
   USE m4hersc
   USE m4hersc2
   USE m4hersc4, ONLY: sstcp,maksp
   IMPLICIT NONE
! *******************************************************************
   REAL(8) tt,tt1,xsj1
   REAL(8) base,bsp,htm0,htp0,stock
   INTEGER i1123j1,i2123j1,it12p,it1p,it2p
   INTEGER it1,it2,it3  
   INTEGER kk,j1,j1km,jj1,jm1,k,km1
   INTEGER ig
   spii=0.D0
   it1p=2*it1+2
   it2p=2*it2+2
   it12p=2*(it1+it2+2)+1
   bsp=rms(1,it1p+1)*rms(2,it2p+1)/(sq2pi*rms(3,it12p))
   kk=1
   do k=1,kmax,2
     km1=k-1
     xsj1=1.D0
     tt1=0.D0
     jj1=1
     do j1=1,k
       jm1=j1-1
       j1km=km1-2*jm1
       if(j1km.lt.0) EXIT
!     j1km must be always greather or equal to zero
!     Gauss quadrature in table 70-a
       i1123j1=it1+it2+it3+jm1
       i2123j1=2*i1123j1+2
       tt=0.D0
       do ig=1,igaus
! Hermite functions
         base=co(ig,it1p)*sn(ig,it2p)/blam(ig,i1123j1+1)
         htm0=hsint(ig,2,i2123j1+1)
         htp0=hsint(ig,1,i2123j1+1)
         tt=tt+base*(htm0-htp0)/sqblam(ig)
       enddo
       if(.not.maksp) then
!  s3pw(j1km+1)=as3**j1km
         stock=2.D0*xsj1*s3pw(j1km+1)
         sstcp(kk,jj1)=fpar(km1,2*jm1)*stock
         xsj1=-xsj1
       endif
       tt1=sstcp(kk,jj1)*tt+tt1
!  enddo from  j1
       jj1=jj1+1
     enddo
     spii=spii+tt1*ck(k)
     kk=kk+1
!  enddo from k (k=1,kmax+1)
   enddo
   maksp=.true.
   spii=-spii*bsp
   END FUNCTION spii
!****************************************************************
!  funtions sigma in table 14
!   these functions are used in tables 77-a-1 to 77-b-2
!   sgppp -->l,m and n even
!   sgpip --> l even, m odd, n even
!   .................................
!*****************************************************************
!> *******************************************************************
!! FUNCTION sgppp(it1,it2,it3)
!! FUNCTION sigma(2t3,2t2,2t1) in table 14
!! in E(2t3,2t2,2t1)           in table 77-a-1
!< *******************************************************************
   REAL(8) FUNCTION sgppp(it1,it2,it3)
   USE m4hersc
   USE m4hersc3, ONLY: hs1,hs2,hs3
   USE m4HermiteFun
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sg1,sgn,stoc
   INTEGER it1,it2,it3  
   INTEGER ik,it3k,it3kp1,jk,jkm1,jt1j,jt23kj,jt3kj,km2
   sgppp=0.D0
   if(it3.eq.0) return
   sgn=-1.D0
   if(.not.mksgp) then
     mksgp=.true.
     do ik=1,it3
       sg1=0.D0
       km2=2*ik-2
       it3kp1=it3-ik+1
       it3k=2*(it3-ik)
       sgp3(ik)=sgn*hs3(km2+1)*rms(3,it3k+1)
       do jk=1,it3kp1
         jkm1=jk-1
         jt3kj=2*(it3-ik-jkm1)
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
         sgrp(ik,jk)=fpar(it3-ik,jkm1)/stoc
         sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+1)
       enddo
       sgppp=sgppp+sgp3(ik)*sg1
       sgn=-sgn
     enddo
   else
     do ik=1,it3
       sg1=0.D0
       it3kp1=it3-ik+1
       do jk=1,it3kp1
         jkm1=jk-1
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+1)
       enddo
       sgppp=sgppp+sgp3(ik)*sg1
     enddo
   endif
   END FUNCTION sgppp
!> *******************************************************************
!! FUNCTION sgpip(it1,it2,it3)
!! FUNCTION sigma(2t3,2t+1,2t1) in table 14
!! is in E(2t3,2t2+1,2t1) given in table 77-a-2
!< *******************************************************************
REAL(8) FUNCTION sgpip(it1,it2,it3)
   USE m4hersc
   USE m4hersc3, ONLY: hs1,hs2,hs3
   USE m4HermiteFun
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sg1,sgn,stoc
   INTEGER it1,it2,it3  
   INTEGER ik,it3k,it3kp1,jk,jkm1,jt1j,jt23kj,jt3kj,km2
   sgpip=0.D0
   if(it3.eq.0) return
   sgn=-1.D0
   if(.not.mksgp) then
     mksgp=.true.
     do ik=1,it3
       sg1=0.D0
       km2=2*ik-2
       it3kp1=it3-ik+1
       it3k=2*(it3-ik)
!omment             hs30=hs3(km2+1)*rms(3,it3k+1)
       sgp3(ik)=sgn*hs3(km2+1)*rms(3,it3k+1)
       do jk=1,it3kp1
         jkm1=jk-1
         jt3kj=2*(it3-ik-jkm1)
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
         sgrp(ik,jk)=fpar(it3-ik,jkm1)/stoc
         sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+1)
       enddo
       sgpip=sgpip+sgp3(ik)*sg1
       sgn=-sgn
     enddo
   else
     do ik=1,it3
       sg1=0.D0
       it3kp1=it3-ik+1
       do jk=1,it3kp1
         jkm1=jk-1
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+1)
       enddo
       sgpip=sgpip+sgp3(ik)*sg1
     enddo
   endif
   END FUNCTION sgpip
!> *******************************************************************
!! FUNCTION sgppi(it1,it2,it3)
!! FUNCTION sigma(2t3,2t2,2t1+1) in table 14
!! is in E(2t3,2t2,2t1+1)        in table 77-a-2
!< *******************************************************************
   REAL(8) FUNCTION sgppi(it1,it2,it3)
   USE m4hersc
   USE m4hersc3, ONLY: hs1,hs2,hs3
   USE m4HermiteFun
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sg1,sgn,stoc
   INTEGER it1,it2,it3  
   INTEGER ik,it3k,it3kp1,jk,jkm1,jt1j,jt23kj,jt3kj,km2
   sgppi=0.D0
   if(it3.eq.0) return
   sgn=-1.D0
   if(.not.mksgp) then
     mksgp=.true.
     do ik=1,it3
       sg1=0.D0
       km2=2*ik-2
       it3kp1=it3-ik+1
       it3k=2*(it3-ik)
       sgp3(ik)=sgn*hs3(km2+1)*rms(3,it3k+1)
       do jk=1,it3kp1
         jkm1=jk-1
         jt3kj=2*(it3-ik-jkm1)
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
         sgrp(ik,jk)=fpar(it3-ik,jkm1)/stoc
         sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+2)
       enddo
       sgppi=sgppi+sgp3(ik)*sg1
       sgn=-sgn
     enddo
   else
     do ik=1,it3
       sg1=0.D0
       it3kp1=it3-ik+1
       do jk=1,it3kp1
         jkm1=jk-1
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+2)
       enddo
       sgppi=sgppi+sgp3(ik)*sg1
     enddo
   endif
   END FUNCTION sgppi
!> *******************************************************************
!! FUNCTION sgpii(it1,it2,it3)
!! FUNCTION sigma(2t3,2t2+1,2t1+1)  in table 14
!! correspond to E(2t3,2t2+1,2t1+1) in table 77-a-1
!< *******************************************************************
   REAL(8) FUNCTION sgpii(it1,it2,it3)
   USE m4hersc
   USE m4hersc3, ONLY: hs1,hs2,hs3
   USE m4HermiteFun
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sg1,sgn,stoc
   INTEGER it1,it2,it3  
   INTEGER ik,it3k,it3kp1,jk,jkm1,jt1j,jt23kj,jt3kj,km2
   sgpii=0.D0
   if(it3.eq.0) return
   sgn=-1.D0
   if(.not.mksgp) then
     mksgp=.true.
     do ik=1,it3
       sg1=0.D0
       km2=2*ik-2
       it3kp1=it3-ik+1
       it3k=2*(it3-ik)
       sgp3(ik)=sgn*hs3(km2+1)*rms(3,it3k+1)
       do jk=1,it3kp1
         jkm1=jk-1
         jt3kj=2*(it3-ik-jkm1)
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
         sgrp(ik,jk)=fpar(it3-ik,jkm1)/stoc
         sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+2)
       enddo
       sgpii=sgpii+sgp3(ik)*sg1
       sgn=-sgn
     enddo
   else
     do ik=1,it3
       sg1=0.D0
       it3kp1=it3-ik+1
       do jk=1,it3kp1
         jkm1=jk-1
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         sg1=sg1+sgrp(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+2)
       enddo
       sgpii=sgpii+sgp3(ik)*sg1
     enddo
   endif
   END FUNCTION sgpii
!> *******************************************************************
!! FUNCTION sgipp(it1,it2,it3)
!! FUNCTION sigma(2t3+1,2t2,2t1) in table 14
!! E(2t3+1,2t2,2t1)     is given in table 77-b-2
!< *******************************************************************
   REAL(8) FUNCTION sgipp(it1,it2,it3)
   USE m4hersc
   USE m4hersc3, ONLY: hs1,hs2,hs3
   USE m4HermiteFun
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sg1,sgn,stoc
   INTEGER it1,it2,it3  
   INTEGER ik,it3k,it3kp1,jk,jkm1,jt1j,jt23kj,jt3kj,km1
   sgipp=0.D0
   if(it3.le.0) return
   sgn=-1.D0
   if(.not.mksgi) then
     mksgi=.true.
     do ik=1,it3
       sg1=0.D0
       km1=2*ik-1
       it3kp1=it3-ik+1
       it3k=2*(it3-ik)
       sgi3(ik)=sgn*hs3(km1+1)*rms(3,it3k+1)
       do jk=1,it3kp1
         jkm1=jk-1
         jt3kj=2*(it3-ik-jkm1)
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
         sgri(ik,jk)=fpar(it3-ik,jkm1)/stoc
         sg1=sg1+sgri(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+1)
       enddo
       sgipp=sgipp+sgi3(ik)*sg1
       sgn=-sgn
     enddo
   else
     do ik=1,it3
       sg1=0.D0
       it3kp1=it3-ik+1
       do jk=1,it3kp1
         jkm1=jk-1
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         sg1=sg1+sgri(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+1)
       enddo
       sgipp=sgipp+sgi3(ik)*sg1
     enddo
   endif
   END FUNCTION sgipp
!> *******************************************************************
!! FUNCTION sgiip(it1,it2,it3)
!! FUNCTION sigma(2t3+1,2t2+1,2t1) in table 14
!! inside E(2t3+1,2t2+1,2t1) given in table 77-b-1
!< *******************************************************************
   REAL(8) FUNCTION sgiip(it1,it2,it3)
   USE m4hersc
   USE m4hersc3, ONLY: hs1,hs2,hs3
   USE m4HermiteFun
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sg1,sgn,stoc
   INTEGER it1,it2,it3  
   INTEGER ik,it3k,it3kp1,jk,jkm1,jt1j,jt23kj,jt3kj,km1
   sgiip=0.D0
   if(it3.eq.0) return
   sgn=-1.D0
   if(.not.mksgi) then
     mksgi=.true.
     do ik=1,it3
       sg1=0.D0
       km1=2*ik-1
       it3kp1=it3-ik+1
       it3k=2*(it3-ik)
       sgi3(ik)=sgn*hs3(km1+1)*rms(3,it3k+1)
       do jk=1,it3kp1
         jkm1=jk-1
         jt3kj=2*(it3-ik-jkm1)
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
         sgri(ik,jk)=fpar(it3-ik,jkm1)/stoc
         sg1=sg1+sgri(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+1)
       enddo
       sgiip=sgiip+sgi3(ik)*sg1
       sgn=-sgn
     enddo
   else
     do ik=1,it3
       sg1=0.D0
       it3kp1=it3-ik+1
       do jk=1,it3kp1
         jkm1=jk-1
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         sg1=sg1+sgri(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+1)
       enddo
       sgiip=sgiip+sgi3(ik)*sg1
     enddo
   endif
   END FUNCTION sgiip
!> *******************************************************************
!! FUNCTION sgipi(it1,it2,it3)
!! FUNCTION sigma(2t3+1,2t2,2t1+1)  in table 14
!! in E(2t3+1,2t2,2t1+1)            in table 77-b-1
!< *******************************************************************
   REAL(8) FUNCTION sgipi(it1,it2,it3)
   USE m4hersc
   USE m4hersc3, ONLY: hs1,hs2,hs3
   USE m4HermiteFun
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sg1,sgn,stoc
   INTEGER it1,it2,it3  
   INTEGER ik,it3k,it3kp1,jk,jkm1,jt1j,jt23kj,jt3kj,km1
   sgipi=0.D0
   if(it3.eq.0) return
   sgn=-1.D0
   if(.not.mksgi) then
     mksgi=.true.
     do ik=1,it3
       sg1=0.D0
       km1=2*ik-1
       it3kp1=it3-ik+1
       it3k=2*(it3-ik)
       sgi3(ik)=sgn*hs3(km1+1)*rms(3,it3k+1)
       do jk=1,it3kp1
         jkm1=jk-1
         jt3kj=2*(it3-ik-jkm1)
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
         sgri(ik,jk)=fpar(it3-ik,jkm1)/stoc
         sg1=sg1+sgri(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+2)
       enddo
       sgipi=sgipi+sgi3(ik)*sg1
       sgn=-sgn
     enddo
   else
     do ik=1,it3
       sg1=0.D0
       it3kp1=it3-ik+1
       do jk=1,it3kp1
         jkm1=jk-1
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         sg1=sg1+sgri(ik,jk)*hs2(jt23kj+1)*hs1(jt1j+2)
       enddo
       sgipi=sgipi+sgi3(ik)*sg1
     enddo
   endif  
   END FUNCTION sgipi
!> *******************************************************************
!! FUNCTION sgiii(it1,it2,it3)
!! FUNCTION sigma(2t3+1,2t2+1,2t1+1) in table 14
!! in E(2t3+1,2t2+1,2t1+1)           in table 77-b-2
!< *******************************************************************
   REAL(8) FUNCTION sgiii(it1,it2,it3)
   USE m4hersc
   USE m4hersc3, ONLY: hs1,hs2,hs3
   USE m4HermiteFun
   IMPLICIT NONE
! *******************************************************************
   REAL(8) sg1,sgn,stoc
   INTEGER it1,it2,it3  
   INTEGER ik,it3k,it3kp1,jk,jkm1,jt1j,jt23kj,jt3kj,km1
   sgiii=0.D0
   if(it3.eq.0) return
   sgn=-1.D0
   if(.not.mksgi) then
     mksgi=.true.
     do ik=1,it3
       sg1=0.D0
       km1=2*ik-1
       it3kp1=it3-ik+1
       it3k=2*(it3-ik)
       sgi3(ik)=sgn*hs3(km1+1)*rms(3,it3k+1)
       do jk=1,it3kp1
         jkm1=jk-1
         jt3kj=2*(it3-ik-jkm1)
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         stoc=rms(1,2*jkm1+1)*rms(2,jt3kj+1)
         sgri(ik,jk)=fpar(it3-ik,jkm1)/stoc
         sg1=sg1+sgri(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+2)
       enddo
       sgiii=sgiii+sgi3(ik)*sg1
       sgn=-sgn
     enddo
   else
     do ik=1,it3
       sg1=0.D0
       it3kp1=it3-ik+1
       do jk=1,it3kp1
         jkm1=jk-1
         jt23kj=2*(it3+it2-ik-jkm1)
         jt1j=2*(it1+jkm1)
         sg1=sg1+sgri(ik,jk)*hs2(jt23kj+2)*hs1(jt1j+2)
       enddo
       sgiii=sgiii+sgi3(ik)*sg1
     enddo
   endif  
   END FUNCTION sgiii
!***********************************************************************
!   Functions U and V given in tables 75 and 76
!   uppp ---> l,m,n  even
!   upip ---> l even, m odd, n even
!   .................................
!***********************************************************************
!> *******************************************************************
!! FUNCTION uppp(it1,it2,it3)
!! the integral U(2t3,2t2,2t1,thet) is given in table 75
!! the summation with cos(thet)**2*t1,cos(thet)**2*t2 is found in
!! table 77-a-1
!< *******************************************************************
   REAL(8) FUNCTION uppp(it1,it2,it3)
   USE m4hersc2, ONLY: wg,igaus,co,sn
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER it1,it2,it3  
   INTEGER i,idt1,idt2,ind,j
   uppp=0.D0
   ind=2*(it1+it2+it3)+1
   idt1=2*it1+1
   idt2=2*it2+1
   do j=1,igaus
     cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
     u=0.D0
     do i=1,igaus
       arcc(i,j)=ragp(i,ind)*akpcc(i,j)
       u=u+arcc(i,j)*epsi1(i,j)
     enddo
     uppp=uppp+cs(j)*u
   enddo
   END FUNCTION uppp
!> *******************************************************************
!! FUNCTION upip(it1,it2,it3)
!! the integral U(2t3,2t2+1,2t1,thet) is given in table 75
!! the summation with cos(thet)**2t1,cos(thet)**(2t2+1) is in
!! table 77-a-2
!< *******************************************************************
   REAL(8) FUNCTION upip(it1,it2,it3)
   USE m4hersc2, ONLY: wg,igaus,co,sn
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER it1,it2,it3  
   INTEGER i,idt1,idt2,ind,j
   upip=0.D0
   ind=2*(it1+it2+it3)+2
   idt1=2*it1+1
   idt2=2*it2+2
   do j=1,igaus
     cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
     u=0.D0
     do i=1,igaus
       arcs(i,j)=ragp(i,ind)*akpcs(i,j)
       u=u+arcs(i,j)*epsi1(i,j)
     enddo
     upip=upip+cs(j)*u
   enddo
   END FUNCTION upip
!> *******************************************************************
!! FUNCTION uppi(it1,it2,it3)
!! the integral U(2t3,2t2,2t1+1,thet)  in table 75
!! the summation with cos(thet)**(2*t1+1),cos(thet)**2*t2  in
!! table 77-a-2
!< *******************************************************************
   REAL(8) FUNCTION uppi(it1,it2,it3)
   USE m4hersc2, ONLY: wg,igaus,co,sn
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER it1,it2,it3  
   INTEGER i,idt1,idt2,ind,j
   uppi=0.D0
   ind=2*(it1+it2+it3)+2
   idt1=2*it1+2
   idt2=2*it2+1
   do j=1,igaus
     cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
     u=0.D0
     do i=1,igaus
       arsc(i,j)=ragp(i,ind)*akpsc(i,j)
       u=u+arsc(i,j)*epsi1(i,j)
     enddo
     uppi=uppi+cs(j)*u
   enddo
   END FUNCTION uppi
!> *******************************************************************
!! FUNCTION upii(it1,it2,it3)
!! the integral U(2*t3,2*t2+1,2*t1+1,thet)  table 75
!! the summation with cos(thet)**(2*t1+1),cos(thet)**(2*t2+1)
!! table 77-a-1
!< *******************************************************************
   REAL(8) FUNCTION upii(it1,it2,it3)
   USE m4hersc2, ONLY: wg,igaus,co,sn
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER it1,it2,it3  
   INTEGER i,idt1,idt2,ind,j
   upii=0.D0
   ind=2*(it1+it2+it3+1)+1
   idt1=2*it1+2
   idt2=2*it2+2
   do j=1,igaus
     cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
     u=0.D0
     do i=1,igaus
       arss(i,j)=ragp(i,ind)*akpss(i,j)
       u=u+arss(i,j)*epsi1(i,j)
     enddo
     upii=upii+cs(j)*u
   enddo
   END FUNCTION upii
!> *******************************************************************
!! FUNCTION uipp(it1,it2,it3)
!! the integral U(2*t3+1,2*t2,2*t1,thet)  table 75
!! for the summation with cos(thet)**2*t1,cos(thet)**2*t2 see
!! table 77-b-2
!< *******************************************************************
   REAL(8) FUNCTION uipp(it1,it2,it3)
   USE m4hersc2, ONLY: wg,igaus,co,sn
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER it1,it2,it3  
   INTEGER i,idt1,idt2,ind,j
   uipp=0.D0
   ind=2*(it1+it2+it3+1)
   idt1=2*it1+1
   idt2=2*it2+1
   do j=1,igaus
     cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
     u=0.D0
     do i=1,igaus
       arcc(i,j)=ragp(i,ind)*akpcc(i,j)
       u=u+arcc(i,j)*epsi1(i,j)
     enddo
     uipp=uipp+cs(j)*u
   enddo
   END FUNCTION uipp
!> *******************************************************************
!! FUNCTION uiip(it1,it2,it3)
!! the integral U(2*t3+1,2*t2+1,2*t1,thet) table 75
!! summation over cos(thet)**2*t1,cos(thet)**(2*t2+1) table 77-b-1
!< *******************************************************************
   REAL(8) FUNCTION uiip(it1,it2,it3)
   USE m4hersc2, ONLY: wg,igaus,co,sn
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER it1,it2,it3  
   INTEGER i,idt1,idt2,ind,j
   uiip=0.D0
   ind=2*(it1+it2+it3+1)+1
   idt1=2*it1+1
   idt2=2*it2+2
   do j=1,igaus
     cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
     u=0.D0
     do i=1,igaus
       arcs(i,j)=ragp(i,ind)*akpcs(i,j)
       u=u+arcs(i,j)*epsi1(i,j)
     enddo
     uiip=uiip+cs(j)*u
   enddo
   END FUNCTION uiip
!> *******************************************************************
!! FUNCTION uipi(it1,it2,it3)
!! the integral U(2t3+1,2t2,2t1+1,thet)  table 75
!! summation over cos(thet)**(2*t1+1),cos(thet)**2*t2  table 77-b-1
!< *******************************************************************
   REAL(8) FUNCTION uipi(it1,it2,it3)
   USE m4hersc2, ONLY: wg,igaus,co,sn
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER it1,it2,it3  
   INTEGER i,idt1,idt2,ind,j
   uipi=0.D0
   ind=2*(it1+it2+it3+1)+1
   idt1=2*it1+2
   idt2=2*it2+1
   do j=1,igaus
     cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
     u=0.D0
     do i=1,igaus
       arsc(i,j)=ragp(i,ind)*akpsc(i,j)
       u=u+arsc(i,j)*epsi1(i,j)
     enddo
     uipi=uipi+cs(j)*u
   enddo
   END FUNCTION uipi
!> *******************************************************************
!! FUNCTION uiii(it1,it2,it3)
!! the integral U(2*t3+1,2*t2+1,2*t1+1,thet)  table 75
!! summation with cos(thet)**(2*t1+1),cos(thet)**(2*t2+1)
!! (see table 77-b-2)
!< *******************************************************************
   REAL(8) FUNCTION uiii(it1,it2,it3)
   USE m4hersc2, ONLY: wg,igaus,co,sn
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER it1,it2,it3  
   INTEGER i,idt1,idt2,ind,j
   uiii=0.D0
   ind=2*(it1+it2+it3+1)+2
   idt1=2*it1+2
   idt2=2*it2+2
   do j=1,igaus
     cs(j)=co(j,idt1)*sn(j,idt2)*wg(j)
     u=0.D0
     do i=1,igaus
       arss(i,j)=ragp(i,ind)*akpss(i,j)
       u=u+arss(i,j)*epsi1(i,j)
     enddo
     uiii=uiii+cs(j)*u
   enddo
   END FUNCTION uiii
!> *******************************************************************
!! FUNCTION vppp(k)
!! the integral V(2t3,2t2,2t1,k,thet)  table 76
!! sum with cos(thet)**2*t1,cos(thet)**2*t2 (see table 77-a-1)
!< *******************************************************************
   REAL(8) FUNCTION vppp(k)
   USE m4hersc2, ONLY: igaus
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER i,j,k
   vppp=0.D0
   do j=1,igaus
     u=0.D0
     do i=1,igaus
       u=u+arcc(i,j)*ragm1(i,k)*epsi2(i,j)
     enddo
     vppp=vppp+cs(j)*u
   enddo
   END FUNCTION vppp
!> *******************************************************************
!! FUNCTION vpip(k)
!! the integral V(2t3,2t2+1,2t1,k,thet)  table 76
!! sum with cos(thet)**2*t1,cos(thet)**(2*t2+1) (table 77-a-2)
!< *******************************************************************
   REAL(8) FUNCTION vpip(k)
   USE m4hersc2, ONLY: igaus
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER i,j,k
   vpip=0.D0
   do j=1,igaus
     u=0.D0
     do i=1,igaus
       u=u+arcs(i,j)*ragm1(i,k)*epsi2(i,j)
     enddo
     vpip=vpip+cs(j)*u
   enddo
   END FUNCTION vpip
!> *******************************************************************
!! FUNCTION vppi(k)
!! the integral V(2t3,2t2,2t1+1,k,thet)  table 76
!! sum wih cos(thet)**2*t1,cos(thet)**(2*t2+1) (table 77-a-2)
!< *******************************************************************
   REAL(8) FUNCTION vppi(k)
   USE m4hersc2, ONLY: igaus
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER i,j,k
   vppi=0.D0
   do j=1,igaus
     u=0.D0
     do i=1,igaus
       u=u+arsc(i,j)*ragm1(i,k)*epsi2(i,j)
     enddo
     vppi=vppi+cs(j)*u
   enddo
   END FUNCTION vppi
!> *******************************************************************
!! FUNCTION vpii(k)
!! the integral V(2*t3,2*t2+1,2*t1+1,k,thet)   table 76
!! sum with cos(thet)**(2*t1+1),cos(thet)**(2*t2+1) (table 77-a-1)
!< *******************************************************************
   REAL(8) FUNCTION vpii(k)
   USE m4hersc2, ONLY: igaus
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER i,j,k
   vpii=0.D0
   do j=1,igaus
     u=0.D0
     do i=1,igaus
       u=u+arss(i,j)*ragm1(i,k)*epsi2(i,j)
     enddo
     vpii=vpii+cs(j)*u
   enddo
   END FUNCTION vpii
!> *******************************************************************
!! FUNCTION vipp(k)
!! the integral V(2*t3+1,2*t2,2*t1,thet)  table 76
!! sum with cos(thet)**2*t1,cos(thet)**2*t2 ( table 77-b-2)
!< *******************************************************************
   REAL(8) FUNCTION vipp(k)
   USE m4hersc2, ONLY: igaus
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER i,j,k
   vipp=0.D0
   do j=1,igaus
     u=0.D0
     do i=1,igaus
       u=u+arcc(i,j)*ragm1(i,k)*epsi2(i,j)
     enddo
     vipp=vipp+cs(j)*u
   enddo
   END FUNCTION vipp
!> *******************************************************************
!! FUNCTION viip(k)
!! the integral V(2*t3+1,2*t2+1,2*t1,thet)       table 76
!! sum with cos(thet)**2*t1,cos(thet)**(2*t2+1) (table 77-b-1)
!< *******************************************************************
   REAL(8) FUNCTION viip(k)
   USE m4hersc2, ONLY: igaus
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER i,j,k
   viip=0.D0
   do j=1,igaus
     u=0.D0
     do i=1,igaus
       u=u+arcs(i,j)*ragm1(i,k)*epsi2(i,j)
     enddo
     viip=viip+cs(j)*u
   enddo
   END FUNCTION viip
!> *******************************************************************
!! FUNCTION vipi(k)
!! the integral V(2*t3+1,2*t2,2*t1+1,k,thet)     table 76
!! sum with cos(thet)**(2*t1+1),cos(thet)**2*t2 (table 77-b-1)
!< *******************************************************************
   REAL(8) FUNCTION vipi(k)
   USE m4hersc2, ONLY: igaus
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER i,j,k
   vipi=0.D0
   do j=1,igaus
     u=0.D0
     do i=1,igaus
       u=u+arsc(i,j)*ragm1(i,k)*epsi2(i,j)
     enddo
     vipi=vipi+cs(j)*u
   enddo
   END FUNCTION vipi
!> *******************************************************************
!! FUNCTION viii(k)
!! the integral V(2*t3+1,2*t2+1,2*t1+1,thet)      in table 76
!! sum with cos(thet)**(2*t1+1),cos(thet)**(2*t2+1) (table 77-b-2)
!< *******************************************************************
   REAL(8) FUNCTION viii(k)
   USE m4hersc2, ONLY: igaus
   USE m4hersc5
   IMPLICIT NONE
! *******************************************************************
   REAL(8) u
   INTEGER i,j,k
   viii=0.D0
   do j=1,igaus
     u=0.D0
     do i=1,igaus
       u=u+arss(i,j)*ragm1(i,k)*epsi2(i,j)
     enddo
     viii=viii+cs(j)*u
   enddo
   END FUNCTION viii
!---------------------------------------------------------------------
!  Functions for HERSC and SCHERM
!---------------------------------------------------------------------
!> *******************************************************************
!! FUNCTION fpar(i,j)
!! Factorial function called by HERSC and SCHERM
!< *******************************************************************
   REAL(8) FUNCTION fpar(i,j)
   USE m4herFACTscher, ONLY: fpir
   IMPLICIT NONE
   INTEGER i,j,ii,jj
   ii=i+1
   jj=j+1
   fpar=fpir(ii,jj)
   END FUNCTION fpar
!> *******************************************************************
!! FUNCTION fper(i,j)
!! called by HERSC and SCHERM
!! i*(i-1)*(i-2)*...(i-j+1)/(1.2....j)
!< *******************************************************************
   REAL(8) FUNCTION fper(i,j)
   IMPLICIT NONE
   REAL(8) faci,facj
   INTEGER i,j,ii,k
   faci=1.D0
   facj=1.D0
   fper=1.D0
   if(i.eq.0) return
   if(j.eq.0) return
   do  k=1,j
     facj=facj*DBLE(k)
   enddo
   ii=i
   do k=1,j
     faci=faci*DBLE(ii)
     ii=ii-1
   enddo
   fper=faci/facj
   END FUNCTION fper
!> *******************************************************************
!! FUNCTION hermint(s,ihd)
!! called by HERSC and SCHERM
!< *******************************************************************
   REAL(8) FUNCTION hermint(s,ihd)
   IMPLICIT NONE
   REAL(8) s
   INTEGER ihd,m1,k
   REAL(8) he(100)
   hermint=0.D0
   if(ihd.eq.0) then
     hermint=1.D0
   else if(ihd.eq.1) then
     hermint=s
   else
     he(1)=1.D0
     he(2)=s
     m1=ihd-1
     do k=1,m1
       he(k+2)=s*he(k+1)-DBLE(k)*he(k)
     enddo
     hermint=he(ihd+1)*exp(-s*s/2.D0)
   endif
   END FUNCTION hermint
END MODULE fun4scherm
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE fun4cstrip
!---------------------------------------------------------------------
!  Module containing supporting function for charge stripper
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! FUNCTION dkeBethe(xkeval)
!! Kinetic Energy Decrease in Carbon Stripper
!!
!! Input:  xkeval=particle energy (MeV)
!! Output: dkeBethe=energy loss (MeV)
!! Contributing Author: Ji-Ho Jang, RAON/IBS, Daejeon, South Korea
!! Date: 25-Jan-2016
!!
!! Based on Bethe-Bloch formula in "Energy loss in matter by heavy
!! particles" by D. Groom, PDG-93-06
!! The charge state of projectile is the statistical net charge on the
!! partially neutralized ion.
!!     Ref: "The Stopping of Energetic light ions in elemental matter"
!!     by J.F. Ziegler in J. Appl. Phys / Rev. Appl. Phys., 85,
!!     1249-1279 (1999)
!< *******************************************************************
   REAL(8) FUNCTION dkeBethe(xkeval)
   USE DynacConstants
   USE m4beam, ONLY: XMAT
   USE m4mcs
   USE m4input
   USE m4output
   USE m4cavs
   IMPLICIT NONE
! *******************************************************************
   REAL(8) xkeval,aval,beval,cadjval,cbar,coeff,d0val,delden,dkecal,etaval,factor
   REAL(8) factor1,factor2,factor3,factor4,gaval
   REAL(8) xme,xna,znm,znt
   REAL(8) re,velbohr,vlm,x0,x1,xiadj,xin,xkemaxval,xkfactor,xkval,xmas
!--- Parameters to calculate dE/dx for graphite(Z=6,A=12.01115) with density of 2.265 g/cm^3
!--- xNA: Avogadro's number
   xNA = 6.02214129D23
!--- re: classical electron radius in m
   re = 2.8179403267D-15
!--- xme: mass of electron in eV
   xme = 0.510998928D6
!--- znt  = A of graphite target
   znt=12.011D0
!--- parameters from appendix.2 in energy loss by D. Groom in PDG-93-06
   xIadj=78
   Cbar=2.8680D0
   x0=-0.0178D0
   x1=2.3415D0
   aval=0.2614D0
   xkval=2.8697D0
   d0val=0.12D0
!----------------------- End of parameters
!--- calculation start the energy loss in carbon stripper
!---------- in unit of eV, m/sec
   XMAS=XMAT*1.D6
   VLM = VL/100.D0
!--- velBohr: Bohr velocity in m/sec
   velBohr = VLM/137.035999D0
   gaval = 1.D0 + xkeval/XMAT
   beval = sqrt(1.D0-1.D0/(gaval*gaval))
   etaval = beval*gaval
!--- statistical net charge on the partially neutralized ion
!--- Ref: "The Stopping of Energetic light ions in elemental matter"
!--- by J.F. Ziegler in J. Appl. Phys / Rev. Appl. Phys., 85, 1249-1279 (1999)
   znm = anp*(1.D0-exp(-beval*VLM/(anp**(2.D0/3.D0)*velBohr)))
!--- xKEmaxval: maximum possible electron recoil kinetic energy
!--- (Energy loss in matter by heavy particles by D. Groom in Particle Data Group Notes, PDG-93-06)
   xKEmaxval=2.D0*xme*etaval**2.D0/(1.D0+2.D0*gaval*xme/XMAS+(xme/XMAS)**2.D0)
   xKfactor = 4.D0*PI*xNA*re**2.D0*xme
!--- Cadjval: Analytic approximation of shell correction
!---          This formula is valid for beta*gamma > 0.13
!---          (Energy loss in matter by heavy particles by D. Groom in Particle Data Group Notes, PDG-93-06)
   Cadjval=(0.422377D0*etaval**(-2.D0)+0.0304043D0*etaval**(-4.D0)- &
            0.00038106D0*etaval**(-6.D0))*1.D-6*xIadj**2.D0+ &
           (3.858019D0*etaval**(-2.D0)-0.1667989D0*etaval**(-4.D0)+ &
            0.00157955D0*etaval**(-6.D0))*1.D-9*xIadj**3.D0
!--- delden : Density effect correction
!---          (Energy loss in matter by heavy particles by D. Groom in Particle Data Group Notes, PDG-93-06)
   xin = log10(etaval)
   if(xin >= x1) then
     delden = 2.D0*log(10.D0)*xin-Cbar
   elseif(xin >= x0 .and. xin < x1) then
     delden = 2.D0*log(10.D0)*xin-Cbar+aval*(x1-xin)**xkval
   elseif(xin < x0) then
     delden = d0val*10.D0**(2.D0*(xin-x0))
   endif
!-----------------------------------------------
   coeff=xKfactor*(znm/beval)**2*(qs/atms)
   factor1=1.D0/2.D0*log(2*xme*etaval**2.D0* &
                        xKEmaxval/xIadj**2.D0)
   factor2=beval**2.D0
   factor3=Cadjval/znt
   factor4=1.D0/2.D0*delden
   factor=factor1-factor2-factor3-factor4
!--- dkeval: kinetic energy decrease in eV/(g/cm**2)
   dkecal=coeff*factor
!--- ths: thickness in g/cm**2 = 1E4*g/m**2
!--- dkeBethe: kinetic energy decrease in MeV
   dkeBethe=dkecal*ths*1.D4/1.D6
   END FUNCTION dkeBethe
END MODULE fun4cstrip
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
MODULE fun4wien
!---------------------------------------------------------------------
!  Module containing supporting function for Wien filter
!---------------------------------------------------------------------
CONTAINS
!> *******************************************************************
!! FUNCTION  LSTSET(I)
!!
!< *******************************************************************
   INTEGER FUNCTION LSTSET(I)
! *******************************************************************
   IMPLICIT NONE
   INTEGER I,II,K
!   SAVE K
   K = 1
   DO
     II = I/10
     IF(II .EQ. 0) THEN
       LSTSET = I
       EXIT
     ELSE
       I = II
       K = 10*K
     ENDIF
   ENDDO
   END FUNCTION LSTSET
END MODULE fun4wien

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!--------------------------------------------------------------------
!!
!!  SUBROUTINE BLOCK
!!
!!--------------------------------------------------------------------
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> *******************************************************************
!! SUBROUTINE mytime
!! get system time and convert it to an ascii string
!< *******************************************************************
SUBROUTINE mytime(iitime)
   IMPLICIT NONE
   character(len=30) :: iitime
   integer :: dt(8),j,k
   integer weekday,month,year
   character(len=3), parameter :: DAYS(7) = [ 'Sun', 'Mon', 'Thu', 'Wed', 'Thu', 'Fri', 'Sat' ]
   character(len=3), parameter :: MONTHS(12) = &
    [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ]
!*******************************************************************
   call date_and_time(values=dt)
   year  = dt(1)
   month = dt(2)
   if (month <= 2) then
     month = month + 12
     year  = year - 1
   end if
   j = year / 100
   k = mod(year, 100)
   weekday = mod(dt(3) + ((month + 1) * 26) / 10 + k + k / 4 + j / 4 + 5 * j, 7) -1
   if (weekday < 0) weekday = 6
   write (iitime, '(a,1x,a,1x,i0.2,1x,i0.2,":",i0.2,":",i0.2,1x,i4)')DAYS(weekday+1), &
              MONTHS(dt(2)),dt(3),  dt(5), dt(6), dt(7),dt(1)             
END SUBROUTINE mytime
!> *******************************************************************
!! SUBROUTINE rmami
!! activate the time of flight for bunchers, cavities and accelerating
!! gaps
!! - indic and icor:integer flags
!! - itvol and imamin: logical flags
!! - itvol = true =>   the time of flight is activated, otherwise
!! - itvol = false =>  the time of flight is passive
!! - imamin = true =>  adjustments are automatically made on the phase
!! of bunchers, cavities and acc. gaps
!! - imamin = false => no adjustments on the phase of accelerating
!! elements
!! - indic = 0 => itvol = true, in this case the time of flight is
!! activited for accelerating elements
!! - indic (<>) 0 => itvol = false and imamin = false
!! - icor = 0 => imamin = false
!! - icor (<>) 0 => imamin = true
!< *******************************************************************
SUBROUTINE rmami
   USE DynacConstants, ONLY: VL,PI,RPEL
   USE m4trace3d
   USE m4beam, ONLY: tref
   USE m4mcs
   USE m4input, ONLY: in
   USE m4output
   USE m4cavs, ONLY: FH
   USE m4ITVOLE, ONLY: ITVOL,IMAMIN,ttvols
   IMPLICIT NONE
   REAL(8) fcpi
   INTEGER indic,icor
!*******************************************************************
   fcpi=fh*180.D0/pi
   ttvols=0.D0
   read(in,*) indic,icor
   if(indic.eq.0) then
     itvol=.true.
     ttvols=tref
     write(16,'(A,e12.5,A,e12.5,A,/,4x,A,e12.5,A)') ' ** time of flight activated at: ', &
     ttvols*fcpi,' deg at position: ',davtot,' cm in the lattice', &
     'tof of the reference: ',tref*fcpi,' deg'
   else
     itvol=.false.
     write(16,*) 'time of flight passive '
   endif
   imamin = .false.
   if(itvol.and.icor.ne.0) imamin = .true.
   if(imamin) then
     write(16,*)'   Adjustments on phase offset of acc. elements'
   else
     write(16,*)'   No adjustments on phase offset'
   endif  
END SUBROUTINE rmami
!> *******************************************************************
!! SUBROUTINE entre
!! define some input beam characteristics
!!   uem : Rest mass in MeV
!!
!!          proton:938.27231  MeV
!!          H_    :939.3145   MeV
!!          mesons:33.9093    MeV
!!          pions :139.5685   MeV
!!          kaons :493.667    MeV
!!          electrons : 0.511 MeV
!!
!!   atm : Atomic number
!!   qst : charge
!!
!!   enedep: Kinetic energy
!!   tofini: Time of flight
!!
!!   REMARK : After INPUT the reference coincides with the c.o.g.
!< *******************************************************************
SUBROUTINE entre
   USE DynacConstants
   USE m4trace3d
   USE m4beam
   USE m4beam2, ONLY: twissa,itwiss
   USE m4mcs
   USE m4input
   USE m4output
   USE m4cavs
   USE m4STIS
   USE m4TILT   
   IMPLICIT NONE
   REAL(8) bdep,bref,dum,encog,gai,gcog,gdep
   REAL(8) uem,tmp 
   INTEGER i,j,icg
!*******************************************************************
   DAVE=.FALSE.
   read(in,*)uem,atm,qst
   if(ncstat.eq.1) cstat(1)=qst
!  input energy(MeV) and initial time of flight(deg)
   read(in,*) enedep,tofini
! if icog=0 reference (vref,tref) is not cog
! if icog=1 reference (vref,tref) is cog
! --- xmat= rest mass
   xmat=uem*atm
   write(16,'(A,e12.5,A,f5.1,A,e12.5,A,f9.5)') & 
   '  **** unit mass: ',uem,' MeV mass units: ',atm, &
   ' rest mass: ',xmat,' MeV charge ',qst
   write(16,'(A,e12.5,A,e12.5,A)') &
   '  **** energy: ',enedep,' MeV initial tof: ',tofini,' deg'
   tmp=tofini
   tofini=tofini*pi/(180.D0*fh)
   gdep=enedep/xmat+1.D0
   bdep=sqrt(1.D0-1.D0/(gdep*gdep))
! trace3d stuff start
   write(tif,'(A,5(f12.6,1x),f12.4)') ' BEAMI(1)= ',(tracebi(i),i=1,6)
   kt3h=kt3h+1
   trace3h(kt3h)=tif
   write(tif,'(A,f12.6,1x,f12.6,1x,f12.4)') ' EMITI(1)= ',(traceei(i),i=1,3)
   kt3h=kt3h+1
   trace3h(kt3h)=tif
   write(tif,'(A,E16.7,A,I3,A,E14.7)') &
   ' ER= ',uem*atm,', Q=',int(qst),', FREQ= ',fhinit/2.D0/pi/1.D6
   kt3h=kt3h+1
   trace3h(kt3h)=tif
   write(tif,'(A,f12.4)') ' W= ',enedep
   kt3h=kt3h+1
   trace3h(kt3h)=tif
!       
! fo(index,i), index=1 initial particle # ,
!              index=2 x
!              index=3 xp
!              index=4 y
!              index=5 yp
!              index=6 time of flight (tof)
!              index=7 energy
!              index=8 if = 0 , then particle is lost
!              index=9 charge
!              i= particle #
   do i=1,ngood
! if itwiss=1,  apply tofini in tiltbm routine
     if(itwiss.ne.1) fo(6,i)=fo(6,i)+tofini
     fo(9,i)=qst
     fo(7,i)=enedep+fo(1,i)+xmat
     if(fo(7,i).lt.xmat) fo(7,i)=xmat
     fo(1,i)=DBLE(i)
   enddo
! --- the reference particle and the cog coincide
   bref=0.D0
   tref=0.D0
   encog=0.D0
   do i=1,ngood
     encog=encog+fo(7,i)
     gai=fo(7,i)/xmat
     bref=bref+sqrt(1.D0-1.D0/(gai*gai))
     tref=tref+fo(6,i)
   enddo
   encog=encog/DBLE(ngood)
   bref=bref/DBLE(ngood)
   vref=bref*vl
   tref=tref/DBLE(ngood)
   vrefi=vref
   trefi=tref
!  pack the table f(,) of the current beam
   do i=1,ngood
     do j=1,9
       f(j,i)=fo(j,i)
     enddo
   enddo
!  momentum of the  reference (i.e. the c.o.g.)
   gcog=1.D0/sqrt(1.D0-bref*bref)
   boro=3.3356D0*xmat*bref*gcog/abs(qst)
   write(16,'(A,e12.5)') '  **** momentum of c.o.g. (kG.cm): ',boro
   if (itwiss.eq.1) then
! Beam was defined in MCOBJET with Twiss parameters
! call TILTBM to apply Twiss alpha
     TIPHA=twissa(3)
     TIX=twissa(1)
     TIY=twissa(2)
     SHIFW=.000000D0
     SHIFP=.000000D0
     icg=1
     call tiltbm(icg)
!  write the input beam in file 'dynac_in_pr.dst'
     dum=100.D0
     do i=1,ngood
       f(2,i)=f(2,i)+centre(2)
       f(3,i)=f(3,i)+centre(3)
       f(4,i)=f(4,i)+centre(4)
       f(5,i)=f(5,i)+centre(5)
       f(6,i)=f(6,i)+centre(6)
       f(7,i)=f(7,i)+centre(1)
     enddo
   else
!  in case of itwiss.ne.1 apply CENTRE and write input beam in TILTBM
     TIPHA=0.D0
     TIX=0.D0
     TIY=0.D0
     SHIFW=.000000D0
     SHIFP=.000000D0
     icg=1
     call tiltbm(icg)
   endif
   call emiprt(0)
! store START data for .dmp file
   dmpdat(1)=0.D0
   dmpdat(2)=100.D0
   dmpdat(3)=0.D0
   dmpdat(4)=tmp
   dmpdat(5)=bdep
   dmpdat(6)=enedep
   dmpdat(7)=tref*180.D0*fh/pi
   dmpdat(8)=bdep
   dmpdat(9)=enedep
! dmpdat(10), dmpdat(11), dmpdat(12) loaded in emiprt
!       dmpdat(13)=0.
!       dmpdat(14)=0.
!       nd=0
END SUBROUTINE entre
!> *******************************************************************
!! SUBROUTINE adjrfq
!! read the coordinates of particles from file
!< *******************************************************************
SUBROUTINE adjrfq
   USE DynacConstants
   USE m4trace3d
   USE m4beam
   USE m4beam2, ONLY: bindst
   USE m4mcs
   USE m4input
   USE m4output
   USE m4cavs
   USE m4spacecharge
   USE mCOMisxpyp
   IMPLICIT NONE
   INTEGER i,j,k,idum,ift,mcstat
   REAL(8) bdep,gdep,dum,dum1,dum2,dumf,enedep,freq,uem
!********************************************
   allocate(f(10,iptsz))   
   allocate(fo(10,iptsz))   
   allocate(fd(iptsz))   
!********************************************
   read(in,*) iflag
   if(iflag.eq.0 .or. iflag.eq.100) write(16,*)'Standard file, phase in rad'
   if(iflag.eq.1 .or. iflag.eq.101) write(16,*)'File with particle number, ', &
                'phase in rad'
   if(iflag.eq.2 .or. iflag.eq.102) write(16,*)'File with several charge states', &
                ', phase in rad'
   if(iflag.eq.3 .or. iflag.eq.103) write(16,*)'File with charge state and ', &
                'particle number, phase in rad'
   if(iflag.eq.9 .or. iflag.eq.109) write(16,*)'File with charge state and rest ', &
                'mass, phase in rad'
   if(iflag.eq.10 .or. iflag.eq.110) write(16,*)'Standard file, phase in ns'
   if(iflag.eq.11 .or. iflag.eq.111) write(16,*)'File with particle number, ', &
                'phase in ns'
   if(iflag.eq.12 .or. iflag.eq.112) write(16,*)'File with several charge states', &
                ', phase in ns'
   if(iflag.eq.13 .or. iflag.eq.113) write(16,*)'File with charge state and ', &
                'particle number, phase in ns'
   if(iflag.eq.19 .or. iflag.eq.119) write(16,*)'File with charge state and rest', &
                ' mass, phase in ns'
! ---  input: freq.(MHz) tofini: phase offset (deg) to be applied both to the reference and the beam
   read(in,*) freq,tofini
   write(16,*) 'Frequency [MHz]:',freq
   fh=2.D0*pi*freq*1.D06
   FHINIT=FH
   read(in,*)uem,atm
   xmat=uem*atm
! --- reference:
!   enedep:energy(MeV), qst: charge of the reference
!   when iflag =0 or iflag = 1 qst is the charge of the beam
   read(in,*) enedep,qst
   tofini=tofini*pi/(180.D0*fh)
   gdep=enedep/xmat+1.D0
   bdep=sqrt(1.D0-1.D0/(gdep*gdep))
   vref=bdep*vl
   vrefi=vref
   tref=tofini
   trefi=tofini
   ncstat=1
   boro=3.3356D0*xmat*bdep*gdep/qst
   write(16,'(A,e12.5,A,f6.1,/,A,f4.1,A,e12.5,A,/,A,e12.5,A,e12.5,A,e12.5,A)') &
   ' **** unit mass: ',uem,' MeV, mass units: ',atm, &
   ' **** reference charge ',qst,' time of flight ',tofini,' sec', &
   ' **** reference : energy ',enedep,' MeV beta ',bdep,' momentum ',boro,' kG.cm'
   if(bindst) then
     read(55) imax,ift,idum
   else
     read(55,*) imax,dumf,dum
     ift=int(dumf)
   endif
   write(16,*)'File type listed in particle distribution file:',ift
   write(16,*)'File type listed in DYNAC    input        file:',iflag
   if(ift.ne.iflag) then
     WRITE(6,*) 'IFLAG in distribution file different from ', &
                 'IFLAG listed in DYNAC input file'
     WRITE(16,*) 'IFLAG in distribution file different from ', &
                 'IFLAG listed in DYNAC input file'
     stop
   endif
   write(16,*)'Number of macro particles in distribution file:',imax
   if(imax+2.gt.iptsz) then
     WRITE(6,*) 'Too many particles in distribution file'
     WRITE(16,*)'Too many particles '
     stop
   endif
   if(ncstat.eq.1) cstat(1)=qst
   if(iflag.eq.0 .or. iflag.eq.10 .or. iflag.eq.100 .or. &
      iflag.eq.110) then
!  iflag = 0 standard file:f(1,)=x, f(2,)=xp, f(3,)=y, f(4,)=yp, f(5,)=phase, f(6,)=kinetic energy
     if(bindst) then
       do j=1,imax
         read(55) (f(i,j),i=1,6)
       enddo
     else
       read(55,*) ((f(i,j),i=1,6),j=1,imax)
     endif
   elseif(iflag.eq.1 .or. iflag.eq.11 .or. iflag.eq.101 .or. &
          iflag.eq.111) then
!  iflag = 1  File with particle number: f(1,)=x, f(2,)=xp, f(3,)=y, f(4,)=yp, f(5,)=phase, f(6,)=kinetic energy, dum1
     if(bindst) then
       do j=1,imax
         read(55) (f(i,j),i=1,6),dum1
       enddo
     else
       read(55,*) ((f(i,j),i=1,6),dum1,j=1,imax)
     endif
   elseif(iflag.eq.2 .or. iflag.eq.12 .or. iflag.eq.102 .or. &
          iflag.eq.112) then
!  iflag = 2 beam with different charges: f(7,) = charge;
!  figure out how many different ones there are and store them
     ncstat=1
     if(bindst) then
       read(55) (f(i,1),i=1,7)
     else
       read(55,*) (f(i,1),i=1,7)
     endif
     cstat(1)=f(7,1)
     do j=2,imax
       if(bindst) then
         read(55) (f(i,j),i=1,7)
       else
         read(55,*) (f(i,j),i=1,7)
       endif
       mcstat=0
       do k=1,ncstat
!         if(int(f(7,j)).eq.int(cstat(k))) then
!         if(f(7,j).eq.cstat(k)) then
         if(abs(f(7,j)-cstat(k)).le.fprec) then
           mcstat=1
         endif
       enddo
       if(mcstat.eq.0) then
         ncstat=ncstat+1
         cstat(ncstat)=f(7,j)
       endif
     enddo
     write(16,*) 'Number of charge states: ',ncstat
     write(16,*) 'Charge state(s): ',(cstat(j),j=1,ncstat)
     if(ncstat.gt.1) imcs=1
   elseif(iflag.eq.3 .or. iflag.eq.13 .or. iflag.eq.103 .or. &
          iflag.eq.113) then
!  iflag = 3 beam with different charges and particle number: f(7,) = ch
!  figure out how many different ones there are and store them
     ncstat=1
     if(bindst) then
       read(55) (f(i,1),i=1,7),dum1
     else
       read(55,*) (f(i,1),i=1,7),dum1
     endif
     cstat(1)=f(7,1)
     do j=2,imax
       if(bindst) then
         read(55) (f(i,j),i=1,7),dum1
       else
         read(55,*) (f(i,j),i=1,7),dum1
       endif
       mcstat=0
       do k=1,ncstat
!         if(int(f(7,j)).eq.int(cstat(k))) then
!         if(f(7,j).eq.cstat(k)) then
         if(abs(f(7,j)-cstat(k)).le.fprec) then
           mcstat=1
         endif
       enddo
       if(mcstat.eq.0) then
         ncstat=ncstat+1
         cstat(ncstat)=f(7,j)
       endif
     enddo
     write(16,*) 'Number of charge states: ',ncstat
     write(16,*) 'Charge state(s): ',(cstat(j),j=1,ncstat)
     if(ncstat.gt.1) imcs=1
   elseif(iflag.eq.9 .or. iflag.eq.19 .or. iflag.eq.109 .or. &
          iflag.eq.119) then
!  iflag = 9  File with charge state and rest mass: f(1,)=x, f(2,)=xp,
!         f(3,)=y, f(4,)=yp, f(5,)=phase, f(6,)=kinetic energy, dum1, dum2
     if(bindst) then
       do j=1,imax
         read(55) (f(i,j),i=1,6),dum1,dum2
       enddo
     else
       do j=1,imax
         read(55,*) (f(i,j),i=1,6),dum1,dum2
       enddo
     endif
   endif
   WRITE(6,'(A,I8,A)') 'Simulation with ',IMAX,' particles'
   call intfac
   if(T3D) then
     write(tif,'(A,5(f12.6,1x),f12.4)') ' BEAMI(1)= ',(tracebi(i),i=1,6)
     kt3h=kt3h+1
     trace3h(kt3h)=tif
     write(tif,'(A,f12.6,1x,f12.6,1x,f12.4)') ' EMITI(1)= ',(traceei(i),i=1,3)
     kt3h=kt3h+1
     trace3h(kt3h)=tif
     write(tif,'(A,E16.7,A,i3,A,E14.7)') ' ER= ',uem*atm,', Q=',int(qst), &
     ' FREQ= ',fhinit/2.D0/pi/1.D6
     kt3h=kt3h+1
     trace3h(kt3h)=tif
     write(tif,'(A,f12.4)') ' W= ',enedep
     kt3h=kt3h+1
     trace3h(kt3h)=tif
   endif
END SUBROUTINE adjrfq
!> *******************************************************************
!! SUBROUTINE intfac(tofini)
!! convert the particles coordinates to DYNAC units
!!
!!      FH :INITIAL FREQENCY (hertz)
!!  Use frequency from part. dist. file to calculate f(6,i)
!!    iflag = 100 : standard file, phase in rad
!!    iflag = 101 : special file, phase in rad
!!    iflag = 102 : several charge states, phase in rad
!!    iflag = 109 : several charge states, rest mass, phase in rad
!!    iflag = 110 : standard file, phase in ns
!!    iflag = 111 : special file, phase in ns
!!    iflag = 112 : several charge states, phase in ns
!!    iflag = 119 : several charge states, rest mass, phase in ns
!!
!< *******************************************************************
SUBROUTINE intfac
   USE DynacConstants
   USE m4trace3d
   USE m4beam
   USE m4mcs
   USE m4input
   USE m4output
   USE m4cavs
   USE m4chase, ONLY: ichas
   USE mCOMisxpyp
   IMPLICIT NONE
   INTEGER i,j,k
   REAL(8) bor,bref,breft,gref,tcog,treft,xe
   REAL(8) foo(20,9),NDP(20)
!*******************************************************************
   if (.not. allocated(ichas)) allocate(ichas(iptsz))
   imcs=0
   if(iflag.eq.2 .or. iflag.eq.12 .or. iflag.eq.102 .or. &
      iflag.eq.112)  imcs=1
   QMOY=QST
   j=1
   breft=vref/vl
   treft=tref
   tcog=0.D0
!  the table fo(,) is built from the input beam stored in the table f(,)
   if(iflag.le.2 .or. iflag.eq.100 .or. iflag.eq.101 .or. &
      iflag.eq.102 .or. iflag.eq.9 .or. iflag.eq.19 .or. &
      iflag.eq.109 .or. iflag.eq.119) then
     do i=1,imax
       fo(7,i)=f(6,j)+xmat
       if(iflag.le.1 .or. iflag.eq.100 .or. &
          iflag.eq.101 .or. iflag.eq.9 .or. iflag.eq.19 .or. &
          iflag.eq.109 .or. iflag.eq.119) fo(9,i)=qst
       if(iflag.eq.2 .or. iflag.eq.102) fo(9,i)=f(7,i)
       ichas(i)=1
       fo(8,i)=1.D0
       fo(1,i)=DBLE(j)
       fo(2,i)=f(1,j)
       fo(3,i)=f(2,j)*1000.D0
       fo(4,i)=f(3,j)
       fo(5,i)=f(4,j)*1000.D0
       fo(6,i)=tofini+f(5,j)/fh
       tcog=tcog+fo(6,i)
       j=j+1
     enddo
   else
     do i=1,imax
       fo(7,i)=f(6,j)+xmat
       if(iflag.le.11 .or. iflag.eq.110 .or. iflag.eq.111) &
          fo(9,i)=qst
       if(iflag.eq.12 .or. iflag.eq.112) fo(9,i)=f(7,i)
       ichas(i)=1
       fo(8,i)=1.D0
       fo(1,i)=DBLE(j)
       fo(2,i)=f(1,j)
       fo(3,i)=f(2,j)*1000.D0
       fo(4,i)=f(3,j)
       fo(5,i)=f(4,j)*1000.D0
       fo(6,i)=tofini+f(5,j)*1.D-9
       tcog=tcog+fo(6,i)
       j=j+1
     enddo
   endif
   tcog=tcog/DBLE(imax)
!   cog of the beam
   if(iflag.eq.0 .or. iflag.eq.1 .or. iflag.eq.10 .or. iflag.eq.11 &
     .or. iflag.eq.100 .or. iflag.eq.101 .or. iflag.eq.110 .or. &
          iflag.eq.111 .or. iflag.eq.9 .or. iflag.eq.19 &
     .or. iflag.eq.109 .or. iflag.eq.119) then
! single charge state
     NDP(1)=imax
     do j=2,7
       foo(1,j)=0.D0
     enddo
     do i=1,imax
       do j=2,7
         foo(1,j)=foo(1,j)+fo(j,i)
       enddo
     enddo
   else
! multi charge state
     kt3h=kt3h+1
     trace3h(kt3h)='ERROR: RDBEAM reads more than 1 charge state'
     DO k=1,ncstat
       NDP(k)=0
       do j=2,7
         foo(k,j)=0.D0
       enddo
     ENDDO
     DO i=1,imax
       DO k=1,ncstat
!         if(int(fo(9,i)).eq.int(cstat(k))) then
!         if(fo(9,i).eq.cstat(k)) then
         if(abs(fo(9,i)-cstat(k)).le.fprec) then
           NDP(k)=NDP(k)+1
           do j=2,7
             foo(k,j)=foo(k,j)+fo(j,i)
           enddo
         endif
       ENDDO
     ENDDO
   endif
   DO k=1,ncstat
     do j=2,7
       foo(k,j)=foo(k,j)/DBLE(NDP(k))
     enddo
   ENDDO
   ngood=imax
   if(iflag.eq.0 .or. iflag.eq.1 .or. iflag.eq.10 .or. iflag.eq.11 &
     .or. iflag.eq.100 .or. iflag.eq.101 .or. iflag.eq.110 .or. &
          iflag.eq.111 .or. iflag.eq.9 .or. iflag.eq.19 &
     .or. iflag.eq.109 .or. iflag.eq.119 )then
! --- COG
     gref=foo(1,7)/xmat
     bref=sqrt(1.D0-1.D0/(gref*gref))
     xe=(gref-1.D0)*xmat
!   magnetic rigidity
     bor=3.3356D0*xmat*bref*gref/qst
     write(16,*) '**** COG : energy ',xe,'MeV beta ',bref, &
       ' momentum ',bor,' kG.cm'
   else
     DO k=1,ncstat
       gref=foo(k,7)/xmat
       bref=sqrt(1.D0-1.D0/(gref*gref))
       xe=(gref-1.D0)*xmat
!   magnetic rigidity
       bor=3.3356D0*xmat*bref*gref/cstat(k)
       write(16,*) ' Q: ',cstat(k),' COG : energy ',xe, &
       ' MeV beta ',bref,' momentum ',bor,' kG.cm'
     ENDDO
   endif
   vrefi=vref
   trefi=tref
! now save data back to f
   do i=1,ngood
     do k=1,9
       f(k,i)=fo(k,i)
     enddo
   enddo
   imaxo=ngood
   call emiprt(0)
! store START data for .dmp file
   dmpdat(1)=0.D0
   dmpdat(2)=100.D0
   dmpdat(3)=0.D0
   dmpdat(4)=tcog*180.D0*fh/pi
   dmpdat(5)=bref
   dmpdat(6)=xe
   dmpdat(7)=treft*180.D0*fh/pi
   dmpdat(8)=breft
   dmpdat(9)=(sqrt(1.D0/(1.D0-breft*breft))-1.D0)*xmat
! dmpdat(10), dmpdat(11), dmpdat(12) loaded in emiprt
!       dmpdat(13)=0.
!       dmpdat(14)=0.
!       nd=0
   if(T3D) then
     call emit3d
   endif
END SUBROUTINE intfac
!> *******************************************************************
!! SUBROUTINE chrefe
!! change of reference frame
!!   ENTRY : XC YC A
!!    XC   : DISPLACEMENT IN THE HORIZONTAL DIRECTION (CM)
!!    YC   : DISPLACEMENT IN THE VERTICAL DIRECTION   (CM)
!!    A    : ROTATION ABOUT THE vertical AXIS         (DEG)
!< *******************************************************************
SUBROUTINE chrefe
   USE DynacConstants, ONLY: VL,PI,RPEL
   USE m4beam, ONLY: f,ngood
   USE m4input
   IMPLICIT NONE
   INTEGER i
!*******************************************************************
   REAL(8) XC,YC,A,dl,x,x0,xl,xp,y,yl,yp
   READ(IN,*)XC,YC,A
   a=a*pi/180.D0
   WRITE(16,'(A,f6.2,A,f6.2,A,f6.4,A,/,/,/)') &
     ' New reference frame  XC =',XC,' CM , YC =',YC,' CM , A =',A,' RADIAN'
   do i=1,ngood
     x=f(2,i)
     xp=f(3,i)*0.001D0
     yp=f(5,i)*0.001D0
     y=f(4,i)
     x0=x
     x=((x-yc)*cos(xp)+xc*sin(xp))/cos(xp-a)
     xp=xp-a
     xl=xc-x*sin(a)
     yl=yc-x0+x*cos(a)
     dl=sqrt(xl*xl+yl*yl)
     dl=sign(dl,xl)
     y=y+dl*tan(yp)
     f(2,i)=x
     f(3,i)=xp*1000.D0
     f(4,i)=y
     f(5,i)=yp*1000.D0
   enddo
END SUBROUTINE chrefe
!> *******************************************************************
!! SUBROUTINE egun(fmult,indp)
!! method:Bode's rule
!! read the axial field of the DC gun field from disk
!!     z (m)   E(z) is normalized
!< *******************************************************************
SUBROUTINE egun(fmult,indp)
   USE DynacConstants
   USE m4trace3d
   USE m4beam
   USE m4mcs
   USE m4input
   USE m4output
   USE m4cavs
   USE m4plots
   USE m4spacecharge
   USE fun4rfq, ONLY: spline
   USE m4SPLfun
   USE m4ble, ONLY: cr
   IMPLICIT NONE
   REAL(8) dum
   REAL(8) fmult,a1,a2,bet,bets,bg1,bg2,bg3,bg4,bg5,bgt2,bgt3,bgt4,bgt5
   REAL(8) bgts1,bgts2,bgts3,bgts4,bgts5,cof,cof1,cof2,cw,dcfld,de,de1,delwrm
   REAL(8) dgam,dgam1,dgami,dpe1,dpe2,dt,dxe,dxpe1,dxpe2,dye,dype1,dype2,e0
   REAL(8) egl,eglp,eglsc,elgun,emns,fpos,fpos1,fpos2,fpos3,fpos4,fpos5
   REAL(8) gam0,gam1,gam2,gam3,gam4,gam5,gamm1,gamm2,gams1,gams2,gams3,gams4,gams5
   REAL(8) gref,gtm,gtm1,gtpm,gtpz,p0,qc,scl,swe1,swe2,tcgprt,tof,trnsms,tspl
   REAL(8) tspl1,tspl2,tspl3,tspl4,tspl5,vlm,we,weinf,wref,x0,xe0,xi,xlres,xlstart
   REAL(8) xmor,xnh,xnhf,xnht,xpas,xpe0,xpi,y0,ye0,yi,ype0,ypi,zinf,zsup,t0,tslpt
   INTEGER i,i1,ij,j,ilost,indp,idavs,idum,iflg,ipart,npas,npas1,npt
   REAL(8) gam(3000),xe(3000),xpe(3000),ye(3000),ype(3000)
   REAL(8) ptrans,ptrans1
   logical flgsc
   character(len=8) :: PRTLAB
!*******************************************************************
!    print out on terminal of transport element #
   nrres=nrres+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   write(6,'(A)') 'EGUN calculation started'
   flush(6)   
! energy at the entrance
   we=0.D0
   e0=xmat
   do i=1,ngood
     we=we+f(7,i)
     tref=tref+f(6,i)
   enddo
   tref=tref/DBLE(ngood)
   tcgprt=fh*tref*180.D0/pi
   we=we/DBLE(ngood)
   gref=we/e0
   we=we-xmat
   bets=sqrt(1.D0-1.D0/(gref*gref))
! indp: define the number of space charge computations
!   indp = 1 : 8 space charge computations. The EGUN field is divided in 16 elements
!   indp = 2 : 16 space charge computation.                           in 32 elements
!   indp = 3 : 32 space charge computation.                           in 64 elements
   if(indp.gt.3) indp=3
   if(indp.eq.1) ipart=16
   if(indp.ge.2) ipart=32
   if(indp.eq.3) ipart=64
! research the number of steps w.r.t. the input energy
!    convert energy: MeV --> eV
   we=we*1.D06
   weinf=19.99D0
   if(we.le.weinf) then
     write(ierr,*) ' Energy at the cathode: ',we, &
               ' eV is below the lower limit of 20 eV '
     stop
   endif
!    read egun field from the disk
   vlm=vl*1.D-02
   read(22,*)npt
   do i=1,npt
     read(22,*) xspl(i),yspl(i)
   enddo
   zinf=xspl(1)
   zsup=xspl(npt)
   egl=zsup-zinf
   call deriv2(npt)
   elgun=egl*100.D0
!  PLOT
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
!  prep data for .short file
   idav=idav+1
   idavs=idav
   iitem(idav)=13
   dav1(idav,1)=egl*1000.D0
   dav1(idav,2)=fmult
   davtot=davtot+elgun
   dav1(idav,4)=elgun*10.D0
!    divide the length in ipart partitions
!    the space charge computations are made at the middle of each partition
   eglp=egl/DBLE(ipart)
!      eglsc :space charge acting length (cm)  (of each part)
   scl=DBLE(ipart)/2.D0
   eglsc=egl*100.D0/scl
!    compute the EGUN field (MV)
   npas=200
!       xpas=eglp/DBLE(npas)
   xpas=egl/DBLE(npas)
   xnhf=0
   dcfld=0.D0
   do i=1,npas
     fpos=xnhf*xpas
     tspl=spline(npt,fpos)*fmult
     dcfld=dcfld+qst*tspl*xpas
     xnhf=xnhf+1.D0
   enddo
   dav1(idav,3)=dcfld*1000.D0
   write(16,'(5x,A,f9.4,A,/,5x,A,f10.4,A,/,5x,A,e13.5,A,/)') &
   '  FIELD LENGTH  = ',elgun,'      cm ', &
   '  FIELD CREST   =',fmult,'      MV/m', &
   '  FIELD INTEGRAL=  ',dcfld*1000.D0,' kV'
! **** demarrage sur 0.5 mm (?) soit 0.5 D-3 m
!    energy threshold
   swe1=19.99D0
   swe2=79.99D0
   npas=200
   if(we.lt.swe1) npas=400
   if(we.lt.swe2) npas=300
   xlstart=0.5D-3
   xpas=xlstart/DBLE(npas)
   npas1=npas+1
   iflg=-1
   xnht=0.D0
   flgsc=.false.
   idum=0
   dum=0.D0
   trnsms=100.D0*DBLE(ngood)/DBLE(imax)
   DO
     if(iflg.eq.ipart) EXIT
     do j=1,ngood
       xnh=xnht
       qc=f(9,j)
       gam0=f(7,j)/e0
       gam(1)=gam0
       tof=f(6,j)
!   the tranverse coordinates are converted to (m,rad)
       x0=f(2,j)*1.D-02
       y0=f(4,j)*1.D-02
       t0=f(3,j)*1.D-03
       p0=f(5,j)*1.D-03
!   Picht transformation
       ptrans1=(gam0*gam0-1.D0)
       ptrans=ptrans1**0.25D0
       xe0 =x0*ptrans
       xpe0=t0*ptrans
       ye0 =y0*ptrans
       ype0=p0*ptrans
       fpos=xnh*xpas
       tspl=spline(npt,fpos)*fmult
       dgam=(qc/e0)*tspl
       dgami=dgam
       xpe0=xpe0+0.5D0*xe0*gam0*dgam/ptrans1
       ype0=ype0+0.5D0*ye0*gam0*dgam/ptrans1
       a1=qc*qc/(4.D0*e0*e0)
       a2=qc/(e0*vlm)
       xe(1)=xe0
       xpe(1)=xpe0
       ye(1)=ye0
       ype(1)=ype0
       do i=2,npas1
         i1=i-1
         fpos1=xnh*xpas
         fpos2=(xnh+0.25D0)*xpas
         fpos3=(xnh+0.5D0)*xpas
         fpos4=(xnh+0.75D0)*xpas
         fpos5=(xnh+1.D0)*xpas
         tspl1=spline(npt,fpos1)*fmult
         tspl2=spline(npt,fpos2)*fmult
         tspl3=spline(npt,fpos3)*fmult
         tspl4=spline(npt,fpos4)*fmult
         tspl5=spline(npt,fpos5)*fmult
         cw=(qc/e0)*xpas/90.D0
         tspl=7.D0*tspl1+32.D0*tspl2+12.D0*tspl3+32.D0*tspl4+7.D0*tspl5
         gam(i)=cw*tspl+gam(i1)
         gam1=gam(i1)
         gam5=gam(i)
         dgam1=(qc/e0)*tspl1
         cof1=(gam5-gam1)/(xpas*xpas)
         cof2=dgam1/xpas
         cof=cof1-cof2
         gam2=gam1+dgam1*xpas/4.D0+cof*xpas*xpas/16.D0
         gam3=gam1+dgam1*xpas*0.5D0+cof*xpas*xpas/4.D0
         gam4=gam1+dgam1*xpas*0.75D0+cof*9.D0*xpas*xpas/16.D0
         gams1=gam1*gam1
         gams2=gam2*gam2
         gams3=gam3*gam3
         gams4=gam4*gam4
         gams5=gam5*gam5
!omment          bgt1=(gams1-1.D0)**1.5D0
         bgt2=(gams2-1.D0)**1.5D0
         bgt3=(gams3-1.D0)**1.5D0
         bgt4=(gams4-1.D0)**1.5D0
         bgt5=(gams5-1.D0)**1.5D0
         tslpt=8.D0*tspl2/bgt2+6.D0*tspl3/bgt3+24.D0*tspl4/bgt4 &
            +7.D0*tspl5/bgt5
         dt=a2*xpas*xpas*tslpt/90.D0
         bet=sqrt(1.D0-1.D0/gams1)
         tof=tof+xpas/(vlm*bet)+dt
         f(7,j)=gam(i)*e0
         f(6,j)=tof
         bg1=(gams1+2.D0)/((gams1-1.D0)*(gams1-1.D0))
         bg2=(gams2+2.D0)/((gams2-1.D0)*(gams2-1.D0))
         bg3=(gams3+2.D0)/((gams3-1.D0)*(gams3-1.D0))
         bg4=(gams4+2.D0)/((gams4-1.D0)*(gams4-1.D0))
         bg5=(gams5+2.D0)/((gams5-1.D0)*(gams5-1.D0))
         bgts1=bg1*tspl1*tspl1
         bgts2=bg2*tspl2*tspl2
         bgts3=bg3*tspl3*tspl3
         bgts4=bg4*tspl4*tspl4
         bgts5=bg5*tspl5*tspl5
!        gtpm=bgts1+3.D0*bgts2+3.D0*bgts3+bgts4
         gtpm=7.D0*bgts1+32.D0*bgts2+12.D0*bgts3+32.D0*bgts4+7.D0*bgts5
!                  gtm=bgts1+2.D0*bgts2+bgts3
         gtm=7.D0*bgts1+24.D0*bgts2+6.D0*bgts3+8.D0*bgts4
!             gtpz=bgts2+2.D0*bgts3+bgts4
         gtpz=8.D0*bgts2+6.D0*bgts3+24.D0*bgts4+7.D0*bgts5
         gtm1=2.D0*bgts2+3.D0*bgts3+18.D0*bgts4+7.D0*bgts5
         de=-a1*xpas*xpas*gtm/90.D0
         de1=-a1*xpas*xpas*xpas*gtm1/90.D0
         dpe1=-a1*xpas*gtpm/90.D0
         dpe2=-a1*xpas*xpas*gtpz/90.D0
         dxpe1=dpe1*xe(i1)
         dype1=dpe1*ye(i1)
         dxpe2=dpe2*xpe(i1)
         dype2=dpe2*ype(i1)
         dxe=de*xe(i1)+de1*xpe(i1)
         dye=de*ye(i1)+de1*ype(i1)
         xpe(i)=xpe(i1)+dxpe1+dxpe2
         ype(i)=ype(i1)+dype1+dype2
         xe(i)=xe(i1)+dxe+xpe(i1)*xpas
         ye(i)=ye(i1)+dye+ype(i1)*xpas
!   back to the real variables and convert to (cm,mrad)
         gamm1=(gams5-1.D0)**0.25D0
         gamm2=(gams5-1.D0)**1.25D0
         dgam=(qc/e0)*tspl5
         xi=xe(i)/gamm1
         xpi=xpe(i)/gamm1-xe(i)*gam(i)*dgam/(gamm2*2.D0)
         yi=ye(i)/gamm1
         ypi=ype(i)/gamm1-ye(i)*gam(i)*dgam/(gamm2*2.D0)
!  convert in cm and mrd
         f(2,j)=xi*1.D2
         f(4,j)=yi*1.D2
         f(3,j)=xpi*1.D3
         f(5,j)=ypi*1.D3
!    *****  follow prtcl ifpt  not active ************
!omment          if(j.eq.ifpt)
!omment     *    write(49,4445) fpos5,xi,xpi,yi,ypi,e0*(gam5-1.D0)
!omment4445      format(6(2x,e12.5))
         xnh=xnh+1.D0
       enddo
     enddo
     iflg=iflg+1
     xnht=xnh
     if(iflg.eq.0) then
       if(indp.eq.1) npas=96
       if(indp.eq.2) npas=48
       if(indp.eq.3) npas=24
       npas1=npas+1
       xlres=egl-xlstart
       xpas=xlres/(DBLE(npas)*DBLE(ipart))
       xnht=fpos5/xpas
       flgsc=.true.
       dav1(idavs,7)=tspl5
       dav1(idav,5)=xlstart*1000.D0
       call disp
       cycle
     endif
     if(iflg.eq.1) then
       if(indp.eq.1) npas=48
       if(indp.eq.2) npas=24
       if(indp.eq.3) npas=12
       npas1=npas+1
       xlres=egl-xlstart
       xpas=xlres/(DBLE(npas)*DBLE(ipart))
       xnht=fpos5/xpas
     endif
     if(.not.flgsc) then
       flgsc=.true.
       call disp
       cycle
     else
       if(ichaes) then
!        Space charge
         iesp=.true.
         call cesp(eglsc)
         iesp=.false.
       endif
!      Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
       flgsc=.false.
!      reference ( c.o.g. of the bunch)
       tref=0.D0
       gref=0.D0
       do ij=1,ngood
         tref=tref+f(6,ij)
         gref=gref+f(7,ij)/e0
       enddo
       tref=tref/DBLE(ngood)
       gref=gref/DBLE(ngood)
       bets=sqrt(1.D0-1.D0/(gref*gref))
       vref=bets*vl
       write(16,'(A,e12.5,A,/,5x,A,e12.5,A,e12.5,A,e12.5)') &
       ' ref.(c.o.g.) at ',fpos5*1000.D0,' mm of the  cathode', &
       ' tof: ',tref,' sec beta: ',bets,' field (MV/m) ',tspl5
       write(6,'(A,e12.5,A,e12.5,a1)',advance='no') &
       ' EGUN: at ',fpos5*1000.D0,' mm from the cathode; beta: ',bets,cr
       flush(6)
     endif
   ENDDO
   write(6,*)
   write(6,'(A)') 'EGUN calculation finished'
! Test window
   call cogetc
   PRTLAB='EGUN    '
   call reject(ilost,PRTLAB)
   write(16,*)'particles lost :',ilost
   write(16,*) 'EGUN calculation finished'
!    reference ( c.o.g. of the bunch)
   tref=0.D0
   gref=0.D0
   do i=1,ngood
     tref=tref+f(6,i)
     gref=gref+f(7,i)/e0
   enddo
   tref=tref/DBLE(ngood)
   gref=gref/DBLE(ngood)
   bets=sqrt(1.D0-1.D0/(gref*gref))
   write(16,'(A,/,5x,A,e12.5,A,e12.5)') &
   ' Reference at output of the DC gun',' tof: ',tref,' sec beta: ',bets
   vref=bets*vl
   WREF=XMAT*(gref-1.D0)
!   new magnetic rigidity of the reference
   xmor=xmat*bets*gref
   boro=33.356D0*xmor*1.D-01/qst
   dav1(idavs,6)=bets
   dav1(idavs,36)=DBLE(ngood)

!   plots
   PRLAB(IPRF)='EGUN    '
   CALL STAPL(davtot*10.D0)
   call emiprt(0)
! egun number (set to 1), z(m), transmission (%), synchronous phase (deg), time of flight (deg) (cog), COG relativistic beta (@ output)
! COG output energy (MeV), time of flight (deg) (REF), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
   trnsms=100.D0*DBLE(ngood)/DBLE(imax)
   idum=1
   dum=0.D0
   tcgprt=fh*tref*180.D0/pi
   emns=(1.D12)*dav1(idav,12)/fh
   delwrm=wref-we/1.D6
   write(50,'(A)') '# egun.dmp'
   write(50,'(A,A,A,A,A)') &
     '#  egun    Z       trans   ', &
     'PHIs     TOF(COG)      COG      Wcog          TOF(REF)   ', &
     '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ', &
     'El,RMS        dWref       EffVolt      ElementName      ', &
     '        amplitude'
   write(50,'(A,A,A,A,A)') &
    '#   #     (m)       (%)  ', &
    '(not used)  (deg)        beta     (MeV)          (deg)    ', &
    '     beta        (MeV)      (mm.mrad)    (mm.mrad)    ', &
    '(ns.keV)      (MeV)        (not used)                         ', &
    '  FMULT'
   write(50,'(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)') &
     idum,0.01D0*davtot,trnsms,dum,tcgprt,bets,wref,tcgprt,bets, &
     wref,0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),0.25D0*emns,delwrm,dum,trim(uden),fmult
   write(50,'(A)') '# '
END SUBROUTINE egun
!> *******************************************************************
!! SUBROUTINE refer
!! change the longitudinal position of the reference
!!
!! ---- IREF =0 and IREFW = 0:  dewref is dW/W where W is the kinetic
!!                              energy of the old reference
!! ---- IREF =0 and IREFW = 1:  dewref is dW (MeV) relative to the
!!                              kinetic energy of the old reference
!! ---- IREF =0 and IREFW = 2:  dewref is dW (MeV) is new reference
!!                              energy and dbref new reference
!!                              phase (deg) in abs. units
!! ---- IREF =1 and IREFW = 0:  dewref is dW/W where W is the kinetic
!!                              energy of the c.o.g
!! ---- IREF =1 and IREFW = 1:  dewref is dW (MeV) relative to the
!!                              kinetic energy of the c.o.g.
!< *******************************************************************
SUBROUTINE refer
   USE DynacConstants
   USE m4beam
   USE m4mcs
   USE m4input
   USE m4cavs
   USE m4ITVOLE, ONLY: ITVOL,ttvols
   USE mCOMnewref
   IMPLICIT NONE
   INTEGER i
   REAL(8) bref,gref,tcog
   REAL(8) atref,attvols,avref,baref,bcog,bnref,dbref,delt,fcpi,garef,gcog
   REAL(8) gncog,gnref,gpai,grefn,waref,wcog,wncog,wref,wnref,wrefn
!*******************************************************************
! ---- save  reference
   avref=vref
   atref=tref
   attvols=ttvols
   if(irefw.eq.2) then
     wnref=dewref
     gnref=wnref/xmat+1.D0
     bref=sqrt(gnref*gnref-1.D0)/gnref
! ---- set tref in sec based on dephas (deg)
        delt=dephas*pi/(fh*180.D0)
! ------ the new reference is:
     tref=delt
     vref=bref*vl
     if(itvol)ttvols=tref
   endif
   if(iref.eq.0) then
     if(irefw.eq.0) then
       bref=vref/vl
       gref=1.D0/sqrt(1.D0-bref*bref)
       dbref=bref*dewref*0.01D0/(gref*(gref+1.D0))
! ---- change dephas (deg) in delt (sec)
       delt=dephas*pi/(fh*180.D0)
! ------ the new reference is:
        tref=tref+delt
        vref=vref+dbref*vl
        if(itvol)ttvols=tref
     endif
     if(irefw.eq.1) then
       bref=vref/vl
       gref=1.D0/sqrt(1.D0-bref*bref)
       wref=(gref-1.D0)*xmat
       wnref=wref+dewref
       gnref=wnref/xmat+1.D0
       bref=sqrt(gnref*gnref-1.D0)/gnref
! ---- change dephas (deg) in delt (sec)
       delt=dephas*pi/(fh*180.D0)
! ------ the new reference is:
       tref=tref+delt
       vref=bref*vl
       if(itvol)ttvols=tref
     endif
   endif
   if(iref.eq.1) then
!  ----- c.o.g. of the bunch is the new reference
     tcog=0.D0
     bcog=0.D0
     do i=1,ngood
       tcog=tcog+f(6,i)
       gpai=f(7,i)/xmat
       bcog=bcog+sqrt(1.D0-1.D0/(gpai*gpai))
     enddo
     tcog=tcog/DBLE(ngood)
     bcog=bcog/DBLE(ngood)
     gcog=1.D0/sqrt(1.D0-bcog*bcog)
     wcog=(gcog-1.D0)*xmat
! ---- change dephas (deg) in delt (sec)
     delt=dephas*pi/(fh*180.D0)
     if(irefw.eq.0) then
       wrefn=wcog+wcog*dewref/100.D0
! ------ the new reference is:
       tref=tcog+delt
       grefn=wrefn/xmat+1.D0
       vref=vl*sqrt(grefn*grefn-1.D0)/grefn
       if(itvol)ttvols=tref
     endif
     if(irefw.eq.1) then
       wncog=wcog+dewref
       gncog=wncog/xmat+1.D0
       bcog=sqrt(gncog*gncog-1.D0)/gncog
! ------ the new reference is:
       tref=tcog+delt
       vref=bcog*vl
       if(itvol)ttvols=tref
     endif
   endif
   baref=avref/vl
   garef=1.D0/sqrt(1.D0-baref*baref)
   waref=(garef-1.D0)*xmat
   bnref=vref/vl
   gnref=1.D0/sqrt(1.D0-bnref*bnref)
   wnref=(gnref-1.D0)*xmat
   fcpi=fh*180.D0/pi
   write(16,'(3x,A,/,5x,A,e12.5,A,e12.5,A,e12.5,A)') '**before NREF', &
    'tof of the reference: ',atref*fcpi,' deg tof for adjustments: ',attvols*fcpi, &
    ' deg energy of reference: ',waref,' MeV'
   write(16,'(3x,A,/,5x,A,e12.5,A,e12.5,A,e12.5,A)') '**after NREF', &
     'tof of the reference: ',tref*fcpi,' deg tof for adjustments: ',ttvols*fcpi, &
     ' deg energy of reference: ',wnref,' MeV'
END SUBROUTINE refer
!> *******************************************************************
!! SUBROUTINE emiprt(L)
!! following EMIT or EMITL card, store data in arrays to be printed
!! by subroutine "daves"
!! L=0 corresponds to EMIT (do not read and print a label)
!! L=1 corresponds to EMITL (do read and print a label in dynac.short)
!! look for the statistics with EXT2D and returns them in array dav1
!!
!!      IDCH EQ 1: WITH  CHASE TEST
!!      IDCH NE 1: OTHERWISE
!!
!!       cog(1) : Energy(MeV)
!!       cog(3) : t.o.f. (sec)
!!       cog(4) : x-direction (cm)
!!       cog(5) : xp(mrd)
!!       cog(6) : y-direction (cm)
!!       cog(7) : yp(mrd)
!!
!!  exten(1) : Sum( dE*dE )  MeV*MeV
!!  exten(2) : Sum( dE*dPHase ) MeV*rad
!!  exten(3) : Sum( dPHase*dPHase ) rad*rad
!!  exten(4) : Sum( x*x )   cm*cm
!!  exten(5) : Sum( xp*xp )   mrad*mrad
!!  exten(6) : Sum( y*y )   cm*cm
!!  exten(7) : Sum( yp*yp )  mrad*mrad
!!  exten(8) : Sum( x*xp )   cm*mrad
!!  exten(9) : Sum( y*yp )   cm*mrad
!< *******************************************************************
SUBROUTINE emiprt(L)
   USE DynacConstants
   USE m4beam
   USE m4mcs
   USE m4output
   USE m4cavs
   USE m4chase, ONLY: chasit,chexmin,chexmax,ichas,ichxyz,fractx,fracty,fractl
   USE m4short
   USE mCOMfrmacc
   IMPLICIT NONE
   REAL(8) foo(20,9),chasdat(20),dav2(maxcell1,33),csexten(20,20)
   INTEGER I,J,K,KLM,L,MLK,NDP(20),iarg,ngx,ngy,ngz
   REAL(8) bcog,bref,bor,beref,cor12,encog,enprt,gcog,gref,tcog
   REAL(8) phnw
   REAL(8) qdianp,qdiant,qdisp,qditax,qditay,qdp,qmdv,sqmdv
   REAL(8) surxth,suryph,trpf,trqpy,trqpz,trqtx,trqty,trtf,trxf,tryf,xe
!*******************************************************************
   if (.not. allocated(ichxyz)) allocate(ichxyz(iptsz))
   if (.not. allocated(ichas)) allocate(ichas(iptsz))
   nbemit=nbemit+1
!  ichxyz(i)=1 for particles kept by chase
!  ichxyz(i)=0 for particles rejected by chase
   do i=1,ngood
     ichxyz(i)=1
   enddo
   xltot(nbemit)=davtot
   idav=idav+1
   iitem(idav)=3
   dav1(idav,40)=fh
   do i=1,ngood
     ichas(i)=1
   enddo
   iarg=1
   if (L.eq.1) davprt(idav)=shortl
   call cdg(iarg)
   encog=cog(1)
   gcog=encog/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   CALL EXT2D(1)
! --- qdisp : average dispersion (MeV)
! --- sqmdv:  emittance (MeV*rad)
   qdisp=2.D0*sqrt(exten(1))
   qmdv=exten(1)*exten(3)-exten(2)*exten(2)
   sqmdv=4.D0*pi*sqrt(qmdv)
! --- qdp : average extension in phase (rad)
   qdp=2.D0*sqrt(exten(3))
! --- cor12: coefficient of correlation in (dE, dPHI)
   if(exten(1)*exten(3) .gt. fprec) then
     cor12=exten(2)/sqrt(exten(1)*exten(3))
   else
     cor12=0.D0
   endif
! ---  particle reference
!      dav1(idav,3): relativistic beta
!      dav1(idav,4): Kinetic energy (MeV)
!      dav1(idav,5): phase (in deg. w.r.t. k*pi)
   beref=vref/vl
   gref=1.D0/sqrt(1.D0-beref*beref)
   dav1(idav,3)=beref
   dav1(idav,4)=xmat*(gref-1.D0)
! print out absolute TOF
   dav1(idav,5)=180.D0*tref*fh/pi
! ---  c.o.g of the bunch
!      dav1(idav,6): Kinetic energy (MeV)
!      dav1(idav,7): phase (in deg. w.r.t. k*pi)
! print out absolute TOF
   phnw=180.D0*tcog*fh/pi
   dav1(idav,6)=encog-xmat
   dav1(idav,7)=phnw
! ---- deviation between the fictious reference and the c.o.g. of the bunch
!     dav1(idav,8) : deviation in energy (MeV)
!     dav1(idav,9) : deviation of phase (deg)
   dav1(idav,8)=encog-xmat-dav1(idav,4)
   dav1(idav,9)=phnw-dav1(idav,5)
! ---- statistics in z-zp
! --- dav1(idav,10) :  extension dPHI (deg)
! --- dav1(idav,11) :  dispersion dE (MeV)
! --- dav1(idav,12) :  emittance (MeV*rad)
! --- dav1(idav,23) :  correlation in  between dE an dPHI
   dav1(idav,10)=qdp*180.D0/pi
   dav1(idav,11)=qdisp
   dav1(idav,12)=sqmdv/pi
   dmpdat(12)=(1.D12)*dav1(idav,12)/(4.D0*fh)
   dav1(idav,23)=cor12
! sup       dav1(idav,39)=sqmdv*180.D0/(pi*pi)
! sup       Ez(ns.keV)
! ---- statistics in x-xp and y-yp
   trqtx=exten(4)*exten(5)-exten(8)*exten(8)
   trqpy=exten(6)*exten(7)-exten(9)*exten(9)
   surxth=4.D0*pi*sqrt(trqtx)
   suryph=4.D0*pi*sqrt(trqpy)
   qditax=2.D0*sqrt(exten(4))
   qdiant=2.D0*sqrt(exten(5))
   qditay=2.D0*sqrt(exten(6))
   qdianp=2.D0*sqrt(exten(7))
!  dav1(idav,13): extension in x (mm)
!  dav1(idav,14): extension in xp (mrad)
! --- dav1(idav,15): correlation between x and xp
   dav1(idav,13)=qditax*10.D0
   dav1(idav,14)=qdiant
   dav1(idav,15)=0.D0
   if(exten(4)*exten(5) .gt. fprec) dav1(idav,15)=exten(8)/sqrt(exten(4)*exten(5))
!    Emittance(norm)  x-xp (mm*mrad)
   dav1(idav,16)=bcog*surxth*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   dmpdat(10)=dav1(idav,16)/4.D0
!    Emittance(non norm) x-xp (mm*mrad)
   dav1(idav,17)=surxth*10.D0/pi
! --- dav1(idav,18): y-extension  (mm)
! --- dav1(idav,19): yp-extension (mrad)
! --- dav1(idav,20): correlation between y and yp
   dav1(idav,20)=0.D0
   if(exten(6)*exten(7) .gt. fprec) dav1(idav,20)=exten(9)/sqrt(exten(6)*exten(7))
   dav1(idav,18)=qditay*10.D0
   dav1(idav,19)=qdianp
!    dav1(idav,21) : Emittance(norm) y-yp (pi*mm*mrad)
   dav1(idav,21)=bcog*suryph*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   dmpdat(11)=dav1(idav,21)/4.D0
!    dav1(idav,22) : Emittance(non norm) y-yp (mm*mrad)
   dav1(idav,22)=suryph*10.D0/pi
   dav1(idav,30)=DBLE(ngood)
   dav1(idav,31)=cog(4)*10.D0
   dav1(idav,32)=cog(5)
   dav1(idav,33)=cog(6)*10.D0
   dav1(idav,34)=cog(7)
! next card to indicate no chase
   dav1(idav,26)=0.D0
!****************************
! --- statistics with chase *
!****************************
   if(chasit .and. .not. fracc) then
     write(16,*)' EMIT: # of good particles             :',ngood
     if(fractl.lt.1.D0) then
! ---  chase in z-zp
       call chasel
! ngz is number of retained particles in Z
       ngz=0
       do i=1,ngood
         ichxyz(i)=ichas(i)
         if(ichxyz(i).eq.1) ngz=ngz+1
       enddo
       write(16,*)' EMIT: # of retained particles (chasel):',ngz
       iarg=1
       call cdg(iarg)
       tcog=cog(3)
       encog=cog(1)
       gcog=encog/xmat
       bcog=sqrt(1.D0-1.D0/(gcog*gcog))
       enprt=encog-xmat
       CALL EXT2D(1)
       qmdv=exten(1)*exten(3)-exten(2)*exten(2)
       trqty=exten(4)*exten(5)-exten(8)*exten(8)
       trqpz=exten(6)*exten(7)-exten(9)*exten(9)
!     qdisp : average dispersion dE (MeV)
       qdisp=2.D0*sqrt(exten(1))
!     qdp : average extension dPHI (rad)
       qdp=2.D0*sqrt(exten(3))
!     cor12: coefficient of correlation in (dE, dPHI)
       cor12=exten(2)/sqrt(exten(1)*exten(3))
! ---  fictitious reference
!      dav2(idav,3): relativistic beta
!      dav2(idav,4): Kinetic energy (MeV)
!      dav2(idav,5): phase (in deg. w.r.t. k*pi)
       beref=vref/vl
       gref=1.D0/sqrt(1.D0-beref*beref)
       dav2(idav,3)=beref
       dav2(idav,4)=xmat*(gref-1.D0)
       dav2(idav,5)=180.D0*tref*fh/pi
! ---  c.o.g of the bunch
!      dav2(idav,6): Kinetic energy (MeV)
       dav2(idav,6)=encog-xmat
! ---- deviation between fictitious reference and c.o.g.
!     dav2(idav,8) : deviation in energy (MeV)
       dav2(idav,8)=encog-xmat-dav2(idav,4)
! ---- caracteristics of the bunch in longitudinal plane (dE, dPHI)
!       dav2(idav,10) :  dPHI extension (deg)
!       dav2(idav,11) :  dispersion dE (MeV)
!       dav2(idav,23) :  coefficient of correlation in  (dE, dPHI)
       dav2(idav,10)=qdp*180.D0/pi
       dav2(idav,11)=qdisp
       dav2(idav,23)=cor12
! 2016-05-16
       chasdat(1)=davtot/100.D0
       chasdat(2)=100.D0*fractl
       chasdat(3)=encog-xmat
       chasdat(4)=180.D0*tcog*fh/pi
! long emittance in keV.ns
       chasdat(7)=1.D12*sqrt(qmdv)/fhinit
! h emittance
       chasdat(5)=bcog*sqrt(trqty)*10.D0/(sqrt(1.D0-bcog*bcog))
! v emittance
       chasdat(6)=bcog*sqrt(trqpz)*10.D0/(sqrt(1.D0-bcog*bcog))
! write the chasel data
       write(46, &
        '(1x,E13.6,1x,F6.3,5(1x,E13.6),1x,I6,1x,I6,10(1x,E13.6))') &
       (chasdat(klm),klm=1,7),ngz,ngood, &
       (10.D0*chexmin(mlk),10.D0*chexmax(mlk),mlk=1,2), &
       (chexmin(mlk),chexmax(mlk),mlk=3,5)
       do i=1,ngood
         ichas(i)=1
       enddo
     endif
     if(fractx.lt.1.D0) then
! ---  chase in x-xp
       call chasex
! ngx is number of retained particles in X
       ngx=0
!  ichxyz(i)=1 for particles kept by chase
!  ichxyz(i)=0 for particles rejected by chase
       do i=1,ngood
         ichxyz(i)=1
       enddo
       do i=1,ngood
         ichxyz(i)=ichas(i)*ichxyz(i)
         if(ichxyz(i).eq.1) ngx=ngx+1
       enddo
       write(16,*)' EMIT: # of retained particles (chasex):',ngx
       iarg=1
       call cdg(iarg)
       tcog=cog(3)
       encog=cog(1)
       gcog=encog/xmat
       bcog=sqrt(1.D0-1.D0/(gcog*gcog))
       dav2(idav,26)=cog(4)*10.D0
       dav2(idav,27)=cog(5)
       CALL EXT2D(1)
       qmdv=exten(1)*exten(3)-exten(2)*exten(2)
       trqty=exten(4)*exten(5)-exten(8)*exten(8)
       trqpz=exten(6)*exten(7)-exten(9)*exten(9)
       surxth=4.D0*pi*sqrt(trqty)
       qditax=2.D0*sqrt(exten(4))
       qdiant=2.D0*sqrt(exten(5))
! below for fourth line of EMIT output
! ---- caracteristics of the bunch in x-direction
!        dav2(idav,13): x-extension (mm)
!        dav2(idav,14): xp-extension (mrad)
!        dav2(idav,15): coefficient of correlation in plane (x, xp)
       dav2(idav,13)=qditax*10.D0
       dav2(idav,14)=qdiant
       dav2(idav,15)=0.D0
       if(exten(4)*exten(5).gt.fprec) &
       dav1(idav,15)=exten(8)/sqrt(exten(4)*exten(5))
!    Emittance(non norm) in x-xp (mm*mrad)
!           dav2(idav,17)=surxth*10.D0/pi
! 2016-05-16
       chasdat(1)=davtot/100.D0
       chasdat(2)=100.D0*fractx
       chasdat(3)=encog-xmat
       chasdat(4)=180.D0*tcog*fh/pi
! long emittance in keV.ns
       chasdat(7)=1.D12*sqrt(qmdv)/fhinit
! h emittance
       chasdat(5)=bcog*sqrt(trqty)*10.D0/(sqrt(1.D0-bcog*bcog))
! v emittance
       chasdat(6)=bcog*sqrt(trqpz)*10.D0/(sqrt(1.D0-bcog*bcog))
! write the chasex data
       write(44,'(1x,E13.6,1x,F6.3,5(1x,E13.6),1x,I6,1x,I6,10(1x,E13.6))') &
         (chasdat(klm),klm=1,7),ngx,ngood, &
         (10.D0*chexmin(mlk),10.D0*chexmax(mlk),mlk=1,2), &
         (chexmin(mlk),chexmax(mlk),mlk=3,5)
       do i=1,ngood
         ichas(i)=1
       enddo
     endif
     if(fracty.lt.1.D0) then
! ---  chase in y-yp
       call chasey
! ngy is number of retained particles in Y
       ngy=0
!  ichxyz(i)=1 for particles kept by chase
!  ichxyz(i)=0 for particles rejected by chase
       do i=1,ngood
         ichxyz(i)=1
       enddo
       do i=1,ngood
         ichxyz(i)=ichas(i)*ichxyz(i)
         if(ichxyz(i).eq.1) ngy=ngy+1
       enddo
       write(16,*)' EMIT: # of retained particles (chasey):',ngy
       write(16,*)
       iarg=1
       call cdg(iarg)
       tcog=cog(3)
       encog=cog(1)
       gcog=encog/xmat
       bcog=sqrt(1.D0-1.D0/(gcog*gcog))
       dav2(idav,28)=cog(6)*10.D0
       dav2(idav,29)=cog(7)
       CALL EXT2D(1)
       qmdv=exten(1)*exten(3)-exten(2)*exten(2)
       trqty=exten(4)*exten(5)-exten(8)*exten(8)
       trqpz=exten(6)*exten(7)-exten(9)*exten(9)
       suryph=4.D0*pi*sqrt(trqpz)
       qditay=2.D0*sqrt(exten(6))
       qdianp=2.D0*sqrt(exten(7))
!     dav2(idav,18): y-extension  (mm)
!     dav2(idav,19): yp-extension (mrad)
!     dav2(idav,20): coefficient of correlation in the plane (y, yp)
       dav2(idav,20)=0.D0
       if(exten(6)*exten(7).gt.fprec) dav2(idav,20)=exten(9)/sqrt(exten(6)*exten(7))
       dav2(idav,18)=qditay*10.D0
       dav2(idav,19)=qdianp
!    dav1(idav,22) : Emittance(non norm) in y-yp (mm*mrad)
!           dav2(idav,22)=suryph*10.D0/pi
! 2016-05-16
       chasdat(1)=davtot/100.D0
       chasdat(2)=100.D0*fracty
       chasdat(3)=encog-xmat
       chasdat(4)=180.D0*tcog*fh/pi
! long emittance in keV.ns
       chasdat(7)=1.D12*sqrt(qmdv)/fhinit
! h emittance
       chasdat(5)=bcog*sqrt(trqty)*10.D0/(sqrt(1.D0-bcog*bcog))
! v emittance
       chasdat(6)=bcog*sqrt(trqpz)*10.D0/(sqrt(1.D0-bcog*bcog))
! write the chasey data
       write(45,'(1x,E13.6,1x,F6.3,5(1x,E13.6),1x,I6,1x,I6,10(1x,E13.6))') &
         (chasdat(klm),klm=1,7),ngy,ngood, &
         (10.D0*chexmin(mlk),10.D0*chexmax(mlk),mlk=1,2), &
         (chexmin(mlk),chexmax(mlk),mlk=3,5)
       do i=1,ngood
         ichas(i)=1
       enddo
     endif
   endif
! print energy, boro etc for each charge state in long
   if(ncstat.gt.1) then
     write(16,'(1x,a4)') 'EMIT'
     DO k=1,ncstat
       NDP(k)=0
       do j=2,7
         foo(k,j)=0.D0
       enddo
     ENDDO
     DO i=1,imax
       if(int(f(8,i)).eq.1) then
         DO k=1,ncstat
           if(abs(f(9,i)-cstat(k)).le.fprec) then
             NDP(k)=NDP(k)+1
             do j=2,7
               foo(k,j)=foo(k,j)+f(j,i)
             enddo
           endif
         ENDDO
       endif
     ENDDO
     DO k=1,ncstat
       if(NDP(k).ne.0) then
         do j=2,7
           foo(k,j)=foo(k,j)/DBLE(NDP(k))
           csexten(k,j)=0.D0
         enddo
       endif
     ENDDO
! now get beam extents
     DO i=1,imax
       if(int(f(8,i)).eq.1) then
         DO k=1,ncstat
!           if(f(9,i).eq.cstat(k)) then
           if(abs(f(9,i)-cstat(k)).le.fprec) then
!             FDPP=fd(i)-1.D0
!             FFDPP=ffd(i)-1.D0
!             fdp=f(7,i)-cog(1)
!             TRPH1=FH*(f(6,i)-cog(3))
             TRXF=F(2,I)-foo(k,2)
             TRTF=F(3,I)-foo(k,3)
             TRYF=F(4,I)-foo(k,4)
             TRPF=F(5,I)-foo(k,5)
!             exten(1)=exten(1)+FDP**2
!             exten(2)=exten(2)+TRPH1*FDP
!             exten(3)=exten(3)+TRPH1**2
             csEXTEN(k,4)=csEXTEN(k,4)+TRXF**2
             csexten(k,5)=csexten(k,5)+TRTF**2
             csEXTEN(k,6)=csEXTEN(k,6)+TRYF**2
             csexten(k,7)=csexten(k,7)+TRPF**2
!             EXTEN(8)=EXTEN(8)+TRXF*TRTF
!             EXTEN(9)=EXTEN(9)+TRYF*TRPF
!             exten(12)=exten(12)+FDPP*TRXF
!             exten(13)=exten(13)+FDPP*TRYF
!             exten(14)=exten(14)+FDPP**2
!             exten(15)=exten(15)+FFDPP*TRXF
!             exten(16)=exten(16)+FFDPP*TRYF
!             exten(17)=exten(17)+FFDPP**2
           endif
         enddo
       endif
     enddo
     DO k=1,ncstat
       if(NDP(k).ne.0) then
         do j=2,7
           csEXTEN(k,j)=sqrt(csEXTEN(k,j)/DBLE(NDP(k)))
         enddo
       endif
     ENDDO
! print to dynac.long
     write(16,*) '     Q       Particles   beta       Wcog(MeV)   ', &
       '   Wcog(MeV/u)    Pcog(kG.cm)    TOF(deg)       TOF(sec)   ', &
       '     X_avg(cm)    Xp_avg(mrad)    Y_avg(cm)     Yp_avg(mrad)', &
       '  X_rms        Xp_rms         Y_rms        Yp_rms'
     DO k=1,ncstat
       if(NDP(k).ne.0) then
         gref=foo(k,7)/xmat
         bref=sqrt(1.D0-1.D0/(gref*gref))
         xe=(gref-1.D0)*xmat
!   magnetic rigidity
         bor=3.3356D0*xmat*bref*gref/cstat(k)
         write(16,'(2x,f9.5,3x,I6,4x,F9.7,5(1x,E14.7),1x,8(F12.5,2x))') &
         cstat(k),NDP(k),bref,xe,xe/atm,bor,foo(k,6)*180.D0*fh/pi, &
         foo(k,6),foo(k,2),foo(k,3),foo(k,4),foo(k,5), &
         csexten(k,4),csexten(k,5),csexten(k,6),csexten(k,7)
       else
         write(16,'(2x,f5.2,3x,I5)') cstat(k),NDP(k)
       endif
     ENDDO
     write(16,*)
   endif
END SUBROUTINE emiprt
!> *******************************************************************
!! SUBROUTINE clear
!! CLEAR MATRICES R AND T
!< *******************************************************************
SUBROUTINE clear
   USE m4tmatrix
   IMPLICIT NONE
   INTEGER IA,IB,IC
!*******************************************************************
!  CLEAR R
   DO IA=1,6
     DO IB=1,6
       R(IA,IB)=0.D0
!       IF(IA.EQ.IB) R(IA,IB)=1.D0
     ENDDO
   ENDDO
   DO IA=1,6
     R(IA,IA)=1.D0
   ENDDO
!  CLEAR T
   IF(ISEOR) THEN
     DO IA=1,6
       DO IB=1,6
         DO IC=1,6
           T(IA,IB,IC)=0.D0
         ENDDO
       ENDDO
     ENDDO
   ENDIF
END SUBROUTINE clear
!> *******************************************************************
!! SUBROUTINE cobeam(ii,xl)
!! MATRIX BASED BEAM COMPUTATION
!< *******************************************************************
SUBROUTINE cobeam(ii,xl)
   USE DynacConstants
   USE m4tmatrix
   USE m4beam
   USE mCOMradia
   IMPLICIT NONE
   INTEGER IA,IB,IC,II
   REAL(8) xl,bpai,gpai,vpai
   REAL(8) SF(6),SSF(6)
!*******************************************************************
!     MATRIX R AND T ARE IN  M-RD
!   beam conversion:  CM ===> M      MRD ==> RD
   SF(1)=F(2,II)*1.D-02
   SF(2)=F(3,II)*1.D-03
   SF(3)=F(4,II)*1.D-02
   SF(4)=F(5,II)*1.D-03
   SF(5)=XL*1.D-02
   SF(5)=SF(5)/(cos(sf(2))*cos(sf(4)))
   SF(6)=(FD(II)-1.D0)
!   FIRST order COMPUTATION (M-RD)
   DO IA=1,6
     SSF(IA)=0.D0
     DO IB=1,6
       SSF(IA)=R(IA,IB)*SF(IB)+SSF(IA)
     ENDDO
   ENDDO
   IF(ISEOR) THEN
!    SECOND order COMPUTATION  (M-RD)
     DO IA=1,6
       DO IB=1,6
         DO IC=1,6
           SSF(IA)=SSF(IA)+T(IA,IB,IC)*SF(IB)*SF(IC)
         ENDDO
       ENDDO
     ENDDO
   ENDIF
   DO IA=1,4
     F(IA+1,II)=SSF(IA)
   ENDDO
!   CONVERT RD ==> MRD    M ==> CM
   F(3,II)=F(3,II)*1000.D0
   F(5,II)=F(5,II)*1000.D0
   F(2,II)=F(2,II)*100.D0
   F(4,II)=F(4,II)*100.D0
   GPAI=F(7,II)/XMAT
   BPAI=sqrt(1.D0-1.D0/(gpai*gpai))
   VPAI=VL*BPAI
   TRT=100.D0*SSF(5)/VPAI
   F(6,II)=F(6,II)+TRT
END SUBROUTINE cobeam
!> *******************************************************************
!! SUBROUTINE zrotat(zrot)
!! BEAM ROTATION
!!     the transverse coordinates X and Y may be rotated
!!     through an angle about the axis tangent to the
!!     central trajectory at the point in question.
!< *******************************************************************
SUBROUTINE zrotat(zrot)
   USE DynacConstants
   USE m4beam
   USE m4output
   USE mCOMgrot
   IMPLICIT NONE
   REAL(8) zrot,RS24,RS44
   INTEGER IA,IB
   INTEGER II
   REAL(8) RS(6,6),FF(6),FC(6)
!*******************************************************************
   WRITE(16,'(/,20X,A,F10.4,A,/)') 'BEAM ROTATION ',ZROT, &
            '  degrees  ABOUT THE POSITIVE Z-AXIS'
   if(.not.izrot) then
     izrot=.true.
     rzot=zrot
   else
     izrot=.false.
   endif
!  Daves start
   idav=idav+1
   iitem(idav)=20
   dav1(idav,1)=zrot
! initialize
   DO IA=1,4
     DO IB=1,4
       RS(IA,IB)=0.D0
     ENDDO
   ENDDO
!  Conversion DEG ==> RAD
   ZROT=  ZROT*pi/180.D0
   RS44  =  COS(ZROT)
   RS( 4,4 )  =    RS44
   RS( 3,3 )  =    RS44
   RS( 2,2 )  =    RS44
   RS( 1,1 )  =    RS44
   RS24     =  SIN(ZROT)
   RS( 2,4 )  =    RS24
   RS( 1,3 )  =    RS24
   RS( 4,2 )  =  - RS24
   RS( 3,1 )  =  - RS24
   DO II=1,ngood
     FF(1)=F(2,II)
     FF(2)=F(3,II)
     FF(3)=F(4,II)
     FF(4)=F(5,II)
     DO IA=1,4
       FC(IA)=0.D0
       DO IB=1,4
         FC(IA)=FC(IA)+FF(IB)*RS(IA,IB)
       ENDDO
     ENDDO
     F(2,II)=FC(1)
     F(3,II)=FC(2)
     F(4,II)=FC(3)
     F(5,II)=FC(4)
   ENDDO
END SUBROUTINE zrotat
!> *******************************************************************
!! SUBROUTINE matrix
!! print first and second order matrix of a lens
!< *******************************************************************
SUBROUTINE matrix
   USE m4tmatrix
   IMPLICIT NONE
   INTEGER IA,IB,IC
   REAL(8) fprec
!*******************************************************************
   write(16,*) ' TRANSPORT MATRIX (m-rd)'
   write(16,*) ' FIRST ORDER TRANSPORT********'
   fprec=epsilon(T(1,1,1))
   DO IA=1,6
     write(16,'(6(3x,e12.5))') (r(ia,ib),ib=1,6)
   ENDDO
   write(16,*)   '**********************************************'
   IF(ISEOR) THEN
     write(16,*) '******* SECOND ORDER TRANSPORT (m-rd) ********'
     DO IA=1,6
       DO IB=1,6
         DO IC=1,6
           IF(abs(T(IA,IB,IC)).gt.fprec) &
              WRITE(16,'(A,3(i1),3x,e12.5)')' T',IA,IB,IC,T(IA,IB,IC)
         ENDDO
       ENDDO
     ENDDO
     write(16,*) '**********************************************'
   ENDIF
END SUBROUTINE matrix
!> *******************************************************************
!! SUBROUTINE ELQUA(gam)
!! FIRST AND SECOND order TRANSPORT MATRIX R AND T
!!      PURE QUADRUPOLE FIELD, MATRIX R AND T  ARE IN  (M,RD)
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                 OTHERWIZE DECLARED *********
!!       GAM=relativistic gamma of COG
!< *******************************************************************
SUBROUTINE ELQUA(gam)
   USE DynacConstants
   USE m4tmatrix
   USE m4beam
   USE m4QSEX
   IMPLICIT NONE
   REAL(8) gam,AKQ2,AL,AKQ,ARG,CSIN,CCOS,HSIN,HCOS,SSOK,SC,BSOK,BC
   REAL(8) gam2,bet2gam2,bet
!*******************************************************************
   AKQ2=KQ2*1.D4
   AL=L*1.D-02
   AKQ=SQRT(ABS(AKQ2))
   IF(AKQ.LT.1.D-13) AKQ=1.D-13
   ARG=AKQ*AL
   CSIN=SIN(ARG)
   CCOS=COS(ARG)
   HSIN=SINH(ARG)
   HCOS=COSH(ARG)
   IF(AKQ2 .gt. 0.D0) THEN
     SSOK=CSIN/AKQ
     SC=CCOS
     BSOK=HSIN/AKQ
     BC=HCOS
   ELSE
     SSOK=HSIN/AKQ
     SC=HCOS
     BSOK=CSIN/AKQ
     BC=CCOS
   ENDIF
   R(1,1)=SC
   R(1,2)=SSOK
   R(2,1)=-AKQ2*SSOK
   R(2,2)=SC
   R(3,3)=BC
   R(3,4)=BSOK
   R(4,3)=AKQ2*BSOK
   R(4,4)=BC
!   R(5,6)=AL/(gam*gam)
   gam2=gam*gam
   bet2gam2=gam2-1.D0
   bet=sqrt(bet2gam2/gam2)
!!   R(5,6)=-AL/(bet*gam2*vl*0.01)
!   R(5,6)=0.
   IF(.NOT.ISEOR) RETURN
!  T116=AMAT(12,1)
   T(1,1,6)=AL*AKQ2*SSOK/2.D0
!  T126=AMAT(17,1)
   T(1,2,6)=(SSOK-AL*SC)/2.D0
!  T216=AMAT(12,2)
   T(2,1,6)=AKQ2*(SSOK+AL*SC)/2.D0
!  T226=AMAT(17,2)
   T(2,2,6)=T(1,1,6)
!  T336= AMAT(21,3) T346=AMAT(24,3)
   T(3,3,6)=-AL*AKQ2*BSOK/2.D0
   T(3,4,6)=(BSOK-AL*BC)/2.D0
!  T436=AMAT(21,4)  T446=AMAT(24,4)
   T(4,3,6)=-AKQ2*(BSOK+AL*BC)/2.D0
   T(4,4,6)=T(3,3,6)
!  T511=AMAT(7,5)  T512=AMAT(8,5) T522=AMAT(13,5) T533=AMAT(18,5)
   T(5,1,1)=AKQ2*(AL-SC*SSOK)/4.D0
   T(5,1,2)=-AKQ2*SSOK*SSOK/2.D0
   T(5,2,2)=(AL+SC*SSOK)/4.D0
   T(5,3,3)=-AKQ2*(AL-BC*BSOK)/4.D0
!  T534=AMAT(19,5)  T544=AMAT(22,5)
   T(5,3,4)=AKQ2*(BSOK*BSOK)/2.D0
   T(5,4,4)=(AL+BC*BSOK)/4.D0
END SUBROUTINE ELQUA
!> *******************************************************************
!! SUBROUTINE ELQSEX
!! FIRST AND SECOND order TRANSPORT MATRIX R AND T
!!      QUADRUPOLE FIELD      + SEXTUPOLE FIELD
!! quadrupole field combined with a sextupole field
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                 OTHERWIZE DECLARED *********
!< *******************************************************************
SUBROUTINE ELQSEX
   USE DynacConstants
   USE m4tmatrix
   USE m4beam
   USE m4QSEX
   USE mCOMelq
   IMPLICIT NONE
   REAL(8) AKS2,AL,CSIN,CCOS,HSIN,HCOS,SSOK,SC,BSOK
   REAL(8) AKQ,AKQ2,ARG,bc
!*******************************************************************
   AKS2=KS2*1.D06
   AL=L*1.D-02
   AKQ2=KQ2*1.D4
   AKQ=SQRT(ABS(AKQ2))
   ARG=AKQ*AL
   CSIN=SIN(ARG)
   CCOS=COS(ARG)
   HSIN=SINH(ARG)
   HCOS=COSH(ARG)
   IF(AKQ2 .GT. 0.D0) THEN
    SSOK=CSIN/AKQ
    SC=CCOS
    BSOK=HSIN/AKQ
    BC=HCOS
   ELSE
    SSOK=HSIN/AKQ
    SC=HCOS
    BSOK=CSIN/AKQ
    BC=CCOS
   ENDIF
!   IF(AKQ2.EQ.6.*0) THEN
   IF(abs(AKQ2).LE.fprec) THEN
    R(1,2)=AL
    R(3,4)=AL
   ELSE
    R(1,1)=SC
    R(1,2)=SSOK
    R(2,1)=-AKQ2*SSOK
    R(2,2)=SC
    R(3,3)=BC
    R(3,4)=BSOK
    R(4,3)=AKQ2*BSOK
    R(4,4)=BC
   ENDIF
   IF(.NOT.ISEOR) RETURN
!omment       IF(KS2.EQ.0.0)RETURN
!      IF(AKQ2.EQ.6.*0) THEN
   IF(abs(AKQ2).LE.fprec) THEN
     inisk=1
     call elsex
   ELSE
!   T111=AMAT( 7,1)  T112=AMAT( 8,1) T116=AMAT(12,1)
     T(1,1,1)=-AKS2*(SSOK*SSOK+(1.D0-SC)/AKQ2)/3.D0
     T(1,1,2)=-2.D0*AKS2*(SSOK*(1.D0-SC)/AKQ2)/3.D0
     T(1,1,6)=AL*AKQ2*SSOK/2.D0
!    T122=AMAT(13,1) T126=AMAT(17,1)
     T(1,2,2)=-AKS2*(2.D0*(1.D0-SC)/AKQ2-SSOK*SSOK)/ &
     (3.D0*AKQ2)
     T(1,2,6)=(SSOK-AL*SC)/2.D0
!   T133=AMAT(18,1) T134=AMAT(19,1) T144=AMAT(22,1)
     T(1,3,3)=AKS2*(BSOK*BSOK+3.D0*(1.D0-SC)/AKQ2)/5.D0
     T(1,3,4)=2.D0*AKS2*(BSOK*BC-SSOK)/(5.D0*AKQ2)
     T(1,4,4)=AKS2*(BSOK*BSOK-2.D0*(1.D0-SC)/AKQ2)/ &
     (5.D0*AKQ2)
!   T211=AMAT( 7,2) T212= AMAT( 8,2) T216=AMAT(12,2)
     T(2,1,1)=-AKS2*(2.D0*SSOK*SC+SSOK)/3.D0
     T(2,1,2)=-2.D0*AKS2*(SC*(1.D0-SC)/AKQ2+SSOK*SSOK)/3.D0
     T(2,1,6)=AKQ2*(SSOK+AL*SC)/2.D0
!   T222=AMAT(13,2)  T226=AMAT(17,2)
       T(2,2,2)=-AKS2*(2.D0*SSOK-2.D0*SSOK*SC)/(3.D0*AKQ2)
       T(2,2,6)=T(1,1,6)
!    T233=AMAT(18,2) T234=AMAT(19,2) T244=AMAT(22,2)
     T(2,3,3)=AKS2*(2.D0*BSOK*BC+3.D0*SSOK)/5.D0
     T(2,3,4)=2.D0*AKS2*(BC*BC+BSOK*BSOK*AKQ2-SC)/ &
          (5.D0*AKQ2)
     T(2,4,4)=2.D0*AKS2*(BSOK*BC-SSOK)/(5.D0*AKQ2)
!    T313=AMAT(9,3)   T314=AMAT(10,3)  T323=AMAT(14,3)
     T(3,1,3)=2.D0*AKS2*(BC*(1.D0-SC)/AKQ2+ &
                   2.D0*SSOK*BSOK)/5.D0
     T(3,1,4)=2.D0*AKS2*(2.D0*SSOK*BC-BSOK*(1.D0+SC)) &
     /(5.D0*AKQ2)
     T(3,2,3)=2.D0*AKS2*(3.D0*BSOK-2.D0*BSOK*SC- &
       SSOK*BC)/(5.D0*AKQ2)
!   T324=AMAT(15,3) T336= AMAT(21,3) T346=AMAT(24,3)
     T(3,2,4)=2.D0*AKS2*(2.D0*BC*(1.D0-SC)/AKQ2- &
        SSOK*BSOK)/(5.D0*AKQ2)
     T(3,3,6)=-AL*AKQ2*BSOK/2.D0
     T(3,4,6)=(BSOK-AL*BC)/2.D0
!   T413=AMAT( 9,4)  T414=AMAT(10,4)  T423=AMAT(14,4)    T424=AMAT(15,4)
     T(4,1,3)=2.D0*AKS2*(BSOK*(1.D0-SC)+BC*SSOK+ &
     2.D0*SC*BSOK+2.D0*SSOK*BC)/5.D0
     T(4,1,4)=2.D0*AKS2*(2.D0*SC*BC+2.D0*SSOK*BSOK*AKQ2- &
      BC*(1.D0+SC)+BSOK*SSOK*AKQ2)/(5.D0*AKQ2)
     T(4,2,3)=2.D0*AKS2*(3.D0*BC-2.D0*BC*SC &
    +2.D0*BSOK*SSOK*AKQ2-SC*BC-SSOK*BSOK*AKQ2)/(5.D0*AKQ2)
     T(4,2,4)=2.D0*AKS2*(2.D0*BSOK*(1.D0-SC)+ &
     2.D0*BC*SSOK-SC*BSOK-SSOK*BC)/(5.D0*AKQ2)
!   T436=AMAT(21,4)  T446=AMAT(24,4)
     T(4,3,6)=-AKQ2*(BSOK+AL*BC)/2.D0
     T(4,4,6)=T(3,3,6)
!  T511=AMAT(7,5)  T512=AMAT(8,5) T522=AMAT(13,5) T533=AMAT(18,5)
     T(5,1,1)=AKQ2*(AL-SC*SSOK)/4.D0
     T(5,1,2)=-AKQ2*SSOK*SSOK/2.D0
     T(5,2,2)=(AL+SC*SSOK)/4.D0
     T(5,3,3)=-AKQ2*(AL-BC*BSOK)/4.D0
!   T534=AMAT(19,5)  T544=AMAT(22,5)
     T(5,3,4)=AKQ2*(BSOK*BSOK)/2.D0
     T(5,4,4)=(AL+BC*BSOK)/4.D0
   ENDIF
END SUBROUTINE ELQSEX
!> *******************************************************************
!! SUBROUTINE ELSEX
!! FIRST AND SECOND order TRANSPORT MATRIX R AND T
!!    PURE SEXTUPOLE FIELD, MATRIX R AND T  ARE IN  (M,RD)
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                 OTHERWIZE DECLARED *********
!< *******************************************************************
SUBROUTINE ELSEX
   USE DynacConstants
   USE m4tmatrix
   USE m4beam
   USE m4QSEX
   USE mCOMelq
   IMPLICIT NONE
   REAL(8) AL
   REAL(8) AKL1,AKL2,AKL3,AKL4,AKS2
!*******************************************************************
   if(inisk.eq.0) then
     AKS2=KS2*1.D06
     AL=L*1.D-02
   else
     inisk=0
   endif
   AKL1=AKS2*AL
   AKL2=AKL1*AL
   AKL3=AKL2*AL
   AKL4=AKL3*AL
   R(1,2)=AL
   R(3,4)=AL
   IF(.NOT.ISEOR) RETURN
!   T522=AMAT(13,5) T544=AMAT(22,5)
   T(5,2,2)=AL/2.D0
   T(5,4,4)=AL/2.D0
!   IF(AKS2.EQ.0.0)RETURN
   IF(abs(AKS2).LE.fprec)RETURN
!  T111=AMAT( 7,1) T112=AMAT( 8,1) T122=AMAT(13,1)
   T(1,1,1)=-AKL2/2.D0
   T(1,1,2)=-AKL3/3.D0
   T(1,2,2)=-AKL4/12.D0
!  T133=AMAT(18,1)  T134=AMAT(19,1)  T144=AMAT(22,1)
   T(1,3,3)= AKL2/2.D0
   T(1,3,4)= AKL3/3.D0
   T(1,4,4)= AKL4/12.D0
!  T211=AMAT( 7,2) T212=AMAT( 8,2) T222=AMAT(13,2)
   T(2,1,1)=-AKL1
   T(2,1,2)=-AKL2
   T(2,2,2)=-AKL3/3.D0
!  T233=AMAT(18,2) T234=AMAT(19,2) T244=AMAT(22,2)
   T(2,3,3)= AKL1
   T(2,3,4)= AKL2
   T(2,4,4)= AKL3/3.D0
!  T313=AMAT( 9,3) T314=AMAT( 10,3)  T323=AMAT(14,3) T324=AMAT(15,3)
   T(3,1,3)= AKL2
   T(3,1,4)= AKL3/3.D0
   T(3,2,3)= AKL3/3.D0
   T(3,2,4)= AKL4/6.D0
!  T413=AMAT(9,4) T414=AMAT( 10,4) T423=AMAT(14,4) T424=AMAT(15,4)
   T(4,1,3)= AKL1*2.D0
   T(4,1,4)= AKL2
   T(4,2,3)= AKL2
   T(4,2,4)= AKL3*2.D0/3.D0
END SUBROUTINE ELSEX
!> *******************************************************************
!! SUBROUTINE disp
!! Compute the dispersion dE/E with respect to the center of
!! gravity of the bunch
!< *******************************************************************
SUBROUTINE disp
   USE DynacConstants
   USE m4beam
   USE m4mcs
   USE m4spacecharge
   IMPLICIT NONE
   REAL(8) bcog,gcog,bpai,gpai
   INTEGER i
!*******************************************************************
   gcog=0.D0
   do i=1,ngood
     gcog=f(7,i)/xmat+gcog
   enddo
   gcog=gcog/DBLE(ngood)
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   do i=1,ngood
     gpai=f(7,i)/xmat
     if(gpai.ge.1.D0) then
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     else
       bpai=0.D0
     endif
     fd(i)=bpai/bcog * gpai/gcog
   enddo
END SUBROUTINE disp
!> *******************************************************************
!! SUBROUTINE matdet4(mat,det)
!! Calculate the det of a 4x4 matrix
!< *******************************************************************
SUBROUTINE matdet4(mat,det)
   IMPLICIT NONE
!   real(8), intent(in) :: mat(4,4)
!   real(8), intent(out) :: det
   real(8) mat(4,4), det
   ! submatrices for determinant calculation
   real(8) :: submat1(3,3), submat2(3,3), submat3(3,3), submat4(3,3)
   ! submatrix determinants
   real(8):: det1, det2, det3, det4

   !To compute the 4x4 determinant, first do the four 3x3 ones

   !Build submat1 and get its determinant
   submat1(1,1) = mat(2,2)
   submat1(1,2) = mat(2,3)
   submat1(1,3) = mat(2,4)
   submat1(2,1) = mat(3,2)
   submat1(2,2) = mat(3,3)
   submat1(2,3) = mat(3,4)
   submat1(3,1) = mat(4,2)
   submat1(3,2) = mat(4,3)
   submat1(3,3) = mat(4,4)
   call matdet3(submat1, det1)
 
   !Build submat2 and get its determinant
   submat2(1,1) = mat(2,1)
   submat2(1,2) = mat(2,3)
   submat2(1,3) = mat(2,4)
   submat2(2,1) = mat(3,1)
   submat2(2,2) = mat(3,3)
   submat2(2,3) = mat(3,4)
   submat2(3,1) = mat(4,1)
   submat2(3,2) = mat(4,3)
   submat2(3,3) = mat(4,4)
   call matdet3(submat2, det2)

   !Build submat3 and get its determinant
   submat3(1,1) = mat(2,1)
   submat3(1,2) = mat(2,2)
   submat3(1,3) = mat(2,4)
   submat3(2,1) = mat(3,1)
   submat3(2,2) = mat(3,2)
   submat3(2,3) = mat(3,4)
   submat3(3,1) = mat(4,1)
   submat3(3,2) = mat(4,2)
   submat3(3,3) = mat(4,4)
   call matdet3(submat3, det3)

   !Build submat4 and get its determinant
   submat4(1,1) = mat(2,1)
   submat4(1,2) = mat(2,2)
   submat4(1,3) = mat(2,3)
   submat4(2,1) = mat(3,1)
   submat4(2,2) = mat(3,2)
   submat4(2,3) = mat(3,3)
   submat4(3,1) = mat(4,1)
   submat4(3,2) = mat(4,2)
   submat4(3,3) = mat(4,3)
   call matdet3(submat4, det4)

   !Calcute the determinant of the 4x4 matrix
   det = mat(1,1)*det1 - mat(1,2)*det2 + mat(1,3)*det3 - mat(1,4)*det4
   !write(6,*) 'The matrix determinant is', det	
END SUBROUTINE matdet4
!> *******************************************************************
!! SUBROUTINE matdet3(S,det)
!! Calculate the det of a 3x3 matrix
!< *******************************************************************
SUBROUTINE matdet3(S,sdet)
   implicit none
!   real(8), intent(in) :: S(3,3)
!   real(8), intent(out) :: sdet
   real(8) S(3,3), sdet
   sdet = S(1,1)*S(2,2)*S(3,3) + S(1,2)*S(2,3)*S(3,1) &
        + S(1,3)*S(2,1)*S(3,2) - S(1,1)*S(2,3)*S(3,2) &
        - S(1,2)*S(2,1)*S(3,3) - S(1,3)*S(2,2)*S(3,1)
END SUBROUTINE matdet3
!> *******************************************************************
!! SUBROUTINE cdg(IDCH)
!! Calculate the c.o.g. of the bunch
!!      IDCH EQ 1: WITH  CHASE
!!      IDCH NE 1: OTHERWISE
!!      cog(1) : Energy(MeV)
!!      cog(3) : t.o.f. (sec)
!!      cog(4) : x-direction (cm)
!!      cog(5) : xp(mrd)
!!      cog(6) : y-direction (cm)
!!      cog(7) : yp(mrd)
!< *******************************************************************
SUBROUTINE cdg(IDCH)
   USE m4cavs, ONLY: FH
   USE DynacConstants
   USE m4beam
   USE m4chase, ONLY: chexmin,chexmax,ichas
   IMPLICIT NONE
   INTEGER i,imaxf,IDCH
!*******************************************************************
   cog(1)=0.D0
   cog(3)=0.D0
   cog(4)=0.D0
   cog(5)=0.D0
   cog(6)=0.D0
   cog(7)=0.D0
   imaxf=0       
   IF(IDCH.EQ.1) THEN
     chexmin(1)=f(2,1)
     chexmax(1)=f(2,1)
     chexmin(2)=f(4,1)
     chexmax(2)=f(4,1)
     chexmin(3)=f(6,1)
     chexmax(3)=f(6,1)
     chexmin(4)=f(7,1)
     chexmax(4)=f(7,1)
     DO i=1,ngood
       IF(ICHAS(I).EQ.1) THEN
         if(f(2,i).lt.chexmin(1)) chexmin(1)=f(2,i)
         if(f(4,i).lt.chexmin(2)) chexmin(2)=f(4,i)
         if(f(6,i).lt.chexmin(3)) chexmin(3)=f(6,i)
         if(f(7,i).lt.chexmin(4)) chexmin(4)=f(7,i)
         if(f(2,i).gt.chexmax(1)) chexmax(1)=f(2,i)
         if(f(4,i).gt.chexmax(2)) chexmax(2)=f(4,i)
         if(f(6,i).gt.chexmax(3)) chexmax(3)=f(6,i)
         if(f(7,i).gt.chexmax(4)) chexmax(4)=f(7,i)
         cog(1)=cog(1)+f(7,i)
         cog(3)=cog(3)+f(6,i)
         cog(4)=cog(4)+f(2,i)
         cog(5)=cog(5)+f(3,i)
         cog(6)=cog(6)+f(4,i)
         cog(7)=cog(7)+f(5,i)
         imaxf=imaxf+1
       ENDIF
     ENDDO
   ELSE
     DO i=1,ngood
       cog(1)=cog(1)+f(7,i)
       cog(3)=cog(3)+f(6,i)
       cog(4)=cog(4)+f(2,i)
       cog(5)=cog(5)+f(3,i)
       cog(6)=cog(6)+f(4,i)
       cog(7)=cog(7)+f(5,i)
       imaxf=imaxf+1
     ENDDO
   ENDIF
   cog(1)=cog(1)/DBLE(imaxf)
   cog(3)=cog(3)/DBLE(imaxf)
   cog(4)=cog(4)/DBLE(imaxf)
   cog(5)=cog(5)/DBLE(imaxf)
   cog(6)=cog(6)/DBLE(imaxf)
   cog(7)=cog(7)/DBLE(imaxf)
   IF(ICHAS(I).EQ.1) THEN
     chexmin(1)=chexmin(1)-cog(4)
     chexmin(2)=chexmin(2)-cog(6)
     chexmin(3)=chexmin(3)-cog(3)
     chexmin(5)=chexmin(3)*fh*180.D0/pi
     chexmin(4)=chexmin(4)-cog(1)
     chexmax(1)=chexmax(1)-cog(4)
     chexmax(2)=chexmax(2)-cog(6)
     chexmax(3)=chexmax(3)-cog(3)
     chexmax(5)=chexmax(3)*fh*180.D0/pi
     chexmax(4)=chexmax(4)-cog(1)
   ENDIF
END SUBROUTINE cdg
!> *******************************************************************
!! SUBROUTINE ext2(IDCH)
!! Looks for average extensions squared and return them in array exten
!! Used in the routines: stapl  tiltbm  ytzp
!!
!!      IDCH EQ 1: WITH  CHASE TEST
!!      IDCH NE 1: OTHERWISE
!!
!!        cog(1) : Energy(MeV)
!!        cog(3) : t.o.f. (sec)
!!        cog(4) : x-direction (cm)
!!        cog(5) : xp(mrd)
!!        cog(6) : y-direction (cm)
!!        cog(7) : yp(mrd)
!!
!!      exten(1) : Sum( (dp/p)*(dp/p) ) compared to p of COG
!!      exten(2) : Sum( (dp/p)*phase )  rad
!!      exten(3) : Sum( phase*phase) )  rad*rad
!!      exten(4) : Sum( x(i)*x(i) )     cm*cm
!!      exten(5) : Sum( xp(i)*xp(i) )   mrad*mrad
!!      exten(6) : Sum( y(i)*y(i) )     cm*cm
!!      exten(7) : Sum( yp(i)*yp(i) )   mrad*mrad
!!      exten(8) : Sum( x(i)*xp(i) )    cm*mrad
!!      exten(9) : Sum( y(i)*yp(i) )    cm*mrad
!!      exten(10): Sum( dE*dE )         MeV*MeV
!!      exten(11): Sum( dE*phase )      MeV*rad
!!      exten(12): Sum( (dp/p)*x(i) )   cm, with p of REF
!!      exten(13): Sum( (dp/p)*y(i) )   cm, with p of REF
!!      exten(14): Sum( (dp/p)*(dp/p) ) compared to p of REF
!!      exten(15): Sum( (dp/p)*x(i) )   cm, with p of COG
!!      exten(16): Sum( (dp/p)*y(i) )   cm, with p of COG
!!      exten(17): Sum( (dp/p)*(dp/p) ) compared to p of COG
!!      exten(18): Sum( dE*dE*dE*dE )                 MeV*MeV*MeV*MeV
!!      exten(19): Sum( dPHase*dPHase*dPHase*dPHase ) rad*rad*rad*rad
!!      exten(20): Sum( dPHase*dPHase*dE*dE )         rad*rad*MeV*MeV
!!      exten(21): Sum( dPHase*dE*dE*dE )             rad*MeV*MeV*MeV
!!      exten(22): Sum( dPHase*dPHase*dPHase*dE )     rad*rad*rad*MeV
!!      exten(23): Sum( x*x*x*x )       cm*cm*cm*cm
!!      exten(24): Sum( xp*xp*xp*xp )   mrad*mrad*mrad*mrad
!!      exten(25): Sum( x*x*xp*xp )     cm*cm*mrad*mrad
!!      exten(26): Sum( x*xp*xp*xp )    cm*mrad*mrad*mrad
!!      exten(27): Sum( x*x*x*xp )      cm*cm*cm*mrad
!!      exten(28): Sum( y*y*y*y )       cm*cm*cm*cm
!!      exten(29): Sum( yp*yp*yp*yp )   mrad*mrad*mrad*mrad
!!      exten(30): Sum( y*y*yp*yp )     cm*cm*mrad*mrad
!!      exten(31): Sum( y*yp*yp*yp )    cm*mrad*mrad*mrad
!!      exten(32): Sum( y*y*y*yp )      cm*cm*cm*mrad
!!      exten(33): Sum( x*yp  )         cm*mrad
!!      exten(34): Sum( xp*y  )         mrad*cm
!!      exten(35): Sum( x*y )           cm*cm
!!      exten(36): Sum( xp*yp )         mrad*mrad
!< *******************************************************************
SUBROUTINE ext2(IDCH)
   USE m4cavs, ONLY: FH
   USE DynacConstants
   USE m4beam
   USE m4chase, ONLY: ichas
   USE m4plots 
   IMPLICIT NONE
   INTEGER i,imaxf,IDCH
   REAL(8) bcog,bref,bpai,gcog,gpai,gref,fdp,dener
   REAL(8) FDDP,TRPF,TRPH1,TRTF,TRXF,TRYF
   REAL(8) hxrt,hyrt,hzrt, det, mat(4,4)
   REAL(8), allocatable ::  fdd(:)   
!*******************************************************************
   if (.not. allocated(fdd)) allocate(fdd(iptsz))   
! EXT2 looks for average extensions squared and returns them in exten(14)
   do i=1,36
     exten(i)=0.D0
   enddo
   qmoy=0.D0
   imaxf=0
   gcog=cog(1)/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   if(acpt) then
     bref=vrefi/vl
   else
     bref=vref/vl
   endif
   gref=1.D0/sqrt(1.D0-bref*bref)
   do i=1,ngood
     gpai=f(7,i)/xmat
     if(gpai.gt.1.D0) then
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     else
       bpai=0.D0
       gpai=1.D0
     endif
     fd(i)=(gpai*bpai)/(gcog*bcog)
     fdd(i)=(gpai*bpai)/(gref*bref)
   enddo
   do i=1,ngood
     fdp=fd(i)-1.D0
     FDDP=fdd(i)-1.D0
     dener=f(7,i)-cog(1)
     TRPH1=FH*(f(6,i)-cog(3))
     TRXF=F(2,I)-COG(4)
     TRTF=F(3,I)-cog(5)
     TRYF=F(4,I)-COG(6)
     TRPF=F(5,I)-cog(7)
     IF(IDCH.EQ.1.AND.ICHAS(I).EQ.1) THEN
       exten(1)=exten(1)+FDP**2
       exten(2)=exten(2)+TRPH1*FDP
       exten(3)=exten(3)+TRPH1**2
       EXTEN(4)=EXTEN(4)+TRXF**2
       exten(5)=exten(5)+TRTF**2
       EXTEN(6)=EXTEN(6)+TRYF**2
       exten(7)=exten(7)+TRPF**2
       EXTEN(8)=EXTEN(8)+TRXF*TRTF
       EXTEN(9)=EXTEN(9)+TRYF*TRPF
       exten(10)=exten(10)+dener*dener
       exten(11)=exten(11)+dener*trph1
       exten(12)=exten(12)+FDDP*TRXF
       exten(13)=exten(13)+FDDP*TRYF
       exten(14)=exten(14)+FDDP**2
       exten(15)=exten(15)+FDP*TRXF
       exten(16)=exten(16)+FDP*TRYF
       exten(17)=exten(17)+FDP**2
!
       EXTEN(18)=EXTEN(18)+TRPH1**4
       exten(19)=exten(19)+dener**4
       EXTEN(20)=EXTEN(20)+(TRPH1**2)*(dener**2)
       EXTEN(21)=EXTEN(21)+TRPH1*dener**3
       EXTEN(22)=EXTEN(22)+dener*TRPH1**3
!
       EXTEN(23)=EXTEN(23)+TRXF**4
       exten(24)=exten(24)+TRTF**4
       EXTEN(25)=EXTEN(25)+(TRXF**2)*(TRTF**2)
       EXTEN(26)=EXTEN(26)+TRXF*TRTF**3
       EXTEN(27)=EXTEN(27)+TRTF*TRXF**3
!
       EXTEN(28)=EXTEN(28)+TRYF**4
       exten(29)=exten(29)+TRPF**4
       EXTEN(30)=EXTEN(30)+(TRYF**2)*(TRPF**2)
       EXTEN(31)=EXTEN(31)+TRYF*TRPF**3
       EXTEN(32)=EXTEN(32)+TRPF*TRYF**3
!
       EXTEN(33)=EXTEN(33)+TRXF*TRPF
       EXTEN(34)=EXTEN(34)+TRTF*TRYF
       EXTEN(35)=EXTEN(35)+TRXF*TRYF
       EXTEN(36)=EXTEN(36)+TRTF*TRPF
       qmoy=qmoy+f(9,i)
       imaxf=imaxf+1
     ELSEIF(IDCH.NE.1) THEN
       exten(1)=exten(1)+FDP**2
       exten(2)=exten(2)+TRPH1*FDP
       exten(3)=exten(3)+TRPH1**2
       EXTEN(4)=EXTEN(4)+TRXF**2
       exten(5)=exten(5)+TRTF**2
       EXTEN(6)=EXTEN(6)+TRYF**2
       exten(7)=exten(7)+TRPF**2
       EXTEN(8)=EXTEN(8)+TRXF*TRTF
       EXTEN(9)=EXTEN(9)+TRYF*TRPF
       exten(10)=exten(10)+dener*dener
       exten(11)=exten(11)+dener*trph1
       exten(12)=exten(12)+FDDP*TRXF
       exten(13)=exten(13)+FDDP*TRYF
       exten(14)=exten(14)+FDDP**2
       exten(15)=exten(15)+FDP*TRXF
       exten(16)=exten(16)+FDP*TRYF
       exten(17)=exten(17)+FDP**2
!
       EXTEN(18)=EXTEN(18)+TRPH1**4
       exten(19)=exten(19)+dener**4
       EXTEN(20)=EXTEN(20)+(TRPH1**2)*(dener**2)
       EXTEN(21)=EXTEN(21)+TRPH1*dener**3
       EXTEN(22)=EXTEN(22)+dener*TRPH1**3
!
       EXTEN(23)=EXTEN(23)+TRXF**4
       exten(24)=exten(24)+TRTF**4
       EXTEN(25)=EXTEN(25)+(TRXF**2)*(TRTF**2)
       EXTEN(26)=EXTEN(26)+TRXF*TRTF**3
       EXTEN(27)=EXTEN(27)+TRTF*TRXF**3
!
       EXTEN(28)=EXTEN(28)+TRYF**4
       exten(29)=exten(29)+TRPF**4
       EXTEN(30)=EXTEN(30)+(TRYF**2)*(TRPF**2)
       EXTEN(31)=EXTEN(31)+TRYF*TRPF**3
       EXTEN(32)=EXTEN(32)+TRPF*TRYF**3
!
       EXTEN(33)=EXTEN(33)+TRXF*TRPF
       EXTEN(34)=EXTEN(34)+TRTF*TRYF
       EXTEN(35)=EXTEN(35)+TRXF*TRYF
       EXTEN(36)=EXTEN(36)+TRTF*TRPF
       qmoy=qmoy+f(9,i)
       imaxf=imaxf+1
     ENDIF
   enddo
   do i=1,36
     exten(i)=exten(i)/DBLE(imaxf)
   enddo
   qmoy=qmoy/DBLE(imaxf)
! halo parameter as defined by Allen & Wangler: Beam halo definitions based on moments
! of the particle distribution, Physical Review ST AB, 5(124202), Dec.2002   
   hxrt=3.D0*exten(23)*exten(24)+9.D0*exten(25)*exten(25)-12.D0*exten(26)*exten(27)
   halox=-2.D0+sqrt(hxrt)/(2.D0*EXTEN(4)*EXTEN(5)-2.D0*EXTEN(8)*EXTEN(8))
   hyrt=3.D0*exten(28)*exten(29)+9.D0*exten(30)*exten(30)-12.D0*exten(31)*exten(32)
   haloy=-2.D0+sqrt(hyrt)/(2.D0*EXTEN(6)*EXTEN(7)-2.D0*EXTEN(9)*EXTEN(9))
   hzrt=3.D0*exten(18)*exten(19)+9.D0*exten(20)*exten(20)-12.D0*exten(21)*exten(22)
   haloz=-2.D0+sqrt(hzrt)/(2.D0*EXTEN(10)*EXTEN(3)-2.D0*EXTEN(11)*EXTEN(11))
! prep for calculation of 4d emittance; convert cm to mm   
   mat(1,1)=exten(4)
   mat(1,2)=exten(8)
   mat(1,3)=exten(35)
   mat(1,4)=exten(33)

   mat(2,1)=exten(8)
   mat(2,2)=exten(5)
   mat(2,3)=exten(34)
   mat(2,4)=exten(36)

   mat(3,1)=exten(35)
   mat(3,2)=exten(34)
   mat(3,3)=exten(6)
   mat(3,4)=exten(9)

   mat(4,1)=exten(33)
   mat(4,2)=exten(36)
   mat(4,3)=exten(9)
   mat(4,4)=exten(7)
   call matdet4(mat,det)   
   if(det.gt.0.D0) then
     emit4d=100.D0*bcog*bcog*gcog*gcog*sqrt(det)
   else
     emit4d=0.D0
   endif
!   write(53,*) "DBX EXT2  ",emit4d
   deallocate(fdd)   
END SUBROUTINE ext2
!> *******************************************************************
!! SUBROUTINE ext2d(IDCH)
!! Look for average extensions squared and return them in array exten
!! Used in the routines: EMIPRT ETGAP RESTAY STATIS
!!
!!      IDCH EQ 1: WITH  CHASE TEST
!!      IDCH NE 1: OTHERWISE
!!
!!        cog(1) : Energy(MeV)
!!        cog(3) : t.o.f. (sec)
!!        cog(4) : x-direction (cm)
!!        cog(5) : xp(mrd)
!!        cog(6) : y-direction (cm)
!!        cog(7) : yp(mrd)
!!
!!      exten(1) : Sum( dE*dE )         MeV*MeV
!!      exten(2) : Sum( dE*dPHase )     MeV*rad
!!      exten(3) : Sum( dPHase*dPHase ) rad*rad
!!      exten(4) : Sum( x*x )           cm*cm
!!      exten(5) : Sum( xp*xp )         mrad*mrad
!!      exten(6) : Sum( y*y )           cm*cm
!!      exten(7) : Sum( yp*yp )         mrad*mrad
!!      exten(8) : Sum( x*xp )          cm*mrad
!!      exten(9) : Sum( y*yp )          cm*mrad
!!      exten(10): Sum( x*y  )          cm*cm
!!      exten(11): Sum( xp*yp  )        mrad*mrad
!!      exten(12): Sum( (dp/p)*x(i) )   (cm), with p of REF
!!      exten(13): Sum( (dp/p)*y(i) )   (cm), with p of REF
!!      exten(14): Sum( (dp/p)*(dp/p) ) compared to p of REF
!!      exten(15): Sum( (dp/p)*x(i) )   (cm), with p of COG
!!      exten(16): Sum( (dp/p)*y(i) )   (cm), with p of COG
!!      exten(17): Sum( (dp/p)*(dp/p) ) compared to p of COG
!!      exten(18): Sum( dE*dE*dE*dE )                 MeV*MeV*MeV*MeV
!!      exten(19): Sum( dPHase*dPHase*dPHase*dPHase ) rad*rad*rad*rad
!!      exten(20): Sum( dPHase*dPHase*dE*dE )         rad*rad*MeV*MeV
!!      exten(21): Sum( dPHase*dE*dE*dE )             rad*MeV*MeV*MeV
!!      exten(22): Sum( dPHase*dPHase*dPHase*dE )     rad*rad*rad*MeV
!!      exten(23): Sum( x*x*x*x )       cm*cm*cm*cm
!!      exten(24): Sum( xp*xp*xp*xp )   mrad*mrad*mrad*mrad
!!      exten(25): Sum( x*x*xp*xp )     cm*cm*mrad*mrad
!!      exten(26): Sum( x*xp*xp*xp )    cm*mrad*mrad*mrad
!!      exten(27): Sum( x*x*x*xp )      cm*cm*cm*mrad
!!      exten(28): Sum( y*y*y*y )       cm*cm*cm*cm
!!      exten(29): Sum( yp*yp*yp*yp )   mrad*mrad*mrad*mrad
!!      exten(30): Sum( y*y*yp*yp )     cm*cm*mrad*mrad
!!      exten(31): Sum( y*yp*yp*yp )    cm*mrad*mrad*mrad
!!      exten(32): Sum( y*y*y*yp )      cm*cm*cm*mrad
!!      exten(33): Sum( x*yp  )         cm*mrad
!!      exten(34): Sum( xp*y  )         mrad*cm
!< *******************************************************************
SUBROUTINE ext2d(IDCH)
   USE m4cavs, ONLY: FH
   USE DynacConstants
   USE m4beam
   USE m4chase, ONLY: ichas
   USE m4plots 
   IMPLICIT NONE
   INTEGER i,imaxf,IDCH
   REAL(8) bcog,bref,bpai,gcog,gpai,gref,fdp
   REAL(8) FDPP,FFDPP,TRPF,TRPH1,TRTF,TRXF,TRYF
   REAL(8) hxrt,hyrt,hzrt, det, mat(4,4)
   REAL(8), allocatable ::  ffd(:)   
!*******************************************************************
   if (.not. allocated(ffd)) allocate(ffd(iptsz))   
   do i=1,36
     exten(i)=0.D0
   enddo
   qmoy=0.D0
! --- imaxf: particles keep in the bunch. With CHASE imaxf may be different from ngood(i.e. imaxf < ngood)
   imaxf=0
   gcog=cog(1)/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   if(acpt) then
     bref=vrefi/vl
   else
     bref=vref/vl
   endif
   gref=1.D0/sqrt(1.D0-bref*bref)
   do i=1,ngood
     gpai=f(7,i)/xmat
     if(gpai.gt.1.D0) then
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     else
       bpai=0.D0
       gpai=1.D0
     endif
     fd(i)=(gpai*bpai)/(gref*bref)
     ffd(i)=(gpai*bpai)/(gcog*bcog)
   enddo
   do i=1,ngood
     FDPP=fd(i)-1.D0
     FFDPP=ffd(i)-1.D0
     fdp=f(7,i)-cog(1)
     TRPH1=FH*(f(6,i)-cog(3))
     TRXF=F(2,I)-COG(4)
     TRTF=F(3,I)-cog(5)
     TRYF=F(4,I)-COG(6)
     TRPF=F(5,I)-cog(7)
! --- without CHASE
     IF(IDCH.NE.1) THEN
       exten(1)=exten(1)+FDP**2
       exten(2)=exten(2)+TRPH1*FDP
       exten(3)=exten(3)+TRPH1**2
       EXTEN(4)=EXTEN(4)+TRXF**2
       exten(5)=exten(5)+TRTF**2
       EXTEN(6)=EXTEN(6)+TRYF**2
       exten(7)=exten(7)+TRPF**2
       EXTEN(8)=EXTEN(8)+TRXF*TRTF
       EXTEN(9)=EXTEN(9)+TRYF*TRPF
       EXTEN(10)=EXTEN(10)+TRXF*TRYF
       EXTEN(11)=EXTEN(11)+TRTF*TRPF
!	   
       exten(12)=exten(12)+FDPP*TRXF
       exten(13)=exten(13)+FDPP*TRYF
       exten(14)=exten(14)+FDPP**2
       exten(15)=exten(15)+FFDPP*TRXF
       exten(16)=exten(16)+FFDPP*TRYF
       exten(17)=exten(17)+FFDPP**2
!
       EXTEN(18)=EXTEN(18)+TRPH1**4
       exten(19)=exten(19)+FDP**4
       EXTEN(20)=EXTEN(20)+(TRPH1**2)*(FDP**2)
       EXTEN(21)=EXTEN(21)+TRPH1*FDP**3
       EXTEN(22)=EXTEN(22)+FDP*TRPH1**3
!
       EXTEN(23)=EXTEN(23)+TRXF**4
       exten(24)=exten(24)+TRTF**4
       EXTEN(25)=EXTEN(25)+(TRXF**2)*(TRTF**2)
       EXTEN(26)=EXTEN(26)+TRXF*TRTF**3
       EXTEN(27)=EXTEN(27)+TRTF*TRXF**3
!
       EXTEN(28)=EXTEN(28)+TRYF**4
       exten(29)=exten(29)+TRPF**4
       EXTEN(30)=EXTEN(30)+(TRYF**2)*(TRPF**2)
       EXTEN(31)=EXTEN(31)+TRYF*TRPF**3
       EXTEN(32)=EXTEN(32)+TRPF*TRYF**3
!
       EXTEN(33)=EXTEN(33)+TRXF*TRPF
       EXTEN(34)=EXTEN(34)+TRTF*TRYF
       qmoy=qmoy+f(9,i)
       imaxf=imaxf+1
     ELSEIF(IDCH.EQ.1.AND.ICHAS(I).EQ.1) THEN
! --- with CHASE
       exten(1)=exten(1)+FDP**2
       exten(2)=exten(2)+TRPH1*FDP
       exten(3)=exten(3)+TRPH1**2
       EXTEN(4)=EXTEN(4)+TRXF**2
       exten(5)=exten(5)+TRTF**2
       EXTEN(6)=EXTEN(6)+TRYF**2
       exten(7)=exten(7)+TRPF**2
       EXTEN(8)=EXTEN(8)+TRXF*TRTF
       EXTEN(9)=EXTEN(9)+TRYF*TRPF
       EXTEN(10)=EXTEN(10)+TRXF*TRYF
       EXTEN(11)=EXTEN(11)+TRTF*TRPF
!	   
       exten(12)=exten(12)+FDPP*TRXF
       exten(13)=exten(13)+FDPP*TRYF
       exten(14)=exten(14)+FDPP**2
       exten(15)=exten(15)+FFDPP*TRXF
       exten(16)=exten(16)+FFDPP*TRYF
       exten(17)=exten(17)+FFDPP**2
!
       EXTEN(18)=EXTEN(18)+TRPH1**4
       exten(19)=exten(19)+FDP**4
       EXTEN(20)=EXTEN(20)+(TRPH1**2)*(FDP**2)
       EXTEN(21)=EXTEN(21)+TRPH1*FDP**3
       EXTEN(22)=EXTEN(22)+FDP*TRPH1**3
!
       EXTEN(23)=EXTEN(23)+TRXF**4
       exten(24)=exten(24)+TRTF**4
       EXTEN(25)=EXTEN(25)+(TRXF**2)*(TRTF**2)
       EXTEN(26)=EXTEN(26)+TRXF*TRTF**3
       EXTEN(27)=EXTEN(27)+TRTF*TRXF**3
!
       EXTEN(28)=EXTEN(28)+TRYF**4
       exten(29)=exten(29)+TRPF**4
       EXTEN(30)=EXTEN(30)+(TRYF**2)*(TRPF**2)
       EXTEN(31)=EXTEN(31)+TRYF*TRPF**3
       EXTEN(32)=EXTEN(32)+TRPF*TRYF**3
!
       EXTEN(33)=EXTEN(33)+TRXF*TRPF
       EXTEN(34)=EXTEN(34)+TRTF*TRYF
       qmoy=qmoy+f(9,i)
       imaxf=imaxf+1
     ENDIF
   enddo
   do i=1,34
     exten(i)=exten(i)/DBLE(imaxf)
   enddo
! halo parameter as defined by Allen & Wangler: Beam halo definitions based on moments
! of the particle distribution, Physical Review ST AB, 5(124202), Dec.2002   
   hxrt=3.D0*exten(23)*exten(24)+9.D0*exten(25)*exten(25)-12.D0*exten(26)*exten(27)
   halox=-2.D0+sqrt(hxrt)/(2.D0*EXTEN(4)*EXTEN(5)-2.D0*EXTEN(8)*EXTEN(8))
   hyrt=3.D0*exten(28)*exten(29)+9.D0*exten(30)*exten(30)-12.D0*exten(31)*exten(32)
   haloy=-2.D0+sqrt(hyrt)/(2.D0*EXTEN(6)*EXTEN(7)-2.D0*EXTEN(9)*EXTEN(9))
   hzrt=3.D0*exten(18)*exten(19)+9.D0*exten(20)*exten(20)-12.D0*exten(21)*exten(22)
   haloz=-2.D0+sqrt(hzrt)/(2.D0*EXTEN(1)*EXTEN(3)-2.D0*EXTEN(2)*EXTEN(2))
! prep for calculation of 4d emittance; convert cm to mm   
   mat(1,1)=exten(4)
   mat(1,2)=exten(8)
   mat(1,3)=exten(10)
   mat(1,4)=exten(33)

   mat(2,1)=exten(8)
   mat(2,2)=exten(5)
   mat(2,3)=exten(34)
   mat(2,4)=exten(11)

   mat(3,1)=exten(10)
   mat(3,2)=exten(34)
   mat(3,3)=exten(6)
   mat(3,4)=exten(9)

   mat(4,1)=exten(33)
   mat(4,2)=exten(11)
   mat(4,3)=exten(9)
   mat(4,4)=exten(7)
   call matdet4(mat,det)   
   if(det.gt.0.D0) then
     emit4d=100.D0*bcog*bcog*gcog*gcog*sqrt(det)
   else
     emit4d=0.D0
   endif
!   write(53,*) "DBX EXT2D ",emit4d
   qmoy=qmoy/DBLE(imaxf)
   deallocate(ffd)      
END SUBROUTINE ext2d
!> *******************************************************************
!! SUBROUTINE statis
!! statitics of the 6-d ellipsoid (for print)
!! calls EXT2D:
!!  exten(1) : Sum( dE(i)*dE(i) )  MeV*MeV
!!  exten(2) : Sum( dE(i)*dPHase(i) ) MeV*rad
!!  exten(3) : Sum( dPHase(i)*dPHase(i) ) rad*rad
!!  exten(4) : Sum( x(i)*x(i) )   cm*cm
!!  exten(5) : Sum( xp(i)*xp(i) )   mrad*mrad
!!  exten(6) : Sum( y(i)*y(i) )   cm*cm
!!  exten(7) : Sum( yp(i)*yp(i) )  mrad*mrad
!!  exten(8) : Sum( x(i)*xp(i) )   cm*mrad
!!  exten(9) : Sum( y(i)*yp(i) )   cm*mrad
!< *******************************************************************
SUBROUTINE statis
   USE DynacConstants
   USE m4beam
   USE m4cavs
   USE m4STIS
   IMPLICIT NONE
   REAL(8) bcog,gcog,tcog,encog,BREF,GREF,ENREF,CCGP,CCGD,bpai,gpai
   REAL(8) COR12,PENT12,PENT21,QDIANP,QDIANT,QDISP,QDITAX,QDITAY,QDP,QDPDE,QMD
   REAL(8) SQMDV,SURM,TRQPY,TRQTX
   INTEGER I,iarg
!*******************************************************************
! EXT2D looks for average extensions squared and returns them in EXTEN
   iarg=1
   call cdg(iarg)
   encog=cog(1)
   gcog=encog/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   BREF=VREF/VL
   GREF=1.D0/SQRT(1.D0-BREF*BREF)
   ENREF=XMAT*GREF
   CCGP=(tcog-tref)*fh*180.D0/pi
   CCGD=ENCOG-ENREF
   DO I=1,ngood
     gpai=f(7,i)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     fd(i)=bpai/bcog * gpai/gcog
   enddo
   CALL EXT2D(1)
   TESTCA=exten(1)*exten(2)*exten(3)
   IF(abs(TESTCA).gt.1.D-40) THEN
     QDISP=2.D0*SQRT(exten(1))
     QMD=exten(1)*exten(3)-exten(2)*exten(2)
     SURM=4.D0*PI*SQRT(QMD)*180.D0/PI
     QDP=2.D0*SQRT(exten(3))
     COR12=exten(2)/sqrt(exten(1)*exten(3))
!  sup         PENT12=SQRT(exten(1)/exten(3))/COR12
!  sup         PENT21=SQRT(exten(1)/exten(3))*COR12
     QDPDE=QDP*180.D0/PI
   ELSE
     QDISP=0.D0
     QMD=0.D0
     SURM=0.D0
     QDP=0.D0
     COR12=0.D0
     PENT12=0.D0
     PENT21=0.D0
     QDPDE=0.D0
   ENDIF
   TRQTX=EXTEN(4)*EXTEN(5)-EXTEN(8)*EXTEN(8)
   TRQPY=EXTEN(6)*EXTEN(7)-EXTEN(9)*EXTEN(9)
   QDITAX=2.D0*SQRT(EXTEN(4))
   QDIANT=2.D0*SQRT(exten(5))
   QDITAY=2.D0*SQRT(EXTEN(6))
   QDIANP=2.D0*SQRT(exten(7))
   SURYTH=4.D0*PI*SQRT(TRQTX)
   SURZPH=4.D0*PI*SQRT(TRQPY)
   SQMDV=4.D0*PI*SQRT(QMD)
   WRITE(16,'(4X,A,I8,A,I8,/)')' TOTAL NUMBER OF PARTICLES :',IMAX, &
            '   NUMBER OF PARTICLES CONSIDERED :',ngood
   WRITE(16,'(5X,A)') ' *** TRANSVERSE AND LONGITUDINAL STATISTICS'
   WRITE(16,'(4X,A,E12.5,A,E12.5,A)') ' COG COORD   X : ',cog(4), &
            ' CM  XP :',cog(5),' MRD'
   WRITE(16,'(4X,A,E12.5,A,E12.5,A)') ' COG COORD   Y : ',cog(6), &
            ' CM  YP :',cog(7),' MRD'
   WRITE(16,'(4X,A,E12.5,A,E12.5,A)') ' COG COORD dPHI: ',CCGP, &
            ' deg dW :',CCGD,' MeV'
   WRITE(16,'(4X,A,E12.5,A,E12.5,A,E15.8,A)') ' X :',QDITAX,' CM  XP :', &
            QDIANT,' MRD  EMITTANCE :',SURYTH/pi,' CM.MRD'
   WRITE(16,'(4X,A,E12.5,A,E12.5,A,E15.8,A)') ' Y :',QDITAY,' CM  YP :', &
            QDIANP,' MRD  EMITTANCE :',SURZPH/pi,' CM.MRD'
   WRITE(16,'(4X,A,F7.3,A,3X,F7.3,3X,A,E15.8,A,/)') ' dPHI :  ',QDPDE,' deg dW :', &
            qdisp,'MeV  EMITTANCE :',SQMDV*180.D0/(pi*pi),' MeV.deg'
! sup       write(16,*) ' *** ellipse (dE,dPHI) '
! sup       write(16,19) surm,qdp,qdisp,cor12
! sup19     format(' area: ',e12.5,' MeV*deg  half phase extent: ',e12.5,
! sup     *        ' deg half energy extend: ',e12.5,' MeV',/,
! sup     *        ' correlation coef: ',e12.5)
! sup     *
END SUBROUTINE statis
!> *******************************************************************
!! SUBROUTINE emit3d
!! get beam data following RDBEAM for TRACE3D file
!< *******************************************************************
SUBROUTINE emit3d
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4input
   IMPLICIT NONE
   REAL(8) alphax,alphay,alphaz,betax,betay,betaz,cor12,emitx,emity,emitz
   REAL(8) gamx,gamy,gamz,qdianp,qdiant,qdisp,qditax,qditay,qdp,qmdv,sgn,sqmdv
   REAL(8) surxth,suryph,trqpy,trqtx
   INTEGER iarg
!*******************************************************************    
   iarg=1
   call cdg(iarg)
   CALL EXT2D(1)
! --- qdisp : average dispersion (MeV)
! --- sqmdv:  emittance (MeV*rad)
   qdisp=2.D0*sqrt(exten(1))
   qmdv=exten(1)*exten(3)-exten(2)*exten(2)
   sqmdv=4.D0*pi*sqrt(qmdv)
! --- qdp : average extension in phase (rad)
   qdp=2.D0*sqrt(exten(3))
! --- cor12: coefficient of correlation in (dE, dPHI)
   cor12=exten(2)/sqrt(exten(1)*exten(3))
! ---- statistics in x-xp and y-yp
   trqtx=exten(4)*exten(5)-exten(8)*exten(8)
   trqpy=exten(6)*exten(7)-exten(9)*exten(9)
   surxth=4.D0*pi*sqrt(trqtx)
   suryph=4.D0*pi*sqrt(trqpy)
   qditax=2.D0*sqrt(exten(4))
   qdiant=2.D0*sqrt(exten(5))
   qditay=2.D0*sqrt(exten(6))
   qdianp=2.D0*sqrt(exten(7))
! trace3d
! x-xp (mm*mrad)
   emitx=surxth*10.D0/pi
   sgn=1.D0
!   if (exten(4).ne.0. .and. exten(5).ne.0.)
   if (exten(4)*exten(5).gt.fprec) &
     sgn=exten(8)/sqrt(exten(4)*exten(5))
   betax=qditax*10.D0*qditax*10.D0/emitx
   gamx=qdiant*qdiant/emitx
   alphax=sqrt(betax*gamx-1.D0)
   if(sgn.gt.0.D0) alphax=-alphax
! y-yp (mm*mrad)
   emity=suryph*10.D0/pi
   sgn=1.D0
!   if (exten(6).ne.0. .and. exten(7).ne.0.)
   if (exten(6)*exten(7).gt.fprec) &
     sgn=exten(9)/sqrt(exten(6)*exten(7))
   betay=qditay*10.D0*qditay*10.D0/emity
   gamy=qdianp*qdianp/emity
   alphay=sqrt(betay*gamy-1.D0)
   if(sgn.gt. 0.D0) alphay=-alphay
! z-zp (keV*deg)
   emitz=sqmdv/pi*1000.D0*(180.D0/pi)
   betaz=qdp*180.D0/pi*qdp*180.D0/pi/emitz
   gamz=qdisp*1000.D0*qdisp*1000.D0/emitz
   alphaz=sqrt(betaz*gamz-1.D0)
   if(cor12.gt.0.D0) alphaz=-alphaz
! store parameters for trace3d
   tracebi(1)=alphax
   tracebi(2)=betax
   tracebi(3)=alphay
   tracebi(4)=betay
   tracebi(5)=alphaz
   tracebi(6)=betaz
   traceei(1)=emitx
   traceei(2)=emity
   traceei(3)=emitz
END SUBROUTINE emit3d
!> *******************************************************************
!! SUBROUTINE reject(ilost,PRTLAB)
!! reject particles outside window set by REJECT card
!!      ifw = 0  ===> wdisp = dW/W relative to cog
!!      ifw = 1  ===> wdisp = dW (MeV) relative to cog
!!      ifw = 10 ===> wdisp = dW/W relative to REF
!!      ifw = 11 ===> wdisp = dW (MeV) relative to REF
!< *******************************************************************
SUBROUTINE reject(ilost,PRTLAB)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output, ONLY: davtot
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4FENE
   IMPLICIT NONE
   REAL(8) FH0,fcpi,bcour,cgtv,bcg,gcour,gcg,gpai,wcg,dispr,wref,bref,f6i,gref,ray
   INTEGER ilost,i,j,k,istc,mcstat
   INTEGER, allocatable ::  lossreason(:)   
   integer cscount(20)
   character(len=8) :: PRTLAB
!*******************************************************************
   allocate(lossreason(iptsz))   
! lossreason= -2 --> energy
! lossreason= -1 --> phase
! lossreason=  0 --> not lost
! lossreason=  1 --> radius
! lossreason=  2 --> x position
! lossreason=  3 --> y position
   ilost=0
   FH0=FH/VL
   fcpi=fh*180.D0/pi
! Test window
   write(16,*)'Check if the ',ngood,' particles are within the window'
   write(16,*) 'Number of charge states: ',ncstat
   if(ifw.le.1) then
! Relative to COG
     write(16,'(A)') ' Window w.r.t. COG'
! ---- ifw = 0 ===> wdisp = dW/W
! ---- ifw = 1 ===> wdisp = dW (MeV)
     if (ncstat.gt.1) call cogetc
     bcour=0.D0
     cgtv=0.D0
     do i=1,ngood
       gpai=f(7,i)/xmat
       if(gpai.lt.1.D0) gpai=1.D0           
       bcour=sqrt(1.D0-1.D0/(gpai*gpai))+bcour
       cgtv=cgtv+f(6,i)
       lossreason(i)=0
     enddo
     cgtv=cgtv/DBLE(ngood)
     bcour=bcour/DBLE(ngood)
     bcg=bcour
     gcour=1.D0/sqrt(1.D0-bcour*bcour)
     gcg=gcour
     wcg=(gcour-1.D0)*xmat
     do i=1,ngood
       gpai=f(7,i)/xmat
       if(gpai.lt.1.D0) gpai=1.D0
       bcour=sqrt(1.D0-1.D0/(gpai*gpai))
       fd(i)=bcour/bcg * gpai/gcg
     enddo
     if(ifw.eq.0) then
       dispr=gcour*gcour*wdisp/(gcour*(gcour+1.D0))
     else
       dispr=gcour*gcour*wdisp/(gcour*(gcour+1.D0)*wcg)
     endif
   else
! Relative to REF
     write(16,'(A)') ' Window w.r.t. reference particle'
     bref=VREF/VL
     gref=1.D0/sqrt(1.D0-bref*bref)
     wref=(gref-1.D0)*xmat
     do i=1,ngood
       gpai=f(7,i)/xmat
       bcour=sqrt(1.D0-1.D0/(gpai*gpai))
       fd(i)=bcour/bref * gpai/gref
     enddo
     if(ifw.eq.10) then
       dispr=gref*gref*wdisp/(gref*(gref+1.D0))
     else
       dispr=gref*gref*wdisp/(gref*(gref+1.D0)*wref)
     endif
   endif
   write(16,'(A,3(f10.2,9x),A,e12.5,9x,e12.5)') ' LIM R,X,Y ', &
         rlim,wx,wy,'P,W ',wphas,wdisp
   f6i=0.D0
   do i=1,ngood
     ray=f(2,i)*f(2,i)+f(4,i)*f(4,i)
     ray=sqrt(ray)
     if(ray.gt.rlim) then
       f(8,i)=0.D0
       lossreason(i)=1
     endif
     if(abs(f(2,i)).gt.wx) then
       f(8,i)=0.D0
       lossreason(i)=2
     endif
     if(abs(f(4,i)).gt.wy) then
       f(8,i)=0.D0
       lossreason(i)=3
     endif
     if(ifw.le.1) then
! Relative to cog
       if (ncstat.gt.1) then
!---- each charge state has its own COG in phase
         do istc=1,ncstat
!           if(int(f(9,i)).eq.int(charm(istc)))then
!           if(f(9,i).eq.charm(istc))then
           if(abs(f(9,i)-charm(istc)).le.fprec)then
             f6i=f(6,i)-cgtdv(istc)
!         tmp=cgtdv(istc)
           endif
         enddo
       else
         f6i=f(6,i)-cgtv
       endif
     else
! Relative to REF
       f6i=f(6,i)-TREF
     endif
     if(fh*abs(f6i).ge.wphas) then
       f(8,i)=0.D0
       lossreason(i)=-1
     endif
     if(ifw.eq.0 .or. ifw.eq.10) then
! ---- ifw = 0 or 10 ===> wdisp = dW/W
       if(abs(fd(i)-1.D0).ge.dispr) then
         f(8,i)=0.D0
         lossreason(i)=-2
       endif
     elseif(ifw.eq.1) then
! Relative to COG
! ---- ifw = 1 ===> wdisp = dW (MeV)
       if(abs(f(7,i)-xmat-wcg).ge.wdisp) then
         f(8,i)=0.D0
         lossreason(i)=-2
       endif
     elseif(ifw.eq.11) then
! Relative to REF
! ---- ifw = 11 ===> wdisp = dW (MeV)
       if(abs(f(7,i)-xmat-wref).ge.wdisp) then
         f(8,i)=0.D0
         lossreason(i)=-2
       endif
     endif  
     if(int(f(8,i)).eq.0) then
        write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,A25)') &
        prtlab,NRRES,davtot/100.D0,i,int(f(1,i)), &
        f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180.D0/pi,f(7,i)-xmat, &
        f(9,i),lossreason(i),uden
       ilost=ilost+1
     endif
   enddo
!  Reshuffles f(i,j) array after window
   call shuffle
!cccc       cstat=1
   ncstat=1
   cstat(1)=f(9,1)
   do j=2,ngood
     mcstat=0
     do k=1,ncstat
!       if(int(f(9,j)).eq.int(cstat(k))) then
!       if(f(9,j).eq.cstat(k)) then
       if(abs(f(9,j)-cstat(k)).le.fprec) then
         mcstat=1
       endif
     enddo
     if(mcstat.eq.0) then
       ncstat=ncstat+1
       cstat(ncstat)=f(9,j)
     endif
   enddo
   netac=ncstat
   write(16,*) 'Number of good particles left: ',ngood
   write(16,*) 'Number of charge states left : ',ncstat
   write(16,'(1x,A,20(f9.5,1x))') 'Charge state(s):             ',(cstat(j),j=1,ncstat)
! 2024-Apr-12 in the case of a multi charge state beam, make sure that there are 10 or
! more particles left for each charge state. If less, eliminate them. 	   
   do k=1,ncstat
     cscount(k)=0
   enddo
   if(ncstat.gt.1) then
     do j=1,ngood
       do k=1,ncstat
         if(f(9,j).eq.cstat(k)) then
           cscount(k)=cscount(k)+1
         endif
       enddo
     enddo
   else
    cscount(1)=ngood
   endif
   write(16,'(1x,A,20(I9,1x))') '# of particles/charge state: ',(cscount(j),j=1,ncstat)
   do k=1,ncstat
     if(cscount(k).lt.10) then
       write(16,'(A,f9.5,A)')'As there are less then 10 particles left for charge state ', &
         cstat(k),' these will be eliminated.'
       do j=1,ngood
         if(f(9,j).eq.cstat(k)) then
           f(8,j)=0.D0
           lossreason(j)=1
         endif
       enddo
       ncstat=ncstat-1
     endif
   enddo
!  Reshuffles f(i,j) array after window
   call shuffle
   deallocate(lossreason)      
   imcs=0
   if(ncstat.gt.1) imcs=1
END SUBROUTINE reject
!> *******************************************************************
!! SUBROUTINE cogetc
!! COG of TOF with respect to the various charge states
!< *******************************************************************
SUBROUTINE cogetc
   USE DynacConstants, ONLY: fprec
   USE m4beam, ONLY: f,ngood 
   USE m4mcs,  ONLY: charm,cgtdv,nbch,netac
   IMPLICIT NONE
   INTEGER i,j,itot,n
!*******************************************************************
   itot=0
   n=1
   do i=1,20
     nbch(i)=0
   enddo
   charm(n)=f(9,1)
  100  continue
       do i=1,ngood
         if(abs(f(9,i)-charm(n)).le.fprec) nbch(n)=nbch(n)+1
       enddo
!   the following charge states
       itot=itot+nbch(n)
       if(itot.lt.ngood) then
         do i=1,ngood
           do j=1,n
             if(abs(f(9,i)-charm(j)).le.fprec) go to 120
           enddo
           if(abs(f(9,i)-charm(n)).gt.fprec) then
             n=n+1
             charm(n)=f(9,i)
             go to 100
           endif
  120      continue
         enddo
       endif
!   compute the cog of TOF for each charge state
       do i=1,n
         cgtdv(i)=0.D0
         do j=1,ngood
           if(abs(f(9,j)-charm(i)).le.fprec) cgtdv(i)=cgtdv(i)+f(6,j)
         enddo
         cgtdv(i)=cgtdv(i)/DBLE(nbch(i))
!        write(16,*)'i,nch,cgtdv=',i,nbch(i),cgtdv(i),charm(i)
       enddo
       netac=n
END SUBROUTINE cogetc
!> *******************************************************************
!! SUBROUTINE tiltbm(icg)
!! tilt and shift of the beam with respect to the cog
!!      TIPHA : Shift on the phase axis(DEG)
!!      TIX   : Shift in the x-direction (CM)
!!      TIY   : Shift in the y-direction   (CM)
!!      SHIFW : Change the energy position of the c.o.g.(MeV)
!!      SHIFP : Change the phase position of the c.o.g.(deg)
!!      DTIPH : Change the position of the phase (radian)
!!      ICG  : = 0 VREF and TREF are the ones of sync. particle
!!      ICG  :. NE. 0 VREF ET TREF are the ones of the c.o.g.
!< *******************************************************************
SUBROUTINE tiltbm(icg)
   USE m4cavs, ONLY: FH
   USE DynacConstants
   USE m4input
   USE m4output
   USE m4beam
   USE m4beam2, ONLY: itwiss
   USE m4spacecharge
   USE m4plots 
   USE m4STIS
   USE m4TILT   
   USE m4ITVOLE, ONLY: DTIPH,SHIFT
   IMPLICIT NONE
   REAL(8) bcog,bcour,bcrt,bepi,bpai,bshift,bvref,deg,tcog,tcrt,tshift
   REAL(8) deltat,deltav,delxp,delyp,dlx,dly,dv,delv
   REAL(8) encog,encrt,enshift,gamcrt,gamref,gapi,gcog,gcour,gpai,gshift
   REAL(8) vapi,vcour,vcrt,vpai,vshift,wvref
   REAL(8) eshift,shtref
   REAL(8) QDISPW
   INTEGER i,iarg,icg
!*******************************************************************
   WRITE(16,'(A,/,5(A,E12.5,A,/))') '  Shift the position of the bunch', &
   '    in the z-direction :',TIPHA,' DEG', &
   '    in the x-direction :',TIX,' CM ', &
   '    in the y-direction :',TIY,' CM ', &
   '    shift the energy of the cog with  :',SHIFW,' MeV', &
   '    shift the phase  of the cog with  :',SHIFP,' deg'
   TIPHA=TIPHA*PI/180.D0
   SHIFP=SHIFP*PI/180.D0
   deg=fh*180.D0/pi
   iarg=1
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
   ELSE
     PRLAB(IPRF)='TILT    '
   ENDIF
   call cdg(iarg)
   encog=cog(1)
   tcog=cog(3)
   gcog=encog/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
! --- this routine is called by the routine ENTRE with icg = 1
   WRITE(16,*)' *** Before tilt and shift '
   if(icg.ne.0) then
!    the reference particle is the cog of the bunch
     tref=tcog
     vref=vl*bcog
     vcour=vref
     gcour=gcog
     bcour=bcog
     WRITE(16,'(A,/,4(A,E12.5),A,/)') '  *** The reference particle is the cog:', &
     '  REF AND COG: BETA :',bcog,'  TOF :',tref,' SEC OR: ',tref*deg, &
     ' deg   ENERGY :',encog-xmat,' MeV'
   endif
   if(icg.eq.0) then
!    the reference is distinct from the cog
     vcour=vl*bcog
     bcour=bcog
     gcour=gcog
     bvref=vref/vl
     gamref=1.D0/sqrt(1.D0-bvref*bvref)
     wvref=(gamref-1.D0)*xmat
     WRITE(16,*)' *** The reference particle and cog are distinct'
     shift=.true.
     write(16,'(4(A,E12.5),A,/,4(A,E12.5),A,/)') &                   
     '  REF: BETA ',bvref,' T.O.F. ',tref,' SEC  OR ',tref*deg, &
     ' DEG ENERGY ',wvref,' MeV', &
     '  COG: BETA ',bcog,' T.O.F. ',tcog,' SEC  OR ',tcog*deg, &
     ' DEG ENERGY ',encog-xmat,' MeV'          
   endif
   DO I=1,ngood
     gapi=f(7,i)/xmat
     bepi=sqrt(1.D0-1.D0/(gapi*gapi))
     fd(i)=bepi/bcour*gapi/gcour
   ENDDO
   CALL EXT2(1)
!    shift of the ellipse in the longitudinal plane with regard to the cog (TILT)
!    the slip of phase is : TIPHA
!    the ellipsoid generated by GEBEAM and INPUT is upright
!    qdispw=dispersion in energy
   QDISPW=2.D0*SQRT(exten(10))
   encrt=encog+qdispw
   gamcrt=encrt/xmat
   bcrt=sqrt(1.D0-1.D0/(gamcrt*gamcrt))
   vcrt=bcrt*vl
   delv=vcrt-vcour
!    shift of the ellipse in the transverse planes with regard to the cog
!  DELTH ET DELPH: slips in xp and yp (mrd)
!    horizontal plane
   delxp=2.D0*sqrt(exten(5))
!    vertical plane
   delyp=2.D0*sqrt(exten(7))
   write(16,'(3(A,E12.5,A,/))') &
   '  half size in energy ',qdispw,' MeV', &
   '  half size in xp     ',delxp,' mrd', &
   '  half size in yp     ',delyp,' mrd'
!    Shift of the ellipses in the phase spaces
   tcrt=0.D0
   do i=1,ngood
     gapi=f(7,i)/xmat
     bpai=sqrt(1.D0-1.D0/(gapi*gapi))
     vpai=vl*bpai
     dv=(vpai-vcour)*tipha/(delv*fh)
     f(6,i)=f(6,i)-dv
     tcrt=tcrt+f(6,i)
     dlx=0.D0
     dly=0.D0
     if(abs(delxp).gt.fprec) dlx=f(3,i)*tix/delxp
     if(abs(delyp).gt.fprec) dly=f(5,i)*tiy/delyp
     f(2,i)=f(2,i)+dlx
     f(4,i)=f(4,i)+dly
   enddo
   tcrt=tcrt/DBLE(ngood)
   DTIPH=0.D0
   shtref=0.D0
   if(abs(shifw).gt.fprec .or. abs(shifp).gt.fprec) then
!     SHIFT=.TRUE.
     shtref=shifp/fh
     enshift=encog+shifw
     gshift=enshift/xmat
     bshift=sqrt(1.D0-1.D0/(gshift*gshift))
     eshift=enshift-xmat
     vshift=vl*bshift
     tshift=tcrt+shtref
     deltav=vshift-vcour
     deltat=tshift-tcog
   endif
   if(abs(shifw).le.fprec .and. abs(shifp).le.fprec) then
!     SHIFT=.FALSE.
     enshift=encog
     eshift=enshift-xmat
     gshift=gcour
     vshift=vcour
     bshift=vshift/vl
     tshift=tcrt
     deltav=0.D0
     deltat=0.D0
   endif
   do i=1,ngood
     f(7,i)=f(7,i)+shifw
     gpai=f(7,i)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     f(6,i)=f(6,i)+shtref
     vapi=vl*bpai
   enddo
   if(itwiss.eq.1) tref=tref+tofini
   WRITE(16,*)' *** After tilt and shift '
   bvref=vref/vl
   gamref=1.D0/sqrt(1.D0-bvref*bvref)
   wvref=(gamref-1.D0)*xmat
   write(16,'(4(A,E12.5),A,/,4(A,E12.5),A,/)') &                   
   '  REF: BETA ',bvref,' T.O.F. ',tref,' SEC  OR ',tref*deg, &
   ' DEG ENERGY ',wvref,' MeV', &
   '  COG: BETA ',bshift,' T.O.F. ',tshift,' SEC  OR ',tshift*deg, &
   ' DEG ENERGY ',eshift,' MeV'
   do i=1,ngood
     fo(7,i)=f(7,i)
     fo(2,i)=f(2,i)
     fo(3,i)=f(3,i)
     fo(4,i)=f(4,i)
     fo(5,i)=f(5,i)
     fo(6,i)=f(6,i)
   enddo
   if(itwiss.ne.1) then
!     dum=0.D0
     do i=1,ngood
       f(2,i)=f(2,i)+centre(2)
       f(3,i)=f(3,i)+centre(3)
       f(4,i)=f(4,i)+centre(4)
       f(5,i)=f(5,i)+centre(5)
       f(6,i)=f(6,i)+centre(6)
       f(7,i)=f(7,i)+centre(1)
     enddo
   endif
!  ENVELOPE
   CALL STAPL(davtot*10.D0)
END SUBROUTINE tiltbm
!> *******************************************************************
!! SUBROUTINE accept
!! computes a physical beam acceptance at the entrance of the machine
!< *******************************************************************
SUBROUTINE accept
   USE DynacConstants, ONLY: VL,PI,RPEL,iptsz
   USE m4cavs, ONLY: FH
   USE m4input
   USE m4beam
   USE m4mcs, ONLY: ncstat
   USE m4chase
   USE m4short, ONLY: shortl
   USE mCOMfrmacc
   USE mCOMpaths
   USE mCOMfiles
   IMPLICIT NONE
   REAL(8) eprt,f2,f3,f4,f5,satref,savfh,savref,tprt
   REAL(8) bref,gref,WREF,eptr   
   INTEGER idum,igrprm,iprint,j,jj,k,lfile,lpath,ngd,nold
   INTEGER i
   REAL(8), allocatable ::  BACK(:,:)
   character(len=256) :: myfile
!*******************************************************************
   allocate(BACK(9,iptsz))
   myfile=''
! make statistics on initial beam using IEX at the point where
! the ACCEPT card has been placed
   write(16,*)
   write(16,*) 'Physical acceptance has:'
   write(16,*) imaxo,' particles at origin'
   iprint=1
   savfh=fh
   satref=tref
   savref=vref
! recall initial frequency
   fh=fhinit
   tref=trefi
   vref=vrefi
   bref=vref/vl
   gref=1.D0/sqrt(1.D0-bref*bref)
   WREF=XMAT*(gref-1.D0)          
! save current beam
   do i=1,9
     do j=1,ngood
       back(i,j)=f(i,j)
     enddo
   enddo
! original particle number is in f(1,j)
! F (I,8): =1 the particle is good,   =0 the particle is lost
! recuperate original particle numbers and their coordinates
! next loop for graphics and file of good particles
   myfile='input_kept.dst'
   if(mcselect) myfile='mc'//mc//'input_kept.dst'
   lpath=LEN_TRIM(dpath)
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(23,file=myfile,status='unknown')
   ngd=ngood
   eptr=0.d0       
   do j=1,ngood
     nold=int(f(1,j))
     eprt=fo(7,nold)-xmat+eprt         
   enddo
   eprt=eprt/dble(ngood)
!2024 updated dst type and added energy              
   idum=100
   if(ncstat.gt.1) idum=102
   write(23,*) ngood,idum, fh/(2000000.D0*pi),wref,eprt
   do j=1,ngood
     nold=int(f(1,j))
     do jj=1,9
       f(jj,j)=fo(jj,nold)
     enddo
     tprt=fh*f(6,j)
     eprt=f(7,j)-xmat
     f2=f(2,j)
     f3=f(3,j)
     f4=f(4,j)
     f5=f(5,j)
     if(ncstat.gt.1) then
       write(23,'(7(F15.8,1x))')f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,j)
     else
       write(23,'(6(F15.8,1x))')f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
     endif
   enddo
   close(23)
! now make graphics
   write(16,*) 'Starting good particles graphics for ACCEPT card'
   igrprm=0
   call ytzp
! print out beam statistics
   fracc=.true.
   shortl='ACCEPT input beam data for retained particles'
   call emiprt(1)
! next loop for graphics and file of lost particles
   myfile='input_lost.dst'
   if(mcselect) myfile='mc'//mc//'input_lost.dst'
   lpath=LEN_TRIM(dpath)
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(23,file=myfile,status='unknown')
   j=0
   ngd=ngood
   eptr=0.d0
   do k=ngood+1,imax
     nold=int(f(1,k))
     eprt=fo(7,nold)-xmat+eprt
     j=j+1
   enddo
   eprt=eprt/dble(j)
!2024 updated dst type and added energy       
   idum=100
   if(ncstat.gt.1) idum=102
   write(23,*) imax-ngood,idum,fh/(2000000.D0*pi),wref,eprt
   j=1
   ngd=ngood
   do k=ngood+1,imax
     nold=int(f(1,k))
     do jj=1,9
       f(jj,j)=fo(jj,nold)
     enddo
     tprt=fh*f(6,j)
     eprt=f(7,j)-xmat
     f2=f(2,j)
     f3=f(3,j)
     f4=f(4,j)
     f5=f(5,j)
     if(ncstat.gt.1) then
       write(23,'(7(F15.8,1x))')f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,j)
     else
       write(23,'(6(F15.8,1x))')f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
     endif
     j=j+1
   enddo
   ngood=imax-ngood
   close(23)
! now make graphics
   write(16,*) 'Starting lost particles graphics for ACCEPT card'
   igrprm=0
   call ytzp
! print out beam statistics
   shortl='ACCEPT input beam data for rejected particles'
   call emiprt(1)
   fracc=.false.
! recall original coordinates
   ngood=ngd
   do i=1,9
     do j=1,ngood
       f(i,j)=back(i,j)
     enddo
   enddo
   deallocate(BACK)   
   tref=satref
   vref=savref
   fh=savfh
END SUBROUTINE accept
!> *******************************************************************
!! SUBROUTINE stapl(zpos)
!!   the statistics in EXT2
!!
!!   sprfx(cm): 2.D0*sqrt( sum(x*x) )
!!   sprfy(cm): 2.D0*sqrt( sum(y*y) )
!!   sprfw:     2.D0*sqrt( sum(dp/p * dp/p) )*beta*beta =
!!                     (energy spread)/(energy of c.o.g)
!!   sprfp(deg):2.D0*sqrt( sum(dphi * dphi) )
!!   sprfz(cm) :   sqrt( sum(dt * dt) )
!!   sprfl(m) : t.o.f of the reference
!!   sprww(MeV):kinetic energy of the c.o.g
!!   eprfw(ns.keV) : longitudinal emittance
!!   eprnx(mm.mrad): normalized emittance in x-direction
!!   eprny(mm.mrad): normalized emittance in y-direction
!< *******************************************************************
SUBROUTINE stapl(zpos)
   USE m4cavs, ONLY: FH
   USE DynacConstants
   USE m4beam
   USE m4plots 
   USE m4FENE
   USE mCOMgrot
   IMPLICIT NONE
   INTEGER i,iarg
   REAL(8) zpos,encog,bcog,gcog,tcog,bref,gref,bpai,gpai,fdp,tf,tof
   REAL(8) trqfi,trqpy,trqtx
   REAL(8) chdmn,chdmx,chpmn,chpmx,chwmn,chwmx,chxmn,chxmx,chymn,chymx,cmult
   REAL(8) sqmdv,surxth,suryph,sizens,alpx,alpy,alpz,gamx,gamy,gamz
!*******************************************************************
! store available aperture
   aaperx(iprf)=WX
   aapery(iprf)=WY
   aaperr(iprf)=RLIM   
!  izrot: logical flag set as .true. in the routine ZROTA
   if(izrot) call zrotap(-rzot)
   iarg=0
   call cdg(iarg)
   encog=cog(1)
   gcog=encog/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   CALL EXT2(iarg)
   sqmdv=4.D0*sqrt(exten(10)*exten(3)-exten(11)*exten(11))
   eprfw(iprf)=sqmdv*1.D12/fh
   sprfx(iprf)=2.D0*sqrt(exten(4))
   sprfy(iprf)=2.D0*sqrt(exten(6))
   trqtx=exten(4)*exten(5)-exten(8)*exten(8)
   trqpy=exten(6)*exten(7)-exten(9)*exten(9)
   surxth=4.D0*pi*sqrt(trqtx)
   suryph=4.D0*pi*sqrt(trqpy)
   eprnx(iprf)=bcog*surxth*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   eprny(iprf)=bcog*suryph*10.D0/(pi*sqrt(1.D0-bcog*bcog))
! Twiss parameters transverse
   twbx(iprf)=0.D0
   twby(iprf)=0.D0
   gamx=0.D0
   gamy=0.D0
   if(trqtx.gt.1D-10) then
     twbx(iprf)=10.D0*exten(4)/sqrt(trqtx)
     gamx=0.1D0*exten(5)/sqrt(trqtx)
   endif
   if(trqpy.gt.1D-10) then
     twby(iprf)=10.D0*exten(6)/sqrt(trqpy)
     gamy=0.1D0*exten(7)/sqrt(trqpy)
   endif
   twax(iprf)=0.D0
   tway(iprf)=0.D0
   if(twbx(iprf)*gamx.ge.1.D0) alpx=sqrt(twbx(iprf)*gamx-1.D0)
   if(exten(8).gt. 0.D0)alpx=-alpx
   if(twby(iprf)*gamy.ge.1.D0) alpy=sqrt(twby(iprf)*gamy-1.D0)
   if(exten(9).gt. 0.D0)alpy=-alpy
   twax(iprf)=alpx
   tway(iprf)=alpy       
! horizontal and vertical dispersion in meter (w.r.t. COG)
   dispcx(iprf)=0.01D0*exten(15)/exten(17)
   dispcy(iprf)=0.01D0*exten(16)/exten(17)
   trqfi=0.D0
   tof=0.D0
   chxmx=f(2,1)
   chxmn=f(2,1)
   chymx=f(4,1)
   chymn=f(4,1)
   chpmx=f(6,1)-tcog
   chpmn=f(6,1)-tcog
   chwmx=f(7,1)-encog
   chwmn=f(7,1)-encog
   chdmx=chpmx*fh*180.D0/pi
   chdmn=chpmn*fh*180.D0/pi
   sizens=0.D0
   do i=1,ngood
     gpai=f(7,i)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     fdp=(gpai*bpai)/(gcog*bcog)-1.D0
     trqfi=trqfi+fdp*fdp
     sizens=sizens+1.E18*(tcog-f(6,i))*(tcog-f(6,i))         
     tf=(tcog-f(6,i))*bpai*vl
     tof=tof+tf*tf
     if(f(2,i).gt.chxmx)chxmx=f(2,i)
     if(f(2,i).lt.chxmn)chxmn=f(2,i)
     if(f(4,i).gt.chymx)chymx=f(4,i)
     if(f(4,i).lt.chymn)chymn=f(4,i)
     if(f(6,i)-tcog.gt.chpmx) then
       chpmx=f(6,i)-tcog
       chdmx=chpmx*fh*180.D0/pi
     endif
     if(f(6,i)-tcog.lt.chpmn) then
       chpmn=f(6,i)-tcog
       chdmn=chpmn*fh*180.D0/pi
     endif
     if(f(7,i)-encog.gt.chwmx)chwmx=f(7,i)-encog
     if(f(7,i)-encog.lt.chwmn)chwmn=f(7,i)-encog
   enddo
   sizens=sizens/DBLE(ngood)
   sprft(iprf)=sizens       
   trqfi=trqfi/DBLE(ngood)
   tof=tof/DBLE(ngood)
   sprfz(iprf)=sqrt(tof)
   cmult=(gcog+1.D0)/gcog
   sprfw(iprf)=2.D0*sqrt(trqfi)*cmult
   sprfp(iprf)=2.D0*sqrt(exten(3))*180.D0/pi
   sprww(iprf)=cog(1)-xmat
! Twiss parameters longitudinal
   twbz(iprf)=0.D0
   gamz=0.D0
   if(eprfw(iprf).gt.1D-10) then
     twbz(iprf)=4.D0*sizens/eprfw(iprf)
     gamz=4000000.D0*exten(10)/eprfw(iprf)
   endif
   twaz(iprf)=0.D0
   if(twbz(iprf)*gamz.ge.1.D0) alpz=sqrt(twbz(iprf)*gamz-1.D0)
   if(exten(2).gt. 0.D0)alpz=-alpz
   twaz(iprf)=alpz
   twbz(iprf)=4.D0*sizens/eprfw(iprf)       
!   t.o.f of the reference in m
   sprfl(iprf)=zpos/1000.D0
   sprng(iprf)=DBLE(ngood)
!*et*2014-Sep-25 Add recording of min. and max. positions in x,y and z,z
   sxmx(iprf)=chxmx*10.D0
   sxmn(iprf)=chxmn*10.D0
   symx(iprf)=chymx*10.D0
   symn(iprf)=chymn*10.D0
   stmx(iprf)=chpmx
   stmn(iprf)=chpmn
   spmx(iprf)=chdmx
   spmn(iprf)=chdmn
   swmx(iprf)=chwmx
   swmn(iprf)=chwmn
!*et*2014-Sep-25 Add recording of energy spread and Wref
   sdwbeam(iprf)=sqrt(exten(10))
   bref=vref/vl
   gref=1.D0/sqrt(1.D0-bref*bref)
   swref(iprf)=(gref-1.D0)*xmat
!*et*2017-Feb-05 Add recording of Tref, Tcog, Xbar and Ybar
   stref(iprf)=tref
   stcog(iprf)=tcog
   sxbar(iprf)=10.D0*cog(4)
   sybar(iprf)=10.D0*cog(6)
   ELNAM(IPRF)=trim(uden)       
!*et*2025-Oct-12 Add recording of halo parameters halox,haloy,haloz and 4d emittance
   shalox(iprf)=halox
   shaloy(iprf)=haloy
   shaloz(iprf)=haloz
   semit4d(iprf)=emit4d
! evolve pointer iprf
   iprf=iprf+1
   if(izrot) call zrotap(-rzot)
END SUBROUTINE stapl
!> *******************************************************************
!! SUBROUTINE tiltz(tilta)
!! Skew the right ellipse generated by GEBEAM in the phase plane (x,z)
!< *******************************************************************
SUBROUTINE tiltz(tilta)
!   USE DynacConstants, ONLY : maxcell1
   USE DynacConstants
   USE m4beam
   USE m4input
   IMPLICIT NONE
   REAL(8) tilta, xrot, trot, vpai, gpai, vref1, tref1
   INTEGER I 
!*******************************************************************
!       WRITE(16,1)TILTA
!    1  FORMAT(' tilt in the plane (x,z) around the c.o.g', &
!       '    ANGLE :',E12.5,' DEG',/)
   write(16,'(A,e12.5,A,/)') ' Tilt in the plane (x,z) around the c.o.g     ANGLE :', &
         TILTA,' DEG'
   TILTA=TILTA*pi/180.D0
   tref=0.D0
   vref=0.D0
   DO I=1,imax
     gpai=f(7,i)/xmat
     vref=vref+vl*sqrt(1.D0-1.D0/(gpai*gpai))
     tref=tref+f(6,i)
   enddo
   vref=vref/DBLE(imax)
   tref=tref/DBLE(imax)
   vref1=0.D0
   tref1=0.D0
   DO I=1,IMAX
     gpai=f(7,i)/xmat
     vpai=sqrt(1.D0-1.D0/(gpai*gpai))*vl
     trot=(f(6,i)-tref)*cos(tilta)-sin(tilta)*f(2,i)/vpai
     xrot=(f(6,i)-tref)*sin(tilta)*vpai+cos(tilta)*f(2,i)
     f(6,i)=trot
     f(2,i)=xrot
     tref1=tref1+f(6,i)
     vref1=vref1+vpai
   ENDDO
   tref=tref1/DBLE(imax)
   vref=vref1/DBLE(imax)
END SUBROUTINE tiltz
!> *******************************************************************
!! SUBROUTINE rotat(ii)
!! (+-) 90 DEG BEAM ROTATION
!< *******************************************************************
SUBROUTINE rotat(ii)
   USE m4beam, ONLY: f
   USE m4plots 
   IMPLICIT NONE
   INTEGER II
   REAL(8)  FF(6)
!*******************************************************************
   IF(II.GE.0) THEN
!   90 degree rotation
     FF(1)=F(2,II)
     FF(2)=F(3,II)
     FF(3)=F(4,II)
     FF(4)=F(5,II)
     F(2,II)=FF(3)
     F(3,II)=FF(4)
     F(4,II)=-FF(1)
     F(5,II)=-FF(2)
   ELSE
!   -90 degree rotation
     II=-II
     FF(1)=F(2,II)
     FF(2)=F(3,II)
     FF(3)=F(4,II)
     FF(4)=F(5,II)
     F(2,II)=-FF(3)
     F(3,II)=-FF(4)
     F(4,II)=FF(1)
     F(5,II)=FF(2)
   ENDIF
END SUBROUTINE rotat
!> *******************************************************************
!! SUBROUTINE zrotap(zrot)
!! BEAM ROTATION
!!     the transverse coordinates X and Y may be rotated
!!     through an angle about the axis tangent to the
!!     central trajectory at the point in question.
!< *******************************************************************
SUBROUTINE zrotap(zrot)
   USE DynacConstants
   USE m4beam
   USE m4plots 
   USE mCOMgrot
   IMPLICIT NONE
   REAL(8) zrot,RS24,RS44
   INTEGER II,IA,IB
   REAL(8)  RS(6,6),FF(6),FC(6)
!*******************************************************************
   WRITE(16,'(/,20X,A,F10.4,A,/)') &
   'BEAM ROTATION ',ZROT,'  degrees  ABOUT THE POSITIVE Z-AXIS'
   rzot=zrot
   RS( 1,2 )  =    0.D0
   RS( 1,4 )  =    0.D0
   RS( 2,1 )  =    0.D0
   RS( 2,3 )  =    0.D0
   RS( 3,2 )  =    0.D0
   RS( 3,4 )  =    0.D0
   RS( 4,1 )  =    0.D0
   RS( 4,3 )  =    0.D0
!  Conversion DEG ==> RAD
   ZROT=  ZROT*pi/180.D0
   RS44  =  COS(ZROT)
   RS( 4,4 )  =    RS44
   RS( 3,3 )  =    RS44
   RS( 2,2 )  =    RS44
   RS( 1,1 )  =    RS44
   RS24     =  SIN(ZROT)
   RS( 2,4 )  =    RS24
   RS( 1,3 )  =    RS24
   RS( 4,2 )  =  - RS24
   RS( 3,1 )  =  - RS24
   DO II=1,ngood
     FF(1)=F(2,II)
     FF(2)=F(3,II)
     FF(3)=F(4,II)
     FF(4)=F(5,II)
     DO IA=1,4
       FC(IA)=0.D0
       DO IB=1,4
         FC(IA)=FC(IA)+FF(IB)*RS(IA,IB)
       ENDDO
     ENDDO
     F(2,II)=FC(1)
     F(3,II)=FC(2)
     F(4,II)=FC(3)
     F(5,II)=FC(4)
   ENDDO
END SUBROUTINE zrotap
!> *******************************************************************
!! SUBROUTINE chase
!! analysis of emittance by elimination of remote particles
!! read the parameters and print them out
!< *******************************************************************
SUBROUTINE chase
   USE DynacConstants, ONLY : iptsz
   USE m4chase, ONLY: fractx,fracty,fractl,ichas,chasit,zl,ipin,ichxyz
   USE m4input
   USE mCOMpaths   
   USE mCOMfiles
   IMPLICIT NONE
   character(len=300) :: myfile
!*******************************************************************
   if (.not. allocated(ichas)) allocate(ichas(iptsz))
   if (.not. allocated(zl)) allocate(zl(iptsz))
   if (.not. allocated(ipin)) allocate(ipin(iptsz))
   if (.not. allocated(ichxyz)) allocate(ichxyz(iptsz))
!*******************************************************************
   myfile='chase_emith.out'
   if(mcselect) myfile='mc'//mc//'chase_emith.out'
   myfile=trim(dpath)//trim(myfile)
   READ(in,*)FRACTX,FRACTY,FRACTL
   WRITE(16,'(A,/,A,f7.3,A,/,A,f7.3,A,/,A,f7.3,A)') '    ARE KEPT IN THE BUNCH ', &
           '       (x,xp)   : ',FRACTX*100.D0,' %', &
           '       (y,yp)   : ',FRACTY*100.D0,' %', &
           '       (w,phase): ',FRACTL*100.D0,' %'
! write heading for the chase_emith.out file; emmittances are RMS
   open(44,file=myfile,status='unknown')
   WRITE(44,'(A,A,A,A,A,A)') '#    z(m)      % in H  ', &
         '  Wcog(MeV)     PHIcog(deg)', &
         '  Eh(mm.mrad)   Ev(mm.mrad)   El(kev.ns)', &
         '  #remain ngood   xmin(mm)      xmax(mm)      ymin(mm)', &
         '      ymax(mm)      tmin(s)       tmax(s)     ', &
         '  Wmin(MeV)     Wmax(MeV)     phmin(deg)    phmax(deg)'
   myfile=''
   myfile='chase_emitv.out'
   if(mcselect) myfile='mc'//mc//'chase_emitv.out'
   myfile=trim(dpath)//trim(myfile)
   open(45,file=myfile,status='unknown')
   WRITE(45,'(A,A,A,A,A,A)') '#    z(m)      % in V  ', &
         '  Wcog(MeV)     PHIcog(deg)', &
         '  Eh(mm.mrad)   Ev(mm.mrad)   El(kev.ns)', &
         '  #remain ngood   xmin(mm)      xmax(mm)      ymin(mm)', &
         '      ymax(mm)      tmin(s)       tmax(s)     ', &
         '  Wmin(MeV)     Wmax(MeV)     phmin(deg)    phmax(deg)'
   myfile=''
   myfile='chase_emitl.out'
   if(mcselect) myfile='mc'//mc//'chase_emitl.out'
   myfile=trim(dpath)//trim(myfile)
   open(46,file=myfile,status='unknown')
   WRITE(46,'(A,A,A,A,A,A)') '#    z(m)      % in L  ', &
         '  Wcog(MeV)     PHIcog(deg)', &
         '  Eh(mm.mrad)   Ev(mm.mrad)   El(kev.ns)', &
         '  #remain ngood   xmin(mm)      xmax(mm)      ymin(mm)', &
         '      ymax(mm)      tmin(s)       tmax(s)     ', &
         '  Wmin(MeV)     Wmax(MeV)     phmin(deg)    phmax(deg)'
   CHASIT=.FALSE.
   if(fractx .lt. 1.D0) CHASIT=.TRUE.
   if(fracty .lt. 1.D0) CHASIT=.TRUE.
   if(fractl .lt. 1.D0) CHASIT=.TRUE.
   if(CHASIT) then
     ichas=1
     ichxyz=1   
   else
     WRITE(16,*) 'All 3 fractions are set to 100%, CHASE disabled'
   endif
END SUBROUTINE chase
!> *******************************************************************
!! SUBROUTINE chasel
!! analysis of emittance by elimination of remote particles in the
!! z-direction
!< *******************************************************************
SUBROUTINE chasel
   USE m4chase
   USE m4input 
   USE DynacConstants
   USE m4beam
   USE m4FENE
   IMPLICIT NONE
   REAL(8) tx2,txp2,txxp,delxxp,rpart,cost,cos2,sint,sin2,al,bl,cl,denom,emil
   REAL(8) flcrit,fl2rms,psx,psz,relpse,theta,tlx0,tlz0,tx,txp,xcg,zcg,xxl,zzl,xzl,zlma
   INTEGER i,j,nl,ikept,imaxf,imaxx,inx,inz,izlma
!*******************************************************************
   if(fractl.ge.1.D0) return
   do i=1,ngood
     ichas(i)=1
     zl(i)=0.D0
     ipin(i)=1
   enddo
   nl=int(DBLE(ngood)*fractl)
   inz=0
   imaxf=ngood
   inx=0
!  ellipsoid of concentration (phase-dispersion)
   tx2=0.D0
   txp2=0.D0
   txxp=0.D0
! Use ns and not s as unit where f(6,i) is used; this is for precision reasons	   
   do i=1,ngood
     tx2=tx2+f(6,i)*f(6,i)*1.D18
     txp2=txp2+fd(i)*fd(i)
     txxp=txxp+f(6,i)*1.D09*fd(i)
   enddo
   tx2=tx2/DBLE(ngood)
   txp2=txp2/DBLE(ngood)
   txxp=txxp/DBLE(ngood)
   delxxp=tx2*txp2-txxp*txxp
   ikept=0
   do i=1,ngood
     theta=pi/2.D0
     if(abs(fd(i)).gt.fprec)theta=atan(f(6,i)*1.D09/fd(i))
     rpart=f(6,i)*f(6,i)*1.D18+fd(i)*fd(i)
     cost=cos(theta)
     cos2=cost*cost
     sint=sin(theta)
     sin2=sint*sint
     denom=tx2*cos2+txp2*sin2-2.D0*txxp*cost*sint
     relpse=1.5D0*delxxp/denom
     if(fractl .ge. 0.97D0) then
       relpse=3.5D0*delxxp/denom
     else
       if(fractl .ge. 0.95D0) relpse=3.D0*delxxp/denom
     endif
     if(rpart.le.relpse) then
       ipin(i)=0
       ikept=ikept+1
     endif
   enddo
   write(16,*) ' CHASEL: keep',100.D0*fractl,'  % of ',ngood, &
               ' particles; chase ',ngood-int(fractl*DBLE(ngood)), &
              ' from the ',ngood-ikept,' most outlying particles'
   do j=1,ngood
     if(ipin(j).eq.1) then
       inz=inz+1
       if(imaxf.le.nl) exit
       imaxx=0
       tx=0.D0
       txp=0.D0
       txxp=0.D0
       tx2=0.D0
       txp2=0.D0
       do i=1,ngood
         if(ichas(i).eq.1) then
           tx=f(6,i)*1.D09+tx
           txp=fd(i)+txp
           tx2=tx2+f(6,i)*f(6,i)*1.D18
           txp2=txp2+fd(i)*fd(i)
           txxp=txxp+f(6,i)*fd(i)*1.D09
           imaxx=imaxx+1
         endif
       enddo
       tx=tx/DBLE(imaxx)
       txp=txp/DBLE(imaxx)
       tx2=tx2/DBLE(imaxx)
       txp2=txp2/DBLE(imaxx)
       txxp=txxp/DBLE(imaxx)
       xcg=tx
       zcg=txp
!   betatron parameters
       xxl=tx2-tx*tx
       zzl=txp2-txp*txp
       xzl=txxp-tx*txp
       if(inz.ne.1) then
         flcrit=2.D0*fl2rms*log(2.D0*DBLE(imaxx))
         if(zlma.ge.flcrit) then 
           if(xxl*zzl.gt.xzl*xzl) then
             emil=sqrt(xxl*zzl-xzl*xzl)
           else
             emil=0.D0
           endif    
           if (abs(emil).le.fprec) then
             al=0.D0
             bl=0.D0
             cl=0.D0
           else
             bl=sqrt(xxl/emil)
             cl=1.D0/bl
             al=-xzl/emil
           endif
           tlx0=tx
           tlz0=txp
         endif
       else
         if(xxl*zzl.gt.xzl*xzl) then
           emil=sqrt(xxl*zzl-xzl*xzl)
         else
           emil=0.D0
         endif    
         if (abs(emil).le.fprec) then
           al=0.D0
           bl=0.D0
           cl=0.D0
         else
           bl=sqrt(xxl/emil)
           cl=1.D0/bl
           al=-xzl/emil
         endif
         tlx0=tx
         tlz0=txp
       endif
       fl2rms=(1.D0+al*al)*xxl/bl+2.D0*al*xzl+bl*zzl
       zlma=0.D0
       do i=1,ngood
         zl(i)=0.D0
         if(ichas(i).eq.1) then
           psx=f(6,i)*1.D09-tlx0
           psz=fd(i)-tlz0
           if(abs(bl).gt.fprec) then
             zl(i)=psx*psx*cl*cl+(psx*al/bl+psz*bl)**2
           else
             zl(i)=0.D0  
           endif
           if (zlma.lt.zl(i)) then
             zlma=zl(i)
             izlma=i
           endif
         endif
       enddo
!    particle is eliminated
       imaxf=0
       if (abs(zlma).le.fprec) zlma=1.D10
       do i=1,ngood
         if(ichas(i).eq.1 .and. zl(i).lt.zlma) then
           imaxf=imaxf+1
         else
           ichas(i)=0
         endif
       enddo
     endif
   enddo
!       write(16,*) ' CHASEL:',imaxf,' retained'
END SUBROUTINE chasel
!> *******************************************************************
!! SUBROUTINE chasex
!! analysis of emittance by elimination of remote particles in the
!! x-direction
!< *******************************************************************
SUBROUTINE chasex
   USE m4chase
   USE m4input 
   USE DynacConstants
   USE m4beam
   USE m4FENE
   IMPLICIT NONE
   REAL(8) tx2,txp2,txxp,delxxp,rpart,cost,cos2,sint,sin2,al,bl,cl,denom,emil
   REAL(8) flcrit,fl2rms,psx,psz,relpse,theta,tlx0,tlz0,tx,txp,xcg,zcg,xxl,zzl,xzl,zlma
   REAL(8) f2,f3
   INTEGER i,j,nl,ikept,imaxf,imaxx,inx,inz,izlma
!*******************************************************************
   if(fractx.ge.1.D0) return
   do i=1,ngood
     ichas(i)=1
     zl(i)=0.D0
     ipin(i)=1
   enddo
   nl=int(DBLE(ngood)*fractx)
   inz=0
   imaxf=ngood
   inx=0
!  ellipsoid of concentration (x-xp)
   tx2=0.D0
   txp2=0.D0
   txxp=0.D0
   do i=1,ngood
     f2=f(2,i)*1.D-02
     f3=f(3,i)*1.D-03
     tx2=tx2+f2*f2
     txp2=txp2+f3*f3
     txxp=txxp+f2*f3
   enddo
   tx2=tx2/DBLE(ngood)
   txp2=txp2/DBLE(ngood)
   txxp=txxp/DBLE(ngood)
   delxxp=tx2*txp2-txxp*txxp
   ikept=0
   do i=1,ngood
     theta=pi/2.D0
     f2=f(2,i)*1.D-02
     f3=f(3,i)*1.D-03
     if(abs(f3).gt.fprec)theta=atan(f2/f3)
     rpart=f2*f2+f3*f3
     cost=cos(theta)
     cos2=cost*cost
     sint=sin(theta)
     sin2=sint*sint
     denom=tx2*cos2+txp2*sin2-2.D0*txxp*cost*sint
     relpse=1.5D0*delxxp/denom
     if(fractx.ge. 0.97D0) then
       relpse=3.5D0*delxxp/denom
     else
       if(fractx.ge. 0.95D0) relpse=3.D0*delxxp/denom
     endif
     if(rpart.le.relpse) then
       ipin(i)=0
       ikept=ikept+1
     endif
   enddo
   write(16,*) ' CHASEX: keep',100.D0*fractx,'  % of ',ngood, &
               ' particles; chase ',ngood-int(fractx*DBLE(ngood)), &
              ' from the ',ngood-ikept,' most outlying particles'
   do j=1,ngood
     if(ipin(j).eq.1) then
       inz=inz+1
       if(imaxf.le.nl) exit
       imaxx=0
       tx=0.D0
       txp=0.D0
       txxp=0.D0
       tx2=0.D0
       txp2=0.D0
       do i=1,ngood
         if(ichas(i).eq.1) then
           tx=f(2,i)+tx
           txp=f(3,i)+txp
           tx2=tx2+f(2,i)*f(2,i)
           txp2=txp2+f(3,i)*f(3,i)
           txxp=txxp+f(2,i)*f(3,i)
           imaxx=imaxx+1
         endif
       enddo
       tx=tx/DBLE(imaxx)
       txp=txp/DBLE(imaxx)
       tx2=tx2/DBLE(imaxx)
       txp2=txp2/DBLE(imaxx)
       txxp=txxp/DBLE(imaxx)
       xcg=tx
       zcg=txp
!   betatron parameters
       xxl=tx2-tx*tx
       zzl=txp2-txp*txp
       xzl=txxp-tx*txp
       if(inz.ne.1) then
         flcrit=2.D0*fl2rms*log(2.D0*DBLE(imaxx))
         if(zlma.ge.flcrit) then
           emil=sqrt(xxl*zzl-xzl*xzl)
           if (abs(emil).le.fprec) then
             al=0.D0
             bl=0.D0
             cl=0.D0
           else
             bl=sqrt(xxl/emil)
             cl=1.D0/bl
             al=-xzl/emil
           endif
           tlx0=tx
           tlz0=txp
         endif
       else
         emil=sqrt(xxl*zzl-xzl*xzl)
         if (abs(emil).le.fprec) then
           al=0.D0
           bl=0.D0
           cl=0.D0
         else
           bl=sqrt(xxl/emil)
           cl=1.D0/bl
           al=-xzl/emil
         endif
         tlx0=tx
         tlz0=txp
       endif
       fl2rms=(1.D0+al*al)*xxl/bl+2.D0*al*xzl+bl*zzl
       zlma=0.D0
       do i=1,ngood
         zl(i)=0.D0
         if(ichas(i).eq.1) then
           psx=f(2,i)-tlx0
           psz=f(3,i)-tlz0
           zl(i)=psx*psx*cl*cl+(psx*al/bl+psz*bl)**2
           if (zlma.lt.zl(i)) then
             zlma=zl(i)
             izlma=i
           endif
         endif
       enddo
!    particle is eliminated
       imaxf=0
       if (abs(zlma).le.fprec) zlma=1.D10
       do i=1,ngood
         if(ichas(i).eq.1 .and. zl(i).lt.zlma) then
           imaxf=imaxf+1
         else
           ichas(i)=0
         endif
       enddo
     endif
   enddo
END SUBROUTINE chasex
!> *******************************************************************
!! SUBROUTINE chasey
!! analysis of emittance by elimination of remote particles in the
!! y-direction
!< *******************************************************************
SUBROUTINE chasey
   USE m4chase
   USE m4input 
   USE DynacConstants
   USE m4beam
   USE m4FENE
   IMPLICIT NONE
   REAL(8) rpart,cost,cos2,sint,sin2,al,bl,cl,denom,emil
   REAL(8) flcrit,fl2rms,psx,psz,relpse,theta,tlx0,tlz0,xcg,zcg,xxl,zzl,xzl,zlma
   REAL(8) delyyp,f4,f5,ty,ty2,typ,typ2,tyyp
   INTEGER i,j,nl,ikept,imaxf,imaxx,inz,izlma
!*******************************************************************
   if(fracty.ge.1.D0) return
   do i=1,ngood
     ichas(i)=1
     zl(i)=0.D0
     ipin(i)=1
   enddo
   nl=int(DBLE(ngood)*fracty)
   imaxf=ngood
!  ellipsoid of concentration (y-yp)
   ty2=0.D0
   typ2=0.D0
   tyyp=0.D0
   do i=1,ngood
     f4=f(4,i)*1.D-02
     f5=f(5,i)*1.D-03
     ty2=ty2+f4*f4
     typ2=typ2+f5*f5
     tyyp=tyyp+f4*f5
   enddo
   ty2=ty2/DBLE(ngood)
   typ2=typ2/DBLE(ngood)
   tyyp=tyyp/DBLE(ngood)
   delyyp=ty2*typ2-tyyp*tyyp
   ikept=0
   do i=1,ngood
     f4=f(4,i)*1.D-02
     f5=f(5,i)*1.D-03
     theta=pi/2.D0
     if(abs(f5).gt.fprec)theta=atan(f4/f5)
     rpart=f4*f4+f5*f5
     cost=cos(theta)
     cos2=cost*cost
     sint=sin(theta)
     sin2=sint*sint
     denom=ty2*cos2+typ2*sin2-2.D0*tyyp*cost*sint
     relpse=2.5D0*delyyp/denom
     if(fracty.ge. 0.97D0) then
       relpse=3.5D0*delyyp/denom
     else
       if(fracty.ge. 0.95D0) relpse=3.D0*delyyp/denom
     endif
     if(rpart.le.relpse) then
       ipin(i)=0
       ikept=ikept+1
     endif
   enddo
   write(16,*) ' CHASEY: keep',100.D0*fracty,'  % of ',ngood, &
               ' particles; chase ',ngood-int(fracty*DBLE(ngood)), &
              ' from the ',ngood-ikept,' most outlying particles'
   inz=0
   do j=1,ngood
     if(ipin(j).eq.1) then
       inz=inz+1
       if(imaxf.le.nl) exit
       imaxx=0
       ty=0.D0
       typ=0.D0
       tyyp=0.D0
       ty2=0.D0
       typ2=0.D0
       do i=1,ngood
         if(ichas(i).eq.1) then
           ty=f(4,i)+ty
           typ=f(5,i)+typ
           ty2=ty2+f(4,i)*f(4,i)
           typ2=typ2+f(5,i)*f(5,i)
           tyyp=tyyp+f(4,i)*f(5,i)
           imaxx=imaxx+1
         endif
       enddo
       ty=ty/DBLE(imaxx)
       typ=typ/DBLE(imaxx)
       ty2=ty2/DBLE(imaxx)
       typ2=typ2/DBLE(imaxx)
       tyyp=tyyp/DBLE(imaxx)
       xcg=ty
       zcg=typ
!   betatron parameters
       xxl=ty2-ty*ty
       zzl=typ2-typ*typ
       xzl=tyyp-ty*typ
       if(inz.ne.1) then
         flcrit=2.D0*fl2rms*log(2.D0*DBLE(imaxx))
         if(zlma.ge.flcrit) then
          emil=sqrt(xxl*zzl-xzl*xzl)
           if (abs(emil).le.fprec) then
             al=0.D0
             bl=0.D0
             cl=0.D0
           else
             bl=sqrt(xxl/emil)
             cl=1.D0/bl
             al=-xzl/emil
           endif
           tlx0=ty
           tlz0=typ
        endif
       else
         emil=sqrt(xxl*zzl-xzl*xzl)
         if (abs(emil).le.fprec) then
           al=0.D0
           bl=0.D0
           cl=0.D0
         else
           bl=sqrt(xxl/emil)
           cl=1.D0/bl
           al=-xzl/emil
         endif
         tlx0=ty
         tlz0=typ
       endif
       fl2rms=(1.D0+al*al)*xxl/bl+2.D0*al*xzl+bl*zzl
       zlma=0.D0
       do i=1,ngood
         zl(i)=0.D0
         if(ichas(i).eq.1) then
           psx=f(4,i)-tlx0
           psz=f(5,i)-tlz0
           zl(i)=psx*psx*cl*cl+(psx*al/bl+psz*bl)**2
           if (zlma.lt.zl(i)) then
             zlma=zl(i)
             izlma=i
           endif
         endif
       enddo
!    particle is eliminated
       imaxf=0
       if (abs(zlma).le.fprec) zlma=1.D10
       do i=1,ngood
         if(ichas(i).eq.1 .and. zl(i).lt.zlma) then
           imaxf=imaxf+1
         else
           ichas(i)=0
         endif
       enddo
     endif
   enddo
END SUBROUTINE chasey
!> *******************************************************************
!! SUBROUTINE monte
!! random generation of the 6D coordinates of the cloud of particles
!!   LOI : 1 IMAX particles are generated randomly in three phase
!!           plane ellipse with uniform distribution in real space
!!           (x,y,z), then xp,yp, and zp from within each phase-plane
!!           ellipse. z,zp are converted to phi,w
!!   LOI : 2 IMAX particles are generated randomly in a six
!!           dimensional ellipsoid
!!   LOI : 3 IMAX particles are generated randomly in three phase
!!           plane ellipse in real space (x,y,z),with distribution
!!           corrresponding to an equilibrium stationary sphere at the
!!           limit of the of the current acceptable (see help_DYNAC).
!!           Then xp,yp, and zp from within each phase-plane for
!!           each phase-plane ellipse. z,zp are converted to phi,w
!!   LOI : 4 IMAX particles are generated randomly in a six
!!           dimensional ellipsoid from a distribution corresponding
!!           to an equilibrium stationary sphere
!!   LOI : 5 IMAX particles are generated randomly in a six
!!           dimensional cylinder (axis in z-direction)
!!           with uniform distribution in transverse directions
!!   LOI : 6 IMAX particles are generated randomly in a six
!!           dimensional cylinder (axis in z-direction)
!!           with gaussian distribution in transverse directions
!!   ITWISS=1   read Twiss parameters for emittance definition
!!   ITWISS<>1  reading emittance bounderies for upright ellipse
!!
!! This routine uses the CERN random # routine RLUX (named ranlux in
!! the CERN library)
!< *******************************************************************
SUBROUTINE monte
   USE DynacConstants
   USE m4trace3d
   USE m4input
   USE m4beam
   USE m4beam2, ONLY: CORD,twissa,itwiss,ntir
   USE m4cavs, ONLY: FH  
   USE m4chase, ONLY: ichas
   IMPLICIT NONE
   REAL(8) vecx(1)
   real(8) alphax,betax,emitx,gammax
   real(8) alphay,betay,emity,gammay
   real(8) alphaz,betaz,emitz,gammaz
   real(8) am,cph,ecorct,tcorct
   real(8) sig,Y1,Y2,Y3,Y4
   integer i,j,len,loi
   real(8) dmax,pmax,ptmax,tmax,ttmax,ymax,zmax
   real(8) r1,r2,r3,r4,r5,r6,rho,rho3,s
   REAL(8) vec 
   REAL(8) y1x,y2x,y3x,y4x
!********************************************
   allocate(CORD(IPTSZ,6))
   allocate(f(10,iptsz))   
   allocate(fo(10,iptsz))   
   allocate(fd(iptsz))   
   if (.not. allocated(ichas)) allocate(ichas(iptsz))
!********************************************
   read(in,*)LOI,itwiss
   WRITE(16,'(A,I2)') '  Generate particles based on law ',loi
   if(loi.gt.8) then
     write(ierr,*)' ERROR in GEBEAM: law .gt. 8 invalid !! '
     write(16,*) ' ERROR in GEBEAM: law .gt. 8 invalid !! '
     stop
   endif
   read(in,*)FH,IMAX
   WRITE(16,'(/,A,E12.5,A,/)') '  FREQUENCY : ',FH,' Hz'
   FH=FH*2.D0*pi
   FHINIT=FH
!   Center of the beam ellipsoid
!    X X' Y Y' Z' Z
   read(in,*)(CENTRE(J),J=2,5),CENTRE(1),CENTRE(6)
   if (itwiss.ne.1) then
     read(in,*)YMAX,TMAX,ZMAX,PMAX,DMAX,TTMAX
     kt3h=kt3h+1
     trace3h(kt3h)='ERROR: GEBEAM ITWISS.NE.1 not yet implemented'
   else
     read(in,*) alphax,betax,emitx
     read(in,*) alphay,betay,emity
     read(in,*) alphaz,betaz,emitz
     gammax=(1.D0+alphax*alphax)/betax
     gammay=(1.D0+alphay*alphay)/betay
     ymax=0.1D0*sqrt(emitx/gammax)
     tmax=sqrt(emitx*gammax)
     zmax=0.1D0*sqrt(emity/gammay)
     pmax=sqrt(emity*gammay)
     twissa(1)=-alphax*ymax
     twissa(2)=-alphay*zmax
!     if(loi.ne.5) then
     if(loi.lt.5 .or. loi.gt.6) then
       gammaz=(1.D0+alphaz*alphaz)/betaz
       dmax=0.001D0*sqrt(emitz*gammaz)
       ttmax=pi*sqrt(emitz/gammaz)/(fh*180.D0)
       twissa(3)=alphaz*sqrt(emitz/gammaz)
     endif
     if(loi.eq.5 .or. loi.eq.6) then
       dmax=alphaz
       twissa(3)=0.D0
       ttmax=pi/fh
     endif
     if(loi.eq.6) then
       sig=betaz
       if(sig .lt. 1.D0) then
         write(6,*)'ERROR: BETAZ in GEBEAM equal to zero'
         write(16,*)'ERROR: BETAZ in GEBEAM equal to zero'
         STOP
       endif
     endif
! store parameters for trace3d, write them in ENTRE
     tracebi(1)=alphax
     tracebi(2)=betax
     tracebi(3)=alphay
     tracebi(4)=betay
     tracebi(5)=alphaz
     tracebi(6)=betaz
     traceei(1)=emitx
     traceei(2)=emity
     traceei(3)=emitz
   endif
! --- beam centre is activated in SUBROUTINE entre
   cph=centre(6)*fh*180.D0/pi
   WRITE(16,'(A,/,A,/,2(A,E12.5,A,E12.5,/),A,/,A,E12.5,A,E12.5,/,A,E12.5,/)') & 
   '  *** Beam centre defined as:','      Transverse direction :', &
   '        HORZ PLANE X(CM) = ',CENTRE(2),'       XP(MRD) = ',CENTRE(3), &
   '        VERT PLANE Y(CM) = ',CENTRE(4),'       YP(MRD) = ',CENTRE(5), &
   '      Longitudinal direction :', &
   '       DELTA ENERGY(MeV) = ',CENTRE(1),'     TIME(SEC) = ',CENTRE(6), &
   '                                           PHASE(DEG) = ',cph
   PTMAX=ttmax*fh*180.D0/pi
   if(itwiss.ne.1) then
     WRITE(16,'(A,/,A,/,2(1x,A,e12.5,A,e12.5,/),A,/,A,e12.5,A,e12.5,/,4x,A,e12.5,/,/)') &
       '    *** Limits of the random distribution ', &
       '     Transverse direction :', &
       '      HORZ PLANE X(CM) = ',YMAX,'       XP(MRD) = ',TMAX, &
       '      VERT PLANE Y(CM) = ',ZMAX,'       YP(MRD) = ',PMAX, &
       '     Longitudinal direction :', &
       '      DELTA ENERGY(MeV) = ',DMAX,'     TIME(SEC) = ',TTMAX, &
       '                                      PHASE(DEG) = ',PTMAX
   else
     if(loi.eq.5 .or. loi.eq.6) then
       write(16,*) ' Beam distribution based on Twiss parameters'
       write(16,'(A,/,3(A,e12.5),/,3(A,e12.5))') '      Transverse direction :', &
         '        Horz plane: alpha: ',alphax,' beta(mm/mrad): ',betax, &
         ' emit(pi*mm*mrad): ',emitx, &
         '        Vert plane: alpha: ',alphay,' beta(mm/mrad): ',betay, &
         ' emit(pi*mm*mrad): ',emity
       write(16,'(A,/,A,e12.5,/,A,e12.5)') &
         '      Continuous beam in the longitudinal direction :', &
         '        half phase length (deg): ',ptmax, &
         '        half energy width (MeV): ',dmax
! continuous beam
           ifcont=.true.
     else
       write(16,'(A)') '  *** Beam distribution based on Twiss parameters'
       write(16,'(A,/,3(A,e12.5),/,3(A,e12.5))') '      Transverse direction :', &
         '        Horz plane: alpha: ',alphax,' beta(mm/mrad): ',betax, &
         ' emit(pi*mm*mrad): ',emitx, &
         '        Vert plane: alpha: ',alphay,' beta(mm/mrad): ',betay, &
         ' emit(pi*mm*mrad): ',emity
       write(16,'(A,/,3(A,e12.5),/)') '      Longitudinal direction :', &
         '        alpha: ',alphaz,' beta(deg/keV): ',betaz, &
         ' emit(pi*deg*keV): ',emitz
     endif
   endif
! len : starting value of the random vector for the routine rlux
   len=1
   do j=1,6
     cord(1,j)=0.D0
   enddo
   if(loi.eq.1) then
     do i=2,imax
       DO
         call rlux(vecx,len)
         r1=2.D0*vecx(1)-1.D0
         call rlux(vecx,len)
         r3=2.D0*vecx(1)-1.D0
         call rlux(vecx,len)
         r6=2.D0*vecx(1)-1.D0
!  make round in x,y,z plane
         rho=r1**2+r3**2+r6**2
         if (rho.le.1.D0) EXIT
       ENDDO
       DO
         call rlux(vecx,len)
         r2=2.D0*vecx(1)-1.D0
! make beam round in x,x' plane
         if((r1*r1+r2*r2).le.1.D0) EXIT
       ENDDO
       DO
         call rlux(vecx,len)
         r4=2.D0*vecx(1)-1.D0
!  make beam round in y,yp plane
         if((r4*r4+r3*r3).le.1.D0) EXIT
       ENDDO
       DO
         call rlux(vecx,len)
         r5=2.D0*vecx(1)-1.D0
!   make beam round in plane z, zp
         if((r6*r6+r5*r5).le.1.D0) EXIT
       ENDDO
!    store random numbers in preparation for rms correction
       cord(i,1)=r1
       cord(i,2)=r2
       cord(i,3)=r3
       cord(i,4)=r4
       cord(i,5)=r5
       cord(i,6)=r6
     enddo
   endif
   if(loi.eq.7) then
     do i=2,imax
       DO
         call rlux(vecx,len)
         r1=2.D0*vecx(1)-1.D0
         call rlux(vecx,len)
         r3=2.D0*vecx(1)-1.D0
         call rlux(vecx,len)
         r6=2.D0*vecx(1)-1.D0
!  make round in x,y,z plane
         rho3=r1**2+r3**2+r6**2
         if (rho3.le.1.D0) EXIT
       ENDDO
       DO
         DO
           call rlux(vecx,len)
           r2=2.D0*vecx(1)-1.D0
! make beam round in x,x' plane
           if((r1*r1+r2*r2).le.1.D0) EXIT
         ENDDO
         DO
           call rlux(vecx,len)
           r4=2.D0*vecx(1)-1.D0
!  make beam round in y,yp plane
           if((r4*r4+r3*r3).le.1.D0) EXIT
         ENDDO
         DO
           call rlux(vecx,len)
           r5=2.D0*vecx(1)-1.D0
!   make beam round in plane z, zp
           if((r6*r6+r5*r5).le.1.D0) EXIT
         ENDDO
         if((r2*r2+r4*r4+r5*r5).le.1.D0) EXIT
       ENDDO
!    store random numbers in preparation for rms correction
       cord(i,1)=r1
       cord(i,2)=r2
       cord(i,3)=r3
       cord(i,4)=r4
       cord(i,5)=r5
       cord(i,6)=r6
     enddo
   endif
   if(loi.eq.2) then
     do i=2,imax
       DO
         DO
           call rlux(vecx,len)
           r1=2.D0*vecx(1)-1.D0
           call rlux(vecx,len)
           r2=2.D0*vecx(1)-1.D0
!   make round x,xp
           rho=r1*r1+r2*r2
           if(rho.le.1.D0) EXIT
         ENDDO
         DO
           call rlux(vecx,len)
           r3=2.D0*vecx(1)-1.D0
           call rlux(vecx,len)
           r4=2.D0*vecx(1)-1.D0
!  make beam round in y,yp plane
           if((r4*r4+r3*r3).le.1.D0) EXIT
         ENDDO
         DO
           call rlux(vecx,len)
           r5=2.D0*vecx(1)-1.D0
           call rlux(vecx,len)
           r6=2.D0*vecx(1)-1.D0
!   make beam round in plane z, zp
           if((r6*r6+r5*r5).le.1.D0) EXIT
         ENDDO
!   make round x,xp,y,yp,z,zp
         rho=r1**2+r2**2+r3**2+r4**2+r5**2+r6**2
         if (rho.le.1.D0) EXIT
       ENDDO
!    store random numbers in preparation for rms correction
       cord(i,1)=r1
       cord(i,2)=r2
       cord(i,3)=r3
       cord(i,4)=r4
       cord(i,5)=r5
       cord(i,6)=r6
     enddo
   endif
   if(loi.eq.3) then
     ntir=24
     s=.2493D0
     am=0.D0
     do i=2,imax
       DO
         call gcern (len,s,am,vec)
         r1=vec
         call gcern (len,s,am,vec)
         r3=vec
         call gcern (len,s,am,vec)
         r6=vec
!  make round in x,y,z plane
         rho=r1**2+r3**2+r6**2
         if (rho.le.1.D0) EXIT
       ENDDO
       DO
         call gcern (len,s,am,vec)
         r2=vec
! make beam round in x,x' plane
         if((r1*r1+r2*r2).le.1.D0) EXIT
       ENDDO
       DO
         call gcern (len,s,am,vec)
         r4=vec
!  make beam round in y,yp plane
         if((r4*r4+r3*r3).le.1.D0) EXIT
       ENDDO
       DO
         call gcern (len,s,am,vec)
         r5=vec
!   make beam round in plane z, zp
         if((r6*r6+r5*r5).le.1.D0) EXIT
       ENDDO
!    store random numbers in preparation for rms correction
       cord(i,1)=r1
       cord(i,2)=r2
       cord(i,3)=r3
       cord(i,4)=r4
       cord(i,5)=r5
       cord(i,6)=r6
     enddo
   endif
   if(loi.eq.4) then
     ntir=12
     s=.2493D0
     am=0.D0
     do i=2,imax
       DO
         DO
           call gcern (len,s,am,vec)
           r1=vec
           call gcern (len,s,am,vec)
           r2=vec
! make beam round in x,xp plane
           rho=r1*r1+r2*r2
           if (rho.le.1.D0) EXIT
         ENDDO
         DO
           call gcern (len,s,am,vec)
           r3=vec
           call gcern (len,s,am,vec)
           r4=vec
! make beam round in y,yp plane
           if((r3*r3+r4*r4).le.1.D0) EXIT
         ENDDO
         DO
           call gcern (len,s,am,vec)
           r5=vec
           call gcern (len,s,am,vec)
           r6=vec
!   make beam round in plane z, zp
           if((r6*r6+r5*r5).le.1.D0) EXIT
         ENDDO
!    store random numbers in preparation for rms correction
!   make round x,xp,y,yp,z,zp
         rho=r1**2+r2**2+r3**2+r4**2+r5**2+r6**2
         if (rho.le.1.D0) EXIT
       ENDDO
       cord(i,1)=r1
       cord(i,2)=r2
       cord(i,3)=r3
       cord(i,4)=r4
       cord(i,5)=r5
       cord(i,6)=r6
     enddo
   endif
   if(loi.eq.5) then
     do i=2,imax
       DO
         DO
           call rlux(vecx,len)
           r1=2.D0*vecx(1)-1.D0
           call rlux(vecx,len)
           r3=2.D0*vecx(1)-1.D0
!  make round in x,y plane
           rho=r1**2+r3**2
           if (rho.le.1.D0) EXIT
         ENDDO
         DO
           call rlux(vecx,len)
           r2=2.D0*vecx(1)-1.D0
! make beam round in x,x' plane
           if((r1*r1+r2*r2).le.1.D0) EXIT
         ENDDO
         DO
           call rlux(vecx,len)
           r4=2.D0*vecx(1)-1.D0
!  make beam round in y,yp plane
           if((r4*r4+r3*r3).le.1.D0) EXIT
         ENDDO
!   make round x,xp,y,yp
         rho=r1**2+r2**2+r3**2+r4**2
         if (rho.le.1.D0) EXIT
       ENDDO
!*et*2010-11-23  do NOT make beam round in z,zp plane
       call rlux(vecx,len)
       r5=2.D0*vecx(1)-1.D0
       call rlux(vecx,len)
       r6=2.D0*vecx(1)-1.D0
!    store random numbers in preparation for rms correction
       cord(i,1)=r1
       cord(i,2)=r2
       cord(i,3)=r3
       cord(i,4)=r4
       cord(i,5)=r5
       cord(i,6)=r6
     enddo
   endif
   if(loi.eq.6) then
! Gaussian
     do i=2,imax
       CALL RGAUS2(SIG,Y1,Y2,Y3,Y4)
! do NOT make beam gaussian in z,zp plane
       call rlux(vecx,len)
       r5=2.D0*vecx(1)-1.D0
       call rlux(vecx,len)
       r6=2.D0*vecx(1)-1.D0
!
!    store random numbers in preparation for rms correction
       cord(i,1)=y1
       cord(i,2)=y2
       cord(i,3)=y3
       cord(i,4)=y4
       cord(i,5)=r5
       cord(i,6)=r6
     enddo
     y1x=abs(cord(2,1))
     y2x=abs(cord(2,2))
     y3x=abs(cord(2,3))
     y4x=abs(cord(2,4))
     do i=3,imax
       if(abs(cord(i,1)).gt.y1x)y1x=abs(cord(i,1))
       if(abs(cord(i,2)).gt.y2x)y2x=abs(cord(i,2))
       if(abs(cord(i,3)).gt.y3x)y3x=abs(cord(i,3))
       if(abs(cord(i,4)).gt.y4x)y4x=abs(cord(i,4))
     enddo
     do i=2,imax
       cord(i,1)=cord(i,1)/y1x
       cord(i,2)=cord(i,2)/y2x
       cord(i,3)=cord(i,3)/y3x
       cord(i,4)=cord(i,4)/y4x
     enddo
   endif
   call corre(imax,imax)
!   fimax=ttmax*fh*180.D0/pi
! maximum extent in case of continous beam is +/-pi (i.e. +/-180 deg)
   tcorct=abs(0.5D0*cord(2,6)*ttmax)
   ecorct=abs(0.5D0*cord(2,5)*dmax)
!   in fo(1,) is stored the energy extent (MeV)
   do i=2,imax
     fo(1,i)=0.5D0*cord(i,5)*dmax
     fo(2,i)=0.5D0*cord(i,1)*ymax
     fo(3,i)=0.5D0*cord(i,2)*tmax
     fo(4,i)=0.5D0*cord(i,3)*zmax
     fo(5,i)=0.5D0*cord(i,4)*pmax
     fo(6,i)=0.5D0*cord(i,6)*ttmax
     if(abs(fo(1,i)).gt.ecorct) ecorct=abs(fo(1,i))
     if(abs(fo(6,i)).gt.tcorct) tcorct=abs(fo(6,i))
   enddo
!first particle
   ichas(1)=1
   fo(8,1)=1.D0
   do j=1,6
     fo(j,1)=0.D0
   enddo
!    if(loi.lt.5) then
   if(loi.lt.5 .or. loi.gt.6) then
     do i=2,imax
       fo(8,i)=1
       ICHAS(I)=1
     enddo
   else
! correct the phase length and energy spread for a continuous beam (force +/- 180 deg)
     if(ecorct.le.epsilon(ecorct)) ecorct=1.D0
     if(tcorct.le.epsilon(tcorct)) tcorct=1.D0
     ecorct=dmax/ecorct
     tcorct=ttmax/tcorct
     do i=2,imax
       fo(8,i)=1
       ICHAS(I)=1
       fo(1,i)=fo(1,i)*ecorct
       fo(6,i)=fo(6,i)*tcorct
     enddo
   endif
   ngood=imax
   imaxo=imax
   WRITE(16,'(/,A,I2,A,I8,A,/)') '  *** Law ',LOI,'  with ',IMAX,' particles'
   WRITE(6,'(A,I8,A)') 'Simulation with ',IMAX,' particles'
END SUBROUTINE monte
!> *******************************************************************
!! SUBROUTINE etac
!! Several charge states in the  bunch, generated randomly
!!   ENTRY :
!!     N       : Number of charge states (maximum 6 different charge states)
!!     CHARGE(I)  PCENT(I)  EOFF (I = 1 to N )
!!     CHARGE(I)    : charge state
!!     PCENT(I)     : percentage of charge state
!!     EOFF(I)      : absolute energy offset of charge state w.r.t. COG (MeV)
!!     ix           : RANDOM NUMBER GENERATOR
!< *******************************************************************
SUBROUTINE etac
   USE DynacConstants, ONLY: VL,PI,RPEL
   USE m4beam, ONLY: XMAT,QST,f,imax,ngood,QMOY
   USE m4input
   USE m4beam
   USE m4mcs, ONLY: imcs,ncstat,cstat
   USE mCOMpaths   
   IMPLICIT NONE
   real(8) chstate,POURC,ts,XARPHA,fprec
   integer i,j,len
   INTEGER is,jjj,lpath,N,ntot
   character(len=256) :: myfile
   REAL(8) charge(20),pcent(20),charm(20),pc(20),eoff(20),vecx(1),eof(20),offen
   READ(IN,*) NCSTAT
!*******************************************************************
   N=NCSTAT
   IF (N.GT.20) THEN
     WRITE( 6,'(3x,A,i3,A)') ' NUMBER OF CHARGE STATES : ',N,' GREATER THAN 20'
     WRITE(16,'(3x,A,i3,A)') ' NUMBER OF CHARGE STATES : ',N,' GREATER THAN 20'
     STOP
   ENDIF
   imcs=1
   IF(N.EQ.0) then
! read charge state distribution from file
     myfile=''
     READ(in,'(A)') myfile
     lpath=LEN_TRIM(dpath)
     myfile=TRIM(myfile)
     write(16,*) 'Charge state distribution file: ',myfile
     open(56,file=myfile,status='unknown',action='read')
     read(56,*) ntot
     write(16,*) 'Maximum number of particles:',imax
     write(16,*) 'Number  of   good particles:',ngood
     write(16,*) 'Number of particles in charge state file:',ntot
     IF(ntot.lt.ngood) then
       write(16,*) 'Not enough particles in charge state file'
       STOP
     ENDIF
     DO J=1,ntot
       read(56,*) chstate
       f(9,i)=chstate
     enddo
     close(56)
   ELSE
! generate charge state distribution
     POURC=0.D0
     fprec=epsilon(POURC)     
     DO I=1,N
! for each charge state read charge, percentage and energy offset
       READ(IN,*) charm(I),PC(I),eoff(i)
       CSTAT(i)=charm(i)
       POURC=POURC+PC(I)
       IF (POURC-100.D0 .GT. fprec) THEN
         WRITE( 6,'(3x,A,/,4x,A,i3,A,e14.7)')' WRONG PERCENTAGE IN CHARGE STATE DISTRIBUTION', &
           ' CHARGE STATE ',I,' PERCENTAGE ',POURC
         WRITE(16,'(3x,A,/,4x,A,i3,A,e14.7)')' WRONG PERCENTAGE IN CHARGE STATE DISTRIBUTION', &
           ' CHARGE STATE ',I,' PERCENTAGE ',POURC
         STOP
       ENDIF
     ENDDO
     POURC=0.D0
     DO I=1,N
       POURC=POURC+PC(I)
       eof(i)=eoff(i)
     enddo
     IF (POURC-100.D0 .LT. -fprec) THEN
       WRITE ( 6,'(3x,A,/,4x,A,e12.5)')' TOTAL PERCENTAGE OF ALL CHARGE STATES < 100 %', &
         ' PERCENTAGE ',POURC
       WRITE (16,'(3x,A,/,4x,A,e12.5)')' TOTAL PERCENTAGE OF ALL CHARGE STATES < 100 %', &
         ' PERCENTAGE ',POURC
       STOP
     ENDIF
     j=1
     DO
       if(j.gt.n) exit
       ts=500.D0
       is=1
       offen=0.D0
       do i=1,n
         if(ts.ge.charm(i)) then
           ts=charm(i)
           offen=eof(i)
           is=i
         endif
       enddo
       charge(j)=ts
       pcent(j)=pc(is)
       eoff(j)=offen       
       charm(is)=1000.D0
       j=j+1
     ENDDO
! for each charge state write charge, percentage and energy offset
     jjj=0
     do i=1,n
       WRITE(16,'(3x,A,f9.5,A,e12.5,A,4x,A,e12.5,A)') &
         ' CHARGE STATE ',CHARGE(I),'  PERCENTAGE ',PCENT(I),' %',' ENERGY OFFSET ',eoff(i),' MeV'
       if(charge(i).eq.qst) jjj=1
!       if(int(charge(i)).eq.int(qst)) jjj=1
     enddo
     len=1
! FIRST TRAJECTORY HAS CHARGE STATE AS DEFINED BY INPUT
     PCENT(1)=PCENT(1)/100.D0
     DO I=2,N
       PCENT(I)=PCENT(I-1)+PCENT(I)/100.D0
     enddo
     DO I=1,IMAX
       call rlux(vecx,len)
       XARPHA=VECX(1)
       IF (XARPHA.LE.PCENT(1)) THEN
         f(9,i)=CHARGE(1)
         f(7,i)=f(7,i)+eoff(1)
       ELSE
         DO J=1,N-1
           IF (XARPHA.GT.PCENT(J) .AND. XARPHA.LE.PCENT(J+1))then
             f(7,i)=f(7,i)+eoff(J+1)
             f(9,i)=CHARGE(J+1)
           ENDIF
         enddo
       ENDIF
     ENDDO
   ENDIF
   call emiprt(0)
END SUBROUTINE etac
!> *******************************************************************
!! SUBROUTINE rgaus2(sigma,y1,y2,y3,y4)
!! called by subroutine MONTE
!< *******************************************************************
SUBROUTINE rgaus2(sigma,y1,y2,y3,y4)
   IMPLICIT NONE
   REAL(8) sigma,y1,y2,y3,y4
   REAL(8) vecx(1),fprec,w1,w2,x1,x2,x3,x4
   INTEGER LEN
!*******************************************************************
   fprec=epsilon(sigma)
   len=1
   w1=0.D0
   do while ((w1.ge.1.D0).or.(abs(w1).le.fprec))
     call rlux(vecx,len)
     x1 = 2.D0 * vecx(1) - 1.D0
     call rlux(vecx,len)
     x3 = 2.D0 * vecx(1) - 1.D0
     w1 = x1 * x1 + x3 * x3
   enddo
   w2=0.D0
   do while ((w2.ge.1.D0).or.(abs(w2).le.fprec))
     call rlux(vecx,len)
     x2 = 2.D0 * vecx(1) - 1.D0
     call rlux(vecx,len)
     x4 = 2.D0 * vecx(1) - 1.D0
     w2 = x2 * x2 + x4 * x4
   enddo
   w1 = sigma*sqrt( (-2.D0 * log( w1 ) ) / w1 )
   w2 = sigma*sqrt( (-2.D0 * log( w2 ) ) / w2 )
   y1 = x1 * w1
   y2 = x2 * w2
   y3 = x3 * w1
   y4 = x4 * w2
END SUBROUTINE rgaus2
!> *******************************************************************
!! SUBROUTINE rlux(RVEC,LENV)
!! ranlux.f Rev 1.2  1997/09/22 13:45:47  mclareni
!! Correct error in initializing RANLUX by using RLUXIN with the
!! output of RLUXUT from a previous run.
!! CERN Mathlib gen
!!
!!         Subtract-and-borrow random number generator proposed by
!!         Marsaglia and Zaman, implemented by F. James with the name
!!         RCARRY in 1991, and later improved by Martin Luescher
!!         in 1993 to produce "Luxury Pseudorandom Numbers".
!!         Fortran 77 coded by F. James, 1993
!!
!!   LUXURY LEVELS.
!!   ------ ------      The available luxury levels are:
!!
!!  level 0  (p=24): equivalent to the original RCARRY of Marsaglia
!!           and Zaman, very long period, but fails many tests.
!!  level 1  (p=48): considerable improvement in quality over level 0,
!!           now passes the gap test, but still fails spectral test.
!!  level 2  (p=97): passes all known tests, but theoretically still
!!           defective.
!!  level 3  (p=223): DEFAULT VALUE.  Any theoretically possible
!!           correlations have very small chance of being observed.
!!  level 4  (p=389): highest possible luxury, all 24 bits chaotic.
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!  Calling sequences for RANLUX:                                  ++
!!      CALL RANLUX (RVEC, LEN)   returns a vector RVEC of LEN     ++
!!               32-bit random floating point numbers between      ++
!!               zero (not included) and one (also not incl.).     ++
!!      CALL RLUXGO(LUX,INT,K1,K2) initializes the generator from  ++
!!               one 32-bit integer INT and sets Luxury Level LUX  ++
!!               which is integer between zero and MAXLEV, or if   ++
!!               LUX .GT. 24, it sets p=LUX directly.  K1 and K2   ++
!!               should be set to zero unless restarting at a break++
!!               point given by output of RLUXAT (see RLUXAT).     ++
!!      CALL RLUXAT(LUX,INT,K1,K2) gets the values of four integers++
!!               which can be used to restart the RANLUX generator ++
!!               at the current point by calling RLUXGO.  K1 and K2++
!!               specify how many numbers were generated since the ++
!!               initialization with LUX and INT.  The restarting  ++
!!               skips over  K1+K2*E9   numbers, so it can be long.++
!!   A more efficient but less convenient way of restarting is by: ++
!!      CALL RLUXIN(ISVEC)    restarts the generator from vector   ++
!!                   ISVEC of 25 32-bit integers (see RLUXUT)      ++
!!      CALL RLUXUT(ISVEC)    outputs the current values of the 25 ++
!!                 32-bit integer seeds, to be used for restarting ++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
SUBROUTINE rlux(RVEC,LENV)
   IMPLICIT NONE
   INTEGER, PARAMETER :: MAXLEV=4, LXDFLT=3
   INTEGER, PARAMETER :: IGIGA=1000000000,JSDFLT=314159265
   INTEGER, PARAMETER :: ITWO24=2**24, ICONS=2147483563
   INTEGER LENV,LUXLEV
   REAL(8) RVEC(LENV), SEEDS(24), CARRY, TWOM24, TWOM12, fprec, UNI
   INTEGER ISEEDS(24), NDSKIP(0:MAXLEV), NEXT(24)
   INTEGER I24, J24, NSKIP, IN24, KOUNT, MKOUNT, INSEED
   INTEGER I, K, LP, ISK, IVEC, JSEED
   LOGICAL NOTYET
!   SAVE NOTYET, I24, J24, CARRY, SEEDS, TWOM24, TWOM12, LUXLEV
!   SAVE NSKIP, NDSKIP, IN24, NEXT, KOUNT, MKOUNT, INSEED
   DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
   DATA I24,J24,CARRY/24,10,0.D0/
!                               default
!  Luxury Level   0     1     2   *3*    4
   DATA NDSKIP/0,   24,   73,  199,  365 /
! corresponds to p=24    48    97   223   389
!     time factor 1     2     3     6    10   on slow workstation
!                 1    1.5    2     3     5   on fast mainframe
!
!  NOTYET is .TRUE. if no initialization has been performed yet.
!              Default Initialization by Multiplicative Congruential
!*******************************************************************
   fprec=epsilon(carry)
   IF (NOTYET) THEN
     NOTYET = .FALSE.
     JSEED = JSDFLT
     INSEED = JSEED
     WRITE(16,'(A,I12)')'  RANLUX DEFAULT INITIALIZATION: ',JSEED
     LUXLEV = LXDFLT
     NSKIP = NDSKIP(LUXLEV)
     LP = NSKIP + 24
     IN24 = 0
     KOUNT = 0
     MKOUNT = 0
     WRITE(16,'(A,I2,A,I4)')'  RANLUX DEFAULT LUXURY LEVEL =  ', &
          LUXLEV,'      p =',LP
     TWOM24 = 1.D0
     DO I= 1, 24
       TWOM24 = TWOM24 * 0.5D0
       K = JSEED/53668
       JSEED = 40014*(JSEED-K*53668) -K*12211
       IF (JSEED .LT. 0)  JSEED = JSEED+ICONS
       ISEEDS(I) = MOD(JSEED,ITWO24)
     ENDDO
     TWOM12 = TWOM24 * 4096.D0
     DO I= 1,24
       SEEDS(I) = DBLE(ISEEDS(I))*TWOM24
       NEXT(I) = I-1
     ENDDO
     NEXT(1) = 24
     I24 = 24
     J24 = 10
     CARRY = 0.D0
     IF (abs(SEEDS(24)) .LE. fprec) CARRY = TWOM24
!     IF (SEEDS(24) .EQ. 0.) CARRY = TWOM24
   ENDIF
!
!      The Generator proper: "Subtract-with-borrow",
!      as proposed by Marsaglia and Zaman,
!      Florida State University, March, 1989
!
   DO IVEC= 1, LENV
     UNI = SEEDS(J24) - SEEDS(I24) - CARRY
     IF (UNI .LT. 0.D0)  THEN
       UNI = UNI + 1.0D0
       CARRY = TWOM24
     ELSE
       CARRY = 0.D0
     ENDIF
     SEEDS(I24) = UNI
     I24 = NEXT(I24)
     J24 = NEXT(J24)
     RVEC(IVEC) = UNI
!  small numbers (with less than 12 "significant" bits) are "padded".
     IF (UNI .LT. TWOM12)  THEN
       RVEC(IVEC) = RVEC(IVEC) + TWOM24*SEEDS(J24)
!      and zero is forbidden in case someone takes a logarithm
       IF (abs(RVEC(IVEC)) .LE. fprec)  RVEC(IVEC) = TWOM24*TWOM24
!       IF (RVEC(IVEC) .EQ. 0.)  RVEC(IVEC) = TWOM24*TWOM24
     ENDIF
!    Skipping to luxury.  As proposed by Martin Luscher.
     IN24 = IN24 + 1
     IF (IN24 .EQ. 24)  THEN
       IN24 = 0
       KOUNT = KOUNT + NSKIP
       DO ISK= 1, NSKIP
         UNI = SEEDS(J24) - SEEDS(I24) - CARRY
         IF (UNI .LT. 0.D0)  THEN
           UNI = UNI + 1.0D0
           CARRY = TWOM24
         ELSE
           CARRY = 0.D0
         ENDIF
         SEEDS(I24) = UNI
         I24 = NEXT(I24)
         J24 = NEXT(J24)
       ENDDO
     ENDIF
   ENDDO
   KOUNT = KOUNT + LENV
   IF (KOUNT .GE. IGIGA)  THEN
     MKOUNT = MKOUNT + 1
     KOUNT = KOUNT - IGIGA
   ENDIF
END SUBROUTINE rlux
!> *******************************************************************
!! SUBROUTINE RLUXIN(ISDEXT)
!! ranlux.f Rev 1.2  1997/09/22 13:45:47  mclareni
!! Correct error in initializing RANLUX by using RLUXIN with the
!! output of RLUXUT from a previous run.
!! CERN Mathlib gen
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!           RLUXIN(ISVEC)    restarts the generator from vector   ++
!!                   ISVEC of 25 32-bit integers (see RLUXUT)      ++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
SUBROUTINE RLUXIN(ISDEXT)
   IMPLICIT NONE
   INTEGER, PARAMETER :: MAXLEV=4, LXDFLT=3
   INTEGER LUXLEV, ISD
   REAL(8) SEEDS(24), CARRY, TWOM24, TWOM12
   INTEGER ISDEXT(25), NDSKIP(0:MAXLEV), NEXT(24)
   INTEGER I24, J24, NSKIP, IN24, KOUNT, MKOUNT, INSEED
   INTEGER I
   LOGICAL NOTYET
!   SAVE NOTYET, I24, J24, CARRY, SEEDS, TWOM24, TWOM12, LUXLEV
!   SAVE NSKIP, NDSKIP, IN24, NEXT, KOUNT, MKOUNT, INSEED
   DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
   DATA I24,J24,CARRY/24,10,0.D0/
!                               default
!  Luxury Level   0     1     2   *3*    4
   DATA NDSKIP/0,   24,   73,  199,  365 /
!  corresponds to p=24    48    97   223   389
!     time factor   1     2     3     6    10   on slow workstation
!                   1    1.5    2     3     5   on fast mainframe
!
!     Entry to input and float integer seeds from previous run
!*******************************************************************
   NOTYET = .FALSE.
   TWOM24 = 1.D0
   DO I= 1, 24
     NEXT(I) = I-1
     TWOM24 = TWOM24 * 0.5D0
   ENDDO
   NEXT(1) = 24
   TWOM12 = TWOM24 * 4096.D0
   WRITE(16,'(A)')'FULL INITIALIZATION OF RANLUX WITH 25', &
                    ' INTEGERS'
   WRITE(16,'(5X,5I12)') ISDEXT
   DO I= 1, 24
     SEEDS(I) = DBLE(ISDEXT(I))*TWOM24
   ENDDO
   CARRY = 0.D0
   IF (ISDEXT(25) .LT. 0)  CARRY = TWOM24
   ISD = IABS(ISDEXT(25))
   I24 = MOD(ISD,100)
   ISD = ISD/100
   J24 = MOD(ISD,100)
   ISD = ISD/100
   IN24 = MOD(ISD,100)
   ISD = ISD/100
   LUXLEV = ISD
   IF (LUXLEV .LE. MAXLEV) THEN
     NSKIP = NDSKIP(LUXLEV)
     WRITE (6,'(A,I2)')'RANLUX LUXURY LEVEL SET BY RLUXIN TO: ', &
                           LUXLEV
   ELSE  IF (LUXLEV .GE. 24) THEN
     NSKIP = LUXLEV - 24
     WRITE (6,'(A,I5)')'RANLUX P-VALUE SET BY RLUXIN TO:',LUXLEV
   ELSE
     NSKIP = NDSKIP(MAXLEV)
     WRITE (6,'(A,I5)')'RANLUX ILLEGAL LUXURY RLUXIN: ',LUXLEV
     LUXLEV = MAXLEV
   ENDIF
   INSEED = -1
END SUBROUTINE RLUXIN
!> *******************************************************************
!! SUBROUTINE RLUXUT(ISDEXT)
!! CERN Mathlib gen
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!      CALL RLUXUT(ISVEC)    outputs the current values of the 25 ++
!!                 32-bit integer seeds, to be used for restarting ++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
SUBROUTINE RLUXUT(ISDEXT)
   IMPLICIT NONE
   INTEGER, PARAMETER :: MAXLEV=4, LXDFLT=3
   REAL(8), PARAMETER :: TWOP12=4096.D0
   INTEGER LUXLEV
   REAL(8) SEEDS(24), CARRY
   INTEGER ISDEXT(25), NDSKIP(0:MAXLEV)
   INTEGER I24, J24, IN24, KOUNT, MKOUNT
   INTEGER I
   LOGICAL NOTYET
!   SAVE NOTYET, I24, J24, CARRY, SEEDS, LUXLEV
!   SAVE NDSKIP, IN24, KOUNT, MKOUNT
   DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
   DATA I24,J24,CARRY/24,10,0.D0/
!                               default
!  Luxury Level   0     1     2   *3*    4
   DATA NDSKIP/0,   24,   73,  199,  365 /
! corresponds to p=24    48    97   223   389
!      time factor 1     2     3     6    10   on slow workstation
!                  1    1.5    2     3     5   on fast mainframe
!
!                    Entry to output seeds as integers
!*******************************************************************
   DO I= 1, 24
     ISDEXT(I) = INT(SEEDS(I)*TWOP12*TWOP12)
   ENDDO
   ISDEXT(25) = I24 + 100*J24 + 10000*IN24 + 1000000*LUXLEV
   IF (CARRY .GT. 0.D0)  ISDEXT(25) = -ISDEXT(25)
END SUBROUTINE RLUXUT
!> *******************************************************************
!! SUBROUTINE RLUXAT(LOUT,INOUT,K1,K2)
!! CERN Mathlib gen
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!      CALL RLUXAT(LUX,INT,K1,K2) gets the values of four integers++
!!               which can be used to restart the RANLUX generator ++
!!               at the current point by calling RLUXGO.  K1 and K2++
!!               specify how many numbers were generated since the ++
!!               initialization with LUX and INT.  The restarting  ++
!!               skips over  K1+K2*E9   numbers, so it can be long.++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
SUBROUTINE RLUXAT(LOUT,INOUT,K1,K2)
   IMPLICIT NONE
   INTEGER, PARAMETER :: LXDFLT=3
   INTEGER LUXLEV
   INTEGER IN24, KOUNT, MKOUNT, INSEED, LOUT, INOUT, K1, K2
   LOGICAL NOTYET
!   SAVE NOTYET, LUXLEV
!   SAVE IN24, KOUNT, MKOUNT, INSEED
   DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
!     Entry to output the "convenient" restart point
!*******************************************************************
   LOUT = LUXLEV
   INOUT = INSEED
   K1 = KOUNT
   K2 = MKOUNT
END SUBROUTINE RLUXAT
!> *******************************************************************
!! SUBROUTINE RLUXGO(LUX,INS,K1,K2)
!! CERN Mathlib gen
!!
!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!      CALL RLUXGO(LUX,INT,K1,K2) initializes the generator from  ++
!!               one 32-bit integer INT and sets Luxury Level LUX  ++
!!               which is integer between zero and MAXLEV, or if   ++
!!               LUX .GT. 24, it sets p=LUX directly.  K1 and K2   ++
!!               should be set to zero unless restarting at a break++
!!               point given by output of RLUXAT (see RLUXAT).     ++
!!      ISVEC must be dimensioned 25 in the calling program        ++
!< *******************************************************************
SUBROUTINE RLUXGO(LUX,INS,K1,K2)
   IMPLICIT NONE
   INTEGER, PARAMETER :: MAXLEV=4, LXDFLT=3
   INTEGER, PARAMETER :: IGIGA=1000000000,JSDFLT=314159265
   INTEGER, PARAMETER :: ITWO24=2**24, ICONS=2147483563
   INTEGER LUX,LUXLEV,INS
   REAL(8) SEEDS(24), CARRY, TWOM24, TWOM12, fprec, UNI
   INTEGER ISEEDS(24), NDSKIP(0:MAXLEV), NEXT(24)
   INTEGER I24, J24, NSKIP, IN24, KOUNT, MKOUNT, INSEED
   INTEGER I, ILX, IZIP, IZIP2, IOUTER, K, K1, K2, ISK, INNER, JSEED
   LOGICAL NOTYET
!   SAVE NOTYET, I24, J24, CARRY, SEEDS, TWOM24, TWOM12, LUXLEV
!   SAVE NSKIP, NDSKIP, IN24, NEXT, KOUNT, MKOUNT, INSEED
   DATA NOTYET, LUXLEV, IN24, KOUNT, MKOUNT /.TRUE., LXDFLT, 0,0,0/
   DATA I24,J24,CARRY/24,10,0.D0/
!                               default
!  Luxury Level   0     1     2   *3*    4
   DATA NDSKIP/0,   24,   73,  199,  365 /
! corresponds to p=24    48    97   223   389
!       time factor 1     2     3     6    10   on slow workstation
!                   1    1.5    2     3     5   on fast mainframe
!
!                    Entry to initialize from one or three integers
!*******************************************************************
   IF (LUX .LT. 0) THEN
     LUXLEV = LXDFLT
   ELSE IF (LUX .LE. MAXLEV) THEN
     LUXLEV = LUX
   ELSE IF (LUX .LT. 24 .OR. LUX .GT. 2000) THEN
     LUXLEV = MAXLEV
     WRITE (6,'(A,I7)')'RANLUX ILLEGAL LUXURY RLUXGO: ',LUX
   ELSE
     LUXLEV = LUX
     DO ILX= 0, MAXLEV
       IF (LUX .EQ. NDSKIP(ILX)+24)  LUXLEV = ILX
     ENDDO
   ENDIF
   IF (LUXLEV .LE. MAXLEV)  THEN
     NSKIP = NDSKIP(LUXLEV)
     WRITE(16,'(A,I2,A,I4)')'RANLUX LUXURY LEVEL SET BY RLUXGO :', &
          LUXLEV,'     P=', NSKIP+24
   ELSE
     NSKIP = LUXLEV - 24
     WRITE(16,'(A,I5)')'RANLUX P-VALUE SET BY RLUXGO TO:',LUXLEV
   ENDIF
   IN24 = 0
   IF (INS .LT. 0)  WRITE (6,'(A)') &
     ' Illegal initialization by RLUXGO, negative input seed'
   IF (INS .GT. 0)  THEN
     JSEED = INS
     WRITE(16,'(A,3I12)')'RANLUX INITIALIZED BY ', &
       'RLUXGO FROM SEEDS',JSEED, K1,K2
   ELSE
     JSEED = JSDFLT
     WRITE(16,'(A)')'RANLUX INITIALIZED BY RLUXGO FROM DEFAULT', &
                      ' SEED'
   ENDIF
   INSEED = JSEED
   NOTYET = .FALSE.
   TWOM24 = 1.D0
   DO I= 1, 24
     TWOM24 = TWOM24 * 0.5D0
     K = JSEED/53668
     JSEED = 40014*(JSEED-K*53668) -K*12211
     IF (JSEED .LT. 0)  JSEED = JSEED+ICONS
     ISEEDS(I) = MOD(JSEED,ITWO24)
   ENDDO
   TWOM12 = TWOM24 * 4096.D0
   DO I= 1,24
     SEEDS(I) = DBLE(ISEEDS(I))*TWOM24
     NEXT(I) = I-1
   ENDDO
   NEXT(1) = 24
   I24 = 24
   J24 = 10
   CARRY = 0.D0
   fprec=epsilon(seeds(24))
   IF (abs(SEEDS(24)).LE.fprec) CARRY = TWOM24
!    If restarting at a break point, skip K1 + IGIGA*K2
!    Note that this is the number of numbers delivered to
!    the user PLUS the number skipped (if luxury .GT. 0).
   KOUNT = K1
   MKOUNT = K2
   IF (K1+K2 .NE. 0)  THEN
     DO IOUTER= 1, K2+1
       INNER = IGIGA
       IF (IOUTER .EQ. K2+1)  INNER = K1
       DO ISK= 1, INNER
         UNI = SEEDS(J24) - SEEDS(I24) - CARRY
         IF (UNI .LT. 0.D0)  THEN
           UNI = UNI + 1.D0
           CARRY = TWOM24
         ELSE
           CARRY = 0.D0
         ENDIF
         SEEDS(I24) = UNI
         I24 = NEXT(I24)
         J24 = NEXT(J24)
       ENDDO
     ENDDO
!     Get the right value of IN24 by direct calculation
     IN24 = MOD(KOUNT, NSKIP+24)
     IF (MKOUNT .GT. 0)  THEN
       IZIP = MOD(IGIGA, NSKIP+24)
       IZIP2 = MKOUNT*IZIP + IN24
       IN24 = MOD(IZIP2, NSKIP+24)
     ENDIF
!   Now IN24 had better be between zero and 23 inclusive
     IF (IN24 .GT. 23) THEN
       WRITE (6,'(A/A,3I11,A,I5)') &
      '  Error in RESTARTING with RLUXGO:',' The values',INS, &
         K1, K2, ' cannot occur at luxury level', LUXLEV
       IN24 = 0
     ENDIF
   ENDIF
END SUBROUTINE RLUXGO
!> *******************************************************************
!! SUBROUTINE aliner
!! ALIGNMENT  errors:
!!       HORIZONTAL : XL(cm) XLP(mrad)
!!       VERTICAL   : YL(cm) YLP(mrad)
!< *******************************************************************
SUBROUTINE aliner
   USE m4beam, ONLY: f,ngood
   USE mCOMalin
   IMPLICIT NONE   
   INTEGER II
!*******************************************************************
   WRITE(16,'(/,5x,A,2(e12.5,2x),/,5x,A,2(e12.5,2x),/,/)') &
    ' DISPLACEMENT x(cm)    y(cm)  : ',XL,YL, &
    ' KICK        xp(mrad) yp(mrad): ',XPL,YPL
!    CALCUL DES COORDONNEES DES TRAJECTOIRES
!    UNITES  =  CM-MRD
   DO II=1,ngood
     F(2,II)=F(2,II) + XL
     F(4,II)=F(4,II) + YL
     F(3,II)=F(3,II) + XPL
     F(5,II)=F(5,II) + YPL
   ENDDO
END SUBROUTINE aliner
!> *******************************************************************
!! SUBROUTINE randali
!! RANDOM ALIGNMENT  errors :
!!     HORIZONTAL PLANE : XL(cm) XLP(mrad)
!!     VERTICAL PLANE   : YL(cm) YLP(mrad)
!< *******************************************************************
SUBROUTINE randali
   USE m4beam
   USE mCOMalin
   USE mCOMapel
   IMPLICIT NONE   
   INTEGER II,len
   REAL(8) trans(1),rdcf,xla,yla,xpla,ypla,sign
!*******************************************************************
   write(16,*) ' Random error in alignment to be applied within:'
   WRITE(16,'(5x,A,2(e12.5,2x),/,5X,A,2(e12.5,2x),/)') &
     ' KICK +/- x(cm)     x/- y(cm)   : ',XL,YL, &
     ' KICK +/- xp(mrad)  +/- yp(mrad): ',XPL,YPL
   len=1
   rdcf=0.5D0
   call rlux(trans,len)
   if(trans(1).le.rdcf) sign=-1.D0
   if(trans(1).gt.rdcf) sign=1.D0
   call rlux(trans,len)
   xla=xl*sign*trans(1)
   call rlux(trans,len)
   if(trans(1).le.rdcf) sign=-1.D0
   if(trans(1).gt.rdcf) sign=1.D0
   call rlux(trans,len)
   yla=yl*sign*trans(1)
   call rlux(trans,len)
   if(trans(1).le.rdcf) sign=-1.D0
   if(trans(1).gt.rdcf) sign=1.D0
   call rlux(trans,len)
   xpla=xpl*sign*trans(1)
   call rlux(trans,len)
   if(trans(1).le.rdcf) sign=-1.D0
   if(trans(1).gt.rdcf) sign=1.D0
   call rlux(trans,len)
   ypla=ypl*sign*trans(1)
!   WRITE(16,100) XLA,YLA,XPLA,YPLA
   write(16,*) ' Applied random error in alignment:'
   WRITE(16,'(5x,A,2(e12.5,2x),/,5X,A,2(e12.5,2x),/)') &
     ' KICK x(cm)    y(cm)   : ',XLA,YLA, &
     ' KICK xp(mrad) yp(mrad): ',XPLA,YPLA
   DO II=1,ngood
     f(2,ii)=f(2,ii)+xla
     f(4,ii)=f(4,ii)+yla
     f(3,ii)=f(3,ii)+xpla
     f(5,ii)=f(5,ii)+ypla
   enddo
END SUBROUTINE randali
!> *******************************************************************
!! SUBROUTINE corre(n,nall)
!! correction over the beam generated by MONTE
!< *******************************************************************
SUBROUTINE corre(n,nall)
   USE DynacConstants, ONLY : iptsz
   USE m4beam2, ONLY: CORD
   IMPLICIT NONE
   REAL(8) DUM,H,S
   REAL(8) A(6,6),B(6,6),C(6,6),D(6),E(6),F(6),G(6)
   INTEGER I,J,J1,J3,JJ,K,N,NALL
!*******************************************************************
   DO I =1,6
     D(I)=0.D0
     E(I)=0.D0
     F(I)=0.D0
     G(I)=0.D0
     DO J =1,6
       A(I,J)=0.D0
       B(I,J)=0.D0
       C(I,J)=0.D0
     ENDDO
   ENDDO
   DO J =1,6
     DO I =1,N
       D(J)=D(J)+CORD(I,J)
     ENDDO
     D(J)=D(J)/DBLE(N)
   ENDDO
   DO J =1,6
     DO I=1,NALL
       CORD(I,J)=CORD(I,J)-D(J)
     ENDDO
   ENDDO
   DO J=1,6
     DO K=1,J
       DO I=1,N
         A(J,K)=A(J,K)+ CORD(I,J)*CORD(I,K)
       ENDDO
       A(J,K)=A(J,K)/DBLE(N)
     ENDDO
   ENDDO
! WE MAKE MATRIX A=B*BT WHERE B,BT ARE TRIANGULAR
   DO I=1,6
     DO J=1,I
       H=A(I,J)
       J1=J-1
       IF(J.NE.1) then
         DO K=1,J1
           H=H-A(I,K)*A(J,K)
         ENDDO
       ENDIF
       IF(I.NE.J) THEN
         A(I,J)=H/A(J,J)
       ELSE
         A(I,J)=SQRT(H)
       ENDIF
       B(I,J)=A(I,J)
     ENDDO
   ENDDO
!  WE INVERT B TO GIVE AN UPDATED B
   E(1)=1.D0/B(1,1)
   DO I=2,6
     E(I)= 1.D0/B(I,I)
     J1=I-1
     DO JJ=1,J1
       J=I-JJ
       J3=J+1
       S=0.D0
       IF(JJ.NE.1) THEN
         DO K=J3,J1
           S=S-B(K,I)*B(K,J)
         ENDDO
       ENDIF
       B(J,I)=(S-B(I,J)*E(I))/B(J,J)
     ENDDO
   ENDDO
   DO I=1,6
     B(I,I)=E(I)
   ENDDO
   DO I=1,6
     DO J=1,I
       DUM=B(I,J)
       B(I,J)=B(J,I)
       B(J,I)=DUM
     ENDDO
   ENDDO
!  WE CONVERT CORD(**) SO THAT ITS SIGMA MATRIX IS UNITY
   DO I=1,NALL
     DO K=1,6
       F(K)=0.D0
       DO J=1,K
         F(K)=F(K)+ B(K,J)*CORD(I,J)
       ENDDO
     ENDDO
     DO K=1,6
       CORD(I,K)=F(K)
     ENDDO
   ENDDO
!  WE TEST THE MEANS AND SIGMA MATRIX
   DO J=1,6
     DO I=1,N
       G(J)=G(J)+CORD(I,J)
     ENDDO
     G(J)=G(J)/DBLE(N)
   ENDDO
   DO J=1,6
     DO I=1,N
       CORD(I,J)=CORD(I,J)-G(J)
     ENDDO
   ENDDO
   DO J=1,6
     DO K=1,6
       DO I=1,N
         C(J,K)=C(J,K)+ CORD(I,J)*CORD(I,K)
       ENDDO
       C(J,K)=C(J,K)/DBLE(N)
     ENDDO
   ENDDO
!  deallocate(cord)   
END SUBROUTINE corre
!> *******************************************************************
!! SUBROUTINE gcern(len,s,am,v)
!! random number generator based on normal law
!!        s : sigma of the distribution
!!        am: distribution average
!!        v : random number based on normal law
!< *******************************************************************
SUBROUTINE gcern(len,s,am,v)
   USE m4beam2, ONLY: ntir
   IMPLICIT NONE
   INTEGER len,i
   REAL(8) s,am,v
   REAL(8) vecx(1),a,y
!*******************************************************************
   a=0.D0
   do i=1,ntir
     call rlux(vecx,len)
     y=vecx(1)
     a=a+y
   enddo
   v=(a-DBLE(ntir)/2.D0)*s+am
END SUBROUTINE gcern
!> *******************************************************************
!! SUBROUTINE cesp(xlqua)
!! select the space charge method (optical lenses)
!< *******************************************************************
SUBROUTINE cesp(xlqua)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4input
   USE m4spacecharge
   USE m4scheff
   USE m4wforsc, ONLY: DWP
   IMPLICIT NONE
   REAL(8) xlqua
   INTEGER ini,i
   logical isepa
!*******************************************************************
!  Space charge
   SCDIST=0.D0
   IF(ICHAES) then
     DO I=1,ngood
       DWP(I)=0.D0
     enddo
!    XLQUA: length of space charge effect
     if((iscsp.ne.3).and.(ncstat.gt.1)) then
       write(6,*) '****************************'
       write(ierr,'(A,/,A,/,A)') ' ERROR: Wrong space charge model chosen', &
            ' With multiple charge states in the beam', &
            ' only the SCHEFF routine should be used'
       write(16,'(A,/,A,/,A)') ' ERROR: Wrong space charge model chosen', &
            ' With multiple charge states in the beam', &
            ' only the SCHEFF routine should be used'
       STOP
     endif
     SCDIST=XLQUA
     write(16,*) 'Space charge length(cm): ',scdist
     iesp=.true.
     if(iscsp.le.1) then
       ini=1
       call hersc(ini)
       ini=2
       call hersc(ini)
     endif
     if(iscsp.eq.2) call schermi
     if(iscsp.eq.3) then
       if(ncstat.eq.1) call scheff1(1)
!  ---  otherwise: ncstat > 1 check if the bunches are separated or not
       if(ncstat.gt.1) then
         isepa=.false.
         call b_sep(isepa)
! isepa = true  call special scheff --->scheff_sep
! isepa = false call usual scheff ----> scheff1(1)
         if(isepa) then
           write(16,*) ' Bunches/beamlets separated'
           call scheff_sep
         else
           write(16,*) ' Bunches/beamlets not separated'
           call scheff1(1)
         endif
       endif
     endif
   endif
END SUBROUTINE cesp
!> *******************************************************************
!! SUBROUTINE schermi1
!! Called by SCHERMI when the bunch can be represented
!! by a simple ellipse in the longitudinal direction
!< *******************************************************************
SUBROUTINE schermi1
   USE DynacConstants
   USE m4scherm
   USE m4scherm2
   USE m4scherm3
   USE m4cavs
   USE fun4scherm, ONLY: fact,herm
   USE m4beam
   USE m4input
   USE m4spacecharge
   USE m4DEGHERM
   USE m4HERMRR, ONLY: XCGD,YCGD,ZCGD
   USE m4wforsc
   USE m4prtcls
   USE mCOMtwcst
   IMPLICIT NONE
   REAL(8) dxp,dyp,dz,dz1
   REAL(8) bsc,gsc
   REAL(8) zcdg,zcub,zcub1,zcub3,zrmsz,zsqsum
   REAL(8) c1,cl,ext,extp,eyt
   REAL(8) wavel,xcoup,xmass
   REAL(8) xrmsc,xrmsp,yrmsc,yrmsp,zcoup,zmat,zmit
   REAL(8) zrmsc,zrmsp,zz,ycoup
   REAL(8) const2,const3
   REAL(8) ezt,eztp,dw
   INTEGER k,kap,imaxf
   INTEGER i,j,js
   INTEGER imaxx
   REAL(8) afx(20),afy(20)
!*******************************************************************
   if (.not. allocated(DWP)) allocate(DWP(iptsz))
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
   IF(abs(beamc).le.fprec .OR. abs(scdist).le.fprec) return
   IELL=IELL+1
   imaxf=ngood
   wavel=2.D0*pi*vl/fh
   xmass=xmat*1.78267581D-30
   NMAXY=5
   dxp=0.D0
   dyp=0.D0
   dw=0.D0
   dz=scdist/100.D0
   dz1=dz
   if(ngood.eq.0) then
     write(16,*) ' All the particles are lost '
     stop
   endif
! xi in Amps, beamc in mA
! epsilon =(coul*coul)/nt*(m*m)
   epsil=8.854189586D-12
   c1=1.D0/(3.D0*pi*sqrt(5.D0))
   cl=vl/100.D0
! charge per macro particle
!omment       const1=c1*xi*xi*wavel*wavel/(10000.*imaxf*xmass*
!             *         epsilon*cl*cl*cl*cl)
   const3=1.D-06
   const2=1.D-06/xmat
! calculate rms beam size for beam in one point in time
   CALL sizrms(0,xrms,yrms,zrms,zz)
   xrmsp=xrms
   yrmsp=yrms
   zrmsp=zrms
   CALL sizcor(ect,xrms,yrms,zrms,0)
   xrmsc=xrms
   yrmsc=yrms
   zrmsc=zrms
   xrms1=xrmsp
   yrms1=yrmsp
   zrms1=zrmsp
   xrms=xrmsp
   yrms=yrmsp
   zrms=zrmsp
   xcgd=xsum
   ycgd=ysum
   zcgd=zsum
   do i=1,ngood
     ZCP(I)=ZC(I)
     XCP(I)=XC(I)
     YCP(I)=YC(I)
   enddo
!  limits in z-direction
   zmat=0.D0
   zmit=1000.D0
   do i=1,ngood
     IF(ZCP(I).GE.ZMAT) ZMAT=ZCP(I)
     IF(ZCP(I).LT.ZMIT) ZMIT=ZCP(I)
   enddo
   zmat=zmat/zrms
   zmit=zmit/zrms
!    extends zmat
   zmat=zmat+zmat*0.5D0
   zmit=zmit+zmit*0.5D0
   if(zmat.gt.ect) zmat=ect
   if(abs(zmit).gt.ect) zmit=-ect
!    Hermite coefficients in x and y-direction
   nmaz=0
   do k=1,20
     afzt(k)=0.D0
     afxt(k)=0.D0
     afyt(k)=0.D0
     afzm(k)=0.D0
     afxm(k)=0.D0
     afym(k)=0.D0
   enddo
   do k=1,nmaxy
     kap=k-1
     do j=1,ngood
       xcoup=abs(xcp(j)/xrms)
       ycoup=abs(ycp(j)/yrms)
       zcoup=abs(zcp(j)/zrms)
       if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
         xc(j)=xcp(j)/xrmsc
         yc(j)=ycp(j)/yrmsc
         zc(j)=zcp(j)/zrmsc
         afxm(k)=afxm(k)+herm(2*kap,xc(j))
         afym(k)=afym(k)+herm(2*kap,yc(j))
         AFZM(K)=AFZM(K)+HERM(2*KAP,ZC(J))
       endif
     enddo
     afxm(k)=afxm(k)/(fact(2*kap)*sqrt(2.D0*pi))
     afym(k)=afym(k)/(fact(2*kap)*sqrt(2.D0*pi))
     AFZm(K)=AFZm(K)/(FACT(2*KAP)*SQRT(2.D0*PI))
   enddo
   NMAZ=10
!   Hermite coefficients in z-direction
   zcdg=0.D0
   imaxx=0
   do j=1,ngood
     xcoup=abs(xcp(j)/xrms)
     ycoup=abs(ycp(j)/yrms)
     zcoup=abs(zcp(j)/zrms)
     if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
       zcdg=zcdg+zcp(j)
       imaxx=imaxx+1
     endif
   enddo
   zcdg=zcdg/DBLE(imaxx)
   zsqsum=0.D0
   zcub=0.D0
   zcub1=0.D0
   do j=1,ngood
     xcoup=abs(xcp(j)/xrms)
     ycoup=abs(ycp(j)/yrms)
     zcoup=abs(zcp(j)/zrms)
     if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
       zc(j)=zcp(j)-zcdg
       zsqsum=zsqsum+zc(j)*zc(j)
       zcub=zcub+zc(j)*zc(j)*zc(j)
       zcub1=zcub1+zc(j)
     endif
   enddo
   zrmsz=zsqsum/DBLE(imaxx)
   zrmsz=sqrt(zrmsz)
   zcub3=zcub
   zcub=zcub/(zrmsz*zrmsz*zrmsz)-3.D0*zcub1/zrmsz
   zcub=zcub/(6.D0*sqrt(2.D0*pi))
   do k=1,nmaz
     afzt(k)=0.D0
     afx(k)=0.D0
     afy(k)=0.D0
     kap=k-1
     do j=1,ngood
       xcoup=abs(xcp(j)/xrms)
       ycoup=abs(ycp(j)/yrms)
       zcoup=abs(zcp(j)/zrms)
       if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
         zc(j)=zcp(j)/zrmsc
         xc(j)=xcp(j)/xrmsc
         yc(j)=ycp(j)/yrmsc
         afzt(k)=afzt(k)+herm(kap,zc(j))
         afx(k)=afx(k)+herm(kap,xc(j))
         afy(k)=afy(k)+herm(kap,yc(j))
       endif
     enddo
     afzt(k)=afzt(k)/(fact(kap)*sqrt(2.D0*pi))
     afx(k)=afx(k)/(fact(kap)*sqrt(2.D0*pi))
     afy(k)=afy(k)/(fact(kap)*sqrt(2.D0*pi))
   enddo
! Do Hermite integration to determine Ex,Ey,Ez for each macro particle
! and apply space charge kick. Field components are passed through the
! common INTGRT in units Newton/Coulomb
   DO i=1,ngood
!  reprise coordonnees spaciales pour calcul des champs
     xc(i)=xcp(i)
     yc(i)=ycp(i)
     zc(i)=zcp(i)
     CALL INTGA(i,0)
     ext=ex
     eyt=ey
     ezt=ez
! calculate kick in x',y' and z' (energy)
! calculate kick in x',y' and z' (energy)
!   isochronism correction
     eztp=ezt*cos(apl)-ext*sin(apl)
     extp=ezt*sin(apl)+ext*cos(apl)
     ezt=eztp
     ext=extp
     gsc=f(7,i)/xmat
     bsc=sqrt(1.D0-1.D0/(gsc*gsc))
!    *  valero
     dxp=const2*ext*dz/(bsc*bsc*gsc*gsc*gsc)*abs(f(9,i))
     dyp=const2*eyt*dz/(bsc*bsc*gsc*gsc*gsc)*abs(f(9,i))
     dw=const3*ezt*dz*abs(f(9,i))/gsc
!    *
     if(.not.iesp) then
!  load the entrance beam in cavities or gaps
       do js=1,7
         f(js,i)=fs(js,i)
       enddo
       f(3,i)=f(3,i)+dxp*1000.D0
       f(5,i)=f(5,i)+dyp*1000.D0
       f(2,i)=f(2,i)-dz1*dxp*100.D0*xpsc
       f(4,i)=f(4,i)-dz1*dyp*100.D0*xpsc
       dwp(i)=dw
     else
       f(3,i)=f(3,i)+dxp*1000.D0
       f(5,i)=f(5,i)+dyp*1000.D0
       f(7,i)=f(7,i)+dw
     endif
   enddo
END SUBROUTINE schermi1
!> *******************************************************************
!! SUBROUTINE schermi
!! SCHERM space charge method
!! See NIM A 309(1996) 21-40
!< *******************************************************************
SUBROUTINE schermi
   USE DynacConstants
   USE m4scherm
   USE m4scherm2
   USE m4scherm3, ONLY: ex,ey,ez,IMAXR
   USE m4cavs
   USE fun4scherm
   USE m4beam
   USE m4input
   USE m4mcs
   USE m4spacecharge
   USE m4DEGHERM
   USE m4HERMRR
   USE m4wforsc
   USE m4prtcls
   USE mCOMtwcst
   IMPLICIT NONE
   REAL(8) dxp,dyp,dz,dz1
   REAL(8) bsc,gsc
   REAL(8) aa,bb,c1,cc,cl,dd,ee,ee1,ext,extp,eyt,gsct,pcent1,pcent2,pcent3,rs2e,rs3e
   REAL(8) rsnz,srtot,stm12,sz2e,sz3e,szbd,szbt,tzrr,wavel,xcoup,xmam,xmass,xmim
   REAL(8) xrmsc,xrmsp,xymam,xymim,ymam,ymim,yrmsc,yrmsp,zcoup,zf,zi,zmat,zmam,zmim,zmit
   REAL(8) zrmsc,zrmsp,zsot,zz,ycoup,zrmss1
   REAL(8) const2,const3
   REAL(8) dw,pib
   REAL(8) ezt,eztp
   REAL(8) zsot1
   INTEGER i1elli,k,kap,igsct,imaxf,inint
   INTEGER i,j,js
!*******************************************************************
   if (.not. allocated(DWP)) allocate(DWP(iptsz))
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
   IF(abs(beamc).le.fprec .OR. abs(scdist).le.fprec) return
!  dummy: in order to have the same entry as HERSC and SCHEFF
!2025 test: if DC beam, keep particles within +/- 180 deg
!********************************************
   if(ifcont) then
     pib=180.D0
     call compress(pib)
   endif
!********************************************
! Initialize some constants and variables c wavel in cm
   ect=4.D0
   call shuffle
   call pintim
   IELL=IELL+1
   imaxf=ngood
   wavel=2.D0*pi*vl/fh
   xmass=xmat*1.78267581D-30
   NMAZ=14
   NMAZR=8
   NMAXY=4
   dxp=0.D0
   dyp=0.D0
   dw=0.D0
   dz=scdist/100.D0
   dz1=dz
   zsot1=0.D0
   if(ngood.eq.0) then
     write(16,*) ' All the particles are lost '
     stop
   endif
   WRITE(16,*)' call SCHERM N: ',iell
! xi in Amps, beamc in mA
! epsilon =(coul*coul)/nt*(m*m)
   epsil=8.854189586D-12
   c1=1.D0/(3.D0*pi*sqrt(5.D0))
   cl=vl/100.D0
! charge per macro particle
   const3=1.D-06
   const2=1.D-06/xmat
!  normalized emittances(normalized) in m.radian
! calculate rms beam size for beam in one point in time
   CALL sizrms(0,xrms,yrms,zrms,zz)
   xrmsp=xrms
   yrmsp=yrms
   zrmsp=zrms
   CALL sizcor(ect,xrms,yrms,zrms,0)
   write(16,*) ' bunch RMS(m): ',xrms,yrms,zrms
   xrmsc=xrms
   yrmsc=yrms
   zrmsc=zrms
   xrms=xrmsp
   yrms=yrmsp
   zrms=zrmsp
!   Total bunch charge densities in x,y,z
!      calculation of Hermite coefficients
   do i=1,ngood
     zcp(i)=zc(i)
     xcp(i)=xc(i)
     ycp(i)=yc(i)
   enddo
!  limits in z-direction
   zmat=0.D0
   zmit=1000.D0
   do i=1,ngood
     if(zcp(i).ge.zmat) zmat=zcp(i)
     if(zcp(i).lt.zmit) zmit=zcp(i)
   enddo
   zmat=zmat/zrms
   zmit=zmit/zrms
!    extend zmat
   zmat=zmat+zmat*0.5D0
   zmit=zmit+zmit*0.5D0
!    (xmat,ymat,zmat) >0
   if(zmat.gt.ect) zmat=ect
!   if(abs(zmit).gt.ect) zmat=-ect
   if(abs(zmit).gt.ect) zmit=-ect
!   Hermite coefficients
   do k=1,nmaxy
     afxt(k)=0.D0
     afyt(k)=0.D0
     kap=k-1
     do j=1,ngood
       xcoup=abs(xcp(j)/xrms)
       ycoup=abs(ycp(j)/yrms)
       zcoup=abs(zcp(j)/zrms)
       if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
         xc(j)=xcp(j)/xrmsc
         yc(j)=ycp(j)/yrmsc
         afxt(k)=afxt(k)+herm(2*kap,xc(j))
         afyt(k)=afyt(k)+herm(2*kap,yc(j))
       endif
     enddo
     afxt(k)=afxt(k)/(fact(2*kap)*sqrt(2.D0*pi))
     afyt(k)=afyt(k)/(fact(2*kap)*sqrt(2.D0*pi))
   enddo
   do k=1,nmaz
     afzt(k)=0.D0
     kap=k-1
     do j=1,ngood
       xcoup=abs(xcp(j)/xrms)
       ycoup=abs(ycp(j)/yrms)
       zcoup=abs(zcp(j)/zrms)
       if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
         zc(j)=zcp(j)/zrms
         afzt(k)=afzt(k)+herm(kap,zc(j))
       endif
     enddo
     afzt(k)=afzt(k)/(fact(kap)*sqrt(2.D0*pi))
   enddo
!     Look for surface of the bunch
   szbt=snzt(zmit,zmat)
!     Look for the vertex of the distribution n(z)
!        between  0 and zmat/2
   zf=zmat/2.D0
   zi=0.D0
   call rchsom(zi,zf,nmaz)
   zsot=(zi+zf)/2.D0
   zcgd=zsot*zrms
!   Main ellipsoid (in the right of the vertex)
   imaxd=1
   do i=1,ngood
     if(zcp(i).ge.zcgd) then
       xc(imaxd)=xcp(i)
       yc(imaxd)=ycp(i)
       zc(imaxd)=zcp(i)
       imaxd=imaxd+1
     endif
   enddo
   imaxd=imaxd-1
   imaxr=ngood-2*imaxd
   if(imaxr.lt.0) then
! if imaxr<0 => use one ellipse only, rather than 2
     pcent1=DBLE(2*imaxd)/DBLE(ngood)
     pcent2=DBLE(imaxr)/DBLE(ngood)
     iell=iell-1
     write(16,*) ' one ellipsoid in z-direction '
     call pintim
     call schermi1
     return
   endif
   IF(25*IMAXR.LT.IMAXF.OR.IMAXR.LE.30) THEN
     pcent1=DBLE(2*imaxd)/DBLE(ngood)
     pcent2=DBLE(imaxr)/DBLE(ngood)
     iell=iell-1
! if imaxr<.04*imaxf => use one ellipse only, rather than 2
      write(16,*) 'one ellipsoid in z-direction '
     call pintim
     call schermi1
     IF (12*IMAXR.LT.ngood) &
       write(16,*) 'one ellipsoid in z-direction '
     IF (IMAXR.LE.40) &
       write(16,*) ' one ellipsoid in z-direction '
     return
   endif
   i1elli=0
!  C.O.G. of the principal ellipsoid (in cm)
!  longitudinal RMS of the pricipal ellipsoid
   zrmss1=sqrt(vaprz(zsot,zmat))
   zrms1=zrmss1*zrms
!  RMS in the transverse directions
   xrms1=xrms
   yrms1=yrms
!  surface n(z)
   szbd=snzd(zsot,zmat)
   rsnz=szbd/szbt
!  coefficients Hermite en x,y,z sur partie droite en z
!   principal ellipsoid
   do k=1,nmaxy
     kap=k-1
     afxm(k)=afxt(k)*rsnz
     afym(k)=afyt(k)*rsnz
     afzm(k)=prinz(zsot,zmat,k,zrmss1)
     afzm(k)=2.D0*afzm(k)/(fact(2*kap)*sqrt(2.D0*pi))
   enddo
!  limits in x,y,z of the principal ellipsoid
   do i=1,imaxd
     xc(i)=xc(i)/xrms
     yc(i)=yc(i)/yrms
     zc(i)=zc(i)/zrms
   enddo
   xmam=xc(1)
   ymam=yc(1)
   zmam=zc(1)
   do i=1,imaxd
     if(xc(i).ge.xmam) xmam=xc(i)
     if(yc(i).ge.ymam) ymam=yc(i)
     if(zc(i).ge.zmam) zmam=zc(i)
   enddo
   if(abs(xmam).ge.ect) xmam=ect
   if(abs(ymam).ge.ect) ymam=ect
   if(abs(zmam).ge.ect) zmam=ect
   xmim=xmam
   ymim=ymam
   zmim=zmam
   do i=1,imaxd
     if(xc(i).lt.xmim) xmim=xc(i)
     if(yc(i).lt.ymim) ymim=yc(i)
     if(zc(i).lt.zmim) zmim=zc(i)
   enddo
   if(abs(xmim).ge.ect) xmim=-ect
   if(abs(ymim).ge.ect) ymim=-ect
   if(abs(zmim).ge.ect) zmim=-ect
!  partition commune @ x,y,z
   xymam=ymam
   xymim=ymim
   if(xmam.ge.xymam) xymam=xmam
   if(zmam.ge.xymam) xymam=zmam
   if(xmim.lt.xymim) xymim=xmim
   if(zmim.lt.xymim) xymim=zmim
!  symmetrisation de l'intervalle
   if(abs(xymim).ge.xymam) then
     xymam=abs(xymim)
   else
     xymim=-xymam
   endif
!  vertex of the second ellipsoid
   aa=zmit
   bb=2.D0*zsot-zmat
   cc=zsot
   dd=zmat
   call rchsor(aa,bb,cc,dd,ee)
! second ellipsoid  around ee
!    sz2e : surface
   zrms2=varia(bb,cc,dd,ee)
   zrms2=sqrt(zrms2)
   zcgr=ee*zrms
   sz2e=codsy(bb,cc,dd,ee,1)
   afzr(1)=sz2e/sqrt(2.D0*pi)
   stm12=abs(afzt(1)-afzm(1)-afzr(1))
   rs2e=sz2e/szbt
   xrms2=xrms
   yrms2=yrms
   do k=1,nmaxy
     kap=k-1
     afxr(k)=afxt(k)*rs2e
     afyr(k)=afyt(k)*rs2e
     afzr(k)=codsy(bb,cc,dd,ee,k)
     afzr(k)=afzr(k)/(fact(2*kap)*sqrt(2.D0*pi))
   enddo
!   two ellipsoids:
   if(stm12*10.D0 .le. afzr(1)) inint=2
   if(stm12*10.D0 .gt. afzr(1)) then
!   3 ellipsoids;the principal ellipsoid,the second ellipsoid is symmetrized
!    the third ellipsoid is defined around the c. of g. of the residu
     ee1=grz(aa,bb,cc,dd,ee)
     if(ee1.gt.ee) then
       inint=2
     else
       zrms3=variz(bb,cc,dd,ee,ee1)
       zrms3=sqrt(zrms3)
       xrms3=xrms
       yrms3=yrms
       zcgr3=ee1*zrms
!    C.O.G. of the second ellipsoid
!    on suppose xcgr et ycgr nuls pour le residu
       xcgr=0.D0
       ycgr=0.D0
       sz3e=codif(bb,cc,dd,ee,ee1,1)
       rs3e=sz3e/szbt
!    correction complementaire
       srtot=sz3e/sqrt(2.D0*pi)+afzr(1)+afzm(1)
       srtot=srtot-afzt(1)
!   HERMITE coefficients over the residual ellipse
       do k=1,nmaxy
         kap=k-1
         afxrr(k)=afxt(k)*rs3e
         afyrr(k)=afyt(k)*rs3e
         afzrr(k)=codif(bb,cc,dd,ee,ee1,k)
         afzrr(k)=afzrr(k)/(fact(2*kap)*sqrt(2.D0*pi))
         if(k.eq.1) then
           tzrr=afzrr(k)-srtot
           if(tzrr.ge.0.D0 .and. abs(tzrr).ge.(afzrr(k)/10.D0)) then
             afxrr(k)=afxrr(k)-srtot
             afyrr(k)=afyrr(k)-srtot
             afzrr(k)=afzrr(k)-srtot
           endif
         endif
       enddo
! end of calculus of 2nd ellipse
       inint=3
     endif
   endif
   if(ee1.le.ee) zrms3=zrms3*zrms
   zrms2=zrms2*zrms
!    surface of the ellipsoids in pourcent
   write(16,*) ' surface of the ellipsoids in % of the bunch:'
   if(inint.eq.2) then
     pcent1=afzm(1)/afzt(1)
     pcent2=afzr(1)/afzt(1)
     write(16,'(2x,i4,2x,f7.4,2x,f7.4)') iell,pcent1,pcent2
   endif
   if(inint.eq.3) then
     pcent1=afzm(1)/afzt(1)
     pcent2=afzr(1)/afzt(1)
     pcent3=afzrr(1)/afzt(1)
     write(16,'(2x,i4,2x,f7.4,2x,f7.4,2x,f7.4)') iell,pcent1,pcent2,pcent3
   endif
! Do Hermite integration to determine Ex,Ey,Ez for each macro particle
! and apply space charge kick. Field components are passed through the
! common INTGRT in units Newton/Coulomb
!       gsct introduit pour calcul specifique impulsion
   gsct=0.D0
   igsct=0
   DO i=1,ngood
!  reprise coordonnees spaciales pour calcul des champs
     xc(i)=xcp(i)
     yc(i)=ycp(i)
     zc(i)=zcp(i)
!  principal ellipsoid
     CALL INTGA(i,0)
     ext=ex
     eyt=ey
     ezt=ez
!  second ellipsoid
     CALL INTGA(i,1)
     ext=ext+ex
     eyt=eyt+ey
     ezt=ezt+ez
!  third ellipsoid
     if(inint.eq.3) then
       CALL INTGA(i,2)
       ext=ext+ex
       eyt=eyt+ey
       ezt=ezt+ez
     endif
! calculate kick in x',y' and z' (energy)
!   isochronism correction
     eztp=ezt*cos(apl)-ext*sin(apl)
     extp=ezt*sin(apl)+ext*cos(apl)
     ezt=eztp
     ext=extp
     gsc=f(7,i)/xmat
     gsct=gsct+gsc
     igsct=igsct+1
     bsc=sqrt(1.D0-1.D0/(gsc*gsc))
     dxp=const2*ext*dz/(bsc*bsc*gsc*gsc*gsc)*abs(f(9,i))
     dyp=const2*eyt*dz/(bsc*bsc*gsc*gsc*gsc)*abs(f(9,i))
     dw=const3*ezt*dz/gsc
     if(.not.iesp) then
!  load the entrance beam parameters for cavities or gaps
       do js=1,7
         f(js,i)=fs(js,i)
       enddo
       f(3,i)=f(3,i)+dxp*1000.D0
       f(5,i)=f(5,i)+dyp*1000.D0
       f(2,i)=f(2,i)-dz1*dxp*100.D0*xpsc
       f(4,i)=f(4,i)-dz1*dyp*100.D0*xpsc
!omment           f(2,i)=f(2,i)-dz1*dxp*100.
!omment           f(4,i)=f(4,i)-dz1*dyp*100.
       dwp(i)=dw
     else
       f(3,i)=f(3,i)+dxp*1000.D0
       f(5,i)=f(5,i)+dyp*1000.D0
       f(7,i)=f(7,i)+dw
     endif
   enddo
END SUBROUTINE schermi
!> *******************************************************************
!! SUBROUTINE intga(npt,ireca)
!! Calculate the beam self fields acting on each particle (called by
!! SCHERM) Gauss quadrature
!< *******************************************************************
SUBROUTINE intga(npt,ireca)
   USE DynacConstants
   USE m4scherm
   USE m4scherm2
   USE m4scherm3, ONLY: ex,ey,ez
   USE m4cavs
   USE fun4scherm, ONLY: drxyz
   USE m4beam
   USE m4input
   USE m4mcs
   USE m4spacecharge
   USE m4DEGHERM
   USE m4HERMRR
   USE m4prtcls, ONLY: xc,yc,zc
   USE m4hersc8, ONLY: ratei
   USE mCOMtwcst
   IMPLICIT NONE
   REAL(8) xrmsc,yrmsc,zrmsc
   REAL(8) const,freq,a1,a2,a3,dnorm,dsq,ff1,fxn,fyn,fzn,onethird,qmpart,t1,t2,t3
   REAL(8) txyz,xgc,xsq,ygc,ysq,zc1,zc2,zgc,zsq
   INTEGER npt,ireca
   INTEGER j
   REAL(8) UI(6),WI(6)
   DATA (UI(J),J=1,6)/.033765D0,.169395D0,.380690D0,.619310D0,.830605D0, &
        .966234D0/
   DATA (WI(J),J=1,6)/.085662D0,.180381D0,.233957D0,.233957D0,.180381D0, &
        .085662D0/
!*******************************************************************
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
!
! Initialize some constants and variables
! freq. in MHz
   freq=fh*0.5D-6/pi
! qmpart=coul , xrms=meters
!    ireca=0 : first ellipsoid  over nmaxy terms
!    ireca=4 : one ellipsoid over the first term
   xrmsc=0.D0
   yrmsc=0.D0
   zrmsc=0.D0
   xgc=0.D0
   ygc=0.D0
   zgc=0.D0
   if(ireca.eq.0.or.ireca.eq.4) then
     xrmsc=xrms1
     yrmsc=yrms1
     zrmsc=zrms1
     xgc=xcgd
     ygc=ycgd
     zgc=zcgd
   endif
! ireca=1 : second ellipsoid
   if(ireca.eq.1) then
     xrmsc=xrms2
     yrmsc=yrms2
     zrmsc=zrms2
     xgc=xcgr
     ygc=ycgr
     zgc=zcgr
   endif
! ireca=2 : third elllipsoid
   if(ireca.eq.2) then
     xrmsc=xrms3
     yrmsc=yrms3
     zrmsc=zrms3
     xgc=0.D0
     ygc=0.D0
     zgc=zcgr3
   endif
   qmpart=1.0D-9*beamc/(DBLE(imax)*freq)
!omment        const=qmpart*xrmsc*yrmsc*zrmsc/(2.D0*epsilon)
   qmpart=qmpart*ratei
   const=qmpart/(2.D0*epsil)
   onethird=1.D0/3.D0
   dnorm=(xrmsc*yrmsc*zrmsc)**onethird
   dsq=dnorm*dnorm
   xsq=(xc(npt)-xgc)*(xc(npt)-xgc)
   ysq=(yc(npt)-ygc)*(yc(npt)-ygc)
   zsq=(zc(npt)-zgc)*(zc(npt)-zgc)
   if(ireca.eq.0) zc1=zc(npt)-zgc
   if(ireca.eq.1) zc2=zc(npt)-zgc
   ex=0.D0
   if(ireca.eq.2) zc2=zc(npt)-zgc
   ey=0.D0
   ez=0.D0
! initialize integrals to 0.
! integrate all 3 components (x,y,z)
   DO J=1,6
     a1=xrmsc*xrmsc-dsq+dsq/ui(j)
     a2=yrmsc*yrmsc-dsq+dsq/ui(j)
     a3=zrmsc*zrmsc-dsq+dsq/ui(j)
     t1=xsq/a1
     t2=ysq/a2
     t3=zsq/a3
     txyz=sqrt(t1+t2+t3)
     ff1=drxyz(nmaxy,txyz,ireca)/(ui(j)*ui(j)*sqrt(a1*a2*a3))
     fxn=ff1/a1
     fyn=ff1/a2
     fzn=ff1/a3
     ex=ex+wi(j)*fxn*dsq
     ey=ey+wi(j)*fyn*dsq
     ez=ez+wi(j)*fzn*dsq
   ENDDO
! Field components are in Newton/Coulomb
   ex=ex*const*xc(npt)
   ey=ey*const*yc(npt)
   ez=ez*const*(zc(npt)-zgc)
END SUBROUTINE intga
!> *******************************************************************
!! SUBROUTINE sizcor(ect,xrms,yrms,zrms,imaxd)
!! Computes the R.M.S. of the bunch at positions of space charge
!! computation
!< *******************************************************************
SUBROUTINE sizcor(ect,xrms,yrms,zrms,imaxd)
   USE DynacConstants, ONLY: iptsz
   USE m4beam, ONLY: ngood
   USE m4prtcls, ONLY: xc,yc,zc
   USE m4scherm3, ONLY: xsum,ysum,zsum
   IMPLICIT NONE
   REAL(8) ect,xrms,yrms,zrms
   REAL(8) xcoup,ycoup,zcoup,xsqsum,ysqsum,zsqsum
   REAL(8) xrmsp,yrmsp,zrmsp
   INTEGER IMAXD
   INTEGER i,imaxf,imaxx
!*******************************************************************
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
   imaxf=0
   imaxx=ngood
   xsum=0.D0
   ysum=0.D0
   zsum=0.D0
   xrmsp=xrms
   yrmsp=yrms
   zrmsp=zrms
   xsqsum=0.D0
   ysqsum=0.D0
   zsqsum=0.D0
   if(imaxd.gt.0) imaxx=imaxd
   do  i=1,imaxx
     xcoup=abs(xc(i)/xrmsp)
     ycoup=abs(yc(i)/yrmsp)
     zcoup=abs(zc(i)/zrmsp)
     if(xcoup.le.ect.and.ycoup.le.ect.and.zcoup.le.ect) then
       xsum=xsum+xc(i)
       ysum=ysum+yc(i)
       zsum=zsum+zc(i)
       xsqsum=xsqsum+xc(i)*xc(i)
       ysqsum=ysqsum+yc(i)*yc(i)
       zsqsum=zsqsum+zc(i)*zc(i)
       imaxf=imaxf+1
     endif
   enddo
   xsum=xsum/DBLE(imaxf)
   ysum=ysum/DBLE(imaxf)
   zsum=zsum/DBLE(imaxf)
   xsqsum=xsqsum/DBLE(imaxf)
   ysqsum=ysqsum/DBLE(imaxf)
   zsqsum=zsqsum/DBLE(imaxf)
   xrms=SQRT(xsqsum-xsum*xsum)
   yrms=SQRT(ysqsum-ysum*ysum)
   zrms=SQRT(zsqsum-zsum*zsum)
END SUBROUTINE sizcor
!> *******************************************************************
!! SUBROUTINE sizrms(imaxd,xrms,yrms,zrms,zmin)
!! partial R.M.S. (called by SCHERM and SCHEFF)
!< *******************************************************************
SUBROUTINE sizrms(imaxd,xrms,yrms,zrms,zmin)
   USE DynacConstants
   USE m4beam
   USE m4prtcls, ONLY: xc,yc,zc
   USE m4scherm3, ONLY: xsum,ysum,zsum
   IMPLICIT NONE
   INTEGER imaxx,imaxd,i
   REAL(8) xrms,yrms,zrms,zmin
   REAL(8) xsqsum,ysqsum,zsqsum
!*******************************************************************
!   if (.not. allocated(xc)) allocate(xc(iptsz))
!   if (.not. allocated(yc)) allocate(yc(iptsz))
!   if (.not. allocated(zc)) allocate(zc(iptsz))
   imaxx=ngood
   xsum=0.D0
   ysum=0.D0
   zsum=0.D0
   if(imaxd.gt.0) then
     do i=1,imaxd
       zc(i)=zc(i)-zmin
     enddo
     imaxx=imaxd
   endif
   xsqsum=0.D0
   ysqsum=0.D0
   zsqsum=0.D0
   do i=1,imaxx
     xsum=xsum+xc(i)
     ysum=ysum+yc(i)
     zsum=zsum+zc(i)
     xsqsum=xsqsum+xc(i)*xc(i)
     ysqsum=ysqsum+yc(i)*yc(i)
     zsqsum=zsqsum+zc(i)*zc(i)
   enddo
   xsum=xsum/DBLE(imaxx)
   ysum=ysum/DBLE(imaxx)
   zsum=zsum/DBLE(imaxx)
   xsqsum=xsqsum/DBLE(imaxx)
   ysqsum=ysqsum/DBLE(imaxx)
   zsqsum=zsqsum/DBLE(imaxx)
   xrms=SQRT(xsqsum-xsum*xsum)
   yrms=SQRT(ysqsum-ysum*ysum)
   zrms=SQRT(zsqsum-zsum*zsum)
END SUBROUTINE sizrms
!> *******************************************************************
!! SUBROUTINE pintim
!! Shifts particle coordinates to a single point in time. Uses a
!! linear shift. Divide by 100 to convert from cm to meters
!! Called by SCHEFF or SCHERM
!< *******************************************************************
SUBROUTINE pintim
   USE DynacConstants
   USE m4beam
   USE m4input
   USE m4spacecharge
   USE m4prtcls, ONLY: xc,yc,zc
   IMPLICIT NONE
   INTEGER i,np
   REAL(8) grmoy,trmoy,xbax,xb2x,xb2z,xbxz,bpai,brmoy,f3,f5,gpai,xbar,xnp,ybar,zbar,znp
!*******************************************************************
!   if (.not. allocated(xc)) allocate(xc(iptsz))
!   if (.not. allocated(yc)) allocate(yc(iptsz))
!   if (.not. allocated(zc)) allocate(zc(iptsz))
   grmoy=0.D0
   trmoy=0.D0
   xbax=0.D0
   do i=1,ngood
     grmoy=grmoy+f(7,i)/xmat
     trmoy=trmoy+f(6,i)
     xbax=xbax+f(2,i)
   enddo
   trmoy=trmoy/DBLE(ngood)
   grmoy=grmoy/DBLE(ngood)
   brmoy=sqrt(1.D0-1.D0/(grmoy*grmoy))
   xbax=xbax/DBLE(ngood)
   apl=0.D0
!  Isochronism correction  (bending magnet) only with SCHERM
!    does not work with  with SCHEFF  (iscsp=3)
   if(iscsp.eq.2) then
     xb2x=0.D0
     xb2z=0.D0
     xbxz=0.D0
     do np=1,ngood
       gpai=f(7,np)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       zc(np)=(trmoy-f(6,np))*bpai*vl/100.D0
       xc(np)=(f(2,np)-xbax)/100.D0
       xb2z=xb2z+zc(np)*zc(np)
       xb2x=xb2x+xc(np)*xc(np)
       xbxz=xbxz+zc(np)*xc(np)
     enddo
     xb2z=xb2z/DBLE(ngood)
     xb2x=xb2x/DBLE(ngood)
     xbxz=xbxz/DBLE(ngood)
     apl=atan(-2.D0*xbxz/(xb2x-xb2z))/2.D0
     write(16,*) 'slope of the bunch in plane(Oz,Ox):',apl, &
                 ' radian'
   endif
   do np=1,ngood
     gpai=f(7,np)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
!  iscsp = 3 Lorentz transformation (only with scheff)
!omment         if(iscsp.eq.3) znp=(trmoy-f(6,np))*bpai*vl*grmoy
!omment         if(iscsp.eq.2) znp=(trmoy-f(6,np))*bpai*vl
     znp=(trmoy-f(6,np))*bpai*vl
     xnp=f(2,np)
     zc(np)=znp*cos(apl)+xnp*sin(apl)
     xnp=xnp*cos(apl)-znp*sin(apl)
!    convert from mrad to rad
     f3=f(3,np)*1.D-03
     f5=f(5,np)*1.D-03
!    convert from cm   to m
     xc(np)=(xnp+zc(np)*f3)/100.D0
     yc(np)=(f(4,np)+zc(np)*f5)/100.D0
     zc(np)=zc(np)/100.D0
   enddo
   xbar=0.D0
   ybar=0.D0
   zbar=0.D0
   do np=1,ngood
!  evaluate xbar , ybar , zbar
     xbar=xbar+xc(np)
     ybar=ybar+yc(np)
     zbar=zbar+zc(np)
   enddo
   xbar=xbar/DBLE(ngood)
   ybar=ybar/DBLE(ngood)
   zbar=zbar/DBLE(ngood)
!  Translate distribution by center of mass coordinates to shift
!  coordinate origin to (0,0,0)
   do np=1,ngood
     xc(np)=xc(np)-xbar
     yc(np)=yc(np)-ybar
     zc(np)=zc(np)-zbar
   enddo
END SUBROUTINE pintim
!> *******************************************************************
!! SUBROUTINE schfdyn
!! Input data for SCHEFF
!!   SCE(2)=r extension in rms multiples
!!   SCE(3)=z half extension in rms multiples
!!   SCE(4)=no. of radial mesh intervals (le 20)
!!   SCE(5)=no. of longitudinal mesh intervals (le 40)
!!   sce(6)=no. of adjacent bunches, applicable for buncher studies
!!          and should be 0 for linac dynamics
!!   sce(7)=pulse length, if not beta lambda.(transport studies)
!!          distance bewteen beam pulses
!!          input zero to get default "beta lambda"
!!          units are cm
!!   sce(8)=dummy
!!   sce(9)=option to integrate space charge forces over box
!!          if.eq.0. no integration.  see sub gaus for further
!!          explanation.
!< *******************************************************************
SUBROUTINE schfdyn
   USE m4input
   USE m4spacecharge
   USE m4scheff
   IMPLICIT NONE
   real(8) fread
!*******************************************************************
   read(in,*) fread
   if(int(fread).eq.0) then
!    standard SCHEFF parameters
     sce(2)=4.D0
     sce(3)=4.D0
     sce(4)=20
     sce(5)=40
     sce(6)=0
     sce(9)=0.D0
     sce(7)=0.D0
   else
!    read  SCHEFF parameters
     READ(IN,*) sce(2),sce(3),sce(4),sce(5),sce(6),sce(7),sce(9)
   endif
   write(16,*)" Settings used: ",sce(2),sce(3),sce(4),sce(5),sce(6),sce(7),sce(9)   
   sce(3)=sce(3)*2.D0
   sce(8)=0.D0
   call schefini
END SUBROUTINE schfdyn
!> *******************************************************************
!! SUBROUTINE schefini
!! Set up field tables for SCHEFF1 and SCHEFF_sep
!! input data
!!         sce(2)=radial extension in rms multiples
!!         sce(3)=longitudinal extension in rms multiples
!!         sce(4)=no. of radial mesh intervals (le 20)
!!         sce(5)=no. of longitudinal mesh intervals (le 40)
!!         sce(6)=no. of adjacent bunches, applicable for buncher
!!                studies and should be 0 for linac dynamics
!!         sce(7)=distance between adjacent beam pulses in cm
!!                (transport studies); input zero to get (beta*lambda)
!!                default
!!         sce(8)=deactivated
!!         sce(9)=option to integrate space charge forces over box
!!                  if.eq.0. no integration  see sub gaus for further
!!                  explanation.
!!         sce(10) =1 : call in quads,solenoids,accelarating elements
!!         sce(10) =2 : call in drifts,accelarating elements
!!         sce(10) =3 : call at both
!!  standard SCHEFF parameters (see user guide)
!!         sce(2)=4
!!         sce(3)=4
!!         sce(4)=20
!!         sce(5)=40
!!         sce(6)=0
!!         sce(7)=0
!!         sce(9)=0
!< *******************************************************************
SUBROUTINE schefini
   USE DynacConstants
   USE m4beam, ONLY: ngood,xmat,f
   USE m4cavs
   USE m4spacecharge
   USE m4scheff
   USE m4scheff2, ONLY: irfqp
   IMPLICIT NONE
   INTEGER np,na,nb
   REAL(8) gmoy,bgmoy
!*******************************************************************
   gmoy=0.D0
   do np=1,ngood
     gmoy=f(7,np)/xmat+gmoy
   enddo
   gmoy=gmoy/DBLE(ngood)
   bgmoy=sqrt(gmoy*gmoy-1.D0)
   beams=beamc/1000.D0
   wavel=2.D0*pi*vl/fh
   freq=fh/(2.D0*pi)
   frrms=sce(2)
   fzrms=sce(3)
   nr=idint(sce(4))
   nz=idint(sce(5))
   nip=idint(sce(6))
   opt=sce(9)
   pl=bgmoy*wavel
   if(irfqp) pl=pl/2.D0
!  sce(7)=pulse length, if not beta lambda.(transport studies), units are cm
   if(sce(7).gt. 0.D0) pl=sce(7)*gmoy
   nr1=nr+1
   nz1=nz+1
   im1=nr*nz
   im2=nr1*nz1
   im3=nr1*nz
   na=1
   nb=ngood
   nq=nb-na+1
END SUBROUTINE schefini
!> *******************************************************************
!! SUBROUTINE scheff1(idum)
!! SCHEFF space charge method
!! remark: In this version int is a dummy parameter
!! This version of SCHEFF, starting from Swenson version, has
!! modifications made to include corrections for relativistic beams.
!! The dynamics have been modified to transform to the beam rest
!! frame, calculate the space-charge kicks in this frame, and then
!! transform back to the lab frame.
!!     input data
!!         sce(1)=beam current in ma.
!!         sce(2)=radial extension in rms multiples
!!         sce(3)=longitudinal extension in rms multiples
!!         sce(4)=no. of radial mesh intervals (le 20)
!!         sce(5)=no. of longitudinal mesh intervals (le 40)
!!         sce(6)=no. of adjacent bunches, applicable for buncher
!!                studies and should be 0 for linac dynamics
!!         sce(7)=distance between adjacent beam pulses in cm
!!                (transport studies); input zero to get (beta*lambda)
!!                default
!!         sce(8)=deactivated
!!         sce(9)=option to integrate space charge forces over box
!!                  if.eq.0. no integration  see sub gaus for further
!!                  explanation.
!!         sce(10) =1 : call in quads,solenoids,accelarating elements
!!         sce(10) =2 : call in drifts,accelarating elements
!!         sce(10) =3 : call at both
!!  standard SCHEFF parameters (see sub schfdyn and user guide)
!!         sce(2)=4
!!         sce(3)=4
!!         sce(4)=20
!!         sce(5)=40
!!         sce(6)=0
!!         sce(7)=0
!!         sce(9)=0
!< *******************************************************************
SUBROUTINE scheff1(idum)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4wforsc
   USE m4prtcls
   USE m4plots, ONLY: uden
   USE m4scheff2
   IMPLICIT NONE
   REAL(8) a,a1,b,beta,bg,bgx,bgy,bgz,bgzf,bgzstar,brmoy,c,c1,c2,c3,c4
   REAL(8) cbgr,cbgzs,cc,d,dist,dr,dwc,dws,dww,dxp,dyp,dz,dz1,eng,epsqi
   REAL(8) epsq,er1,ez1,f3,f3np,f5,f5np,f6i,fhbu,gam,gamma,gm1,gmoy
   REAL(8) gmsq,gpai,gstar,halfdr,hl
   REAL(8) rfac,rmax,rmaxsq,rminsq
   REAL(8) pbar,pbgzstar,phimc,pib,q,r,rb,rdr2,rod3
   REAL(8) rrms,rsq,s,sqr,trmoy,x,xbar,xfac,xi,xor,xrms,yrms,zrms,zz
   REAL(8) xsq,y,ybar,rrmax,yfac,yor,ysq,z,zb,zbar,zod3,zph,zrms1,zs,zzmax,zzmin
   INTEGER i,idum,i1,idm,ie,iem,ilost,is,ism,j,j1,je,jm1,js,js1
   INTEGER k,l,m,n,n1,ng,np,npr,npz
   INTEGER k1
   INTEGER lossreason   
   character(len=8) :: PRTLAB
!*******************************************************************
   if (.not. allocated(DWP)) allocate(DWP(iptsz))   
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
   idm=idum
! set up field tables with int=0
!********************************************
   if(ifcont) then
     pib=180.D0
     call compress(pib)
   endif
!********************************************
   PRTLAB='SCHEFF  '
   fhbu=fh
   fh=fhinit
   beamc=beamc*fh/fhbu
   idm=0
   gmoy=0.D0
   do np=1,ngood
     gmoy=f(7,np)/xmat+gmoy
   enddo
   gmoy=gmoy/DBLE(ngood)
   beami=beams
   IF(abs(beami).le.fprec .OR. abs(scdist).le.fprec) return
   IELL=IELL+1
   call pintim
   CALL sizrms(0,xrms,yrms,zrms,zz)
   write(16,'(A,i4,A,e12.5,2x,e12.5,2x,e12.5)') ' Cell ',iell, &
            ' RMS size(m)',xrms,yrms,zrms
   rrms=sqrt(xrms*xrms+yrms*yrms)
!    change unit: m==>cm
   zrms1=zrms*100.D0
   rrms=rrms*100.D0
   dr=rrms*frrms/DBLE(nr)
   dz=zrms1*fzrms/DBLE(nz)
   rmax=DBLE(nr)*dr
!      load rm, zm, rs, zs
   rm(1)=0.D0
   do i=2,nr1
     rm(i)=DBLE(i-1)*dr
     rssq(i-1)=0.5D0*(rm(i-1)**2+rm(i)**2)
     rss(i-1)=0.5D0*(rm(i-1)+rm(i))
     rs(i-1)=sqrt(rssq(i-1))
   enddo
   zs=0.5D0*dz
! zm() has mesh z start/end, zzs has z mid mesh    
   do i=1,nz1
     zm(i)=DBLE(i-1)*dz
     zzs(i)=zm(i)+zs
   enddo
   hl=DBLE(nz)*zs
!  load ers and ezs
!     mesh dimensions are in cm. ers and ezs are in 1/cm.
!     c1, c2 and c3 are in cm., and c4 is in mev-cm.
!     q=coulombs/point.   (2/pi)*e/(4*pi*epsilon)=572167 cm MeV/coul.
   q=beami/(freq*DBLE(nq))
   c1=572167.D0*q/xmat
   l=0
   do k=1,nr
     rfac=(rm(k+1)**2-rm(k)**2)*dz/2.D0
!     if(opt.eq.0.) rfac=1.D0
     if(abs(opt).le.fprec) rfac=1.D0
     do j=1,nz
       zp=zm(j+1)
       do i=1,nr1
         rp=rm(i)
!         if(opt.eq.0.) then
         if(abs(opt).le.fprec) then
           call flds(rs(k),zs,er1,ez1)
         else
           call gaus (rm(k),rm(k+1),zm(1),zm(2),opt,er1,ez1)
         endif
         l=l+1
         ers(l)=c1*er1/rfac
         ezs(l)=c1*ez1/rfac
       ENDDO
     ENDDO
   ENDDO
   IF(abs(beamc).le.fprec .OR. abs(scdist).le.fprec) return
   dz1=scdist/100.D0
   dist=scdist
! sup       WRITE(16, *) ' fields acting length(cm): ',DIST
!          evaluate and apply space charge effects.
!     phimc=phi of mesh center.
!   Shifts particle coordinates to a single point in time. Uses
!   a linear shift
!      Beam c.g.
   xbar=0.D0
   ybar=0.D0
   zbar=0.D0
   brmoy=0.D0
   trmoy=0.D0
   do np=1,ngood
     gpai=f(7,np)/xmat
     if(gpai.gt.1.0D0) brmoy=brmoy+sqrt(1.D0-1.D0/(gpai*gpai))     
     trmoy=trmoy+f(6,np)
   enddo
   trmoy=trmoy/DBLE(ngood)
   phimc=trmoy*fh
   pbar=phimc
   beta=brmoy/DBLE(ngood)
   gsc=1.D0/sqrt(1.D0-beta*beta)
   bg=beta*gsc
   c3=dist/bg
! next one c4 not used ?
   c4=dist*xmat
!      evaluate ng, xbar, ybar, and pbar.
   c2=bg*wavel/(2.D0*pi)
   gmsq=1.D0+bg**2
   gam=sqrt(gmsq)
!      evaluate ng, xbar, ybar
!   ng=0
   xbar=0.D0
   ybar=0.D0
   xsq=0.D0
   ysq=0.D0
   do np=1,ngood
!     ng=ng+1
     x=f(2,np)
     y=f(4,np)
!2025     xf=f(3,np)
!2025     yf=f(5,np)
     xbar=xbar+x
     ybar=ybar+y
     xsq=xsq+x**2
     ysq=ysq+y**2
   enddo
   eng=DBLE(ngood)
   xbar=xbar/eng
   ybar=ybar/eng
   xsq=xsq/eng
   ysq=ysq/eng
   epsq=sqrt((xsq-xbar*xbar)/(ysq-ybar*ybar))
   epsqi=1.D0/epsq
   xfac=2.D0/(epsq + 1.D0)
   yfac=epsq*xfac
!      clear and load bins
   ng=0
   do i=1,im1
     aa(i)=0.D0
   enddo
   do np=1,ngood
     rsq=(f(2,np)-xbar)**2*epsqi+(f(4,np)-ybar)**2*epsq
! i=sqrt(rsq)/dr+1.
     r=sqrt(rsq)
     halfdr=dr*0.5D0
     i=idint(r/dr+1.D0)
     if (i.gt.nr) cycle
     zph=f(6,np)*fh
!  phimc is the mesh center 
     z=-c2*(zph-phimc)
     if (abs(z).ge.hl) cycle
!------distribute charge among adjacent bins.
     ng=ng+1
     zz=z+hl
     jm1=idint(zz/dz+1.D0)
     i1=i+1
     if (rsq.lt.rssq(i)) i1=i-1
!     if (rsq.lt.rss (i)) i1=i-1
     if (i1.lt.1) i1=1
     if (i1.gt.nr) i1=nr
     j1=jm1+1
     if (zz.lt.zzs(jm1)) j1=jm1-1
     if (j1.lt.1) j1=1
     if (j1.gt.nz) j1=nz
     a=1.D0
!  if (i1.ne.i) a=(rsq-rssq(i1))/(rssq(i)-rssq(i1))
     if (i1.ne.i) then
       rdr2=rsq/dr**2
       if(rdr2.gt.0.25D0) then
         sqr=sqrt(4.D0*rdr2-1.D0)
       else
         f(8,np)=0.D0
         ilost=ilost+1
! needs to be on energy
         lossreason=1
         f6i=f(6,np)-trmoy
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,A25)') &
         PRTLAB,idm,davtot/100.D0,i,int(f(1,np)), &
          f(2,np),f(3,np),f(4,np),f(5,np),f6i*fh*180.D0/pi, &
          f(7,np)-xmat,f(9,np),lossreason,uden
         cycle
       endif
       rminsq=(halfdr*(sqr-1.D0))**2
       rmaxsq=(halfdr*(sqr+1.D0))**2
       if (i1.lt.i) then
         a=(rmaxsq-rm(i)**2)/(rmaxsq-rminsq)
       else
         a=(rm(i1)**2-rminsq)/(rmaxsq-rminsq)
       endif
     endif
!omment         if (r.gt.halfdr)then
!omment           rminsq=(r-halfdr)**2
!omment           rmaxsq=(r+halfdr)**2
!omment           if (i1.lt.i) then
!omment             a=(rmaxsq-rm(i)**2)/(rmaxsq-rminsq)
!omment           else
!omment             a=(rm(i1)**2-rminsq)/(rmaxsq-rminsq)
!omment           endif
!omment         endif
     b=1.D0-a
     cc=1.D0
     if (j1.ne.jm1) cc=(zz-zzs(j1))/(zzs(jm1)-zzs(j1))
     d=1.D0-cc
     k=(jm1-1)*nr+i
     aa(k)=aa(k)+a*cc
     k=k+i1-i
     aa(k)=aa(k)+b*cc
     k=(j1-1)*nr+i
     aa(k)=aa(k)+a*d
     k=k+i1-i
     aa(k)=aa(k)+b*d
   enddo
   eng=DBLE(ng)
   do j=1,nz
     l=(j-1)*nr
     k=nr
     do i=1,nr
       m=l+k
       if(aa(m) .le. 0.D0) then
         k=k-1
       else
         exit
       endif
     enddo
     ismax(j)=k
   enddo
!   find iemax for each j
   iemax(1)=1+ismax(1)
   do j=2,nz
     iemax(j)=1+max0(ismax(j-1),ismax(j))
   enddo
   iemax(nz1)=1+ismax(nz)
!   set er and ez to zero
   do i=1,im2
     er(i)=0.D0
     ez(i)=0.D0
   enddo
!      sum up fields
   do js=1,nz
     js1=js+1
     ism=ismax(js)
     if (ism.eq.0) cycle
     do is=1,ism
       l=(js-1)*nr+is
       a1=aa(l)
!       if (a1.eq.0.) cycle
       if (abs(a1).le.fprec) cycle
       l=(is-1)*im3
       do je=1,js
         k1=l+(js-je)*nr1
         n1=(je-1)*nr1
         iem=iemax(je)
         if (iem.le.1) cycle
         do ie=1,iem
           n=n1+ie
           k=k1+ie
           er(n)=er(n)+a1*ers(k)
           ez(n)=ez(n)-a1*ezs(k)
         enddo
       enddo
       do je=js1,nz1
         k1=l+(je-js1)*nr1
         n1=(je-1)*nr1
         iem=iemax(je)
         if (iem.le.1) cycle
         do ie=1,iem
           n=n1+ie
           k=k1+ie
           er(n)=er(n)+a1*ers(k)
           ez(n)=ez(n)+a1*ezs(k)
         enddo
       enddo
     enddo
   enddo
!      evaluate and apply impulse
   rrmax=0.D0
   zzmax=0.D0
   zzmin=1000.D0
   npz=0
   npr=0
   do np=1,ngood
!
!  Transforming to the bunch reference frame
!
     dwc=f(7,np)-xmat
     gm1=dwc/xmat
!    convert xp an yp from mrad to rad
     f3np=f(3,np)*1.D-03
     f5np=f(5,np)*1.D-03
!omment   gm1*(2.D0+gm1)=(gam-1)*(gam+1)=gam*gam-1=beta*beta*gam*gam
     bgz=sqrt(gm1*(2.D0+gm1))
     bgx=bgz*f3np
     bgy=bgz*f5np
     gamma=1.D0+gm1
!  Particle momentum in the bunch frame
!
     bgzstar=gam*(bgz-beta*gamma)
!
!  Particle energy in bunch frame
!
     gstar=gam*(gamma-beta*bgz)
!
     r=sqrt((f(2,np)-xbar)**2*epsqi+(f(4,np)-ybar)**2*epsq)
     if(r.ge.rrmax) rrmax=r
     if(abs(r).le.fprec) r=.000001D0
     xor=(f(2,np)-xbar)*xfac/r
     yor=(f(4,np)-ybar)*yfac/r
     if(r.gt.rmax) then
       npr=npr+1
     else
       zph=f(6,np)*fh
       z=-c2*(zph-phimc)
       if(z.ge.zzmax) zzmax=z
       if(z.lt.zzmin) zzmin=z
       if(abs(z).gt.hl) then
         npz=npz+1
       else
!      interpolate impulse within mesh.
         rb=r/dr
         i=idint(1.D0+rb)
         a=rb-DBLE(i-1)
         b=1.D0-a
         zb=(z+hl)/dz
         j=idint(1.D0+zb)
         c=zb-DBLE(j-1)
         d=1.D0-c
         l=i+(j-1)*nr1
         m=l+nr1
         cbgr=c3*(d*(a*er(l+1)+b*er(l))+c*(a*er(m+1)+b*er(m)))
         cbgzs=c3*(d*(a*ez(l+1)+b*ez(l))+c*(a*ez(m+1)+b*ez(m)))
! *******************
!     different charge states in the bunch (valero)
         cbgr=cbgr*abs(f(9,np))
         cbgzs=cbgzs*abs(f(9,np))
       endif
!    estimate impulse based on point charge at xbar,ybar,pbar.
     endif
     if(r.gt.rmax .or. abs(z).gt.hl) then
       z=-c2*(f(6,np)*fh-pbar)
       d=sqrt(z**2+r**2)
       rod3=r/d**3
       zod3=z/d**3
       if (nip.ne.0) then
!      include neighboring bunches.
         do i=1,nip
           xi=DBLE(i)
           do j=1,2
             s=z+xi*pl
             d=sqrt(s**2+r**2)
             rod3=rod3+r/d**3
             zod3=zod3+s/d**3
             xi=-xi
           enddo
         enddo
       endif
!  Evaluate impulse.
!
       cbgr=eng*c1*c3*rod3*pi/2.D0
       cbgzs=eng*c1*c3*zod3*pi/2.D0
!     different charges in the bunch (valero)
       cbgr=cbgr*abs(f(9,np))
       cbgzs=cbgzs*abs(f(9,np))
     endif
!
!  Apply impulse and transform back to lab frame.
!
     bgx=bgx+cbgr*xor
     bgy=bgy+cbgr*yor
     pbgzstar=bgzstar
     bgzstar=bgzstar+cbgzs
     gstar=1.D0+0.5D0*bgzstar**2
     bgzf=gam*(bgzstar+beta*gstar)
     f3=bgx/bgzf
     f5=bgy/bgzf
     dww=f(7,np)-xmat
     dws=dww*((gamma+1.D0)/gamma)*(bgzf-bgz)/bgz
!cc         write(14,5755)np,pbgzstar,cbgzs,bgzstar
!cc5755   format(2x,i5,3(2x,e12.5))
!  ********************
     if(.not.iesp) then
!     load the entrance beam parameters for cavities or gaps
       do js=1,7
         f(js,np)=fs(js,np)
       enddo
!     dxp and dyp are the jumps of xp and yp (in rad) at the position dz1*xpsc (in m)
       dxp=f3-f3np
       dyp=f5-f5np
!   correction of xp and yp ( in rad)
       f(3,np)=f(3,np)+dxp*1000.D0
       f(5,np)=f(5,np)+dyp*1000.D0
       f(2,np)=f(2,np)-dz1*100.D0*dxp*xpsc
       f(4,np)=f(4,np)-dz1*100.D0*dyp*xpsc
       dwp(np)=dws
     else
       f(3,np)=f3*1000.D0
       f(5,np)=f5*1000.D0
       f(7,np)=f(7,np)+dws
     endif
   enddo
   beamc=beamc*fhbu/fh
   fh=fhbu
END SUBROUTINE scheff1
!> *******************************************************************
!! SUBROUTINE scheff_sep
!! SCHEFF_sep special space charge method
!! This version of SCHEFF, starting from the Swenson version, has
!! modifications made to include corrections for relativistic beams.
!! The dynamics have been modified to transform to the beam rest
!! frame, calculate the space-charge kicks in this frame, and then
!! transform back to the lab frame.
!!     input data
!!         sce(1)=beam current in ma.
!!         sce(2)=radial extension in rms multiples
!!         sce(3)=longitudinal extension in rms multiples
!!         sce(4)=no. of radial mesh intervals (le 20)
!!         sce(5)=no. of longitudinal mesh intervals (le 40)
!!         sce(6)=no. of adjacent bunches, applicable for buncher
!!                studies and should be 0 for linac dynamics
!!         sce(7)=distance between adjacent beam pulses in cm
!!                (transport studies); input zero to get (beta*lambda)
!!                default
!!         sce(8)=deactivated
!!         sce(9)=option to integrate space charge forces over box
!!                  if.eq.0. no integration  see sub gaus for further
!!                  explanation.
!!         sce(10) =1 : call in quads,solenoids,accelarating elements
!!         sce(10) =2 : call in drifts,accelarating elements
!!         sce(10) =3 : call at both
!!  standard SCHEFF parameters (see sub schfdyn and user guide)
!!         sce(2)=4
!!         sce(3)=4
!!         sce(4)=20
!!         sce(5)=40
!!         sce(6)=0
!!         sce(7)=0
!!         sce(9)=0
!< *******************************************************************
SUBROUTINE scheff_sep
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4scheff2
   USE m4wforsc
   USE m4prtcls
   IMPLICIT NONE
   REAL(8) a,a1,b,beta,bg,bgx,bgy,bgz,bgzf,bgzstar,brmoy,c,c1,c2,c3,c4
   REAL(8) cbgr,cbgzs,cc,d,dist,dr,dwc,dws,dww,dxp,dyp,dz,dz1,eng,epsqi
   REAL(8) epsq,er1,ez1,f3,f3np,f5,f5np,fhbu,gam,gamma,gm1,gmoy
   REAL(8) gmsq,gpai,gstar,halfdr,hl,beamcin
   REAL(8) rfac,rmax,rmaxsq,rminsq
   REAL(8) pbar,phimc,pib,q,r,rb,rdr2,rod3
   REAL(8) rrms,rsq,s,sqr,trmoy,x,xbar,xf,xfac,xi,xor,xrms,yrms,zrms,zz
   REAL(8) xsq,y,ybar,rrmax,yf,yfac,yor,ysq,z,zb,zbar,zod3,zph,zrms1,zs,zzmax,zzmin
   INTEGER i,i1,ie,iem,is,ism,j,j1,je,jm1,js,js1
   INTEGER k,l,m,n,n1,ng,np,npr,npz
   INTEGER k1,isp,ngisp
   character(len=8) :: PRTLAB
!*******************************************************************
   if (.not. allocated(DWP)) allocate(DWP(iptsz))
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
!********************************************
!     set up field tables with int=0
   IF(abs(beams).le.fprec .OR. abs(scdist).le.fprec) return
!********************************************
   if(ifcont) then
     pib=180.D0
     call compress(pib)
   endif
!********************************************
   PRTLAB='SCHEFF  '
   fhbu=fh
   fh=fhinit
   beamc=beamc*fh/fhbu
!  isepa true ---> the ncstat bunches are separated
   IELL=IELL+1
   write(16,*) ' ****SCHEFF  ',iell
   write(16,*) ' Number of charge states: ',ncstat
   beamcin=beamc
   do isp=1,ncstat
     ngisp=0
     gmoy=0.D0
     do np=1,ngood
!       if (int(f(9,np)).eq.int(cstat(isp))) then
!       if (f(9,np).eq.cstat(isp)) then
       if (abs(f(9,np)-cstat(isp)).le.fprec) then
         ngisp=ngisp+1
         gmoy=f(7,np)/xmat+gmoy
       endif
     enddo
     gmoy=gmoy/DBLE(ngisp)
     beamc=beams*DBLE(ngisp)/DBLE(ngood)
     beami=beamc
     call pintim1(isp)
     CALL sizer(isp,xrms,yrms,zrms)
     write(16,'(A,f9.5,A,e12.5,A,/,A,e12.5,2x,e12.5,2x,e12.5)') & 
              ' charge: ',cstat(isp),' bunch intensity: ',beamc,' amp', &
              ' with RMS size(m)',xrms,yrms,zrms
     rrms=sqrt(xrms*xrms+yrms*yrms)
!    change unit: m==>cm
     zrms1=zrms*100.D0
     rrms=rrms*100.D0
     dr=rrms*frrms/DBLE(nr)
     dz=zrms1*fzrms/DBLE(nz)
     rmax=DBLE(nr)*dr
!      load rm, zm, rs, zs
     rm(1)=0.D0
     do i=2,nr1
       rm(i)=DBLE(i-1)*dr
       rssq(i-1)=0.5D0*(rm(i-1)**2+rm(i)**2)
       rss(i-1)=0.5D0*(rm(i-1)+rm(i))
       rs(i-1)=sqrt(rssq(i-1))
     enddo
     zs=0.5D0*dz
     do i=1,nz1
       zm(i)=DBLE(i-1)*dz
       zzs(i)=zm(i)+zs
     enddo
     hl=DBLE(nz)*zs
!          load ers and ezs
!     mesh dimensions are in cm. ers and ezs are in 1/cm.
!     c1, c2 and c3 are in cm., and c4 is in mev-cm.
!     q=coulombs/point.   (2/pi)*e/(4*pi*epsilon)=572167 cm mev/coul.
     q=beami/(freq*DBLE(nq))
     c1=572167.D0*q/xmat
     l=0
     do k=1,nr
       rfac=(rm(k+1)**2-rm(k)**2)*dz/2.D0
!       if(opt.eq.0.) rfac=1.
       if(abs(opt).le.fprec) rfac=1.D0
       do j=1,nz
         zp=zm(j+1)
         do i=1,nr1
           rp=rm(i)
!           if(opt.eq.0.) then
           if(abs(opt).le.fprec) then
             call flds(rs(k),zs,er1,ez1)
           else
             call gaus (rm(k),rm(k+1),zm(1),zm(2),opt,er1,ez1)
           endif
           l=l+1
           ers(l)=c1*er1/rfac
           ezs(l)=c1*ez1/rfac
         ENDDO
       ENDDO
     ENDDO
     IF(abs(beamc).le.fprec .OR. abs(scdist).le.fprec) return
     dz1=scdist/100.D0
     dist=scdist
!    phimc=phi of mesh center.
!   Shifts particle coordinates to a single point in time. Uses
!   a linear shift
!      Beam c.g.
     xbar=0.D0
     ybar=0.D0
     zbar=0.D0
     brmoy=0.D0
     trmoy=0.D0
     do np=1,ngood
       if(abs(f(9,np)-cstat(isp)).le.fprec) then
         gpai=f(7,np)/xmat
         brmoy=brmoy+sqrt(1.D0-1.D0/(gpai*gpai))
         trmoy=trmoy+f(6,np)
       endif
     enddo
     trmoy=trmoy/DBLE(ngisp)
     phimc=trmoy*fh
     pbar=phimc
     beta=brmoy/DBLE(ngisp)
     gsc=1.D0/sqrt(1.D0-beta*beta)
     bg=beta*gsc
     c3=dist/bg
     c4=dist*xmat
!      evaluate ng, xbar, ybar, and pbar.
     c2=bg*wavel/(2.D0*pi)
     gmsq=1.D0+bg**2
     gam=sqrt(gmsq)
!      evaluate ng, xbar, ybar
     ng=0
     xbar=0.D0
     ybar=0.D0
     xsq=0.D0
     ysq=0.D0
     do np=1,ngood
       if(abs(f(9,np)-cstat(isp)).le.fprec) then
         ng=ng+1
         x=f(2,np)
         y=f(4,np)
         xf=f(3,np)
         yf=f(5,np)
         xbar=xbar+x
         ybar=ybar+y
         xsq=xsq+x**2
         ysq=ysq+y**2
       endif
     enddo
     eng=DBLE(ngisp)
     xbar=xbar/eng
     ybar=ybar/eng
!  the mesh center is phi*syn
     xsq=xsq/eng
     ysq=ysq/eng
     epsq=sqrt((xsq-xbar*xbar)/(ysq-ybar*ybar))
     epsqi=1.D0/epsq
     xfac=2.D0/(epsq + 1.D0)
     yfac=epsq*xfac
!      clear and load bins
     ng=0
     do i=1,im1
       aa(i)=0.D0
     enddo
     do np=1,ngood
       if(abs(f(9,np)-cstat(isp)).le.fprec) then
         rsq=(f(2,np)-xbar)**2*epsqi+(f(4,np)-ybar)**2*epsq
! i=sqrt(rsq)/dr+1.
         r=sqrt(rsq)
         halfdr=dr*0.5D0
         i=idint(r/dr+1.0D0)
         if (i.gt.nr) cycle
         zph=f(6,np)*fh
         z=-c2*(zph-phimc)
         if (abs(z).ge.hl) cycle
!------distribute charge among adjacent bins.
         ng=ng+1
         zz=z+hl
         jm1=idint(zz/dz+1.D0)
         i1=i+1
! if (rsq.lt.rssq(i)) i1=i-1
         if (rsq.lt.rss (i)) i1=i-1
         if (i1.lt.1) i1=1
         if (i1.gt.nr) i1=nr
         j1=jm1+1
         if (zz.lt.zzs(jm1)) j1=jm1-1
         if (j1.lt.1) j1=1
         if (j1.gt.nz) j1=nz
         a=1.D0
! if (i1.ne.i) a=(rsq-rssq(i1))/(rssq(i)-rssq(i1))
         if (i1.eq.i) then
           a=1.D0
         else
           rdr2=rsq/dr**2
           sqr=sqrt(4.D0*rdr2-1.D0)
           rminsq=(halfdr*(sqr-1.D0))**2
           rmaxsq=(halfdr*(sqr+1.D0))**2
           if (i1.lt.i) then
             a=(rmaxsq-rm(i)**2)/(rmaxsq-rminsq)
           else
             a=(rm(i1)**2-rminsq)/(rmaxsq-rminsq)
           endif
         endif
         b=1.D0-a
         cc=1.D0
         if(j1.ne.jm1) cc=(zz-zzs(j1))/(zzs(jm1)-zzs(j1))
         d=1.D0-cc
         k=(jm1-1)*nr+i
         aa(k)=aa(k)+a*cc
         k=k+i1-i
         aa(k)=aa(k)+b*cc
         k=(j1-1)*nr+i
         aa(k)=aa(k)+a*d
         k=k+i1-i
         aa(k)=aa(k)+b*d
       endif
     enddo
     eng=DBLE(ng)
!      find ismax for each j
     do j=1,nz
       l=(j-1)*nr
       k=nr
       do i=1,nr
         m=l+k
         if(aa(m) .gt. 0.D0) exit
         k=k-1
       enddo
       ismax(j)=k
     enddo
!    find iemax for each j
     iemax(1)=1+ismax(1)
     do j=2,nz
       iemax(j)=1+max0(ismax(j-1),ismax(j))
     enddo
     iemax(nz1)=1+ismax(nz)
!    set er and ez to zero
     do i=1,im2
       er(i)=0.D0
       ez(i)=0.D0
     enddo
!      sum up fields
     do js=1,nz
       js1=js+1
       ism=ismax(js)
       if (ism.eq.0) cycle
       do is=1,ism
         l=(js-1)*nr+is
         a1=aa(l)
         if (abs(a1).le.fprec) cycle
         l=(is-1)*im3
         do je=1,js
           k1=l+(js-je)*nr1
           n1=(je-1)*nr1
           iem=iemax(je)
           if (iem.le.1) cycle
           do ie=1,iem
             n=n1+ie
             k=k1+ie
             er(n)=er(n)+a1*ers(k)
             ez(n)=ez(n)-a1*ezs(k)
           enddo
         enddo
         do je=js1,nz1
           k1=l+(je-js1)*nr1
           n1=(je-1)*nr1
           iem=iemax(je)
           if (iem.le.1) cycle
           do ie=1,iem
             n=n1+ie
             k=k1+ie
             er(n)=er(n)+a1*ers(k)
             ez(n)=ez(n)+a1*ezs(k)
           enddo
         enddo
       enddo
     enddo
!      evaluate and apply impulse
     rrmax=0.D0
     zzmax=0.D0
     zzmin=1000.D0
     npz=0
     npr=0
     do np=1,ngood
!  Transforming to the bunch reference frame
       if(abs(f(9,np)-cstat(isp)).le.fprec) then
         dwc=f(7,np)-xmat
         gm1=dwc/xmat
!    convert xp an yp from mrad to rad
         f3np=f(3,np)*1.D-03
         f5np=f(5,np)*1.D-03
!comment   gm1*(2.D0+gm1)=(gam-1)*(gam+1)=gam*gam-1=beta*beta*gam*gam
         bgz=sqrt(gm1*(2.D0+gm1))
         bgx=bgz*f3np
         bgy=bgz*f5np
         gamma=1.D0+gm1
!  Particle momentum in the bunch frame
!
         bgzstar=gam*(bgz-beta*gamma)
!
!  Particle energy in bunch frame
!
         gstar=gam*(gamma-beta*bgz)
!
         r=sqrt((f(2,np)-xbar)**2*epsqi+(f(4,np)-ybar)**2*epsq)
         if(r.ge.rrmax) rrmax=r
         if (abs(r).le.fprec) r=.000001D0
         xor=(f(2,np)-xbar)*xfac/r
         yor=(f(4,np)-ybar)*yfac/r

         if (r.gt.rmax) then
           npr=npr+1
!           go to 230
!          estimate impulse based on point charge at xbar,ybar,pbar.
           z=-c2*(f(6,np)*fh-pbar)
           d=sqrt(z**2+r**2)
           rod3=r/d**3
           zod3=z/d**3
           if (nip.ne.0) then
!      include neighboring bunches.
             do i=1,nip
               xi=DBLE(i)
               do j=1,2
                 s=z+xi*pl
                 d=sqrt(s**2+r**2)
                 rod3=rod3+r/d**3
                 zod3=zod3+s/d**3
                 xi=-xi
               enddo
             enddo
           endif
!  Evaluate impulse.
!
           cbgr=eng*c1*c3*rod3*pi/2.D0
           cbgzs=eng*c1*c3*zod3*pi/2.D0
           cbgr=cbgr*abs(f(9,np))
           cbgzs=cbgzs*abs(f(9,np))
         else
           zph=f(6,np)*fh
           z=-c2*(zph-phimc)
           if(z.ge.zzmax) zzmax=z
           if(z.lt.zzmin) zzmin=z
           if (abs(z).gt.hl) then
             npz=npz+1
!             go to 230
!            estimate impulse based on point charge at xbar,ybar,pbar.
             z=-c2*(f(6,np)*fh-pbar)
             d=sqrt(z**2+r**2)
             rod3=r/d**3
             zod3=z/d**3
             if (nip.ne.0) then
!      include neighboring bunches.
               do i=1,nip
                 xi=DBLE(i)
                 do j=1,2
                   s=z+xi*pl
                   d=sqrt(s**2+r**2)
                   rod3=rod3+r/d**3
                   zod3=zod3+s/d**3
                   xi=-xi
                 enddo
               enddo
             endif
!  Evaluate impulse.
!
             cbgr=eng*c1*c3*rod3*pi/2.D0
             cbgzs=eng*c1*c3*zod3*pi/2.D0
             cbgr=cbgr*abs(f(9,np))
             cbgzs=cbgzs*abs(f(9,np))
           else
!      interpolate impulse within mesh.
             rb=r/dr
             i=idint(1.D0+rb)
             a=rb-DBLE(i-1)
             b=1.D0-a
             zb=(z+hl)/dz
             j=idint(1.D0+zb)
             c=zb-DBLE(j-1)
             d=1.D0-c
             l=i+(j-1)*nr1
             m=l+nr1
             cbgr=c3*(d*(a*er(l+1)+b*er(l))+c*(a*er(m+1)+b*er(m)))
             cbgzs=c3*(d*(a*ez(l+1)+b*ez(l))+c*(a*ez(m+1)+b*ez(m)))
             cbgr=cbgr*abs(f(9,np))
             cbgzs=cbgzs*abs(f(9,np))
!             go to 260
           endif
         endif
!
!  Apply impulse and transform back to lab frame.
!
!  260    bgx=bgx+cbgr*xor
         bgx=bgx+cbgr*xor
         bgy=bgy+cbgr*yor
         bgzstar=bgzstar+cbgzs
         gstar=1.D0+0.5D0*bgzstar**2
         bgzf=gam*(bgzstar+beta*gstar)
         f3=bgx/bgzf
         f5=bgy/bgzf
         dww=f(7,np)-xmat
         dws=dww*((gamma+1.D0)/gamma)*(bgzf-bgz)/bgz
!  ********************
         if(.not.iesp) then
!     load the entrance beam parameters for cavities or gaps
           do js=1,7
             f(js,np)=fs(js,np)
           enddo
!     dxp and dyp are the jumps of xp and yp (in rad) at the position dz1*xpsc (in m)
           dxp=f3-f3np
           dyp=f5-f5np
!   correction of xp and yp ( in rad)
           f(3,np)=f(3,np)+dxp*1000.D0
           f(5,np)=f(5,np)+dyp*1000.D0
           f(2,np)=f(2,np)-dz1*100.D0*dxp*xpsc
           f(4,np)=f(4,np)-dz1*100.D0*dyp*xpsc
           dwp(np)=dws
         else
           f(3,np)=f3*1000.D0
           f(5,np)=f5*1000.D0
           f(7,np)=f(7,np)+dws
         endif
       endif
     enddo
! big enddo of isp
   enddo
! 2021-03-07       beamc=beamc*fhbu/fh
   beamc=beamcin
   fh=fhbu
END SUBROUTINE scheff_sep
!> *******************************************************************
!! SUBROUTINE compress(pib)
!! Move particles outside the phase window of +/- pib to inside this
!! window.
!< *******************************************************************
SUBROUTINE compress(pib)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4spacecharge
   IMPLICIT NONE
   REAL(8) pib,drad,tcog,dcshift,refphas
   INTEGER i,ite,k,kref
   REAL(8) cstcog(20),NDP(20),csticog(20),cstimin(20),cstimax(20),compfac(20)
!*******************************************************************
!  Do so by shifting particles belonging to the same bunch outside the
!  (+/-) pib window to inside the +/- pib window.
   pib=pib*pi/180.D0
   if(ncstat.gt.1) then
!*************************   
! multiple charge states
!*************************   
! deal with the case of a DC beam
     if(ifcont) then
! Multi charge state DC beam; make sure that different charge states remain within same window
       write(16,*) 'Multiple charge state DC beam' 
       write(16,*) 'Reference charge state ',qst
! find COG phase for each charge state         
       DO k=1,ncstat
         NDP(k)=0
         cstcog(k)=0.D0
       ENDDO
       DO i=1,ngood
         DO k=1,ncstat
           if(f(9,i).eq.cstat(k)) then
             NDP(k)=NDP(k)+1
             cstcog(k)=cstcog(k)+f(6,i)
           endif
         ENDDO
       ENDDO
       DO k=1,ncstat
         cstcog(k)=cstcog(k)/DBLE(NDP(k))
         if(cstat(k).eq.qst) then
           refphas=cstcog(k)
           kref=k
         endif   
         cstimin(k)=cstcog(k)            
         cstimax(k)=cstcog(k)            
       ENDDO
       DO i=1,ngood
         DO k=1,ncstat
           if(f(9,i).eq.cstat(k)) then
             if(f(6,i).lt.cstimin(k)) cstimin(k)=f(6,i)
             if(f(6,i).gt.cstimax(k)) cstimax(k)=f(6,i)
           endif
         ENDDO
       ENDDO
! shift each charge state so that the median is at 0 deg           
       DO k=1,ncstat
         write(16,'(A,f9.5,A,e13.7,A)') ' Charge state ',cstat(k), &
           ' DC beam: COG phase before shifting particles : ',cstcog(k)*fh*180.D0/pi,' deg'
         dcshift=0.5*(cstimax(k)+cstimin(k))
         DO i=1,ngood
           if(f(9,i).eq.cstat(k)) then
             f(6,i)=f(6,i)-dcshift
           else
             cycle  
           endif
         ENDDO                       
       ENDDO
! print phases after correction for dc beam         
       DO k=1,ncstat
         cstcog(k)=0.
         NDP(k)=0
       ENDDO
       DO i=1,ngood
         DO k=1,ncstat
           if(f(9,i).eq.cstat(k)) then
             NDP(k)=NDP(k)+1
             cstcog(k)=cstcog(k)+f(6,i)
           endif
         ENDDO
       ENDDO
       DO k=1,ncstat
         cstcog(k)=cstcog(k)/DBLE(NDP(k))
         cstimin(k)=cstcog(k)            
         cstimax(k)=cstcog(k)            
       ENDDO
       DO i=1,ngood
         DO k=1,ncstat
           if(f(9,i).eq.cstat(k)) then
             if(f(6,i).lt.cstimin(k)) cstimin(k)=f(6,i)
             if(f(6,i).gt.cstimax(k)) cstimax(k)=f(6,i)
					
           endif
         ENDDO
       ENDDO
       DO k=1,ncstat
         compfac(k)=2.d0*pi/(((cstimax(k)-cstimin(k)))*fh)
         write(16,'(A,f9.5,A,e13.7,A,f15.5,1x,f15.5,1x,f9.5)') ' Charge state ',cstat(k), &
           ' COG phase after final correction   : ',cstcog(k)*fh*180.D0/pi,' deg', &
           ((cstimax(k)+cstimin(k)))*fh*90.D0/pi,((cstimax(k)-cstimin(k)))*fh*180.D0/pi,compfac(k)
         if(cstat(k).eq.qst) refphas=cstcog(k)             
       ENDDO 
       DO k=1,ncstat
         NDP(k)=0
         cstcog(k)=0.D0
       ENDDO
       DO i=1,ngood
         DO k=1,ncstat
           if(f(9,i).eq.cstat(k)) then
             NDP(k)=NDP(k)+1
             cstcog(k)=cstcog(k)+f(6,i)
           endif
         ENDDO
       ENDDO
       DO k=1,ncstat
         cstcog(k)=cstcog(k)/DBLE(NDP(k))
         cstimin(k)=cstcog(k)            
         cstimax(k)=cstcog(k)            
       ENDDO
       DO i=1,ngood
         DO k=1,ncstat
           if(f(9,i).eq.cstat(k)) then
             f(6,i)=f(6,i)*compfac(k)
             if(f(6,i).lt.cstimin(k)) cstimin(k)=f(6,i)
             if(f(6,i).gt.cstimax(k)) cstimax(k)=f(6,i)
           endif
         ENDDO
       ENDDO
     else
! multi charge state bunched beam
! keep particles within a 360 deg window
       write(16,*) 'Phase window check with window +/-',pib*180.D0/pi,' deg' 
       do ite=1,3
! Find cog in time for each charge state
         DO k=1,ncstat
           NDP(k)=0
           cstcog(k)=0.D0
         ENDDO
         DO i=1,ngood
           DO k=1,ncstat
             if(f(9,i).eq.cstat(k)) then
               NDP(k)=NDP(k)+1
               cstcog(k)=cstcog(k)+f(6,i)
             endif
           ENDDO
         ENDDO
         write(16,'(A,i1)') ' *** Iteration ',ite
         DO k=1,ncstat
           cstcog(k)=cstcog(k)/DBLE(NDP(k))
           write(16,'(A,f9.5,A,e14.7,A)') ' Charge state ',cstat(k), &
             ' COG phase before shifting particles: ',cstcog(k)*fh*180.D0/pi,' deg'
           csticog(k)=cstcog(k)
         ENDDO
         DO i=1,ngood
           DO k=1,ncstat
             if(f(9,i).eq.cstat(k)) then
               drad=(f(6,i)-cstcog(k))*fh
               if(drad.gt.pib) then
                 f(6,i)=(f(6,i)-2.D0*pi/fh)
               endif
               if(drad.lt.-pib) then
                 f(6,i)=(f(6,i)+2.D0*pi/fh)
               endif
             else
               cycle  
             endif
           ENDDO
         ENDDO
! now recenter to original COG, print the "before correction" first         
         DO k=1,ncstat
           NDP(k)=0
           cstcog(k)=0.D0
         ENDDO
         DO i=1,ngood
           DO k=1,ncstat
             if(f(9,i).eq.cstat(k)) then
               NDP(k)=NDP(k)+1
               cstcog(k)=cstcog(k)+f(6,i)
             endif
           ENDDO
         ENDDO
         DO k=1,ncstat
           cstcog(k)=cstcog(k)/DBLE(NDP(k))
           write(16,'(A,f9.5,A,e14.7,A)') ' Charge state ',cstat(k), &
             ' COG phase after shifting particles : ',cstcog(k)*fh*180.D0/pi,' deg'
         ENDDO
         DO i=1,ngood
           DO k=1,ncstat
             if(f(9,i).eq.cstat(k)) then
               f(6,i)=f(6,i)-(cstcog(k)-csticog(k))
             else
               cycle  
             endif
           ENDDO
         ENDDO          
! now print corrected COG           
         DO k=1,ncstat
           NDP(k)=0
           cstcog(k)=0.D0
         ENDDO
         DO i=1,ngood
           DO k=1,ncstat
             if(f(9,i).eq.cstat(k)) then
               NDP(k)=NDP(k)+1
               cstcog(k)=cstcog(k)+f(6,i)
             endif
           ENDDO
         ENDDO
         DO k=1,ncstat
           cstcog(k)=cstcog(k)/DBLE(NDP(k))
           write(16,'(A,f9.5,A,e14.7,A)') ' Charge state ',cstat(k), &
             ' COG phase after correction         : ',cstcog(k)*fh*180.D0/pi,' deg'
           if(cstat(k).eq.qst) refphas=cstcog(k)             
         ENDDO
       enddo
     endif  
   else
!*************************   
! single charge state beam   
!*************************   
     do ite=1,3
! Find cog of bunch in time
       tcog=0.D0
       do i=1,ngood
         tcog=tcog+f(6,i)
       enddo
       tcog=tcog/DBLE(ngood)
       do i=1,ngood
         drad=(f(6,i)-tcog)*fh
         if(drad.gt.pib) then
           f(6,i)=(f(6,i)-2.D0*pi/fh)
         endif
         if(drad.lt.-pib) then
           f(6,i)=(f(6,i)+2.D0*pi/fh)
         endif
       enddo
     enddo
   endif
! Find cog of bunch/all charge states in time after shifting particles
   do i=1,ngood
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
END SUBROUTINE compress
!> *******************************************************************
!! SUBROUTINE gaus(r1,r2,z1,z2,opt,er,ez)
!! called by SCHEFF
!! calculate er and ez at the r and z location given in fldcom
!! by gauss quadrature integration over the double
!! interval from r1 to r2 and from z1 to z2.
!! if opt.gt.0, determine number of integration points as follows.
!! let rat = max(cr/cz,cz/cr), where cr=r2-r1, and cz=z2-z1
!!     if rat.le.2, use 2 x 2 point array
!!     if rat.gt.2, use 2 x 4 point array
!!     if rat.gt.4, use 2 x 6 point array
!! if opt.lt.0, use 2 x 2 point array regardless of rat
!< *******************************************************************
SUBROUTINE gaus(r1,r2,z1,z2,opt,er,ez)
   IMPLICIT NONE
   REAL(8) r1,r2,z1,z2,opt,er,ez
   REAL(8) r(6),z(6),wr(6),wz(6),xx(3,3),wx(3,3)
   REAL(8) cr,cz,rat,ser,sez,er1,ez1
   INTEGER i,ir,j,jz,k,l,m,kr,kz
   data ((xx(i,j),i=1,3),j=1,3)/.2113248654D0,0.D0,0.D0, &
     .06943184420D0,.33000947820D0, &
     0.D0,.03376524290D0,.16939530680D0,.3806904070D0/
   data ((wx(i,j),i=1,3),j=1,3)/.50D0,0.D0,0.D0,.17392742260D0, &
     .32607257740D0, &
     0.D0, .085662246190D0,.1803807865000D0,.2339569673000D0/
!*******************************************************************
   cr=r2-r1
   cz=z2-z1
   ir=1
   jz=1
   m=1
   if (opt .ge. 0.D0) then
!---determine number of integration points
     rat=abs(cz/cr)
     l=0
     if(rat .lt. 1.D0) then
       rat=1.D0/rat
       l=1
     else
       if(rat .gt. 2.D0)m=2
       if(rat .gt. 4.D0)m=3
     endif  
     if(l.eq.0) then
       jz=m
     elseif(l.eq.1) then
       ir=m
     endif  
   endif
   do i=1,ir
     k=2*i-1
     r(k)=r1+cr*xx(i,ir)
     r(k+1)=r2-cr*xx(i,ir)
     wr(k)=wx(i,ir)
     wr(k+1)=wx(i,ir)
   enddo
   do j=1,jz
     k=2*j-1
     z(k)=z1+cz*xx(j,jz)
     z(k+1)=z2-cz*xx(j,jz)
     wz(k)=wx(j,jz)
     wz(k+1)=wx(j,jz)
   enddo
   ser=0.D0
   sez=0.D0
   kr=2*ir
   kz=2*jz
   do i=1,kr
     do j=1,kz
       call flds(r(i),z(j),er1,ez1)
       ser=ser+wr(i)*wz(j)*er1*r(i)
       sez=sez+wr(i)*wz(j)*ez1*r(i)
     enddo
   enddo
   er=cr*cz*ser
   ez=cr*cz*sez
END SUBROUTINE gaus
!> *******************************************************************
!! SUBROUTINE flds(r,z,er,ez)
!! called by SCHEFF
!! evaluate fields at r1,z1 due to ring of charge at r,z.
!! er=(pi/2)*r/d**3.     ez=(pi/2)*z/d**3.
!< *******************************************************************
SUBROUTINE flds(r,z,er,ez)
   USE m4scheff, ONLY: rp,zp,pl,nip
   USE DynacConstants, ONLY: fprec
   IMPLICIT NONE
   REAL(8) r,z,er,ez
   REAL(8) r1,z1,a,b,c,d,er1,d2,ez1,xi,ee,ek
   INTEGER i,j        
!*******************************************************************
   r1=rp
   z1=zp
! **********************************
   d=z1-z
   c=(r1-r)**2
   b=(r1+r)**2
   a=4.D0*r*r1/(b+d**2)
   call eint (a,ee,ek)
   er1=0.D0
   a=sqrt(b+d**2)
!   if (r1.ne.0.) then
   if (abs(r1).gt.fprec) then
     er1=(ek-(r**2-r1**2+d**2)*ee/(c+d**2))/(2.D0*r1*a)
   endif
   ez1=d*ee/(a*(c+d**2))
   if (nip.ne.0) then
     do i=1,nip
       xi=DBLE(i)
       do j=1,2
         d=z1-(z+xi*pl)
         d2=d**2
!         a=4.D0*r*r1/(b+d**2)
         a=4.D0*r*r1/(b+d2)
         call eint (a,ee,ek)
!         a=sqrt(b+d**2)
         a=sqrt(b+d2)
         if (abs(r1).gt.fprec) then
!           er1=er1+(ek-(r**2-r1**2+d**2)*ee/(c+d**2))/(2.D0*r1*a)
           er1=er1+(ek-(r**2-r1**2+d2)*ee/(c+d2))/(2.D0*r1*a)
         endif
!         ez1=ez1+d*ee/(a*(c+d**2))
         ez1=ez1+d*ee/(a*(c+d2))
         xi=-xi
       enddo
     enddo
   endif
   er=er1
   ez=ez1
END SUBROUTINE flds
!> *******************************************************************
!! SUBROUTINE eint(a,ee,ek)
!! evaluate elliptic integrals  ( called by SCHEFF)
!< *******************************************************************
SUBROUTINE eint(a,ee,ek)
   IMPLICIT NONE
   REAL(8) a,ee,ek,b,c
!*******************************************************************
   b=1.D0-a
   c=log(b)
   ee=1.D0+b*(0.4630106D0-0.2452740D0*c+b*(0.1077857D0-0.04125321D0*c))
   ek=1.38629436D0-0.5D0*c+b*(0.1119697D0-0.1213486D0*c+ &
      b*(0.07253230D0-0.028874721D0*c))
END SUBROUTINE eint
!> *******************************************************************
!! SUBROUTINE shuffle
!! Reshuffles f(i,j) array so that the "good" particles are on top of
!! the stack.  The number of "good" particles (ngood) is passed back.
!< *******************************************************************
SUBROUTINE shuffle
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4input
   USE m4hersc8, ONLY: ratei
   IMPLICIT NONE
   REAL(8) c
   INTEGER k,ngood1,j,mcstat
!*******************************************************************
   k=ngood
   ngood1=0
   DO
     if(ngood1.ge.k) exit
     if(int(f(8,ngood1+1)).ne.1) then
       do j=1,10
         c=f(j,ngood1+1)
         f(j,ngood1+1)=f(j,k)
         f(j,k)=c
       enddo
       k=k-1
     else
       ngood1=ngood1+1
     endif
   ENDDO
   ngood=ngood1
   if(ngood.eq.0) then
     ratei=0.D0
   else
     ratei=DBLE(imax)/DBLE(ngood)
   endif
   ncstat=1
   cstat(1)=f(9,1)
   do j=2,ngood
     mcstat=0
     do k=1,ncstat
!       if(f(9,j).eq.cstat(k)) then
!       if(int(f(9,j)).eq.int(cstat(k))) then
       if(abs(f(9,j)-cstat(k)).le.fprec) then
         mcstat=1
       endif
     enddo
     if(mcstat.eq.0) then
       ncstat=ncstat+1
       cstat(ncstat)=f(9,j)
     endif
   enddo
   write(16,*) 'Number of charge states after shuffle: ',ncstat
   write(16,*) 'Charge state(s): ',(cstat(j),j=1,ncstat)
   imcs=0
   if(ncstat.gt.1) imcs=1
   if(ngood.lt.10) then
     write(16,*)'Less than 10 particles left, statistics too low'
     write(6,*)
     write(6,*)'Less than 10 particles left, statistics too low'                  
     write(ierr,*)'Less than 10 particles left,statistics too low'
     stop
   endif
END SUBROUTINE shuffle
!> *******************************************************************
!! SUBROUTINE b_sep(isepa)
!! check if the bunches in the beam are separated or not
!< *******************************************************************
SUBROUTINE b_sep(isepa)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4input
   IMPLICIT NONE
   REAL(8) csmax1,bzmin1,bzmin2,bzmax1,bzmax2
   REAL(8) bxmin1,bxmin2,bxmax1,bxmax2,bymin1,bymin2,bymax1,bymax2
   REAL(8) csmax2,elip1,elip2,xg1,xg2,xpg1,xpg2
   INTEGER i,icsm1,imax1,imax2
       REAL(8) d11(2),d22(2),d12(2),rp12(2),xpint(2),xint(2)
       logical isepa,found
!*******************************************************************
       csmax1=0.D0
       icsm1=0
       do i=1,ncstat
        if(cstat(i).gt.csmax1) then
         icsm1=i
         csmax1=cstat(i)
        endif
       enddo
       csmax2=0.D0
       do i=1,ncstat
        if(i.ne.icsm1) then
         if(cstat(i).gt.csmax2) then
           csmax2=cstat(i)
         endif
        endif
       enddo
       xg1=0.D0
       xpg1=0.D0
       xg2=0.D0
       xpg2=0.D0
       imax1=0
       imax2=0
!   min and max over state charges csmax1 and csmax2
       found=.false.
       do i=1,ngood
!         if(f(9,i).eq.csmax1) then
         if(abs(f(9,i)-csmax1).le.fprec) then
           if(.not.found) then
             bxmin1=f(2,i)
             bxmax1=f(2,i)
             bymin1=f(4,i)
             bymax1=f(4,i)
             bzmin1=f(6,i)
             bzmax1=f(6,i)
             found=.true.
           else           
             if(f(2,i).lt.bxmin1) bxmin1=f(2,i)
             if(f(2,i).gt.bxmax1) bxmax1=f(2,i)
             if(f(4,i).lt.bymin1) bymin1=f(4,i)
             if(f(4,i).gt.bymax1) bymax1=f(4,i)
             if(f(6,i).lt.bzmin1) bzmin1=f(6,i)
             if(f(6,i).gt.bzmax1) bzmax1=f(6,i)             
           endif           
         endif
       enddo
       found=.false.
       do i=1,ngood
!         if(f(9,i).eq.csmax2) then
         if(abs(f(9,i)-csmax2).le.fprec) then
           if(.not.found) then
             bxmin2=f(2,i)
             bxmax2=f(2,i)
             bymin2=f(4,i)
             bymax2=f(4,i)
             bzmin2=f(6,i)
             bzmax2=f(6,i)
             found=.true.
           else           
             if(f(2,i).lt.bxmin2) bxmin2=f(2,i)
             if(f(2,i).gt.bxmax2) bxmax2=f(2,i)
             if(f(4,i).lt.bymin2) bymin2=f(4,i)
             if(f(4,i).gt.bymax2) bymax2=f(4,i)
             if(f(6,i).lt.bzmin2) bzmin2=f(6,i)
             if(f(6,i).gt.bzmax2) bzmax2=f(6,i)             
           endif           
         endif
       enddo
!   COG over charge states csmax1 and csmax2
       do i=1,ngood
!        if(int(f(9,i)).eq.int(csmax1)) then
!        if(f(9,i).eq.csmax1) then
         if(abs(f(9,i)-csmax1).le.fprec) then
!         if(i.eq.1) then
!           bxmax1=f(2,i)
!           bxmin1=f(2,i)
!         endif           
            xg1=xg1+f(2,i)
            xpg1=xpg1+f(3,i)
            imax1=imax1+1
          endif
!        if(int(f(9,i)).eq.int(csmax2)) then
!        if(f(9,i).eq.csmax2) then
         if(abs(f(9,i)-csmax2).le.fprec) then
           xg2=xg2+f(2,i)
           xpg2=xpg2+f(3,i)
           imax2=imax2+1
         endif
       enddo
       if(imax1.gt.9 .and. imax2.gt.9) then       
         xg1=xg1/DBLE(imax1)
         xpg1=xpg1/DBLE(imax1)
         xg2=xg2/DBLE(imax2)
         xpg2=xpg2/DBLE(imax2)
! ------------------------------------
         d11(1)=0.D0
         d22(1)=0.D0
         d12(1)=0.D0
         d11(2)=0.D0
         d22(2)=0.D0
         d12(2)=0.D0
         do i=1,ngood
!          if(int(f(9,i)).eq.int(csmax1)) then
!          if(f(9,i).eq.csmax1) then
           if(abs(f(9,i)-csmax1).le.fprec) then
             d11(1)=d11(1)+(f(3,i)-xpg1)**2
             d22(1)=d22(1)+(f(2,i)-xg1)**2
             d12(1)=d12(1)+(f(3,i)-xpg1)*(f(2,i)-xg1)
           endif
!          if(int(f(9,i)).eq.int(csmax2)) then
!          if(f(9,i).eq.csmax2) then
           if(abs(f(9,i)-csmax2).le.fprec) then
             d11(2)=d11(2)+(f(3,i)-xpg2)**2
             d22(2)=d22(2)+(f(2,i)-xg2)**2
             d12(2)=d12(2)+(f(3,i)-xpg2)*(f(2,i)-xg2)
           endif
         enddo
         d11(1)=sqrt(d11(1)/DBLE(imax1))
         d22(1)=sqrt(d22(1)/DBLE(imax1))
         d12(1)=sqrt(abs(d12(1))/DBLE(imax1))         
         d11(2)=sqrt(d11(2)/DBLE(imax2))
         d22(2)=sqrt(d22(2)/DBLE(imax2))
         d12(2)=sqrt(abs(d12(2))/DBLE(imax2))         
         rp12(1)=d12(1)/sqrt(d11(1)*d22(1))
         rp12(2)=d12(2)/sqrt(d11(2)*d22(2))
         xpint(1)=sqrt(d11(1)*(1.D0-rp12(1)))
         xint(1)=sqrt(d22(1)*(1.D0-rp12(1)))
         xpint(2)=sqrt(d11(2)*(1.D0-rp12(2)))
         xint(2)=sqrt(d22(2)*(1.D0-rp12(2)))
! ------------------------------------------------------------
         elip1=xpg1+xpint(1)
         elip2=xpg2-xpint(2)
         if(xg1.lt.xg2 .and. xg1+scseprms*d22(1).lt.xg2-scseprms*d22(2)) then
           write(16,*) ' Horizontal   separation based on SCSEP'
           write(16,*) ' ************************************'
           isepa=.true.
         elseif(xg2.lt.xg1 .and. xg2+scseprms*d22(2).lt.xg1-scseprms*d22(1)) then
           write(16,*) ' Horizontal   separation based on SCSEP'
           write(16,*) ' ************************************'
           isepa=.true.
         endif                  
!       if(elip1.lt.elip2)isepa=.true.
! TEST*********
!       write(16,*) ' Number of RMS as basis for separation SCSEP: ',scseprms
!       write(16,*)   xg1,xg2,d22(1),d22(2)
!       write(16,*)   xg1+scseprms*d22(1),xg2-scseprms*d22(2)
         if(bxmax1.lt.bxmin2 .or. bxmax2.lt.bxmin1) then
           write(16,*) ' Horizontal   separation based on most outlying particle in each charge state'
           write(16,*) ' ************************************'
           isepa=.true.
         endif
         if(bymax1.lt.bymin2 .or. bymax2.lt.bymin1) then
           write(16,*) ' Vertical     separation based on most outlying particle in each charge state'
           write(16,*) ' ************************************'
           isepa=.true.
         endif
         if(.not.ifcont) then
! longitudinal seperation only in the case of a bunched beam
           if(bzmax1.lt.bzmin2 .or. bzmax2.lt.bzmin1) then
             write(16,*) ' Longitudinal separation'
             write(16,*) ' ************************************'
             isepa=.true.
           endif
         endif
       endif  
! ***************************************************************
END SUBROUTINE b_sep
!> *******************************************************************
!! SUBROUTINE pintim1(ist)
!! Shifts particle coordinates to a single point in time. Uses
!! a linear shift
!! Divide by 100. to convert from cm to meters
!! called by SCHEFF or SCHERM
!< *******************************************************************
SUBROUTINE pintim1(ist)
   USE DynacConstants
   USE m4beam
   USE m4mcs
   USE m4input
   USE m4spacecharge
   USE m4prtcls, ONLY: xc,yc,zc
   IMPLICIT NONE
   INTEGER i,np,ist,ngist
   REAL(8) grmoy,trmoy,xbax,bpai,brmoy,f3,f5,gpai,xbar,xnp,ybar,zbar,znp
!*******************************************************************
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
   grmoy=0.D0
   trmoy=0.D0
   xbax=0.D0
   ngist=0
   do i=1,ngood
!    if(f(9,i).eq.cstat(ist)) then
!    if(int(f(9,i)).eq.int(cstat(ist))) then
    if(abs(f(9,i)-cstat(ist)).le.fprec) then
     ngist=ngist+1
     grmoy=grmoy+f(7,i)/xmat
     trmoy=trmoy+f(6,i)
     xbax=xbax+f(2,i)
    endif
   enddo
   trmoy=trmoy/DBLE(ngist)
   grmoy=grmoy/DBLE(ngist)
   brmoy=sqrt(1.D0-1.D0/(grmoy*grmoy))
   xbax=xbax/DBLE(ngist)
!ccc       apl=0.D0
!  Isochronism correction  (bending magnet) only with SCHERM
!    does not work with  with SCHEFF  (iscsp=3)
!ccc       if(iscsp.eq.2) then
!ccc         xb2x=0.D0
!ccc         xb2z=0.D0
!ccc         xbxz=0.D0
!ccc         do np=1,ngood
!ccc           gpai=f(7,np)/xmat
!ccc           bpai=sqrt(1.D0-1.D0/(gpai*gpai))
!ccc           zc(np)=(trmoy-f(6,np))*bpai*vl/100.D0
!ccc           xc(np)=(f(2,np)-xbax)/100.D0
!ccc           xb2z=xb2z+zc(np)*zc(np)
!ccc           xb2x=xb2x+xc(np)*xc(np)
!ccc           xbxz=xbxz+zc(np)*xc(np)
!ccc         enddo
!ccc         xb2z=xb2z/DBLE(ngood)
!ccc         xb2x=xb2x/DBLE(ngood)
!ccc         xbxz=xbxz/DBLE(ngood)
!ccc         apl=atan(-2.D0*xbxz/(xb2x-xb2z))/2.D0
!ccc         write(16,*) 'slope of the bunch in plane(Oz,Ox):',apl,' radian'
!ccc       endif
   do np=1,ngood
!     if(f(9,np).eq.cstat(ist)) then
!     if(int(f(9,np)).eq.int(cstat(ist))) then
     if(abs(f(9,np)-cstat(ist)).le.fprec) then
       gpai=f(7,np)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
!      iscsp = 3 Lorentz transformation (only with scheff)
!omment         if(iscsp.eq.3) znp=(trmoy-f(6,np))*bpai*vl*grmoy
!omment         if(iscsp.eq.2) znp=(trmoy-f(6,np))*bpai*vl
       znp=(trmoy-f(6,np))*bpai*vl
       xnp=f(2,np)
       zc(np)=znp*cos(apl)+xnp*sin(apl)
       xnp=xnp*cos(apl)-znp*sin(apl)
!      convert from mrad to rad
       f3=f(3,np)*1.D-03
       f5=f(5,np)*1.D-03
!      convert from cm   to m
       xc(np)=(xnp+zc(np)*f3)/100.D0
       yc(np)=(f(4,np)+zc(np)*f5)/100.D0
       zc(np)=zc(np)/100.D0
     endif
   enddo
   xbar=0.D0
   ybar=0.D0
   zbar=0.D0
   do np=1,ngood
!      evaluate xbar , ybar , zbar
!      if(f(9,np).eq.cstat(ist)) then
!      if(int(f(9,np)).eq.int(cstat(ist))) then
     if(abs(f(9,np)-cstat(ist)).le.fprec) then
       xbar=xbar+xc(np)
       ybar=ybar+yc(np)
       zbar=zbar+zc(np)
     endif
   enddo
   xbar=xbar/DBLE(ngist)
   ybar=ybar/DBLE(ngist)
   zbar=zbar/DBLE(ngist)
!  Translate distribution by center of mass coordinates to shift
!  coordinate origin to (0,0,0)
   do np=1,ngood
!     if(f(9,np).eq.cstat(ist)) then
!     if(int(f(9,np)).eq.int(cstat(ist))) then
     if(abs(f(9,np)-cstat(ist)).le.fprec) then
       xc(np)=xc(np)-xbar
       yc(np)=yc(np)-ybar
       zc(np)=zc(np)-zbar
     endif
   enddo
END SUBROUTINE pintim1
!> *******************************************************************
!! SUBROUTINE sizer(ist,xrms,yrms,zrms)
!! partial R.M.S. (called by SCHEFF_sep)
!< *******************************************************************
SUBROUTINE sizer(ist,xrms,yrms,zrms)
   USE DynacConstants
   USE m4beam
   USE m4mcs
   USE m4prtcls, ONLY: xc,yc,zc
   USE m4scherm3, ONLY: xsum,ysum,zsum
   IMPLICIT NONE
   REAL(8) xrms,yrms,zrms,xsqsum,ysqsum,zsqsum
   INTEGER i,ist,ngist
!*******************************************************************
   xsum=0.D0
   ysum=0.D0
   zsum=0.D0
   xsqsum=0.D0
   ysqsum=0.D0
   zsqsum=0.D0
   ngist=0
   do i=1,ngood
!     if(f(9,i).eq.cstat(ist)) then
!     if(int(f(9,i)).eq.int(cstat(ist))) then
     if(abs(f(9,i)-cstat(ist)).le.fprec) then
       ngist=ngist+1
       xsum=xsum+xc(i)
       ysum=ysum+yc(i)
       zsum=zsum+zc(i)
       xsqsum=xsqsum+xc(i)*xc(i)
       ysqsum=ysqsum+yc(i)*yc(i)
       zsqsum=zsqsum+zc(i)*zc(i)
     endif
   enddo
   xsum=xsum/DBLE(ngist)
   ysum=ysum/DBLE(ngist)
   zsum=zsum/DBLE(ngist)
   xsqsum=xsqsum/DBLE(ngist)
   ysqsum=ysqsum/DBLE(ngist)
   zsqsum=zsqsum/DBLE(ngist)
   xrms=SQRT(xsqsum-xsum*xsum)
   yrms=SQRT(ysqsum-ysum*ysum)
   zrms=SQRT(zsqsum-zsum*zsum)
END SUBROUTINE sizer
!> *******************************************************************
!! SUBROUTINE hersc(ini)
!! space charge method: HERSC
!< *******************************************************************
SUBROUTINE hersc(ini)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4hersc, ONLY: rms,s1,s2,s3
   USE m4hersc2, ONLY: igaus
   USE m4hersc6
   USE m4hersc7
   USE m4hersc8, ONLY: ratei
   USE m4wforsc
   USE m4prtcls
   IMPLICIT NONE
   REAL(8) dxp,dyp,dz,dz1
   REAL(8) gmoy
   REAL(8) bsc,gsc
   REAL(8) ax,ay,az,bcg,bmoy,cmacro,cmacrxy,const2,const3,delu,delux
   REAL(8) delv,delvy,delw,delwz,delx,dely,delz,dw,epsil,ex12,ex43,ex56,ex87
   REAL(8) exp1,exp2,exp3,exp5,exp13,exp25,ext,extp,ey15,ey26,ey37,ey48,eyt
   REAL(8) eyp2,eyp4,eyp5,eyp6,eyp25,eyp46,ez14,ez23,ez58,ez67,ezp1,ezp3,ezp4,ezp6
   REAL(8) ezp13,ezp64,ezt,eztp,gcg,qmpart,freq,rcx,rcy,rcz,rrx,rry,rrz
   REAL(8) sta,u,v,vrms,w,wcg,xnd1,ynd1,znd1,zsot1,pib
   REAL(8) rx,ry,rz
   INTEGER i,j,jm1,js
   INTEGER k
   INTEGER lbmax,mbmax,nbmax
   INTEGER ini,ic,ical,icam,ican,ickl,icoa,imail,insd,iout,isucc
   INTEGER jl,jl1,jm,jn,jn1,nprint
   INTEGER nx,ny,nz
   REAL(8) exk(15,15,30),eyk(15,15,30),ezk(15,15,30)
   data lbmax,mbmax,nbmax/23,23,23/
!*******************************************************************
   if (.not. allocated(DWP)) allocate(DWP(iptsz))
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
! ini = 0 :initialisation of the routine
   if(ini.le.0) then
!   input parameters
     igaus=9
!   eps allows to select the significant terms in the HERMITE series expansion
     eps=8.D-3
!   maximun of the upper limits in the HERMITE series expansion
     lmaxi=11
     mmaxi=11
     nmaxxi=11
!   The HERMITE coefficients Almn are computed with the particles include in a cube
!   with regard to the RMS of the bunch. The sizes of the cube are:RMSx*fxrms, ........
     fxrms=2.5D0
     fyrms=2.5D0
     fzrms=2.5D0
     if(ini.lt.0) then
       read(in,*)lmaxi,mmaxi,nmaxxi
       read(in,*)fxrms,fyrms,fzrms
       read(in,*)eps
     endif
!  rdcf   : in %/100 , allows to select a reduced number of particles for the Almn.
     read(in,*) rdcf
     write(16,*)" Settings used: "
     write(16,*)'   upper limits ',lmaxi,mmaxi,nmaxxi
     write(16,*)'   rms factors ',fxrms,fyrms,fzrms
     write(16,*)'   select the Hermite cefficients with EPS: ',eps
     write(16,*)'   Value of RDCF (reduction in number of particles) in input file: ',rdcf
     if(rdcf .gt. 1.D0) rdcf=1.D0
     if(rdcf .le. 0.D0) then
       if(ngood.gt.15000) then
         rdcf=15000.D0/DBLE(ngood)
       else
         rdcf=1.D0
       endif
     endif
     write(16,*)'   RDCF used: ',rdcf
!    MESH**********
!      limits in (+-) RMS
     rx=4.D0
     ry=4.D0
     rz=4.D0
!      number of nodes in each direction
     nx=8
     ny=8
     nz=8
     call shuffle
     call gausse
     call table(lbmax,mbmax,nbmax)
     return
   endif
! **********************************************************************
   if(ini.eq.1) then
!    .................................................................................
!       seeks: the significant coefficients in the Hermite series expansions
!              ---> storage array a(l,m,n)
!              maximum values of l, m and n of the significant a(l,m,n) --->lmax,mmax,nmax
!              RMS of the bunch ---> xa, xb and xc
!       order of the succesive integrals
!       isucc=1: xa<xb,xc , rms(3,2)=xa, rms(2,2)=xb,  rms(1,2)=xc
!                           rms(3,k)=xa**(k-1), ..........
!       isucc=2: xb<xa,xc , rms(3,2)=xb, rms(2,2)=xc,  rms(1,2)=xa
!       isucc=1: xc<xa,xb , rms(3,2)=xc, rms(2,2)=xa,  rms(1,2)=xb
!       compute the array blam(i,j)
!        blam(i,j): FUNCTION beta**2 in the fifth relation in table 31
!                   blam(i,j)=beta**2j,j=1,...,im=(lmax+mmax+nmax+kmax)/2+2
!                   i is given from the i-Gauss position in absg(i)
!   ..................................................................................
     call bhdist
     call trms(isucc)
     sta=a(1,1,1)
     icoa=0
     do ican=1,nmax
       do icam=1,mmax
         do ical=1,lmax
           if(abs(a(ican,icam,ical)).gt.fprec) icoa=icoa+1
         enddo
       enddo
     enddo
     return
   endif
! **********************************************************************
!   beam self-fields
   if(ini.eq.2) then
!   limits of the mesch : rx ry rz
!   length of the steps
     delx=2.D0*rx/DBLE(nx)
     dely=2.D0*ry/DBLE(ny)
     delz=2.D0*rz/DBLE(nz)
!2025 test: if DC beam, keep particles within +/- 180 deg
!********************************************
     if(ifcont) then
       pib=180.D0
       call compress(pib)
     endif
!********************************************
!    Initialize constants
!   xmass-Kg,wavel=cm,charge=coul.
!   clight=cm/sec MHz/Hz ,freq=Mhz ,xmat=MeV
! freq. in MHz
     freq=fh*0.5D-06/pi
     epsil=8.854189586D-12
     const3=1.D-06
     const2=1.D-06/xmat
     dxp=0.D0
     dyp=0.D0
     dw=0.D0
     dz=scdist/100.D0
     dz1=dz
     zsot1=0.D0
!   qmpart=macro-charge
     qmpart=1.0D-9*beamc/(DBLE(imax)*freq)
     if(ratei.le.0.D0) then
       write(16,*) ' All the particles are lost '
       write(ierr,*) ' All the particles are lost '
       stop
     endif
     qmpart=qmpart*ratei
     vrms=xrmsz*yrmsz*zrmsz
     cmacro=qmpart/(epsil*vrms)
     wcg=0.D0
     do i=1,ngood
      wcg=wcg+f(7,i)
     enddo
     wcg=wcg/DBLE(ngood)
     gcg=wcg/xmat
     gmoy=gcg
     bcg=sqrt(1.D0-1.D0/(gcg*gcg))
     bmoy=bcg
!  relativistic correction
     cmacro=cmacro/gmoy
!
     cmacrxy=cmacro/(bmoy*bmoy*gmoy*gmoy)
!   beam self-fields at the nodes of the mesh
     imail=0
     rcy=-ry
     do j=1,ny
       rcx=-rx
       do i=1,nx
         rcz=-rz
         do k=1,nz
           if(isucc.eq.1) then
             s3=rcx
             s2=rcy
             s1=rcz
             ax=pwtpi*rms(3,2)
             ay=pwtpi*rms(2,2)
             az=pwtpi*rms(1,2)
             rrx=rms(3,2)
             rry=rms(2,2)
             rrz=rms(1,2)
           endif
           if(isucc.eq.2) then
             s3=rcy
             s2=rcz
             s1=rcx
             ax=pwtpi*rms(1,2)
             ay=pwtpi*rms(3,2)
             az=pwtpi*rms(2,2)
             rrx=rms(1,2)
             rry=rms(3,2)
             rrz=rms(2,2)
           endif
           if(isucc.eq.3) then
             s3=rcz
             s2=rcx
             s1=rcy
             ax=pwtpi*rms(2,2)
             ay=pwtpi*rms(1,2)
             az=pwtpi*rms(3,2)
             rrx=rms(2,2)
             rry=rms(1,2)
             rrz=rms(3,2)
           endif
           call uvrms
!     fields
!       loop over the l,m and n
           exk(i,j,k)=0.D0
           eyk(i,j,k)=0.D0
           ezk(i,j,k)=0.D0
           do jn=1,nmax
             jn1=jn-1
             do jm=1,mmax
               jm1=jm-1
               do jl=1,lmax
                 jl1=jl-1
!                 if(a(jl,jm,jn).ne.0.) then
                 if(abs(a(jl,jm,jn)).gt.fprec) then
                   call fielde(jl1,jm1,jn1,isucc)
!     the beam self-fields are  in tables 67-a to 67-h
                   exk(i,j,k)=a(jl,jm,jn)/ax*ex+exk(i,j,k)
                   eyk(i,j,k)=a(jl,jm,jn)/ay*ey+eyk(i,j,k)
                   ezk(i,j,k)=a(jl,jm,jn)/az*ez+ezk(i,j,k)
                 endif
               enddo
             enddo
           enddo
           rcz=rcz+delz
           imail=imail+1
         enddo
         rcx=rcx+delx
       enddo
       rcy=rcy+dely
     enddo
! xi in Amps, ibeam in mA
     dxp=0.D0
     dyp=0.D0
     dw=0.D0
!   save the  particles coordinates
     do i=1,ngood
       xc(i)=xcp(i)
       yc(i)=ycp(i)
       zc(i)=zcp(i)
     enddo
! Do integration to determine Ex,Ey,Ez for each macro particle
     nprint=1
     insd=0
     iout=0
     ickl=0
     do ic=1,ngood
!     position in the mesh
       ickl=ickl+1
       u=xc(ic)/xrmsz
       v=yc(ic)/yrmsz
       w=zc(ic)/zrmsz
!omment           u=xc(ic)/rrx
!omment           v=yc(ic)/rry
!omment           w=zc(ic)/rrz
       i=int((u+rx)/delx)+1
       j=int((v+ry)/dely)+1
       k=int((w+rz)/delz)+1
!   the particle is in the mesh
       if(i.gt.0 .and. i.le.nx .and. j.gt.0 .and. j.le.ny &
                   .and. k.gt.0 .and. k.le.nz) then
         xnd1=-rx+DBLE(i-1)*delx
         ynd1=-ry+DBLE(j-1)*dely
         znd1=-rz+DBLE(k-1)*delz
         delu=u-xnd1
         delv=v-ynd1
         delw=w-znd1
         delux=delu/delx
         delvy=delv/dely
         delwz=delw/delz
! *******interpollation for particle inside a cube
! %%%%%%     in plane 1:
! node 1: (i,j,k)  node 2:(i+1,j,k) node 3:(i+1,j,k+1) node 4:(i,j,k+1)
!  axis (nd1,nd2)
         ex12=(exk(i+1,j,k)-exk(i,j,k))*delux+exk(i,j,k)
!  axis (nd4,nd3)
         ex43=(exk(i+1,j,k+1)-exk(i,j,k+1))*delux+exk(i,j,k+1)
!    plane 1
         exp1=(ex43-ex12)*delwz+ex12
! %%%%%%%     in plane 3:
!  node 5:(i,j+1,k) node 6:(i+1,j+1,k) node 7:(i+1,j+1,k+1) node 8:(i,j+1,k+1)
!  axis(nd5,nd6)
         ex56=(exk(i+1,j+1,k)-exk(i,j+1,k))*delux+exk(i,j+1,k)
!  axis(nd8,nd7)
         ex87=(exk(i+1,j+1,k+1)-exk(i,j+1,k+1))*delux+exk(i,j+1,k+1)
!   plane 3
         exp3=(ex87-ex56)*delwz+ex56
!  $$$$$ plane1+plane3
         exp13=(exp3-exp1)*delvy+exp1
! %%%%%    in plane 2:
! node 1: (i,j,k)  node 2:(i+1,j,k) node 5:(i,j+1,k) node 6:(i+1,j+1,k)
! axis (nd1,nd2) : ex12
! axis (nd5,nd6) : ex56
!  plane 2
         exp2=(ex56-ex12)*delvy+ex12
!  %%%%%%    in plane 5
!  node 4:(i,j,k+1) node 3:(i+1,j,k+1) node 8:(i,j+1,k+1) node 7:(i+1,j+1,k+1)
!   axis(nd4,nd3)
         ex43=(exk(i+1,j,k+1)-exk(i,j,k+1))*delux+exk(i,j,k+1)
!   axis(nd8,nd7)
         ex87=(exk(i+1,j+1,k+1)-exk(i,j+1,k+1))*delux+exk(i,j+1,k+1)
!  plane 5
         exp5=(ex87-ex43)*delvy+ex43
!  $$$$ plane2+plane5
         exp25=(exp5-exp2)*delwz+exp2
!   &&&& (plane1+plane3)+(plane2+plane5) --> field Ex(u,v,w)
         ext=(exp13+exp25)/2.D0
! ******* field component Ey
! %%%%%%     in plane 2:
! node 1: (i,j,k)  node 2:(i+1,j,k) node 5:(i,j+1,k) node 6:(i+1,j+1,k)
!  axis(nd1,nd5)
         ey15=(eyk(i,j+1,k)-eyk(i,j,k))*delvy+eyk(i,j,k)
!  axis (nd2,nd6)
         ey26=(eyk(i+1,j+1,k)-eyk(i+1,j,k))*delvy+eyk(i+1,j,k)
!   plane 2
         eyp2=(ey26-ey15)*delu/delx+ey15
! %%%%%%     in plane 5:
!  node 4:(i,j,k+1) node 3:(i+1,j,k+1) node 8:(i,j+1,k+1) node 7:(i+1,j+1,k+1)
!  axis(nd4,nd8)
         ey48=(eyk(i,j+1,k+1)-eyk(i,j,k+1))*delvy+eyk(i,j,k+1)
!  axis(nd3,nd7)
         ey37=(eyk(i+1,j+1,k+1)-eyk(i+1,j,k+1))*delvy+eyk(i+1,j,k+1)
!   plane 5
         eyp5=(ey37-ey48)*delux+ey48
! $$$$$$ plane2+plane5
         eyp25=(eyp5-eyp2)*delwz+eyp2
! %%%%%%     in plane 6:
!  node 1:(i,j,k) node 5:(i,j+1,k) node 4:(i,j,k+1) node 8:(i,j+1,k+1)
!  axis(nd1,nd5): ey15
!  axis(nd4,nd8): ey48
!  plane 6
         eyp6=(ey48-ey15)*delwz+ey15
! %%%%%%     in plane 4:
!  node 2:(i+1,j,k) node 3:(i+1,j,k+1) node 6:(i+1,j+1,k) node 7:(i+1,j+1,k+1)
!   axis(nd2,nd6): ey26
!   axis(nd3,nd7): ey37
!    plane 4
         eyp4=(ey37-ey26)*delwz+ey26
! $$$$plane6+plane4
         eyp46=(eyp4-eyp6)*delux+eyp6
! \A3\A3\A3 (plane2+plane5)+(plane4+plane6)--> field Ez(u,v,w)
         eyt=(eyp25+eyp46)/2.D0
! *******interpollation of the field component Ez
! %%%%%%     in plane 1:
!  node 1:(i,j,k) node 2:(i+1,j,k) node 3:(i+1,j,k+1) node 4:(i,j,k+1)
! axis(nd1,nd4)
         ez14=(ezk(i,j,k+1)-ezk(i,j,k))*delwz+ezk(i,j,k)
! axis(nd2,nd3)
         ez23=(ezk(i+1,j,k+1)-ezk(i+1,j,k))*delwz+ezk(i+1,j,k)
!   plane 1
         ezp1=(ez23-ez14)*delux+ez14
! %%%%%%     in plane 3:
!  node 5:(i,j+1,k) node 6:(i+1,j+1,k) node 7:(i+1,j+1,k+1) node 8:(i,j+1,k+1)
!  axis (nd5,nd8)
         ez58=(ezk(i,j+1,k+1)-ezk(i,j+1,k))*delwz+ezk(i,j+1,k)
!  axis (nd6,nd7)
         ez67=(ezk(i+1,j+1,k+1)-ezk(i+1,j+1,k))*delwz+ezk(i+1,j+1,k)
!   plane 3
         ezp3=(ez67-ez58)*delux+ez58
!  $$$$$$ plane1+plane3
         ezp13=(ezp3-ezp1)*delvy+ezp1
! %%%%%%     in plane 6:
!  node 1:(i,j,k) node 5:(i,j+1,k) node 4:(i,j,k+1) node 8:(i,j+1,k+1)
!  axis (nd1,nd4)
         ez14=(ezk(i,j,k+1)-ezk(i,j,k))*delwz+ezk(i,j,k)
!  axis (nd5,nd8)
         ez58=(ezk(i,j+1,k+1)-ezk(i,j+1,k))*delwz+ezk(i,j+1,k)
!   plane 6
         ezp6=(ez58-ez14)*delvy+ez14
! %%%%%%     in plane 4:
!  node 2:(i+1,j,k) node 3:(i+1,j,k+1) node 6:(i+1,j+1,k) node 7:(i+1,j+1,k+1)
!  axis(nd2,nd3)
         ez23=(ezk(i+1,j,k+1)-ezk(i+1,j,k))*delwz+ezk(i+1,j,k)
!  axis(nd6,nd7)
         ez67=(ezk(i+1,j+1,k+1)-ezk(i+1,j+1,k))*delwz+ezk(i+1,j+1,k)
!     plane 4
         ezp4=(ez67-ez23)*delvy+ez23
! $$$$$$ plane6+plane4
         ezp64=(ezp4-ezp6)*delux+ezp6
! \A3\A3\A3\A3\A3\A3\A3 (P1+P3)+(P6+P4)----> Ez(u,v,w)
         ezt=(ezp13+ezp64)/2.D0
         insd=insd+1
! calculate kicks in x',y' and z' (energy)
         eztp=ezt*cos(apl)-ext*sin(apl)
         extp=ezt*sin(apl)+ext*cos(apl)
         ezt=eztp
         ext=extp
         gsc=f(7,ic)/xmat
         bsc=sqrt(1.D0-1.D0/(gsc*gsc))
!omment         cmacrxy=cmacro/(bmoy*bmoy*gmoy*gmoy*gmoy)
!omment         cmacrxy=cmacro/(bsc*bsc*gsc*gsc)
         dxp=const2*ext*dz*cmacrxy*abs(f(9,ic))
         dyp=const2*eyt*dz*cmacrxy*abs(f(9,ic))
         dw=const3*ezt*dz*cmacro*abs(f(9,ic))
! ****test************************************
!omment              dw=dw/gmoy
!  ****************************************
         if(.not.iesp) then
!     load the entrance beam parameters for cavities or gaps
           do js=1,7
             f(js,ic)=fs(js,ic)
           enddo
           f(3,ic)=f(3,ic)+dxp*1000.D0
           f(5,ic)=f(5,ic)+dyp*1000.D0
           f(2,ic)=f(2,ic)-dz1*dxp*100.D0*xpsc
           f(4,ic)=f(4,ic)-dz1*dyp*100.D0*xpsc
!omment           f(2,ic)=f(2,ic)-dz1*dxp*100.
!omment           f(4,ic)=f(4,ic)-dz1*dyp*100.
           dwp(ic)=dw
         else
               f(3,ic)=f(3,ic)+dxp*1000.D0
               f(5,ic)=f(5,ic)+dyp*1000.D0
               f(7,ic)=f(7,ic)+dw
         endif
       else
!  the particle is not in the mesh
!   compute the beam self-fields as made at the nodes
         ax=0.D0
         ay=0.D0
         az=0.D0
         if(isucc.eq.1) then
           s3=xc(ic)/rms(3,2)
           s2=yc(ic)/rms(2,2)
           s1=zc(ic)/rms(1,2)
           ax=pwtpi*rms(3,2)
           ay=pwtpi*rms(2,2)
           az=pwtpi*rms(1,2)
           rrx=rms(3,2)
           rry=rms(2,2)
           rrz=rms(1,2)
         endif
         if(isucc.eq.2) then
           s3=yc(ic)/rms(3,2)
           s2=zc(ic)/rms(2,2)
           s1=xc(ic)/rms(1,2)
           ax=pwtpi*rms(1,2)
           ay=pwtpi*rms(3,2)
           az=pwtpi*rms(2,2)
           rrx=rms(1,2)
           rry=rms(3,2)
           rrz=rms(2,2)
         endif
         if(isucc.eq.3) then
           s3=zc(ic)/rms(3,2)
           s2=xc(ic)/rms(2,2)
           s1=yc(ic)/rms(1,2)
           ax=pwtpi*rms(2,2)
           ay=pwtpi*rms(1,2)
           az=pwtpi*rms(3,2)
           rrx= rms(2,2)
           rry=rms(1,2)
           rrz=rms(3,2)
         endif
! abs(argument) of exp needs to be smaller than 708 to avoid overflow/underflow
! means s1,s2,s3 should be smaller than 37.6 (using 30 above); see subroutine uvrms   
         if(abs(s1).gt.30.D0 .or. abs(s2).gt.30.D0 .or. abs(s3).gt.30.D0) f(8,ic)=0.D0
! particle is lost
         if(int(F(8,ic)).EQ.0) cycle
!       storage arrays of the functions in the integrals in tables 75 and 76
!       these values given in table 73 are independent of l, m and n
!       They are stored in: epsi1(i,j),epsi2(i,j), akpc1(i,j), akpc2(i,j),
!          akps1(i,j), akps2(i,j) where i,j are the Gauss positions
         call uvrms
!     field computation
!     loop over the l,m and n
         ext=0.D0
         eyt=0.D0
         ezt=0.D0
         do jn=1,nmax
           jn1=jn-1
           do jm=1,mmax
             jm1=jm-1
             do jl=1,lmax
               jl1=jl-1
!               if(a(jl,jm,jn).ne.0.) then
               if(abs(a(jl,jm,jn)).gt.fprec) then
!     in output the SUBROUTINE field returns the values of the FUNCTION E*(l,m,n)
!     shown in tables 77-a-1 to 77-b-2 in x,y and z-directions-->ex,ey,ez
                 call fielde(jl1,jm1,jn1,isucc)
!     the corresonding field components are obtained from tables 67-a to 67-h
                 ext=a(jl,jm,jn)/ax*ex+ext
                 eyt=a(jl,jm,jn)/ay*ey+eyt
                 ezt=a(jl,jm,jn)/az*ez+ezt
               endif
             enddo
           enddo
         enddo
         iout=iout+1
!    kicks
!    kicks computation
! calculate kick in x',y' and z' (energy)
!   isochronism correction
         eztp=ezt*cos(apl)-ext*sin(apl)
         extp=ezt*sin(apl)+ext*cos(apl)
         ezt=eztp
         ext=extp
         gsc=f(7,ic)/xmat
         bsc=sqrt(1.D0-1.D0/(gsc*gsc))
!omment         cmacrxy=cmacro/(bmoy*bmoy*gmoy*gmoy)
!omment         cmacrxy=cmacro/(bsc*bsc*gsc*gsc)
         dxp=const2*ext*dz*cmacrxy*abs(f(9,ic))
         dyp=const2*eyt*dz*cmacrxy*abs(f(9,ic))
         dw=const3*ezt*dz*cmacro*abs(f(9,ic))
         if(.not.iesp) then
!     load the beam at the input at cavities or gaps
           do js=1,7
             f(js,ic)=fs(js,ic)
           enddo
           f(3,ic)=f(3,ic)+dxp*1000.D0
           f(5,ic)=f(5,ic)+dyp*1000.D0
           f(2,ic)=f(2,ic)-dz1*dxp*100.D0*xpsc
           f(4,ic)=f(4,ic)-dz1*dyp*100.D0*xpsc
!omment            f(2,ic)=f(2,ic)-dz1*dxp*100.
!omment            f(4,ic)=f(4,ic)-dz1*dyp*100.
           dwp(ic)=dw
         else
            f(3,ic)=f(3,ic)+dxp*1000.D0
            f(5,ic)=f(5,ic)+dyp*1000.D0
            f(7,ic)=f(7,ic)+dw
         endif
       endif
! end of if particle not in mesh
       nprint=nprint+1
! end of the loop ic
     enddo
     write(16,*) ' particles in the mesh:',insd,' outside: ',iout
! end of if when ini=2
   endif
END SUBROUTINE hersc
!> *******************************************************************
!! SUBROUTINE bhdist
!! called by HERSC
!! computes: the coefficients A(l,m,n)
!!           the rms sizes in x, y and z-direction
!! selects:  the significants terms in the Hermite series expansion
!! lmax, mmax and nmax are the maximum values of l, m, n for these
!! coefficients
!< *******************************************************************
SUBROUTINE bhdist
   USE m4hersc6, ONLY: lmax,mmax,nmax,lmaxi,mmaxi,nmaxxi
   USE m4hersc7, ONLY: hect
   IMPLICIT NONE
!*******************************************************************
!  hermite degrees
   lmax=lmaxi
   mmax=mmaxi
   nmax=nmaxxi
   hect=4.D0
   call pintfast
   call hcoef
END SUBROUTINE bhdist
!> *******************************************************************
!! SUBROUTINE trms(isucc)
!! called by HERSC
!! storage  of the variables depending only of the rms sizes
!! lmax,mmax,nmax : maximum of the subscripts: l,m,n
!!                  for the significants Almn
!! isucc:order of succession of the integrals in table 1-b
!!     isucc=1: order of succesion x-->y-->z
!!     isucc=2: order of succesion y-->z-->x
!!     isucc=3: order of succesion z-->x-->y
!< *******************************************************************
SUBROUTINE trms(isucc)
   USE DynacConstants
   USE m4hersc, ONLY: rms
   USE m4hersc2, ONLY: igaus,co,sn,blam
   USE m4hersc6, ONLY: lmax,mmax,nmax,xrmsz,yrmsz,zrmsz
   IMPLICIT NONE
   INTEGER i
   REAL(8) rmin,x1,x2,x3
   INTEGER isucc,i1m,i2m,i3m,ii,im,j1,maxi,maxt
!*******************************************************************
!  lmax,mmax,nmax from zero
!  minimum of the rms sizes xrmsz,yrmsz,zrmsz
   rmin=xrmsz
   if(rmin.gt.yrmsz) rmin=yrmsz
   if(rmin.gt.zrmsz) rmin=zrmsz
!  order of the succession of the integrals
   if(abs(rmin-zrmsz).le.fprec) isucc=3
   if(abs(rmin-yrmsz).le.fprec) isucc=2
   if(abs(rmin-xrmsz).le.fprec) isucc=1
!   maximum of lmax,mmax,nmax
   maxi=lmax
   if(maxi.lt.mmax) maxi=mmax
   if(maxi.lt.nmax) maxi=nmax
   maxt=2*(maxi+1)+3
   x3=0.D0
   x2=0.D0
   x1=0.D0
!  order of succession x->y->z
   if(isucc.eq.1) then
     x3=xrmsz
     x2=yrmsz
     x1=zrmsz
   endif
!  order of succession y->z->x
   if(isucc.eq.2) then
     x3=yrmsz
     x2=zrmsz
     x1=xrmsz
   endif
!  order of succession z->x->y
   if(isucc.eq.3) then
     x3=zrmsz
     x2=xrmsz
     x1=yrmsz
   endif
!   array rms(j,i) Powers of the rms sizes  j=1,2,3, the value i is the power
   rms(3,1)=1.D0
   rms(2,1)=1.D0
   rms(1,1)=1.D0
   do i=2,maxt
     rms(3,i)=rms(3,i-1)*x3
     rms(2,i)=rms(2,i-1)*x2
     rms(1,i)=rms(1,i-1)*x1
   enddo
   j1=kmax/2
   i1m=(lmax+1)/2
   i2m=(mmax+1)/2
   i3m=(nmax+1)/2
   im=i1m+i2m+i3m+j1+4
   if(im.ge.40) then
     write(16,*) ' overlap the array blam with im= ',im
     stop
   endif
   do i=1,igaus
     blam(i,1)=(rms(1,3)*co(i,3)+rms(2,3)*sn(i,3))/rms(3,3)
     do ii=2,im
       blam(i,ii)=blam(i,ii-1)*blam(i,1)
     enddo
   enddo
END SUBROUTINE trms
!> *******************************************************************
!! SUBROUTINE uvrms
!! called by HERSC
!! storage of the variables depending only of the coordinate s3
!< *******************************************************************
SUBROUTINE uvrms
   USE DynacConstants
   USE m4hersc
   USE m4hersc2
   USE m4hersc3, ONLY: hs1,hs2,hs3
   USE m4hersc5, ONLY: epsi1,epsi2,akpcc,akpcs,akpsc,akpss,ragp
   USE m4hersc7, ONLY: lmnt
   IMPLICIT NONE
   INTEGER i
   REAL(8) aeps1,aeps2,akc1,akc2,arg,arghm1,arghm2,as31,as32,earg,r13,r23,s12,s22
   REAL(8) s1rms,s2rms,wgpi,xlblam
   INTEGER iarg,ig,ihe,inhs,j
!*******************************************************************
   s32=s3*s3
   s22=s2*s2
   s12=s1*s1
   exs3=exp(-s32/2.D0)
   exs2=exp(-s22/2.D0)
   exs1=exp(-s12/2.D0)
   as3=abs(s3)
   sgns3=1.D0
   if(s3.lt. 0.D0) sgns3=-1.D0
   as31=as3*s1
   as32=as3*s2
   s1rms=s1*rms(1,2)
   s2rms=s2*rms(2,2)
!  power of as3, used in the functions spii,......
   s3pw(1)=1.D0
   do i=2,kmax
     s3pw(i)=s3pw(i-1)*as3
   enddo
!    memory array hsint(ig,arg,indice) for functions sipp,...
   do ig=1,igaus
     wgpi=wg(ig)*pi/2.D0
     sqblam(ig)=sqrt(blam(ig,1))
     xlblam=sqblam(ig)*rms(3,2)
     do iarg=1,2
       arghm1=s1rms*co(ig,2)/xlblam
       arghm2=s2rms*sn(ig,2)/xlblam
       if(iarg.eq.1) then
         arg=arghm1+arghm2
         earg=exp(-arg*arg/2.D0)
       endif
       if(iarg.eq.2) then
         arg=arghm1-arghm2
         earg=exp(-arg*arg/2.D0)
       endif
       hsint(ig,iarg,1)=1.D0*earg*wgpi
       hsint(ig,iarg,2)=arg*earg*wgpi
       do inhs=3,lmnt
         hsint(ig,iarg,inhs)=arg*hsint(ig,iarg,inhs-1) &
                       -DBLE(inhs-2)*hsint(ig,iarg,inhs-2)
       enddo
     enddo
   enddo
   r13=rms(1,2)/rms(3,2)
   r23=rms(2,2)/rms(3,2)
   do j=1,igaus
     do i=1,igaus
       aeps1=ragp(i,3)*(blam(j,1)-1.D0)/2.D0
       aeps1=s32*(aeps1+ragp(i,2))
       aeps2=ragp(i,3)*blam(j,1)/2.D0
       aeps2=aeps2*s32
       if(aeps1 .gt. 300.D0) aeps1=300.D0
       if(aeps2 .gt. 300.D0) aeps2=300.D0
       akc1=ragp(i,2)*r13*co(j,2)*as31
       akc2=ragp(i,2)*r23*sn(j,2)*as32
!2019           aks1=ragp(i,2)*r13*co(j,2)*as31
!2019           aks2=ragp(i,2)*r23*sn(j,2)*as32
       epsi1(i,j)=exp(-aeps1)*wg(i)
       epsi2(i,j)=exp(-aeps2)*wg(i)
       akpcc(i,j)=cos(akc1)*cos(akc2)
       akpcs(i,j)=cos(akc1)*sin(akc2)
       akpsc(i,j)=sin(akc1)*cos(akc2)
       akpss(i,j)=sin(akc1)*sin(akc2)
     enddo
   enddo
!Hermite functions
   hs1(1)=exs1
   hs2(1)=exs2
   hs3(1)=exs3
   hs1(2)=s1*exs1
   hs2(2)=s2*exs2
   hs3(2)=s3*exs3
   do ihe=3,lmnt
     hs1(ihe)=s1*hs1(ihe-1)-DBLE(ihe-2)*hs1(ihe-2)
     hs2(ihe)=s2*hs2(ihe-1)-DBLE(ihe-2)*hs2(ihe-2)
     hs3(ihe)=s3*hs3(ihe-1)-DBLE(ihe-2)*hs3(ihe-2)
   enddo
END SUBROUTINE uvrms
!> *******************************************************************
!! SUBROUTINE fielde(lc,mc,nc,isucc)
!! beam self-fields computation called by HERSC
!! look for the parity of the currents lc,mc and nc
!! compute the corresponding field components
!!     isucc=1: a<b,c
!!     isucc=2: b<a,c
!!     isucc=3: c<a,b
!! x,y,z are the scaling coordinates: x/a,y/b,z/c
!! The corresponding analytical equations are in the number of the
!! tables. The table number in 'comments' refers to the corresponding
!! analytical equations
!< *******************************************************************
SUBROUTINE fielde(lc,mc,nc,isucc)
   USE DynacConstants
   USE m4hersc
   USE m4hersc3, ONLY: makti,maktp
   USE m4hersc4, ONLY: maksi,maksp
   USE fun4scherm, ONLY: eiii,eiip,eipi,eipp,epii,epip,eppi,eppp
   USE m4HermiteFun, ONLY: mksgi,mksgp
   USE m4hersc7, ONLY: ex,ey,ez
   IMPLICIT NONE
   REAL(8) apwas3,tl,tm,tn,xlc,xmc,xnc
   INTEGER lc,mc,nc,isucc
   INTEGER it,it1,it2,it3,itpar
!       pi2=pi*pi, sqpi=(pi/2)**3/2
   logical lpl,lpm,lpn
!*******************************************************************
!     look for the parity of the currents lc,mc,nc
   lpl=.false.
   lpm=.false.
   lpn=.false.
   makti=.false.
   maktp=.false.
   maksi=.false.
   maksp=.false.
   mksgi=.false.
   mksgp=.false.
   xlc=DBLE(lc)
   tl=xlc-2.D0*DBLE(int(xlc/2.D0+0.0001D0))
   if(abs(tl).le.fprec)lpl=.true.
   xmc=DBLE(mc)
   tm=xmc-2.D0*DBLE(int(xmc/2.D0+0.0001D0))
   if(abs(tm).le.fprec)lpm=.true.
   xnc=DBLE(nc)
   tn=xnc-2.D0*DBLE(int(xnc/2.D0+0.0001D0))
   if(abs(tn).le.fprec)lpn=.true.
   if(lpl.and.lpm.and.lpn) itpar=1
   if(lpl.and.lpm.and..not.lpn) itpar=2
   if(lpl.and..not.lpm.and.lpn) itpar=3
   if(lpl.and..not.lpm.and..not.lpn) itpar=4
   if(.not.lpl.and.lpm.and.lpn) itpar=5
   if(.not.lpl.and.lpm.and..not.lpn) itpar=6
   if(.not.lpl.and..not.lpm.and.lpn) itpar=7
   if(.not.lpl.and..not.lpm.and..not.lpn) itpar=8
!
!  values of the variables it1,it2,it3 in relation with lc,mc,nc
!  the initial values of these lc,mc,nc is zero
   if (isucc.eq.1) then
!  a<b,c
     if(itpar.eq.1) then
!       E E E and  a<b,c:
!                  table 67-a: Ex=E(2t3+1,2t2,2t1)
!                              Ey=E(2t3,2t2+1,2t1)
!                              Ez=E(2t3,2t2,2t1+1)
!        values of it1,it2,it3 in table 3-a
       it3=lc/2
       it2=mc/2
       it1=nc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!        it=2*(it1+it2+it3)+1
         it=lc+mc+nc+1
         pwas3=as3**it
       endif
       ex=eipp(it1,it2,it3)
       ey=epip(it1,it2,it3)
       ez=eppi(it1,it2,it3)
       return
     endif
     if(itpar.eq.2) then
!   E E I and  a<b,c
!              table 67-g: Ex=E(2t3+1,2t2,2t1+1)
!                          Ey=E(2t3,2t2+1,2t1+1)
!                          Ez=E(2t3,2t2,2t1)
!    values of it1,it2,it3 in table 3-g
!    x-direction and y-direction
       it3=lc/2
       it2=mc/2
       it1=(nc-1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
! it=2*(it1+it2+it3)+1
         it=lc+mc+nc
         pwas3=as3**it
       endif
       ex=eipi(it1,it2,it3)
       ey=epii(it1,it2,it3)
! z-direction
       it1=(nc+1)/2
!       if(s3.ne.0.)pwas3=pwas3*s32
       if(abs(s3).gt.fprec)pwas3=pwas3*s32
! it=2*(it1+it2+it3)+1
       ez=eppp(it1,it2,it3)
       return
     endif
     if(itpar.eq.3) then
!   E I E and  a<b,c
!           in table 67-h: Ex=E(2t3+1,2t2+1,2t1)
!                          Ey=E(2t3,2t2,2t1)
!                          Ez=E(2t3,2t2+1,2t1+1)
!    values of it1,it2,it3 in table 3-h
!    x-direction
       it3=lc/2
       it2=(mc-1)/2
       it1=nc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
! it=2*(it1+it2+it3)+1
         it=lc+mc+nc
         apwas3=as3**it
         pwas3=apwas3
       endif
       ex=eiip(it1,it2,it3)
!    y-direction
       it3=lc/2
       it2=(mc+1)/2
       it1=nc/2
!   it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=pwas3*s32
       if(abs(s3).gt.fprec)pwas3=pwas3*s32
       ey=eppp(it1,it2,it3)
!    z-direction
       it3=lc/2
       it2=(mc-1)/2
       it1=nc/2
!       if(s3.ne.0.)pwas3=apwas3
       if(abs(s3).gt.fprec)pwas3=apwas3
!   it=2*(it1+it2+it3)+1
       ez=epii(it1,it2,it3)
       return
     endif
     if(itpar.eq.4) then
!   E I I and  a<b,c
!           in table 67-f: Ex=E(2t3+1,2t2+1,2t1+1)
!                          Ey=E(2t3,2t2,2t1+1)
!                          Ez=E(2t3,2t2+1,2t1)
!    values of it1,it2,it3 in table 3-f
!    x-direction
       it3=lc/2
       it2=(mc-1)/2
       it1=(nc-1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!it=2*(it1+it2+it3)+1
         it=lc+mc+nc-1
         pwas3=as3**it
       endif
       ex=eiii(it1,it2,it3)
!    y-direction
       it3=lc/2
       it2=(mc+1)/2
       it1=(nc-1)/2
!     it=2*(it1+it2+it3)+1
!       if(s3.ne.0.)pwas3=pwas3*s32
       if(abs(s3).gt.fprec)pwas3=pwas3*s32
       ey=eppi(it1,it2,it3)
!    z-direction
       it3=lc/2
       it2=(mc-1)/2
       it1=(nc+1)/2
       ez=epip(it1,it2,it3)
       return
     endif
     if(itpar.eq.5) then
!   I E E and  a<b,c
!           in table 67-c: Ex=E(2t3,2t2,2t1)
!                          Ey=E(2t3+1,2t2+1,2t1)
!                          Ez=E(2t3+1,2t2,2t1+1)
!    values of it1,it2,it3 in table 3-c
!    x-direction
       it3=(lc+1)/2
       it2=mc/2
       it1=nc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!   it=2*(it1+it2+it3)+1
         it=lc+mc+nc
         apwas3=as3**it
         pwas3=apwas3*s32
       endif
       ex=eppp(it1,it2,it3)
!    y-direction
       it3=(lc-1)/2
       it2=mc/2
       it1=nc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!   it=2*(it1+it2+it3)+1
         pwas3=apwas3
         pw3as3=apwas3
       endif
       ey=eiip(it1,it2,it3)
!    z-direction
       it3=(lc-1)/2
       it2=mc/2
       it1=nc/2
       ez=eipi(it1,it2,it3)
       return
     endif
     if(itpar.eq.6) then
!   I E I and  a<b,c
!           in table 67-e: Ex=E(2t3,2t2,2t1+1)
!                          Ey=E(2t3+1,2t2+1,2t1+1)
!                          Ez=E(2t3+1,2t2,2t1)
!    values of it1,it2,it3 in table 3-e
!    x-direction
       it3=(lc+1)/2
       it2=mc/2
       it1=(nc-1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!  it=2*(it1+it2+it3)+1
         it=lc+mc+nc-1
         apwas3=as3**it
         pwas3=apwas3*s32
       endif
       ex=eppi(it1,it2,it3)
!    y-direction
       it3=(lc-1)/2
       it2=mc/2
       it1=(nc-1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!         it=2*(it1+it2+it3)+1
         pwas3=apwas3
       endif
       ey=eiii(it1,it2,it3)
!    z-direction
       it3=(lc-1)/2
       it2=mc/2
       it1=(nc+1)/2
!  it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=pwas3*s32
       if(abs(s3).gt.fprec) pwas3=pwas3*s32
       ez=eipp(it1,it2,it3)
       return
     endif
     if(itpar.eq.7) then
!   I I E and  a<b,c
!           in table 67-d: Ex=E(2t3,2t2+1,2t1)
!                          Ey=E(2t3+1,2t2,2t1)
!                          Ez=E(2t3+1,2t2+1,2t1+1)
!    values of it1,it2,it3 in table 3-d
!    x-direction
       it3=(lc+1)/2
       it2=(mc-1)/2
       it1=nc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!  it=2*(it1+it2+it3)+1
         it=lc+mc+nc-1
         apwas3=as3**it
         pwas3=apwas3*s32
       endif
       ex=epip(it1,it2,it3)
!    y-direction
       it3=(lc-1)/2
       it2=(mc+1)/2
       it1=nc/2
!         it=2*(it1+it2+it3)+1
       ey=eipp(it1,it2,it3)
!    z-direction
       it3=(lc-1)/2
       it2=(mc-1)/2
       it1=nc/2
!     it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=apwas3
       if(abs(s3).gt.fprec) pwas3=apwas3
       ez=eiii(it1,it2,it3)
       return
     endif
     if(itpar.eq.8) then
!   I I I and  a<b,c
!           in table 67-b: Ex=E(2t3,2t2+1,2t1+1)
!                          Ey=E(2t3+1,2t2,2t1+1)
!                          Ez=E(2t3+1,2t2+1,2t1)
!    values of it1,it2,it3 in table 3-b
!    x-direction
       it3=(lc+1)/2
       it2=(mc-1)/2
       it1=(nc-1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!    it=2*(it1+it2+it3)+1
         it=lc+mc+nc
         pwas3=as3**it
       endif
       ex=epii(it1,it2,it3)
!    y-direction
       it3=(lc-1)/2
       it2=(mc+1)/2
       it1=(nc-1)/2
! it=2*(it1+it2+it3)+1
       ey=eipi(it1,it2,it3)
!    z-direction
       it3=(lc-1)/2
       it2=(mc-1)/2
       it1=(nc+1)/2
       ez=eiip(it1,it2,it3)
       return
     endif
!endif of isucc=1----> a<b,c
   endif
   if (isucc.eq.2) then
!   b<a,c
     if(itpar.eq.1) then
!   E E E and  b<a,c
!              table 67-a: Ex=E(2t3,2t2,2t1+1)
!                          Ey=E(2t3+1,2t2,2t1)
!                          Ez=E(2t3,2t2+1,2t1)
!    values of it1,it2,it3 in table 3-a
       it3=mc/2
       it2=nc/2
       it1=lc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!  it=2*(it1+it2+it3)+1
         it=mc+nc+lc+1
         pwas3=as3**it
       endif
       ex=eppi(it1,it2,it3)
       ey=eipp(it1,it2,it3)
       ez=epip(it1,it2,it3)
       return
     endif
     if(itpar.eq.2) then
!   E E I and  b<a,c
!              table 67-h: Ex=E(2t3,2t2+1,2t1+1)
!                          Ey=E(2t3+1,2t2+1,2t1)
!                          Ez=E(2t3,2t2,2t1)
!    values of it1,it2,it3 in table 3-h
!    x-direction and y-direction
       it3=mc/2
       it2=(nc-1)/2
       it1=lc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!  it=2*(it1+it2+it3)+1
         it=mc+nc+lc
         pwas3=as3**it
       endif
       ex=epii(it1,it2,it3)
       ey=eiip(it1,it2,it3)
!    z-direction
       it2=(nc+1)/2
! it=2*(it1+it2+it3)+1
!       if(s3.ne.0.)pwas3=pwas3*s32
       if(abs(s3).gt.fprec)pwas3=pwas3*s32
       ez=eppp(it1,it2,it3)
       return
     endif
     if(itpar.eq.3) then
!   E I E and  b<a,c
!           in table 67-c: Ex=E(2t3+1,2t2,2t1+1)
!                          Ey=E(2t3,2t2,2t1)
!                          Ez=E(2t3+1,2t2+1,2t1)
!    values of it1,it2,it3 in table 3-c
!    x-direction
       it3=(mc-1)/2
       it2=nc/2
       it1=lc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
! it=2*(it1+it2+it3)+1
         it=mc+nc+lc
         apwas3=as3**it
         pwas3= apwas3
       endif
       ex=eipi(it1,it2,it3)
!    y-direction
       it3=(mc+1)/2
       it2=nc/2
       it1=lc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!  it=2*(it1+it2+it3)+1
         pwas3=pwas3*s32
       endif
       ey=eppp(it1,it2,it3)
!    z-direction
       it3=(mc-1)/2
       it2=nc/2
       it1=lc/2
!       if(s3.ne.0.) pwas3= apwas3
       if(abs(s3).gt.fprec)pwas3=apwas3
       ez=eiip(it1,it2,it3)
       return
     endif
     if(itpar.eq.4) then
!   E I I and  b<a,c
!           in table 67-d: Ex=E(2t3+1,2t2+1,2t1+1)
!                          Ey=E(2t3,2t2+1,2t1)
!                          Ez=E(2t3+1,2t2,2t1)
!    values of it1,it2,it3 in table 3-d
!    x-direction
       it3=(mc-1)/2
       it2=(nc-1)/2
       it1=lc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!  it=2*(it1+it2+it3)+1
         it=mc+nc+lc-1
         pwas3=as3**it
       endif
       ex=eiii(it1,it2,it3)
!    y-direction
       it3=(mc+1)/2
       it2=(nc-1)/2
       it1=lc/2
!it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         pwas3=pwas3*s32
       endif
       ey=epip(it1,it2,it3)
!    z-direction
       it3=(mc-1)/2
       it2=(nc+1)/2
       it1=lc/2
!         it=2*(it1+it2+it3)+1
       ez=eipp(it1,it2,it3)
       return
     endif
     if(itpar.eq.5) then
!   I E E and  b<a,c
!           in table 67-g: Ex=E(2t3,2t2,2t1)
!                          Ey=E(2t3+1,2t2,2t1+1)
!                          Ez=E(2t3,2t2+1,2t1+1)
!    values of it1,it2,it3 in table 3-g
!    x-direction
       it3=mc/2
       it2=nc/2
       it1=(lc+1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!   it=2*(it1+it2+it3)+1
         it=mc+nc+lc
         apwas3=as3**it
         pwas3=apwas3*s32
       endif
       ex=eppp(it1,it2,it3)
!    y-direction
       it3=mc/2
       it2=nc/2
       it1=(lc-1)/2
!it=2*(it1+it2+it3)+1
!       if(s3.ne.0.)pwas3=apwas3
       if(abs(s3).gt.fprec)pwas3=apwas3
       ey=eipi(it1,it2,it3)
!    z-direction
       it3=mc/2
       it2=nc/2
       it1=(lc-1)/2
       ez=epii(it1,it2,it3)
       return
     endif
     if(itpar.eq.6) then
!   I E I and  b<a,c
!           in table 67-f: Ex=E(2t3,2t2+1,2t1)
!                          Ey=E(2t3+1,2t2+1,2t1+1)
!                          Ez=E(2t3,2t2,2t1+1)
!    values of it1,it2,it3 in table 3-f
!    x-direction
       it3=mc/2
       it2=(nc-1)/2
       it1=(lc+1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!it=2*(it1+it2+it3)+1
         it=mc+nc+lc-1
         apwas3=as3**it
         pwas3=apwas3*s32
       endif
       ex=epip(it1,it2,it3)
!    y-direction
       it3=mc/2
       it2=(nc-1)/2
       it1=(lc-1)/2
!  it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=apwas3
       if(abs(s3).gt.fprec)pwas3=apwas3
       ey=eiii(it1,it2,it3)
!    z-direction
       it3=mc/2
       it2=(nc+1)/2
       it1=(lc-1)/2
!  it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=apwas3*s32
       if(abs(s3).gt.fprec) pwas3=apwas3*s32
       ez=eppi(it1,it2,it3)
       return
     endif
     if(itpar.eq.7) then
!   I I E and  b<a,c
!           in table 66-e: Ex=E(2t3+1,2t2,2t1)
!                          Ey=E(2t3,2t2,2t1+1)
!                          Ez=E(2t3+1,2t2+1,2t1+1)
!    values of it1,it2,it3 in table 3-e
!    x-direction
       it3=(mc-1)/2
       it2=nc/2
       it1=(lc+1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!it=2*(it1+it2+it3)+1
         it=mc+nc+lc-1
         apwas3=as3**it
         pwas3=apwas3*s32
       endif
       ex=eipp(it1,it2,it3)
!    y-direction
       it3=(mc+1)/2
       it2=nc/2
       it1=(lc-1)/2
!         it=2*(it1+it2+it3)+1
       ey=eppi(it1,it2,it3)
!    z-direction
       it3=(mc-1)/2
       it2=nc/2
       it1=(lc-1)/2
!       if(s3.ne.0.) pwas3=apwas3
       if(abs(s3).gt.fprec)pwas3=apwas3
!   it=2*(it1+it2+it3)+1
       ez=eiii(it1,it2,it3)
      return
     endif
     if(itpar.eq.8) then
!   I I I and  b<a,c
!           in table 67-b: Ex=E(2t3+1,2t2+1,2t1)
!                          Ey=E(2t3,2t2+1,2t1+1)
!                          Ez=E(2t3+1,2t2,2t1+1)
!    values of it1,it2,it3 in table 3-b
!    x-direction
       it3=(mc-1)/2
       it2=(nc-1)/2
       it1=(lc+1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!it=2*(it1+it2+it3)+1
         it=mc+nc+lc
         pwas3=as3**it
       endif
       ex=eiip(it1,it2,it3)
!    y-direction
       it3=(mc+1)/2
       it2=(nc-1)/2
       it1=(lc-1)/2
! it=2*(it1+it2+it3)+1
       ey=epii(it1,it2,it3)
!    z-direction
       it3=(mc-1)/2
       it2=(nc+1)/2
       it1=(lc-1)/2
!         it=2*(it1+it2+it3)+1
       ez=eipi(it1,it2,it3)
       return
     endif
!endif of isucc=2----> b<a,c
   endif
   if (isucc.eq.3) then
!   c<a,b
     if(itpar.eq.1) then
!   E E E and  c<a,b
!              table 67-a: Ex=E(2t3,2t2+1,2t1)
!                          Ey=E(2t3,2t2,2t1+1)
!                          Ez=E(2t3+1,2t2,2t1)
!    values of it1,it2,it3 in table 3-a
       it3=nc/2
       it2=lc/2
       it1=mc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!it=2*(it1+it2+it3)+1
         it=nc+lc+mc+1
         pwas3=as3**it
       endif
       ex=epip(it1,it2,it3)
       ey=eppi(it1,it2,it3)
       ez=eipp(it1,it2,it3)
       return
     endif
     if(itpar.eq.2) then
!   E E I and  c<a,b
!              table 67-c: Ex=E(2t3+1,2t2+1,2t1)
!                          Ey=E(2t3+1,2t2,2t1+1)
!                          Ez=E(2t3,2t2,2t1)
!    values of it1,it2,it3 in table 3-c
!    x-direction and y-direction
       it3=(nc-1)/2
       it2=lc/2
       it1=mc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
! it=2*(it1+it2+it3)+1
         it=nc+lc+mc
         pwas3=as3**it
       endif
       ex=eiip(it1,it2,it3)
       ey=eipi(it1,it2,it3)
!    z-direction
       it3=(nc+1)/2
!       if(s3.ne.0.) pwas3=pwas3*s32
       if(abs(s3).gt.fprec) pwas3=pwas3*s32
!   it=2*(it1+it2+it3)+1
       ez=eppp(it1,it2,it3)
       return
     endif
     if(itpar.eq.3) then
!   E I E and  c<a,b
!           in table 67-g: Ex=E(2t3,2t2+1,2t1+1)
!                          Ey=E(2t3,2t2,2t1)
!                          Ez=E(2t3+1,2t2,2t1+1)
!    values of it1,it2,it3 in table 3-g
!    x-direction
       it3=nc/2
       it2=lc/2
       it1=(mc-1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
! it=2*(it1+it2+it3)+1
         it=nc+lc+mc
         apwas3=as3**it
         pwas3=apwas3
       endif
       ex=epii(it1,it2,it3)
!    y-direction
       it3=nc/2
       it2=lc/2
       it1=(mc+1)/2
! it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=pwas3*s32
       if(abs(s3).gt.fprec) pwas3=pwas3*s32
       ey=eppp(it1,it2,it3)
!    z-direction
       it3=nc/2
       it2=lc/2
       it1=(mc-1)/2
!       if(s3.ne.0.) pwas3=apwas3
       if(abs(s3).gt.fprec) pwas3=apwas3
       ez=eipi(it1,it2,it3)
       return
     endif
     if(itpar.eq.4) then
!   E I I and  c<a,b
!           in table 67-e: Ex=E(2t3+1,2t2+1,2t1+1)
!                          Ey=E(2t3+1,2t2,2t1)
!                          Ez=E(2t3,2t2,2t1+1)
!    values of it1,it2,it3 in table 3-e
!    x-direction
       it3=(nc-1)/2
       it2=lc/2
       it1=(mc-1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!   it=2*(it1+it2+it3)+1
         it=nc+lc+mc-1
         pwas3=as3**it
       endif
       ex=eiii(it1,it2,it3)
!    y-direction
       it3=(nc-1)/2
       it2=lc/2
       it1=(mc+1)/2
!  it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=pwas3*s32
       if(abs(s3).gt.fprec) pwas3=pwas3*s32
       ey=eipp(it1,it2,it3)
!    z-direction
       it3=(nc+1)/2
       it2=lc/2
       it1=(mc-1)/2
!    it=2*(it1+it2+it3)+1
       ez=eppi(it1,it2,it3)
       return
     endif
     if(itpar.eq.5) then
!   I E E and  c<a,b
!           in table 67-h: Ex=E(2t3,2t2,2t1)
!                          Ey=E(2t3,2t2+1,2t1+1)
!                          Ez=E(2t3+1,2t2+1,2t1)
!    values of it1,it2,it3 in table 3-h
!    x-direction
       it3=nc/2
       it2=(lc+1)/2
       it1=mc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!    it=2*(it1+it2+it3)+1
         it=nc+lc+mc
         apwas3=as3**it
         pwas3=apwas3*s32
       endif
       ex=eppp(it1,it2,it3)
!    y-direction
       it3=nc/2
       it2=(lc-1)/2
       it1=mc/2
!     it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=apwas3
       if(abs(s3).gt.fprec) pwas3=apwas3
       ey=epii(it1,it2,it3)
!    z-direction
       it3=nc/2
       it2=(lc-1)/2
       it1=mc/2
       ez=eiip(it1,it2,it3)
       return
     endif
     if(itpar.eq.6) then
!   I E I and  c<a,b
!           in table 67-d: Ex=E(2t3+1,2t2,2t1)
!                          Ey=E(2t3+1,2t2+1,2t1+1)
!                          Ez=E(2t3,2t2+1,2t1)
!    values of it1,it2,it3 in table 3-d
!    x-direction
       it3=(nc-1)/2
       it2=(lc+1)/2
       it1=mc/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!    it=2*(it1+it2+it3)+1
         it=nc+lc+mc-1
         apwas3=as3**it
         pwas3=apwas3*s32
       endif
       ex=eipp(it1,it2,it3)
!    y-direction
       it3=(nc-1)/2
       it2=(lc-1)/2
       it1=mc/2
!   it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=apwas3
       if(abs(s3).gt.fprec) pwas3=apwas3
       ey=eiii(it1,it2,it3)
!    z-direction
       it3=(nc+1)/2
       it2=(lc-1)/2
       it1=mc/2
!   it=2*(it1+it2+it3)+1
!       if(s3.ne.0.)  pwas3=pwas3*s32
       if(abs(s3).gt.fprec)  pwas3=pwas3*s32
       ez=epip(it1,it2,it3)
       return
     endif
     if(itpar.eq.7) then
!   I I E and  c<a,b
!           in table 67-f: Ex=E(2t3,2t2,2t1+1)
!                          Ey=E(2t3,2t2+1,2t1)
!                          Ez=E(2t3+1,2t2+1,2t1+1)
!    values of it1,it2,it3 in table 3-f
!    x-direction
       it3=nc/2
       it2=(lc+1)/2
       it1=(mc-1)/2
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
!      it=2*(it1+it2+it3)+1
         it=nc+lc+mc-1
         apwas3=as3**it
         pwas3=apwas3*s32
       endif
       ex=eppi(it1,it2,it3)
!    y-direction
       it3=nc/2
       it2=(lc-1)/2
       it1=(mc+1)/2
!   it=2*(it1+it2+it3)+1
       ey=epip(it1,it2,it3)
!    z-direction
       it3=nc/2
       it2=(lc-1)/2
       it1=(mc-1)/2
!  it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) pwas3=apwas3
       if(abs(s3).gt.fprec) pwas3=apwas3
       ez=eiii(it1,it2,it3)
       return
     endif
     if(itpar.eq.8) then
!   I I I and  c<a,b
!           in table 67-b: Ex=E(2t3+1,2t2,2t1+1)
!                          Ey=E(2t3+1,2t2+1,2t1)
!                          Ez=E(2t3,2t2+1,2t1+1)
!    values of it1,it2,it3 in table 3-b
!    x-direction
     it3=(nc-1)/2
       it2=(lc+1)/2
       it1=(mc-1)/2
!    it=2*(it1+it2+it3)+1
!       if(s3.ne.0.) then
       if(abs(s3).gt.fprec) then
         it=nc+lc+mc
         pwas3=as3**it
       endif
       ex=eipi(it1,it2,it3)
!    y-direction
       it3=(nc-1)/2
       it2=(lc-1)/2
       it1=(mc+1)/2
!    it=2*(it1+it2+it3)+1
       ey=eiip(it1,it2,it3)
!    z-direction
       it3=(nc+1)/2
       it2=(lc-1)/2
       it1=(mc-1)/2
!    it=2*(it1+it2+it3)+1
       ez=eppi(it1,it2,it3)
       return
     endif
!endif of isucc=3----> c<a,b
   endif
END SUBROUTINE fielde
!> *******************************************************************
!! SUBROUTINE pintfast
!! Particles too far from the C. of G. of the bunch are eliminated
!! for the Almn computations with HERSC
!< *******************************************************************
SUBROUTINE pintfast
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4spacecharge
   USE m4hersc8
   USE m4prtcls, ONLY: xc,yc,zc
   IMPLICIT NONE
   REAL(8) bcg,gcg,wcg
   REAL(8) bnp,gnp,eng,f3,f5,trmoy,xb2x,xb2z,xbar,ybar,zbar,xbxz,xcg,ycg,zcg,xnp,znp   
   INTEGER imaxx,np
   INTEGER i
!*******************************************************************
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
   nuelm=nuelm+1
   write(16,*)' space charge with HERSC call number: ',nuelm
   trmoy=0.D0
   wcg=0.D0
   xcg=0.D0
   xcg=0.D0
   ycg=0.D0
   do i=1,ngood
     trmoy=trmoy+f(6,i)
     wcg=wcg+f(7,i)
     xcg=xcg+f(2,i)
     ycg=ycg+f(4,i)
   enddo
   trmoy=trmoy/DBLE(ngood)
   wcg=wcg/DBLE(ngood)
   gcg=wcg/xmat
   bcg=sqrt(1.D0-1.D0/(gcg*gcg))
   xcg=xcg/DBLE(ngood)
   ycg=ycg/DBLE(ngood)
   zcg=trmoy*fh
!  Isochronism correction in bending magnet
!  apl is the angle due to the lack of isochronicity in the plane (x,z)
!  (see : A modified space charge routine for high intensity bunched
!         beam,P.Lapostolle and 5 authors,NIM A Vol.379,pp21-40,
!         September 1996)
!    does not work with SCHEFF method (iscsp=3)
   apl=0.D0
   if(iscsp.le.2) then
     xb2x=0.D0
     xb2z=0.D0
     xbxz=0.D0
     imaxx=0
     do np=1,ngood
       gnp=f(7,np)/xmat
       bnp=sqrt(1.D0-1.D0/(gnp*gnp))
       zc(np)=(trmoy-f(6,np))*bnp*vl/100.D0
!   *   correct. relativiste
!omment           zc(np)=zc(np)*gcg
!   *
       xc(np)=(f(2,np)-xcg)/100.D0
       xb2z=xb2z+zc(np)*zc(np)
       xb2x=xb2x+xc(np)*xc(np)
       xbxz=xbxz+zc(np)*xc(np)
       imaxx=imaxx+1
     enddo
     xb2z=xb2z/DBLE(imaxx)
     xb2x=xb2x/DBLE(imaxx)
     xbxz=xbxz/DBLE(imaxx)
     apl=atan(-2.D0*xbxz/(xb2x-xb2z))/2.D0
   endif
   write(16,*)'*slope of the bunch in plane(Oz,Ox):',apl,' radian'
! bunch at the space charge position
   xbar=0.D0
   ybar=0.D0
   zbar=0.D0
   imaxx=0
!  Divide by 100. to convert from centimeters to meters
   do np=1,ngood
     gnp=f(7,np)/xmat
     bnp=sqrt(1.D0-1.D0/(gnp*gnp))
     znp=(trmoy-f(6,np))*bnp*vl
!   *   correct. relativiste valero
!omment         znp=znp*gcg
!   *
     xnp=f(2,np)
     zc(np)=znp*cos(apl)+xnp*sin(apl)
     xnp=xnp*cos(apl)-znp*sin(apl)
!  convert from mrad to rad
     f3=f(3,np)*1.D-03
     f5=f(5,np)*1.D-03
!  convert from cm   to m
     xc(np)=(xnp+zc(np)*f3)/100.D0
     yc(np)=(f(4,np)+zc(np)*f5)/100.D0
     zc(np)=zc(np)/100.D0
! evaluate xbar , ybar , zbar
     xbar=xbar+xc(np)
     ybar=ybar+yc(np)
     zbar=zbar+zc(np)
   enddo
   eng=DBLE(ngood)
   xbar=xbar/eng
   ybar=ybar/eng
   zbar=zbar/eng
   do np=1,ngood
     xc(np)=xc(np)-xbar
     yc(np)=yc(np)-ybar
     zc(np)=zc(np)-zbar
   enddo
END SUBROUTINE pintfast
!> *******************************************************************
!! SUBROUTINE hcoef
!! the significant Hermite coefficients (called by HERSC)
!< *******************************************************************
SUBROUTINE hcoef
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4spacecharge
   USE fun4scherm, ONLY: hermint
   USE m4herFACTscher
   USE m4hersc6, ONLY: lmax,mmax,nmax,a,xrmsz,yrmsz,zrmsz
   USE m4hersc7, ONLY: eps,lmnt,fxrms,fyrms,fzrms,rdcf
   USE m4hersc8
   USE m4prtcls, ONLY: xc,yc,zc,zcp,xcp,ycp
   IMPLICIT NONE
   REAL(8) xcg,ycg,zcg
   REAL(8) ab,ach,ces,cesl,cesm,cesn,fond,rate,rdcfc,rpeps,xherm
   REAL(8) xx,yy,zz,xcj,ycj,zcj,xsqsum,ysqsum,zsqsum
   INTEGER ipar,irct,iret,itm,itot
   INTEGER i,j,kl,km,kn,l,len,lsup,m,msup,n,nsup
   REAL(8) hx(30),hy(30),hz(30),tran(1)
!*******************************************************************
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
! calculation of Hermite coefficients on the principal axis in x,y,z
   do i=1,ngood
     zcp(i)=zc(i)
     xcp(i)=xc(i)
     ycp(i)=yc(i)
   enddo
   do kn=1,nmax
     do km=1,mmax
       do kl=1,lmax
         a(kl,km,kn)=0.D0
       enddo
     enddo
   enddo
   zcg=0.D0
   xcg=0.D0
   ycg=0.D0
   do i=1,ngood
     zcg=zcg+zc(i)
     xcg=xcg+xc(i)
     ycg=ycg+yc(i)
   enddo
   xcg=xcg/DBLE(ngood)
   ycg=ycg/DBLE(ngood)
   zcg=zcg/DBLE(ngood)
   xsqsum=0.D0
   ysqsum=0.D0
   zsqsum=0.D0
!evaluate the rms sizes
   do j=1,ngood
     xcj=xc(j)-xcg
     ycj=yc(j)-ycg
     zcj=zc(j)-zcg
     xsqsum=xsqsum+xcj*xcj
     ysqsum=ysqsum+ycj*ycj
     zsqsum=zsqsum+zcj*zcj
   enddo
   xrmsz=xsqsum/DBLE(ngood)
   yrmsz=ysqsum/DBLE(ngood)
   zrmsz=zsqsum/DBLE(ngood)
   xrmsz=sqrt(xrmsz)
   yrmsz=sqrt(yrmsz)
   zrmsz=sqrt(zrmsz)
   write(16,*) '*RMS of the bunch (m): ',xrmsz,yrmsz,zrmsz
!omment       write(17,25) nuelm,xrmsz,yrmsz,zrmsz
!omment25     format(2x,i5,3(2x,e12.5))
!     ***TEST control s.c.
!omment        rewind(19)
!omment        irep=0
!omment        rewind(21)
!omment        write(21,*) '      x(cm)         y(cm)         z(cm)'
!   coordinates of the bunch  x, y, z
!omment        do j=1,ngood
!omment          xcoup=(xcp(j)-xcg)/xrmsz
!omment          ycoup=(ycp(j)-ycg)/yrmsz
!omment          zcoup=(zcp(j)-zcg)/zrmsz
!omment          write(21,1188) xcoup,ycoup,zcoup
!omment          if((abs(xcoup).lt.fxrms).and.(abs(ycoup).lt.fyrms).and.
!omment     *      (abs(zcoup).lt.fzrms)) then
!omment           write(19,1188) xcoup,ycoup,zcoup
!omment           irep=irep+1
!omment          endif
!omment        enddo
!omment1188     format(3(2x,e12.5))
!    ***END TEST control s.c.
   if(rdcf.ge.1.D0) then
     hz(1)=1.D0
     hy(1)=1.D0
     hx(1)=1.D0
     irct=0
     do j=1,ngood
       xc(j)=(xcp(j)-xcg)/xrmsz
       yc(j)=(ycp(j)-ycg)/yrmsz
       zc(j)=(zcp(j)-zcg)/zrmsz
       if((abs(xc(j)).lt.fxrms).and.(abs(yc(j)).lt.fyrms).and. &
          (abs(zc(j)).lt.fzrms)) then
         irct=irct+1
         ach=abs(f(9,j))
         hz(2)=zc(j)
         hy(2)=yc(j)
         hx(2)=xc(j)
         do kn=1,nmax
           if(kn.gt.2) hz(kn)=zc(j)*hz(kn-1)-DBLE(kn-2)*hz(kn-2)
           do km=1,mmax
             if(km.gt.2) hy(km)=yc(j)*hy(km-1)-DBLE(km-2)*hy(km-2)
             do kl=1,lmax
               if(kl.gt.2) hx(kl)=xc(j)*hx(kl-1)-DBLE(kl-2)* &
                                  hx(kl-2)
               xherm=hx(kl)*hy(km)*hz(kn)/(fect(kl)*fect(km)* &
                     fect(kn))
               a(kl,km,kn)=a(kl,km,kn)+xherm/pwtpi*ach
             enddo
           enddo
         enddo
       endif
     enddo
     rate=DBLE(ngood)/DBLE(irct)
!     write(16,*) ' particles kept in Almn computation: ',irct
     do kn=1,nmax
       do km=1,mmax
         do kl=1,lmax
           a(kl,km,kn)=a(kl,km,kn)*rate
         enddo
       enddo
     enddo
   endif
!*********************************
   if(rdcf .lt. 1.D0) then
     rdcfc=rdcf*DBLE(imax)/DBLE(ngood)
     if(rdcfc .gt. 1.D0) rdcfc=1.D0
     len=1
     irct=0
     hz(1)=1.D0
     hy(1)=1.D0
     hx(1)=1.D0
     do j=1,ngood
       call rlux(tran,len)
       if(tran(1).le.rdcfc) then
         xc(j)=(xcp(j)-xcg)/xrmsz
         yc(j)=(ycp(j)-ycg)/yrmsz
         zc(j)=(zcp(j)-zcg)/zrmsz
         if((abs(xc(j)).lt.fxrms).and.(abs(yc(j)).le.fyrms).and. &
           (abs(zc(j)).lt.fzrms)) then
           ach=abs(f(9,j))
           irct=irct+1
           hz(2)=zc(j)
           hy(2)=yc(j)
           hx(2)=xc(j)
           do kn=1,nmax
             if(kn.gt.2) hz(kn)=zc(j)*hz(kn-1)-DBLE(kn-2)*hz(kn-2)
             do km=1,mmax
               if(km.gt.2) hy(km)=yc(j)*hy(km-1)-DBLE(km-2)* &
                                  hy(km-2)
               do kl=1,lmax
                 if(kl.gt.2) hx(kl)=xc(j)*hx(kl-1)-DBLE(kl-2)* &
                                    hx(kl-2)
                 xherm=hx(kl)*hy(km)*hz(kn)/(fect(kl)*fect(km)* &
                       fect(kn))
                 a(kl,km,kn)=a(kl,km,kn)+xherm/pwtpi*ach
               enddo
             enddo
           enddo
         endif
       endif
     enddo
     rate=DBLE(ngood)/DBLE(irct)
     write(16,*) ' particles kept in Almn: ',irct
     do kn=1,nmax
       do km=1,mmax
         do kl=1,lmax
            a(kl,km,kn)=a(kl,km,kn)*rate
         enddo
       enddo
     enddo
   endif
!   *  Cesaro  transformation
   lsup=lmax
   msup=mmax
   nsup=nmax
   do kn=1,nsup
     do km=1,msup
       do kl=1,lsup
         cesl=(1.D0-DBLE(kl-1)/DBLE(lsup))
         cesm=(1.D0-DBLE(km-1)/DBLE(msup))
         cesn=(1.D0-DBLE(kn-1)/DBLE(nsup))
         ces=cesl*cesm*cesn
!Cesaro force             a(kl,km,kn)=a(kl,km,kn)*ces*ces
         a(kl,km,kn)=a(kl,km,kn)*ces
       enddo
     enddo
   enddo
!    *
!   select the significant coefficients
   fond=abs(a(1,1,1))
   itot=0
   iret=0
   do kn=1,nmax
     n=kn-1
     ipar=n-2*int(n/2)
     if(ipar.eq.0)zz=0.D0
     if(ipar.ne.0) then
     if(n.eq.1) zz=1.D0
       if(n.eq.3) zz=.75D0
       if(n.eq.5) zz=.625D0
     if(n.gt.5.and.n.le.11) zz=0.50D0
       if(n.gt.11) zz=0.375D0
     endif
     do km=1,mmax
       m=km-1
     ipar=m-2*int(m/2)
     if(ipar.eq.0)yy=0.D0
       if(ipar.ne.0) then
       if(m.eq.1) yy=1.D0
         if(m.eq.3) yy=.75D0
         if(m.eq.5) yy=.625D0
       if(m.gt.5.and.m.le.11) yy=0.50D0
         if(m.gt.11) yy=0.375D0
       endif
       do kl=1,lmax
         l=kl-1
         ipar=l-2*int(l/2)
         if(ipar.eq.0)xx=0.D0
         if(ipar.ne.0) then
         if(l.eq.1) xx=1.D0
         if(l.eq.3) xx=.75D0
         if(l.eq.5) xx=.625D0
         if(l.gt.5.and.l.le.11) xx=0.50D0
         if(l.gt.11) xx=0.375D0
         endif
         itot=itot+1
         xherm=hermint(xx,l)*hermint(yy,m)*hermint(zz,n)
         ab=abs(a(kl,km,kn)*xherm)/fond
         if(ab.ge.eps) then
         iret=iret+1
       else
         a(kl,km,kn)=0.D0
       endif
       enddo
     enddo
   enddo
   rpeps=DBLE(iret)/DBLE(itot)
   write(16,*)'*significant terms in Hermite series expansion: ', &
               iret,' total of terms :',itot
   if(rpeps .ge. 0.3D0) then
     write(16,*) ' problem in space charge : rpeps gt .3 ',rpeps
     stop
   endif
!   select the maximum values l, m and n for the significant coefficients
   lsup=0
   msup=0
   nsup=0
   lmnt=0
   do kn=1,nmax
     do km=1,mmax
       do kl=1,lmax
!         if(a(kl,km,kn).ne.0.) then
         if(abs(a(kl,km,kn)).gt.fprec) then
           itm=kl+km+kn-3
           if(itm.ge.lmnt) lmnt=itm
           if(lsup.le.kl) lsup=kl
           if(msup.le.km) msup=km
           if(nsup.le.kn) nsup=kn
         endif
        enddo
     enddo
   enddo
   lmnt=lmnt+kmax+4+3
   write(16,*) ' maximum of n m l for the significants terms ', &
              nsup-1,msup-1,lsup-1
   write(16,*) ' maximum of (t) for the significants terms ',lmnt
END SUBROUTINE hcoef
!> *******************************************************************
!! SUBROUTINE gausse
!! called by HERSC
!! GAUSS method
!< *******************************************************************
SUBROUTINE gausse
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4spacecharge
   USE m4hersc2, ONLY: absg,wg,igaus
   USE fun4scherm, ONLY: hermint
   IMPLICIT NONE
   INTEGER i,j
   REAL(8) ui(40),u9(9),u10(10),u12(12)
   REAL(8) w9(9),w10(10),w12(12)
!   GAUSS n=9 de -1. a 1
   DATA (U9(J),J=1,9)/-.9681602D0,-.8360311D0,-.6133714D0,-.3242534D0,0.D0, &
                       .3242534D0,.6133714D0,.8360311D0,.9681602D0/
   data (w9(j),j=1,9)/.0812744D0,.1806482D0,.2606107D0,.3123471D0, &
                      .3302394D0,.3123471D0,.2606107D0,.1806482D0,.0812744D0/
!   GAUSS n=10 de -1. a 1
   DATA (U10(J),J=1,10)/-.9739065D0,-.8650634D0,-.6794096D0,-.4333954D0, &
     -.1488743D0,.1488743D0,.4333954D0,.6794096D0,.8650634D0,.9739065D0/
   data (w10(j),j=1,10)/.0666713D0,.1494513D0,.2190864D0,.2692667D0, &
     .2955242D0,.2955242D0,.2692667D0,.2190864D0,.1494513D0,.0666713D0/
!   GAUSS n=12 de -1. a 1
   DATA (U12(J),J=1,12)/-.9815606D0,-.9041173D0,-.7699027D0,-.5873180D0, &
     -.3678315D0,-.1252334D0,.1252334D0,.3678315D0,.5873180D0,.7699027D0, &
      .9041173D0,.9815606D0/
   data (w12(j),j=1,12)/.0471753D0,.1069393D0,.1600783D0,.2031674D0, &
     .2334925D0,.2491470D0,.2491470D0,.2334925D0,.2031674D0,.1600783D0, &
     .1069393D0,.0471753D0/
!*******************************************************************
!    built the abscissas from (-1,1) to (1,0)
   if(igaus.eq.9) then
     do i=1,igaus
       ui(i)=u9(i)
       wg(i)=w9(i)
     enddo
   endif
!   following options in case one wishes to use 10 or 12 steps
   if(igaus.eq.10) then
     do i=1,igaus
       ui(i)=u10(i)
       wg(i)=w10(i)
     enddo
   endif
   if(igaus.eq.12) then
     do i=1,igaus
       ui(i)=u12(i)
       wg(i)=w12(i)
     enddo
   endif
   do i=1,igaus
     absg(i)=(1.D0+ui(i))/2.D0
     wg(i)=wg(i)/2.D0
   enddo
END SUBROUTINE gausse
!> *******************************************************************
!! SUBROUTINE table(lbmax,mbmax,nbmax)
!! called by HERSC
!! arrays of variables independent of the coordinates of particles
!! lbmax,mbmax,nbmax are the maximum degrees of the
!! coefficients A(l,m,n)
!< *******************************************************************
SUBROUTINE table(lbmax,mbmax,nbmax)
   USE DynacConstants
   USE m4hersc2, ONLY: absg,igaus,co,sn
   USE m4hersc4, ONLY: carg,sarg,argip
   USE m4hersc5, ONLY: ragp,ragm1
   USE fun4scherm, ONLY: fper
   USE m4herFACTscher
   IMPLICIT NONE
   REAL(8) absm2,aco,cod,fi,fj,snd
   INTEGER i,j
   INTEGER lbmax,mbmax,nbmax
   INTEGER ideg,idegp2,idgp,kemax
!*******************************************************************
!       maximum of subscripts : ideg
! igaus: order of the Gauss integration ******
!  maximum of lbmax,mmax,nbmax -->ideg
   ideg=nbmax
   if(lbmax.ge.ideg) ideg=lbmax
   if(mbmax.ge.ideg) ideg=mbmax
   ideg=ideg+1
   idegp2=ideg+2
!  arrays of the power of the circular functions fo the Gauss positions absg(i)
!   the maximum power is ideg+2
   do i=1,igaus
     co(i,1)=1.D0
     sn(i,1)=1.D0
   enddo
   do i=1,igaus
     aco=pi*absg(i)/2.D0
     cod=cos(aco)
     snd=sin(aco)
     do j=2,idegp2
       co(i,j)=co(i,j-1)*cod
       sn(i,j)=sn(i,j-1)*snd
     enddo
   enddo
!    arrays used in the integrals of tables 75 and 76
!    absg(i)**2(t1+t2+t3+1)+1-->ragp(i,j) i: Gauss positions, j: is the power
   idgp=3*ideg+kmax
   kemax=kmax/2
   do i=1,igaus
     ragp(i,1)=1.D0
     ragm1(i,1)=1.D0
     absm2=(1.D0-absg(i))*(1.D0-absg(i))
     do j=2,idgp
       ragp(i,j)=ragp(i,j-1)*absg(i)
     enddo
!   storage of (absg(i)-1)**2*kemax -->ragm1
     do j=2,kemax+1
       ragm1(i,j)=ragm1(i,j-1)*absm2
     enddo
   enddo
   do i=1,idgp+1
     carg(i)=sqrt((4.D0*DBLE(i-1)+1.D0)/2.D0)
     sarg(i)=sqrt((4.D0*DBLE(i-1)+3.D0)/2.D0)
     argip(i)=sqrt(2.D0*DBLE(i-1)+1.D0)
   enddo
!   store the factorials
   do i=1,40
     do j=1,i
       fpir(i,j)=fper(i-1,j-1)
     enddo
   enddo
   fj=1.D0
   fect(1)=1.D0
   do i=1,23
     fi=DBLE(i)
     fj=fj*fi
     fect(i+1)=fj
   enddo
END SUBROUTINE table      
!> *******************************************************************
!! SUBROUTINE getfile(rdb1,lin)
!< *******************************************************************
SUBROUTINE getfile(rdb1,lin)
   USE mCOMosys
   IMPLICIT NONE
   INTEGER lin,nol
   character(len=255) :: cmd 
   character(len=255) :: rdb1,sysresponse(50) 
!*******************************************************************
! figure out OS first          
   rdb1=""
   lin=0
   opsys=""
   cmd=""
   call get_OS(opsys)
   if(len_trim(opsys).gt.0) then
     write(6,'(a,a)')'Running on ',opsys
   else
     write(6,'(a)')'Not directly running on MAC, linux or Windows'
   endif
   if(opsys=='Darwin') then
     call getfile_MAC(rdb1)
   elseif (opsys=='Linux') then
     call getfile_Linux(rdb1)
! remove junk.txt 
     CALL EXECUTE_COMMAND_LINE('rm -f junk.txt')
   elseif (opsys=='Windows') then
     call getfile_Windows(rdb1)
   elseif (opsys=='Cygwin') then
     write(6,'(a)')'Cygwin does not have zenity installed'
   else
     write(6,'(a)')'Check if running WSL linux under Windows'
! maybe running WSL linux under windows; check for this
!     cmd = "cat /etc/os-release"   
     cmd = "uname -a"   
     CALL cmd_by_pipe(cmd,nol,sysresponse)
!     write(6,*)'DBX uname -a yields nol=',nol
     rdb1=sysresponse(1)
     if(rdb1(1:5).eq."Linux") then
!       write(6,*)'DBX after pipe sysresponse=',trim(rdb1)
       write(6,'(a)')'Running WSL linux under Windows'
       rdb1=""
       opsys='Linux'
       call getfile_Linux(rdb1)
     else
       rdb1='***Can only recognize MAC, Windows and Linux ***'
     endif
   endif
   lin=len_trim(rdb1)
!   write(6,*)'DBX in getfile=',lin,trim(rdb1)
END SUBROUTINE getfile
!> *******************************************************************
!! SUBROUTINE getfile_Windows(rdb1)
!< *******************************************************************
SUBROUTINE getfile_Windows(rdb1)
! ********************************************
   IMPLICIT NONE
   character(len=255) :: rdb1       
!*******************************************************************
   rdb1=""        
! interface here to C++ routine that contains call to OPENFILENAME         
   call cstr1(rdb1)
END SUBROUTINE getfile_Windows
!> *******************************************************************
!! SUBROUTINE getfile_MAC(rdb1)
!< *******************************************************************
SUBROUTINE getfile_MAC(rdb1)
   IMPLICIT NONE
   character(len=255) :: cmd1,rdb1       
   character(len=1) :: dq     
   INTEGER lc
!*******************************************************************
! dq is the double quote character "          
   dq=char(34)
   rdb1=""        
   cmd1=""
   cmd1="osascript -so -e 'Choose file with prompt"
   lc=len_trim(cmd1)
   cmd1=cmd1(1:lc)//' "Please select a file"'
   lc=len_trim(cmd1)
   cmd1=cmd1(1:lc)//" of type {"//dq//"in"//dq//","//dq//"dat"//dq//","//dq//"txt"//dq//"}'"    
   lc=len_trim(cmd1)
   cmd1=cmd1(1:lc)//" >MyPipe; echo '\x04' >MyPipe"            
   lc=len_trim(cmd1)
   CALL pipe_mit(cmd1(1:lc),rdb1)
END SUBROUTINE getfile_MAC
!> *******************************************************************
!! SUBROUTINE getfile_Linux(rdb1)
!< *******************************************************************
SUBROUTINE getfile_Linux(rdb1)
   IMPLICIT NONE
   character(len=255) :: cmd1,rdb1,Instruction,cwd,sysresponse(50)
   INTEGER lc,nol
   integer IOSTAT, EXITSTAT, CMDSTAT
   integer, parameter :: IOSTAT_END = -1
   logical WAIT
!*******************************************************************
   WAIT=.true.
   iostat=-999
!   write(6,*) 'DBX in getfile_Linux'
!//remove named pipe (if exists)//
   call EXECUTE_COMMAND_LINE("rm -f /tmp/MyPipe")
!//Create a named pipe//
   call EXECUTE_COMMAND_LINE("mkfifo /tmp/MyPipe")
!//Open a connection to it and check if zenity is installed//
   open(11,file="/tmp/MyPipe", iostat=iostat)
   cmd1=""
!        cmd1="zenity >/tmp/MyPipe; echo '\x04' >/tmp/MyPipe"
   cmd1="zenity --help >/tmp/MyPipe"
   lc=len_trim(cmd1)
!//Execute//
   call EXECUTE_COMMAND_LINE(trim(cmd1), WAIT, EXITSTAT, CMDSTAT )
   if(EXITSTAT/=0)then
     write(6,'(A)') 'Linux as operating system, but zenity file manager does not seem to be installed'
     write(6,'(A)') 'zenity allows a programmatic file selection option with a GUI window'
! for example, thunar on centOS does not have an option for programmatic file selection option with a GUI window          
     write(6,'(A)') 'As zenity is not installed, try to invoke dynac with a valid input file'
!//remove named pipe//
     write(Instruction,'(a)')"( rm -f /tmp/MyPipe)"
     CALL EXECUTE_COMMAND_LINE(Instruction) 
     write(6,'(A)') '*** STOP ***'
     stop
   endif
!For Ubuntu & Redhat/centOS & Kali linux with zenity installed
   cmd1="pwd"
   CALL cmd_by_pipe(cmd1,nol,sysresponse)
! append /*   
   cwd=trim(sysresponse(1))//char(47)
   cwd=trim(cwd)//char(42)
!   WRITE(6,*) "DBX cwd=",TRIM(cwd)
   cmd1=""
! redirect errors to junk.txt (because may get warnings of type Gtk-WARNING) 
   cmd1='zenity --title="Select a DYNAC input file" --filename '//'"trim(cwd)"'
   cmd1=trim(cmd1)//' --file-selection 2>junk.txt'
!   WRITE(6,*) "DBX cmd=",TRIM(cmd1)
!//remove named pipe//
   write(Instruction,'(a)')"( rm -f /tmp/MyPipe)"
   CALL EXECUTE_COMMAND_LINE(Instruction)
   lc=len_trim(cmd1)
   cmd1=cmd1(1:lc)//" >/tmp/MyPipe"            
   CALL pipe_lit(cmd1(1:lc),rdb1)
END SUBROUTINE getfile_Linux  
!> *******************************************************************
!! SUBROUTINE cmd_by_pipe(cmd,nol,sysresponse)
!! Can be used to get response from a call to EXECUTE_COMMAND_LINE
!! Input:  cmd is the sys command
!! Output: nol will contain the # of lines in the sys response to the sys cmd
!! Output: sysresponse will contain the sys response to the sys cmd (up
!! to 50 lines)
!< *******************************************************************
SUBROUTINE cmd_by_pipe(cmd,nol,sysresponse)
   IMPLICIT NONE
   character(len=255) :: cmd,sysresponse(50),Instruction,inp,rdb1 
   INTEGER lc,nol
   integer IOSTAT, EXITSTAT, CMDSTAT, io
   integer, parameter :: IOSTAT_END = -1
   logical WAIT
!*******************************************************************
   WAIT=.true.
   iostat=-999
!//remove named pipe (if exists)//
   call EXECUTE_COMMAND_LINE("rm -f /tmp/MyPipe")
!//Create a named pipe//
   call EXECUTE_COMMAND_LINE("mkfifo /tmp/MyPipe")
!   write(6,'(A)') 'DBX in cmd_by_pipe, mkfifo executed'
!//Open a connection to it and execute command cmd//
   open(11,file="/tmp/MyPipe", access="stream",form="formatted", iostat=iostat)
   cmd=trim(cmd)//" > /tmp/MyPipe; echo '\x04' >/tmp/MyPipe"   
   lc=len_trim(cmd)
!//Execute//
   call EXECUTE_COMMAND_LINE(trim(cmd), WAIT, EXITSTAT, CMDSTAT )
   if(EXITSTAT/=0)then
!//remove named pipe//
     write(Instruction,'(a)')"( rm -f /tmp/MyPipe)"
     CALL EXECUTE_COMMAND_LINE(Instruction) 
     write(6,'(A)') '*** STOP ***'
     stop
   endif
!//Execute a normal reading loop//
   rdb1=''
   io=-999
   nol=0
   do
     inp=''
     read(11,'(A)',iostat=io)inp
     nol=nol+1
     sysresponse(nol)=trim(inp)
!     write(6,*) 'DBX nol,response=',io,nol,trim(inp)
     if(inp(1:1)=='/')then
       rdb1=trim(inp)  
       exit
     endif
     if(io/=0)exit
!     if(ichar(inp(1:LEN_TRIM(inp)))==4)then
     if(inp(1:LEN_TRIM(inp))=='\x04')then
!       write(6,*) 'DBX EOT encountered'
       exit
     endif  
     if(io == iostat_end)exit
   end do
   nol=nol-1   
!   write(6,*) 'DBX NOL=',nol
!   do lc=1,nol
!     write(6,*) 'DBX line#,response=',lc,trim(sysresponse(lc))
!   enddo   
!//remove named pipe//
   write(Instruction,'(a)')"( rm -f /tmp/MyPipe)"
   CALL EXECUTE_COMMAND_LINE(Instruction)
END SUBROUTINE cmd_by_pipe  
!> *******************************************************************
!! SUBROUTINE pipe_lit(command,rdb1)
!< *******************************************************************
SUBROUTINE pipe_lit(command,rdb1)
   IMPLICIT NONE
   integer IOSTAT, IO
   integer, parameter :: IOSTAT_END = -1
   logical WAIT
   character(len=255) :: COMMAND, inp, Instruction, rdb1, rdb2       
!*******************************************************************
   WAIT=.true.
   iostat=-999
!//remove named pipe (if exists)//
   call EXECUTE_COMMAND_LINE("rm -f /tmp/MyPipe")
!//Create a named pipe//
   call EXECUTE_COMMAND_LINE("mkfifo /tmp/MyPipe")
!//Open a connection to it//
   open(11,file="/tmp/MyPipe", iostat=iostat)
!//Execute//
   call EXECUTE_COMMAND_LINE(COMMAND, WAIT)
!   call EXECUTE_COMMAND_LINE("cat /tmp/MyPipe")
!//Execute a normal reading loop//
   inp=''
   rdb1=''
   rdb2=''
   io=-999
   do
     read(11,'(A)',iostat=io)inp
     if(inp(1:1)=='/')then
       rdb1=trim(inp)  
       exit
     endif
     if(io/=0)exit
     if(ichar(inp(1:LEN_TRIM(inp)))==4)exit
     if(io == iostat_end)exit
   end do
!//remove named pipe//
   write(Instruction,'(a)')"( rm -f /tmp/MyPipe)"
   CALL EXECUTE_COMMAND_LINE(Instruction)
END SUBROUTINE pipe_lit              
!> *******************************************************************
!! SUBROUTINE pipe_mit(command,rdb1)
!< *******************************************************************
SUBROUTINE pipe_mit(command,rdb1)
   IMPLICIT NONE
   integer IOSTAT, IO
   integer, parameter :: IOSTAT_END = -1
   logical WAIT
   character(len=255) :: COMMAND, inp, Instruction, rdb1, rdb2       
!*******************************************************************
   WAIT=.true.
!//remove named pipe (if exists)//
   call EXECUTE_COMMAND_LINE("rm -f MyPipe")
!//Create a named pipe//
   call EXECUTE_COMMAND_LINE("mkfifo MyPipe")
!//Open a connection to it//
   open(11,file="MyPipe",iostat=iostat)
!//Execute//
!   write(6,*)trim(COMMAND)
   call EXECUTE_COMMAND_LINE(COMMAND, WAIT)
!//Execute a normal reading loop//
   inp=''
   rdb1=''
   rdb2=''
   io=-999
   do
     read(11,*,iostat=io)inp, rdb1, rdb2
     if(rdb2(1:6)=='error:')then
       write(6,'(a)')"File selection canceled"
       rdb1=''
       exit
     endif
!     if(inp(1:5)=='0:61:')then
!       write(6,'(a)')"File selection canceled"
!       rdb1=''
!       exit
!     endif
!     if(inp(1:5)=='0:62:')then
!       write(6,'(a)')"File selection canceled"
!       rdb1=''
!       exit
!     endif
     if(inp(1:5)=='alias')then
       call copypath(rdb2,rdb1)   
       exit
     endif
     if(rdb2(1:6)=='error:')then
       write(6,'(a)')"File selection canceled"
       rdb1=''
       exit
     endif
     if(io/=0)then
       exit
     endif  
     if(ichar(inp(1:LEN_TRIM(inp)))==4)exit
     if(io == iostat_end)exit
   end do
!//remove named pipe//
   write(Instruction,'(a)')"( rm -f MyPipe)"
   CALL EXECUTE_COMMAND_LINE(Instruction)
END SUBROUTINE pipe_mit
!> *******************************************************************
!! SUBROUTINE copypath(rdb2,rdb1)
!< *******************************************************************
SUBROUTINE copypath(rdb2,rdb1)
   IMPLICIT NONE
   logical back
   character(len=255) :: rdb1, rdb2, temp
   INTEGER i,lrdb2,lusers
!*******************************************************************
   back=.false.
   rdb1=''
   lrdb2=len_trim(rdb2)
   temp=rdb2(1:lrdb2)
   lusers=INDEX(temp, 'Users', back)
!  write(6,*) 'String Users located at ',lusers
   rdb1=temp(lusers-1:lrdb2)
   do i=1,len_trim(rdb1)
     if(rdb1(i:i)==':') rdb1(i:i)='/'
   enddo                 
END SUBROUTINE copypath
!> *******************************************************************
!! SUBROUTINE get_OS(opsys)
!< *******************************************************************
SUBROUTINE get_OS(opsys)
   IMPLICIT NONE
   integer IOSTAT, IO
   integer EXITSTAT, CMDSTAT
   integer, parameter :: IOSTAT_END = -1
   logical WAIT
   character(len=255) :: COMMAND, CMDMSG, inp, Instruction       
   character(len=7) :: opsys       
!*******************************************************************
! try to see if Darwin (MAC), Linux or CYGWIN; find out which
! if unsuccessful, then it is probably Windows        
   COMMAND=""
   COMMAND="uname >/tmp/MyPipe; echo '\x04' >/tmp/MyPipe"
   WAIT=.true.
   opsys=''
!//remove named pipe (if exists)//
!   call EXECUTE_COMMAND_LINE("rm -f /tmp/MyPipe")
   CALL EXECUTE_COMMAND_LINE("rm -f /tmp/MyPipe 2>junk.txt" , WAIT, EXITSTAT, CMDSTAT, CMDMSG )
!   write(6,*) 'DBX in pipe_OS error=',EXITSTAT
   if(EXITSTAT.ne.0) then
! rm is not a DOS command, so must be windows   
     call EXECUTE_COMMAND_LINE("del junk.txt")
     opsys='Windows'
   else
! OS is not Windows
     call EXECUTE_COMMAND_LINE("rm -f junk.txt")
!//Create a named pipe//
     call EXECUTE_COMMAND_LINE("mkfifo /tmp/MyPipe")
!//Open a connection to it//
     open(11,file="/tmp/MyPipe",iostat=iostat)
!//Execute//
     call EXECUTE_COMMAND_LINE(COMMAND, WAIT)
!//Execute a normal reading loop//
     inp=''
     do
       read(11,*,iostat=io)inp
       if(inp=='Darwin')then
         opsys='Darwin'
         exit
       endif
       if(inp=='Linux')then
         opsys='Linux'
         exit
       endif
       if(inp(1:6)=='CYGWIN')then
         opsys='Cygwin'
         exit
       endif
       if(io/=0)exit
       if(ichar(inp(1:LEN_TRIM(inp)))==4)exit
       if(io == iostat_end)exit
     end do
!//remove named pipe//
     write(Instruction,'(a)')"( rm -f /tmp/MyPipe)"
     CALL EXECUTE_COMMAND_LINE(Instruction)
   endif
!   write(6,*) 'DBX in get_OS opsys=',trim(opsys)
END SUBROUTINE get_OS
!> *******************************************************************
!! SUBROUTINE eugwrt
!! This routine writes the dynac.print file
!< *******************************************************************
SUBROUTINE eugwrt
   USE m4plots
   IMPLICIT NONE
   INTEGER I,iprf1
   REAL(8) sprx,spry,sprp,sprz
!*******************************************************************
   write(71,'(9(A))') ' # ELEMENT    l(m)        x(mm)        y(mm)         ', &
        'z(deg)       z(mm)    Ex,n,RMS(mm.mrd)  Ey,n,RMS(mm.mrd) ', &
        'Ez,RMS(ns.keV)  Wcog(MeV)    #particles  xmin(mm)     xmax(mm)     ', &
        'ymin(mm)     ymax(mm)     tmin(s)      tmax(s)     phmin(deg)    ', &
        'phmax(deg)   Wmin(MeV)    Wmax(MeV)    Dx(m)        Dy(m)        ', &
        'dW(MeV)      Wref(MeV)    Tref(s)      Tcog(s)      xbar(mm)     ybar(mm)     ', &
        'ax           bx(mm/mrad)  ay           by(mm/mrad)  az           bz(ns/keV)   ', &
        'ElementName                 Ax(mm)         Ay(mm)         Ar(mm)         ', &
        'halox          haloy          haloz       E4d,n,RMS(mm2*mrad2)'        
   iprf1=iprf-1
   do i=1,iprf1
!    x and y: cm-->mm
     sprx=sprfx(i)*10.D0/2.D0
     spry=sprfy(i)*10.D0/2.D0
     sprp=sprfp(i)/2.D0
     sprz=sprfz(i)*10.D0
     write(71,'(1x,A8,6(1x,e12.5),2(6x,e12.5),2x,e12.5,2x,i8,2x,24(1x,e12.5),1x,A25,7(3x,e12.5))') &
     prlab(i),sprfl(i),sprx,spry,sprp,sprz,eprnx(i)/4.D0, &
     eprny(i)/4.D0,eprfw(i)/4.D0,sprww(i),int(sprng(i)), &
     sxmn(i),sxmx(i),symn(i),symx(i),stmn(i),stmx(i), &
     spmn(i),spmx(i),swmn(i),swmx(i), &
     dispcx(i),dispcy(i),sdwbeam(i),swref(i), &
     stref(i),stcog(i),sxbar(i),sybar(i), &
     twax(i),twbx(i),tway(i),twby(i),twaz(i),twbz(i), &
     trim(elnam(i))//REPEAT(' ',25),10.D0*aaperx(i),10.D0*aapery(i),10.D0*aaperr(i), &
     shalox(i),shaloy(i),shaloz(i),semit4d(i)     
   enddo
END SUBROUTINE eugwrt
!> *******************************************************************
!! SUBROUTINE daves(beame)
!! Write the characteristics of the beam to the disk
!!
!!  ---- statistics (dE-dPHI)
!!    dav1(i,10) :  extension of phase  dPHI (deg)
!!    dav1(i,11) :  dispersion of energy dE (MeV)
!!    dav1(i,12) :  emittance (MeV*rad)
!!    dav1(i,23) :  correlation  between dE an dPHI
!!
!!  ---- statistics (x-xp)
!!
!!    dav1(i,13): x-extension (mm)
!!    dav1(i,14): xp-extension (mrad)
!!    dav1(i,15): correlation between x and xp
!!    dav1(i,16): Emittance(norm)  x-xp (mm*mrad)
!!    dav1(i,17): Emittance(non norm) x-xp (mm*mrad)
!!
!!  ---- statistics (y-yp)
!!     dav1(i,18): y-extension  (mm)
!!     dav1(i,19): yp-extension (mrad)
!!     dav1(i,20): correlation between y and yp
!!     dav1(i,21) : Emittance(norm) y-yp (mm*mrad)
!!     dav1(i,22) : Emittance(non norm) y-yp (mm*mrad)
!!
!< *******************************************************************
SUBROUTINE daves(beame)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4tmatrix, ONLY: ISEOR
   USE m4ITVOLE, ONLY: ITVOL,IMAMIN
   USE m4short, ONLY: davprt
   USE mCOMqfkd
   IMPLICIT NONE
   REAL(8) beame,alpx,alpy,alpz,alpzz,alpzzz,bcog,betx,bety,betz,betzz,betzzz,dez
   REAL(8) dphizz,dphizzz,emx,emy,emz,emzz,emzzz,emzzzn,gamx,gamy,gamz,gamzz,gcog
   REAL(8) wcog
   INTEGER i,j,n,ifirst,iit6,ncell,nemit       
!*******************************************************************
   write(12,'(A)')'*****************************************************'
   write(12,*) ' Energies are in [MeV], phases in [deg]', &
   ' lengths in [mm] ,tof in [deg]'
   write(12,*) ' ** For lenses followed by : Cumulative length, element type, length '
!
   write(12,*) ' ** For emit followed by'
   write(12,*) ' * Line 1: Particle reference:  beta, energy, tof ', &
   '  COG: energy, tof, energy offset, tof offset'
   write(12,*) ' * Line 2: COG coordinates for x  xp  y  yp (mm and mrad)'
   write(12,*) ' * Line 3: alpha-x beta-x(mm/mrad) alpha-y beta-y(mm/mrad)', &
   ' alpha-z beta-z(ns/keV) alpha-z beta-z(mm/mrad)'
   write(12,*) ' * Line 4: alpha-z beta-z(deg/keV) emit-z(non norm.,keV.deg) f(MHz)', &
   ' emit-z(non norm.,mm.mrad) emit-z(norm.,mm.mrad)'
   write(12,*) ' * Line 5: dPHI(deg)  dW(keV)   r12   long. emittance', &
   '  (keV.ns) particles left'
   write(12,*) ' * Line 6:   x(mm)    xp(mrad)  r12   hor.  emittance', &
   '  (norm & non norm, mm.mrad)'
   write(12,*) ' * Line 7:   y(mm)    yp(mrad)  r12   vert. emittance', &
   '  (norm & non norm, mm.mrad)'
   write(12,'(A)')'*****************************************************'
   write(12,*) '            Simulation with ',imax,'particles'
   IF(ICHAES) THEN
     write(12,'(A,f9.5,A)') '             Beam intensity     ',beame,' mA'
     if(iscsp.eq.1) write(12,*) '            Space charge calculations with HERSC   '
     if(iscsp.eq.2) write(12,*) '            Space charge calculations with SCHERM  '
     if(iscsp.eq.3.or.iscsp.eq.4) write(12,*) &
     '            Space charge calculations with SCHEFF  '
     if(int(sce10).eq.1) write(12,*) &
     '            Space charge calculated for all relevant elements, but not at drifts'
     if(int(sce10).eq.2) write(12,*) &
     '            Space charge calculated for accelerating elements only'
     if(int(sce10).eq.3) write(12,*) &
     '            Space charge calculated for all relevant elements'
   ENDIF
   IF(ISEOR) THEN
     write(12,*) '            Second order transport matrix    '
   ELSE
     write(12,*) '            First order transport matrix    '
   ENDIF
   if(itvol) write(12,*)  ' TOF is operational in accelerating elements  '
   if(imamin) write(12,*) 'Phase adjustments for accelerating elements active'
   WRITE(12,'(A)')'*****************************************************'
   ifirst=1
   iit6=0
   nemit=0
!  start (big loop)
   do i=1,idav
     if(davprt(i).ne."") write(12,'(A)') davprt(i)
     if(iitem(i) .eq. 1) then
!  cavity
       n=int(dav1(i,25)+0.5D0)
       if(itvol.and.imamin) then
         write(12,'(f9.2,A,i3,A,f7.2,A,/,A,e12.5,A,A,e14.7,A)') dav1(i,24), &
                  ' mm Cavity ',n,' length ',dav1(i,1),' mm', &
                  ' phase offset: before adjustement ',dav1(i,38),' deg', &
                  ' after adjustment ',dav1(i,39),' deg'
       else
          write(12,'(f9.2,A,i3,A,f7.2,A,A,e12.5,A)') dav1(i,24),' mm Cavity ',n, &
          ' length ',dav1(i,1),' mm',' phase offset: ',dav1(i,38),' deg'
       endif
     endif
!
     if(iitem(i) .eq. 2) then
! quadrupole (magnetic)
       write(12, & 
         '(f9.2,A,e12.5,A,A,e12.5,A,/,A,e13.5,A,e12.5,A,e13.5,A,/,A,e12.5,A,f9.0)') &
            dav1(i,4),' mm  Quadrupole:  length = ', dav1(i,1),' mm', &
         '  aperture radius = ',dav1(i,7),' mm','   field = ',dav1(i,2), &
         ' kG  K2 = ',dav1(i,3),' cm-2 gradient = ',dav1(i,5),' kG/cm', &
         '   momentum = ',dav1(i,6),' kG.cm  particles left  ',dav1(i,36)
       write(12,*)
     endif
!
     if(iitem(i) .eq. 3) then
! emiprt
       write(12,'(A)') '**********          beam (emit card)         **********'
       nemit=nemit+1
       write(12,'(2x,f7.5,4(1x,e14.7),2(2x,e12.5),A)') (dav1(i,j), j=3,9),' MeV-deg'
       write(12,'(4(2x,f7.3),A)') (dav1(i,j), j=31,34),' mm and mrad '
! --- following lines describe Courant-Snyder parameters
       fh=dav1(i,40)
       wavel=vl*2.D0*pi/fh
!     1)  alpz betz
!
!    1-a) emz: emittance (keV*deg) betz(deg/keV)  gamz(keV/deg)
       emz=dav1(i,12)*1000.D0*(180.D0/pi)
       betz=0.D0
       if(emz.gt.1.D-10) betz=dav1(i,10)*dav1(i,10)/emz
       dez=dav1(i,11)*1000.D0
       gamz=0.D0
       if(emz.gt.1.D-10) gamz=dez*dez/emz
       alpz=0.D0
       if(betz*gamz.ge.1.D0) alpz=sqrt(betz*gamz-1.D0)
       if(dav1(i,23).gt. 0.D0)alpz=-alpz
!
!   1-b) emzz: emittance dE-dphi (keV*ns) betzz(ns/keV) gamzz(keV/ns)
       emzz=1.D12*dav1(i,12)/fh
       dphizz=1.D9 * dav1(i,10)/fh *(pi/180.D0)
       betzz=0.D0
       if(emzz.gt.1.D-10) betzz=dphizz*dphizz/emzz
       gamzz=0.D0
       if(emzz.gt.1.D-10) gamzz=dez*dez/emzz
       alpzz=0.D0
       if(betzz*gamzz.ge.1.D0) alpzz=sqrt(betzz*gamzz-1.D0)
       if(dav1(i,23).gt. 0.D0)alpzz=-alpzz
!
!   1-c) emzzz: emittance (mm*mrad) betzzz(mm/mrad) 
       wcog=dav1(i,4)
       gcog=(wcog+xmat)/xmat
       bcog=sqrt(1.D0-1.D0/(gcog*gcog))
! next line has normalized emittance in mm.mrad         
       emzzzn=1.D4*dav1(i,12)/fh*vl/xmat
! next line has non-normalized emittance in mm.mrad         
       emzzz=emzzzn/(bcog*gcog)
!      dphizzz is 2 rms bunch length in mm
       dphizzz=bcog*10.D0*wavel*dav1(i,10)/360.D0
       betzzz=0.D0
       if(emzzz.gt.1.D-10) betzzz=dphizzz*dphizzz/emzzz
       alpzzz=alpzz
!
!    2)  alpx btx
!      betx(mm/mrad)  gamx (mrad/mm)
       betx=0.D0
       emx=dav1(i,17)
       if(emx.gt.1D-10) betx=dav1(i,13)*dav1(i,13)/emx
       gamx=0.D0
       if(emx.gt.1D-10) gamx=dav1(i,14)*dav1(i,14)/emx
       alpx=0.D0
       if(betx*gamx.ge.1.D0) alpx=sqrt(betx*gamx-1.D0)
       if(dav1(i,15).gt. 0.D0)alpx=-alpx
!
!    3)  alpy bety
!      bety(mm/mrad)  gamy (mrad/mm)
       bety=0.D0
       emy=dav1(i,22)
       if(emy.gt.1D-10) bety=dav1(i,18)*dav1(i,18)/emy
       gamy=0.D0
       if(emy.gt.1D-10) gamy=dav1(i,19)*dav1(i,19)/emy
       alpy=0.D0
       if(bety*gamy.ge.1.D0) alpy=sqrt(bety*gamy-1.D0)
       if(dav1(i,20).gt. 0.D0)alpy=-alpy
!
!    betzz: ns/keV betzzz: (mm/mrad) 
       write(12,'(4(2x,e12.5,2x,e12.5))') alpx,betx,alpy,bety,alpzz,betzz,alpzzz,betzzz
!    emittance (keV*deg) betz(deg/keV), emittance (non norm.,mm.mrad)  betzzz(mm/mrad)
       write(12,'(2x,f8.4,2x,e13.6,2x,e13.6,A,2x,f8.3,A,2x,e13.6,A,2x,e13.6,A)') &
         alpz,betz,emz,' keV.deg',fh/(2.D0*pi*1.D6),' MHz',emzzz,' mm.mrad (non norm)', &
         emzzzn,' (norm)'
       if (emzz.gt.1000.D0) then
! ns.MeV
         write(12,'(2x,e12.5,2x,f10.2,2x,f8.4,2x,f7.3,A,f9.0,A)') &
           dav1(i,10),dez,dav1(i,23),emzz/1000.D0,' ns.MeV   ', &
           DAV1(I,30),' particles left'
       else
! ns.keV
         write(12,'(2x,e12.5,2x,f10.2,2x,f8.4,2x,f7.3,A,f9.0,A)') &
           dav1(i,10),dez,dav1(i,23),emzz,' ns.keV   ',DAV1(I,30),' particles left'
       endif
       write(12,'(2(2x,f7.3,3x,f8.3,2x,f8.4,2x,e12.5,A,2x,f7.3,A,/))') &
        (dav1(i,j), j=13,16),' mm.mrad (norm)',dav1(i,17),' (non norm)', &
        (dav1(i,j), j=18,21),' mm.mrad (norm)',dav1(i,22),' (non norm)'
       write(12,*)
     endif
!     
     if(iitem(i) .eq. 4) then
! bending magnet
       write(12,'(f9.2,A,f8.2,A,/,A,f7.3,A,e12.5,A)') dav1(i,4), &
         ' mm bending magnet: central trajectory: ',dav1(i,1),' mm', &
         '     bend angle: ',dav1(i,2),' deg bending radius: ',dav1(i,3),' mm'
       write(12,'(A,f7.3,A,f8.3,A,f8.3)') '     field: ',dav1(i,16), &
         ' T  n: ',dav1(i,14),' beta: ',dav1(i,15)
       write(12,'(A,/,A,f8.3,A,f8.3,A,/,A,f8.3,A,f8.3,/,A,f8.3,A)') '  *Entrance ', &
         '     pole-face rotation:',dav1(i,6),'  deg curvature: ',dav1(i,9),' mm', &
         '     fringe field corrections: K1 ',dav1(i,7),' K2 ',dav1(i,8), &
         '     vertical half-aperture: ',dav1(i,5),' mm'
       write(12,'(A,/,A,f8.3,A,f8.3,A,/,A,f8.3,A,f8.3,/,A,f8.3,A)') '   *Exit ', &
         '     pole-face rotation:',dav1(i,10),'  deg curvature: ',dav1(i,13),' mm', &
         '     fringe field corrections: K1 ',dav1(i,11),' K2 ',dav1(i,12), &
         '     vertical half-aperture: ',dav1(i,17),' mm'
       write(12,'(A,f9.0)') '  particles left  ',dav1(i,37)
       write(12,*)
     endif
     if(iitem(i) .eq. 5) then
! solenoid
       write(12,'(f9.2,A,f8.3,A,A,e12.5,A,e12.5,A,/,A,e12.5,A,f9.0)') dav1(i,4), &
         ' mm  Solenoid:  length = ',dav1(i,1),' mm','   field = ',dav1(i,2), &
         ' kG  K = ',dav1(i,3),' cm-1','      momentum = ',dav1(i,5), &
         ' kG.cm   particles left ',dav1(i,36)
       write(12,*)
     endif
     if(iitem(i) .eq. 6) then
! From adjust or from entre(not yet introduced) input beam reference
       write(12,'(A)') '**********     INITIAL BEAM          **********'
       write(12,'(4(2x,f7.3),A)') (dav1(i,j), j=31,34),' mm and mrad '
!   1)  alpz betz
!
!   1-a) emz: emittance (keV*deg) betz(deg/keV)  gamz(keV/deg)
       emz=dav1(i,12)*1000.D0*(180.D0/pi)
       betz=0.D0
       if(emz.gt.1.D-10) betz=dav1(i,10)*dav1(i,10)/emz
       dez=dav1(i,11)*1000.D0
       gamz=0.D0
       if(emz.gt.1.D-10) gamz=dez*dez/emz
       alpz=0.D0
       if(betz*gamz.ge.1.D0) alpz=sqrt(betz*gamz-1.D0)
!
!   1-b) emzz: emittance dE-dphi (keV*ns) betzz(ns/keV) gamzz(keV/ns)
       emzz=1.D12*dav1(i,12)/fhinit
       dphizz=1.D9 * dav1(i,10)/fhinit *(pi/180.D0)
       betzz=0.D0
       if(emzz.gt.1.D-10) betzz=dphizz*dphizz/emzz
       gamzz=0.D0
       if(emzz.gt.1.D-10) gamzz=dez*dez/emzz
       alpzz=0.D0
       if(betzz*gamzz.ge.1.D0) alpzz=sqrt(betzz*gamzz-1.D0)
!
!   2)  alpx btx
!      betx(mm/mrad)  gamx (mrad/mm)
       betx=0.D0
       emx=dav1(i,17)
       if(emx.gt.1D-10) betx=dav1(i,13)*dav1(i,13)/emx
       gamx=0.D0
       if(emx.gt.1D-10) gamx=dav1(i,14)*dav1(i,14)/emx
       alpx=0.D0
       if(betx*gamx.ge.1.D0) alpx=sqrt(betx*gamx-1.D0)
!
!   3)  alpy bety
!      bety(mm/mrad)  gamy (mrad/mm)
       bety=0.D0
       emy=dav1(i,22)
       if(emy.gt.1D-10) bety=dav1(i,18)*dav1(i,18)/emy
       gamy=0.D0
       if(emy.gt.1D-10) gamy=dav1(i,19)*dav1(i,19)/emy
       alpy=0.D0
       if(bety*gamy.ge.1.D0) alpy=sqrt(bety*gamy-1.D0)
!
!  betzz: ns/keV
       write(12,'(3(2x,e12.5,2x,e12.5))') alpx,betx,alpy,bety,alpzz,betzz
       fh=dav1(i,40)
!  emittance (keV*deg) betz(deg/keV)
       write(12,'(2x,f8.4,2x,e13.6,2x,e13.6,A,2x,f8.3,A)') &
       alpz,betz,emz,' keV.deg',fh/(2.D0*pi*1.D6),' MHz'
       if (emzz.gt.1000.D0) then
! ns.MeV
         write(12,'(2x,e12.5,2x,f7.2,2x,f8.4,2x,f7.3,A,f9.0,A)') &
           dav1(i,10),dez,dav1(i,23),emzz/1000.D0,' ns.MeV   ', &
           DAV1(I,30),' particles left'
       else
! ns.keV
         write(12,'(2x,e12.5,2x,f7.2,2x,f8.4,2x,f7.3,A,f9.0,A)') &
           dav1(i,10),dez,dav1(i,23),emzz,' ns.keV   ',DAV1(I,30),' particles left'
       endif
       write(12,'(2(2x,f7.3,3x,f8.3,2x,f8.4,2x,e12.5,A,2x,f7.3,A,/))') &
         (dav1(i,j), j=13,16),' mm.mrad (norm)',dav1(i,17),' (non norm)', &
         (dav1(i,j), j=18,21),' mm.mrad (norm)',dav1(i,22),' (non norm)'
         iit6=1
     endif
     if(iitem(i) .eq. 7) then
! drift
       write(12,'(f9.2,A,f10.3,A,/,A,f9.0)') dav1(i,4),' mm  Drift:  length ', &
         dav1(i,1),' mm ','   particles left  ',dav1(i,36)
       write(12,*)
     endif
     if(iitem(i) .eq. 8) then
! buncher
       if(.not.imamin) then 
         write(12,'(f9.2,A,f9.3,A,A,f9.3,A,f5.1,A,/,A,f9.0)') &
         dav1(i,4),' mm  Buncher ',dav1(i,1),' MV ','  RF Phase ',dav1(i,2), &
         ' deg  Aperture radius ',dav1(i,3),' cm','   particles left  ',dav1(i,36)
       else
         write(12,'(f9.2,A,f9.3,A,f9.3,A,f9.3,A,f5.1,A,/,A,f9.0)') &
         dav1(i,4),' mm  Buncher ',dav1(i,1),' MV   RF Phase ',dav1(i,2), &
         ' deg  correction ',dav1(i,5),' deg  Aperture radius',dav1(i,3),' cm', &
         '   particles left  ',dav1(i,36)
       endif
       write(12,*)
     endif
     if(iitem(i) .eq. 9) then
! steerer
       if (int(dav1(i,2)).eq.0) then
         write(12,'(f9.2,A,e12.5,A)')dav1(i,3),' mm  Hor. Mag. Steerer ',dav1(i,1),' Tm'
       else if (int(dav1(i,2)).eq.1) then
         write(12,'(f9.2,A,e12.5,A)')dav1(i,3),' mm  Ver. Mag. Steerer ',dav1(i,1),' Tm'
       else if (int(dav1(i,2)).eq.2) then
         write(12,'(f9.2,A,e12.5,A)')dav1(i,3),' mm  Hor. El. Steerer ',dav1(i,1),' kVm/m'
       else if (int(dav1(i,2)).eq.3) then
         write(12,'(f9.2,A,e12.5,A)')dav1(i,3),' mm  Ver. El. Steerer ',dav1(i,1),' kVm/m'
       endif
        write(12,*)
     endif
     if(iitem(i) .eq. 10) then
!  sextupole
       write(12,'(f9.2,A,f7.3,A,A,e12.5,A,/,A,e12.5,A,e12.5,A,A,e12.5,A)')  &
         dav1(i,4),' mm  Sextupole:  length = ',dav1(i,1),' mm', &
         '  aperture radius = ',dav1(i,6),' cm', &
         '   field = ',dav1(i,3),' kG  KS2 = ',dav1(i,5),' cm-3', &
         '   gradient = ',dav1(i,2),' kG/cm2'
       write(12,'(A,e12.5,A,f9.0)') &
         '   momentum = ',dav1(i,7),' kG.cm   particles left  ',dav1(i,36)
       write(12,*)
     endif
     if(iitem(i) .eq. 11) then
! solenoid+quadrupole
       write(12,'(f9.2,A,f7.3,A,A,e12.5,A,/,A,e12.5,A,e12.5,A)')&
         dav1(i,4),' mm  Sol+Quad:  length = ',dav1(i,1),' mm', &
         '  aperture radius= ',dav1(i,7),' mm', &
         '  Solenoid: field = ',dav1(i,2),' kG  K  = ',dav1(i,6),' cm-1'
       write(12,'(A,e12.5,A,e12.5,A,/,A,e12.5,A,f9.0)')&
         '  Quadrupole: field ',dav1(i,3),' kG  K2 = ',dav1(i,5),' cm-2', &
         '  momentum = ',dav1(i,8),' kG.cm   particles left ',dav1(i,36)
!       write(12,5011) dav1(i,4),dav1(i,1),dav1(i,7),dav1(i,2), &
!       dav1(i,6),dav1(i,3),dav1(i,5),dav1(i,8),dav1(i,36)
! 5011  format(f9.2,' mm Sol+Quad: length = ',f7.3, &
!       ' mm aperture radius= ',e12.5,' mm',/, &
!       ' Solenoid: field = ',e12.5,' kG  K = ',e12.5,' cm-1',/, &
!       ' Quadrupole: field ',e12.5,' kG  K2 = ',e12.5,' cm-2',/, &
!       ' momentum = ',e12.5,' kG.cm   particles left ',f9.0)
       write(12,*)
     endif
     if(iitem(i) .eq. 12) then
! quadrupole + sextupole
       write(12,'(f9.2,A,e12.5,A,A,e12.5,A)') dav1(i,4), & 
                ' mm  Quad+Sext: length = ',dav1(i,1),' mm ', &
                ' aperture radius = ',dav1(i,6),' mm'
       write(12,'(2(A,e12.5,A,e12.5,A,/),A,e12.5,A,f9.0)') & 
                '  Quadrupole: B = ',dav1(i,2),' kG  K2 = ',dav1(i,3),' cm-2', &
                '  Sextupole:  B = ',dav1(i,7),' kG  K2 = ',dav1(i,8), ' cm-3', &
                '  momentum = ',dav1(i,10),' kG.cm   particles left ',dav1(i,36)
       write(12,*)
     endif
     if(iitem(i) .eq. 13) then
! electron gun
       write(12,'(f9.2,A,f7.3,A,/,A,f8.3,A,3x,A,f8.3,A,/,A,e12.5,A,f9.0)') &
         dav1(i,4),' mm  DC egun  length:',dav1(i,1),' mm', &
         ' Crest field:',dav1(i,2),' MV/m',' field integral:',dav1(i,3),' kV', &
         ' beta ( output):',dav1(i,6),' particles left ',dav1(i,36)
       write(12,*)
     endif
! rfqcl (RFQ cell)
     if(iitem(i) .eq. 14) then
       write(12,*) 'Card RFQCL is no longer supported'
       write(12,*)
     endif
! rfqptq (RFQ)
     if(iitem(i) .eq. 15) then
       ncell=int(dav1(i,7))
       write(12,'(f9.2,A,i5,A,e12.5,A,/,A,e12.5,A,/,A,e12.5,A,/,A,e12.5,A,/,A,f9.0)') &
         dav1(i,4),' mm rfq: number of cells:',ncell,' total length: ',dav1(i,5),' mm', &
         '  intervane voltage (reference): ',dav1(i,9),' kV', &
         '  intervane voltage (bunch): ',dav1(i,8),' kV', &
         '  energy (output): ',dav1(i,6),' MeV','  particles left ',dav1(i,36)
       write(12,*)
     endif
! stipper foils
     if(iitem(i) .eq. 16) then
       write(12,'(f9.2,A,f4.0,A,f4.0,A,e12.5,A,/,4x,A,f4.0,A,e12.5,A,/,A,f9.0)') &
         dav1(i,4),' mm stripper: atomic number: ',dav1(i,1), &
         '   atomic mass : ',dav1(i,2),'  thickness :',dav1(i,3),' g/cm**2', &
         'particles charge : ',dav1(i,5),'  energy loss: ',dav1(i,6),' MeV', &
         '    particles left ',dav1(i,36)
       write(12,*)
     endif
! accelerating gap
     if(iitem(i) .eq. 17) then
       n=int(dav1(i,25)+0.5D0)
! 16/12/09         if(itvol.and.imamin) then
! 16/12/09          write(12,1009) dav1(i,24),n,dav1(i,1),dav1(i,2),
! 16/12/09     *                   dav1(i,38),dav1(i,39)
! 16/12/09 1009     format(f9.2,' mm Ac. gap ',i3,' length ',f7.2,
! 16/12/09     *                 'mm field ',e12.5,' kV/mm',/,
! 16/12/09     *   '    phase offset adjusted with TOF',/,
! 16/12/09     *   '    before adjustement ',e12.5,' deg',
! 16/12/09     *   ' after adjustement ',e14.7,' deg')
! 16/12/09         else
       write(12,'(f9.2,A,i3,A,f7.2,A,e12.5,A,e12.5,A)') dav1(i,24), &
         ' mm Ac. gap ',n,' length ',dav1(i,1),' mm field ',dav1(i,2), &
         ' kV/mm  phase of RF (middle): ',dav1(i,38),' deg'
! 16/12/09         endif
       write(12,*)
     endif
! QUAELEC electric quadrupole
     if(iitem(i) .eq. 18) then
       write(12,'(f9.2,A,e12.5,A,e12.5,A,/,A,f8.3,A,e12.5,A,e12.5,A,/A,e12.5,A,f9.0)')&
         dav1(i,4),' mm  Quadrupole (electric): length = ',dav1(i,1), &
         ' mm aperture radius = ',dav1(i,7),' mm', &
         '  voltage = ',dav1(i,2),' kV  K2 = ',dav1(i,6), &
         ' cm-2  gradient = ',dav1(i,5),' kV/(cm*cm) ', &
         '  rigidity = ',dav1(i,3),' kV  particles left  ',dav1(i,36)
       write(12,*)
     endif
!  QUAFK  quadrupole(magnetic or electric)
     if(iitem(i) .eq. 19) then
!  electric quadrupole
       if(ityq) then
         write(12,'(f9.2,A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A,e12.5,A,/A,e12.5,A,f9.0)')&
           dav1(i,4),' mm  Quadrupole (electric): length = ',dav1(i,1), &
           ' mm   aperture radius = ',dav1(i,7),' mm', &
           ' voltage = ',dav1(i,2),' kV   K2 = ',dav1(i,6), &
           ' cm-2  gradient = ',dav1(i,5),' kV/cm2', &
           ' rigidity = ',dav1(i,3),' kV   particles left  ',dav1(i,36)
       else
!  magnetic quadrupole
         write(12,'(f9.2,A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A,e12.5,A,/A,e12.5,A,f9.0)')&
           dav1(i,4),' mm  Quadrupole (magnetic): length = ',dav1(i,1), &
           ' mm   aperture radius = ',dav1(i,7),' mm', &
           ' field = ',dav1(i,2),' kG   K2 = ',dav1(i,6), &
           ' cm-2  gradient = ',dav1(i,5),' kG/cm', &
           ' momentum = ',dav1(i,3),' kG.cm   particles left  ',dav1(i,36)
!         write(12,2111) dav1(i,4),dav1(i,1),dav1(i,7),dav1(i,2), &
!         dav1(i,6),dav1(i,5),dav1(i,3),dav1(i,36)
! 2111    format(f9.2,' mm  Quadrupole (magnetic): length = ', &
!         e12.5,' mm  aperture radius= ',e12.5,' mm',/,' field = ', &
!         e12.5,' kG   K2 = ',e12.5,' cm-2  gradient = ',e12.5, &
!         ' kG/cm',/,' momentum = ',e12.5,' kG.cm   particles left  ', &
!         f9.0)
       endif
       write(12,*)
     endif
     if(iitem(i) .eq. 20) then
!  rotating the transverse coordinates about the z axis
       write(12,'(9x,A,A,e12.5,A)') 'rotating the transverse coordinates', &
               ' about the z-axis by an angle: ',dav1(i,1),' deg'
       write(12,*)
     endif
! EDFLEC electric deflector
     if(iitem(i) .eq. 21) then
       write(12,'(f9.2,A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A,e12.5)') &
         dav1(i,4),' mm  Deflector (electric): length = ',dav1(i,1),' mm bend angle = ', &
         dav1(i,2),' deg','  bend radius = ',dav1(i,3),' mm  radii = ',dav1(i,5), &
         '  field index = ',dav1(i,6)
       write(12,'(A,e12.5,A,e12.5,A,A,f9.0)') '  rigidity = ',dav1(i,7),' kV field = ', &
         dav1(i,8),' kV/mm','  particles left  ',dav1(i,36)
       write(12,*)
     endif
!   end (big loop)
   enddo
END SUBROUTINE daves
!> *******************************************************************
!! SUBROUTINE prbeam(iflg,wfile,fromrfq)
!! PRINT OF PARTICLE COORDINATES TO A FILE
!< *******************************************************************
SUBROUTINE prbeam(iflg,wfile,fromrfq)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4beam2, ONLY: bindst
   USE m4cavs
   USE m4input
   USE m4chase
   USE mCOMpaths
   USE mCOMrec   
   IMPLICIT NONE
   INTEGER iflg,nunit,i,ngx,ngy,ngz
   REAL(8) ecog,tcog,xav,xpav,yav,ypav,BEREF,GAMREF,ENREF,f2,f3,f4,f5,eprt,tprt
   REAL(8) ecogc,ecogr
   character(len=256) :: myfile,wfile
   LOGICAL fromrfq
!*******************************************************************
   if (.not. allocated(ichas)) allocate(ichas(iptsz))
   if (.not. allocated(ichxyz)) allocate(ichxyz(iptsz))
!  PRINT OF PARTICLE COORDINATES
   myfile=''
   ecog=0.D0
   tcog=0.D0
   xav=0.D0
   xpav=0.D0
   yav=0.D0
   ypav=0.D0
! **********************************************
!   cog of the bunch
   do i=1,ngood
     ecog=ecog+f(7,i)
     tcog=tcog+f(6,i)
     xav=xav+f(2,i)
     xpav=xpav+f(3,i)
     yav=yav+f(4,i)
     ypav=ypav+f(5,i)
   enddo
   ecog=ecog/DBLE(ngood)
   tcog=tcog/DBLE(ngood)
   xav=xav/DBLE(ngood)
   xpav=xpav/DBLE(ngood)
   yav=yav/DBLE(ngood)
   ypav=ypav/DBLE(ngood)
! write particle coordinates to files,  phase in radian
   BEREF=VREF/VL
   GAMREF=1.D0/SQRT(1.D0-(BEREF*BEREF))
   ENREF=XMAT*GAMREF
   myfile=TRIM(wfile)
   if(fromrfq) then
     nunit=57
   else
     nunit=58
     if(bindst) then
       open(nunit,file=myfile,status='unknown', form='unformatted')
     else
       open(nunit,file=myfile,status='unknown')
     endif
   endif
   if(iflg.lt.100) then
     if(bindst) then
       write(nunit)   ngood,iflg,fh/(2000000.D0*pi)
     else
       write(nunit,*) ngood,iflg,fh/(2000000.D0*pi)
     endif
   else
! iflg.ge.100
     if(bindst) then
       write(nunit)   ngood,iflg,fh/(2000000.D0*pi),ENREF-xmat,ecog-xmat
     else
       write(nunit,*) ngood,iflg,fh/(2000000.D0*pi),ENREF-xmat,ecog-xmat
     endif
   endif
   f2=0.D0
   f3=0.D0
   f4=0.D0
   f5=0.D0
   do i=1,ngood
     if(irec.eq.2) then
! coordinates relative to the reference
       eprt=f(7,i)-enref
       tprt=fh*(f(6,i)-tref)
       f2=f(2,i)
       f3=f(3,i)
       f4=f(4,i)
       f5=f(5,i)
     endif
     if(irec.eq.1) then
! absolute value for energy, phase relative to the COG
       eprt=f(7,i)-xmat
       tprt=fh*(f(6,i)-tcog)
! **********************************
       f2=f(2,i)
       f3=f(3,i)
       f4=f(4,i)
       f5=f(5,i)
     endif
     if(irec.eq.3) then
! absolute values for phase and energy
       eprt=f(7,i)-xmat
       tprt=fh*f(6,i)
! **********************************
       f2=f(2,i)
       f3=f(3,i)
       f4=f(4,i)
       f5=f(5,i)
     endif
     if(irec.eq.0) then
! values for phase and energy relative to the COG
       tprt=fh*(f(6,i)-tcog)
       eprt=f(7,i)-ecog
       f2=f(2,i)-xav
       f3=f(3,i)-xpav
       f4=f(4,i)-yav
       f5=f(5,i)-ypav
     endif
     if(iflg.eq.0 .or. iflg.eq.100) then
       if(bindst) then
         write(nunit)f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
       else
         write(nunit,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
       endif
     elseif(iflg.eq.1 .or. iflg.eq.101) then
       if(bindst) then
         write(nunit)f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(1,i)
       else
         write(nunit,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(1,i)
       endif
     elseif(iflg.eq.2 .or. iflg.eq.102) then
       if(bindst) then
         write(nunit)f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i)
       else
         write(nunit,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i)
       endif
     elseif(iflg.eq.3 .or. iflg.eq.103) then
       if(bindst) then
         write(nunit)f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i), &
            f(1,i)
       else
         write(nunit,"(8(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i), &
            f(1,i)
       endif
     elseif(iflg.eq.10 .or. iflg.eq.110) then
       if(bindst) then
         write(nunit)f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh, &
            eprt
       else
         write(nunit,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh, &
            eprt
       endif
     elseif(iflg.eq.11 .or. iflg.eq.111) then
       if(bindst) then
         write(nunit)f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh, &
            eprt,f(1,i)
       else
         write(nunit,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh, &
            eprt,f(1,i)
       endif
     elseif(iflg.eq.12 .or. iflg.eq.112) then
       if(bindst) then
         write(nunit)f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh, &
            eprt,f(9,i)
       else
         write(nunit,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh, &
            eprt,f(9,i)
       endif
     elseif(iflg.eq.13 .or. iflg.eq.113) then
       if(bindst) then
         write(nunit)f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh, &
           eprt,f(9,i),f(1,i)
       else
         write(nunit,"(8(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh, &
           eprt,f(9,i),f(1,i)
       endif
     endif
   enddo
   if(fromrfq) then
   else
     close(nunit)
! print "chased" beam if selected
     if (chasit) then
       if(fractl .lt. 1.D0) then
! ******************
! ---  chase in z-zp
! ******************
         call chasel
! ngz is number of retained particles in Z
         ngz=0
         ecogc=0.D0
         ecogr=0.D0
         do i=1,ngood
           ichxyz(i)=ichas(i)
           if(ichxyz(i).eq.1) then
             ngz=ngz+1
             ecogc=ecogc+f(7,i)-xmat
           else
             ecogr=ecogr+f(7,i)-xmat
           endif
         enddo
         ecogc=ecogc/DBLE(ngz)
         ecogr=ecogr/DBLE(ngood-ngz)
         if(iflg.lt.100) then
           write(60,*) ngood-ngz,iflg,fh/(2000000.D0*pi)
           write(61,*) ngz,iflg,fh/(2000000.D0*pi)
         else
           write(60,*) ngood-ngz,iflg,fh/(2000000.D0*pi),enref-xmat, &
              ecogr
           write(61,*) ngz,iflg,fh/(2000000.D0*pi),enref-xmat,ecogc
         endif
         f2=0.D0
         f3=0.D0
         f4=0.D0
         f5=0.D0
         do i=1,ngood
           if(irec.eq.2) then
! coordinates relative to the reference
             eprt=f(7,i)-enref
             tprt=fh*(f(6,i)-tref)
             f2=f(2,i)
             f3=f(3,i)
             f4=f(4,i)
             f5=f(5,i)
           endif
           if(irec.eq.1) then
! absolute value for energy, phase relative to the COG
             eprt=f(7,i)-xmat
             tprt=fh*(f(6,i)-tcog)
! **********************************
             f2=f(2,i)
             f3=f(3,i)
             f4=f(4,i)
             f5=f(5,i)
           endif
           if(irec.eq.3) then
! absolute values for phase and energy
             eprt=f(7,i)-xmat
             tprt=fh*f(6,i)
! ****************************************
             f2=f(2,i)
             f3=f(3,i)
             f4=f(4,i)
             f5=f(5,i)
           endif
           if(irec.eq.0) then
! values for phase and energy relative to the COG
             tprt=fh*(f(6,i)-tcog)
             eprt=f(7,i)-ecog
             f2=f(2,i)-xav
             f3=f(3,i)-xpav
             f4=f(4,i)-yav
             f5=f(5,i)-ypav
           endif
           if(ichxyz(i).eq.0) then
!  ************** only with CHASE, write to file particles removed
             if(iflg.eq.0 .or. iflg.eq.100) &
               write(60,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
             if(iflg.eq.10 .or. iflg.eq.110) &
               write(60,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt
             if(iflg.eq.1 .or. iflg.eq.101) &
               write(60,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(1,i)
             if(iflg.eq.11 .or. iflg.eq.111) &
               write(60,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(1,i)
             if(iflg.eq.2 .or. iflg.eq.102) &
               write(60,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i)
             if(iflg.eq.12 .or. iflg.eq.112) &
               write(60,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(9,i)
           else
!  ************** only with CHASE, write to file particles kept
             if(iflg.eq.0 .or. iflg.eq.100) &
               write(61,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
             if(iflg.eq.10 .or. iflg.eq.110) &
               write(61,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt
             if(iflg.eq.1 .or. iflg.eq.101) &
               write(61,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(1,i)
             if(iflg.eq.11 .or. iflg.eq.111) &
               write(61,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(1,i)
             if(iflg.eq.2 .or. iflg.eq.102) &
               write(61,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i)
             if(iflg.eq.12 .or. iflg.eq.112) &
               write(61,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
               f(9,i)
           endif
         enddo
       endif
       if(fractx .lt. 1.D0) then
! ******************
! ---  chase in x-xp
! ******************
         call chasex
! ngx is number of retained particles in X
         ngx=0
         ecogc=0.D0
         ecogr=0.D0
         do i=1,ngood
           ichxyz(i)=ichas(i)
           if(ichxyz(i).eq.1) then
             ngx=ngx+1
             ecogc=ecogc+f(7,i)-xmat
           else
             ecogr=ecogr+f(7,i)-xmat
           endif
         enddo
         ecogc=ecogc/DBLE(ngx)
         ecogr=ecogr/DBLE(ngood-ngx)
         if(iflg.lt.100) then
           write(62,*) ngood-ngx,iflg,fh/(2000000.D0*pi)
           write(63,*) ngx,iflg,fh/(2000000.D0*pi)
         else
           write(62,*) ngood-ngx,iflg,fh/(2000000.D0*pi),enref-xmat, &
              ecogr
           write(63,*) ngx,iflg,fh/(2000000.D0*pi),enref-xmat,ecogc
         endif
         f2=0.D0
         f3=0.D0
         f4=0.D0
         f5=0.D0
         do i=1,ngood
           if(irec.eq.2) then
! coordinates relative to the reference
             eprt=f(7,i)-enref
             tprt=fh*(f(6,i)-tref)
             f2=f(2,i)
             f3=f(3,i)
             f4=f(4,i)
             f5=f(5,i)
           endif
           if(irec.eq.1) then
! absolute value for energy, phase relative to the COG
             eprt=f(7,i)-xmat
             tprt=fh*(f(6,i)-tcog)
! **********************************
             f2=f(2,i)
             f3=f(3,i)
             f4=f(4,i)
             f5=f(5,i)
           endif
           if(irec.eq.3) then
! absolute values for phase and energy
             eprt=f(7,i)-xmat
             tprt=fh*f(6,i)
! ****************************************
             f2=f(2,i)
             f3=f(3,i)
             f4=f(4,i)
             f5=f(5,i)
           endif
           if(irec.eq.0) then
! values for phase and energy relative to the COG
             tprt=fh*(f(6,i)-tcog)
             eprt=f(7,i)-ecog
             f2=f(2,i)-xav
             f3=f(3,i)-xpav
             f4=f(4,i)-yav
             f5=f(5,i)-ypav
           endif
           if(ichxyz(i).eq.0) then
!  ************** only with CHASE, write to file particles removed
             if(iflg.eq.0 .or. iflg.eq.100) &
               write(62,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
             if(iflg.eq.10 .or. iflg.eq.110) &
               write(62,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt
             if(iflg.eq.1 .or. iflg.eq.101) &
               write(62,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(1,i)
             if(iflg.eq.11 .or. iflg.eq.111) &
               write(62,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(1,i)
             if(iflg.eq.2 .or. iflg.eq.102) &
               write(62,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i)
             if(iflg.eq.12 .or. iflg.eq.112) &
               write(62,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(9,i)
           else
!  ************** only with CHASE, write to file particles kept
             if(iflg.eq.0 .or. iflg.eq.100) &
               write(63,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
             if(iflg.eq.10 .or. iflg.eq.110) &
               write(63,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt
             if(iflg.eq.1 .or. iflg.eq.101) &
               write(63,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(1,i)
             if(iflg.eq.11 .or. iflg.eq.111) &
               write(63,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(1,i)
             if(iflg.eq.2 .or. iflg.eq.102) &
               write(63,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i)
             if(iflg.eq.12 .or. iflg.eq.112) &
               write(63,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
               f(9,i)
           endif
         enddo
       endif
       if(fracty .lt. 1.D0) then
! ******************
! ---  chase in y-yp
! ******************
         call chasey
! ngy is number of retained particles in Y
         ngy=0
         ecogc=0.D0
         ecogr=0.D0
         do i=1,ngood
           ichxyz(i)=ichas(i)
           if(ichxyz(i).eq.1) then
             ngy=ngy+1
             ecogc=ecogc+f(7,i)-xmat
           else
             ecogr=ecogr+f(7,i)-xmat
           endif
         enddo
         ecogc=ecogc/DBLE(ngy)
         ecogr=ecogr/DBLE(ngood-ngy)
         if(iflg.lt.100) then
           write(64,*) ngood-ngy,iflg,fh/(2000000.D0*pi)
           write(65,*) ngy,iflg,fh/(2000000.D0*pi)
         else
           write(64,*) ngood-ngy,iflg,fh/(2000000.D0*pi),enref-xmat, &
              ecogr
           write(65,*) ngy,iflg,fh/(2000000.D0*pi),enref-xmat,ecogc
         endif
         f2=0.D0
         f3=0.D0
         f4=0.D0
         f5=0.D0
         do i=1,ngood
           if(irec.eq.2) then
! coordinates relative to the reference
             eprt=f(7,i)-enref
             tprt=fh*(f(6,i)-tref)
             f2=f(2,i)
             f3=f(3,i)
             f4=f(4,i)
             f5=f(5,i)
           endif
           if(irec.eq.1) then
! absolute value for energy, phase relative to the COG
             eprt=f(7,i)-xmat
             tprt=fh*(f(6,i)-tcog)
! **********************************
             f2=f(2,i)
             f3=f(3,i)
             f4=f(4,i)
             f5=f(5,i)
           endif
           if(irec.eq.3) then
! absolute values for phase and energy
             eprt=f(7,i)-xmat
             tprt=fh*f(6,i)
! ****************************************
             f2=f(2,i)
             f3=f(3,i)
             f4=f(4,i)
             f5=f(5,i)
           endif
           if(irec.eq.0) then
! values for phase and energy relative to the COG
             tprt=fh*(f(6,i)-tcog)
             eprt=f(7,i)-ecog
             f2=f(2,i)-xav
             f3=f(3,i)-xpav
             f4=f(4,i)-yav
             f5=f(5,i)-ypav
           endif
           if(ichxyz(i).eq.0) then
!  ************** only with CHASE, write to file particles removed
             if(iflg.eq.0 .or. iflg.eq.100) &
               write(64,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
             if(iflg.eq.10 .or. iflg.eq.110) &
               write(64,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt
             if(iflg.eq.1 .or. iflg.eq.101) &
               write(64,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(1,i)
             if(iflg.eq.11 .or. iflg.eq.111) &
               write(64,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(1,i)
             if(iflg.eq.2 .or. iflg.eq.102) &
               write(64,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i)
             if(iflg.eq.12 .or. iflg.eq.112) &
               write(64,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(9,i)
           else
!  ************** only with CHASE, write to file particles kept
             if(iflg.eq.0 .or. iflg.eq.100) &
               write(65,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt
             if(iflg.eq.10 .or. iflg.eq.110) &
               write(65,"(6(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt
             if(iflg.eq.1 .or. iflg.eq.101) &
               write(65,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(1,i)
             if(iflg.eq.11 .or. iflg.eq.111) &
               write(65,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(1,i)
             if(iflg.eq.2 .or. iflg.eq.102) &
               write(65,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,tprt,eprt,f(9,i)
             if(iflg.eq.12 .or. iflg.eq.112) &
               write(65,"(7(e13.6,1x))")f2,f3/1000.D0,f4,f5/1000.D0,1.D9*tprt/fh,eprt, &
                 f(9,i)
           endif
         enddo
! following endif fracty
       endif
! following endif chaseit
     endif
! following endif fromrfq
   endif
END SUBROUTINE prbeam
!> *******************************************************************
!! SUBROUTINE histgrm
!! called by plotting routine grcomp(text,iskale)
!< *******************************************************************
SUBROUTINE histgrm
   USE DynacConstants
   USE m4beam
   USE m4input
   USE m4cavs
   USE m4prtcls, ONLY: xc,yc,zc
   USE m4histos
   IMPLICIT NONE
   REAL(8) trmoy,wcg,xcg,ycg,zcg,fnstp,gnp,vnp,xb2x,xb2z,xbxz,apl,xbar,ybar,zbar
   REAL(8) xsqsum,ysqsum,zsqsum,xrmsz,yrmsz,zrmsz,xinf,yinf,zinf,xsup,ysup,zsup
   REAL(8) eng,f3,f5,f7,fract,pax,pay,paz,stepx,stepy,stepz,paxp,payp,pazp
   REAL(8) sta,stpx,stpy,stpz,xnp,znp,zpnor
   REAL(8) x0,x1,xnor,xp0,xp1,xpinf,xpsum,xpsup,xtot  
   REAL(8) y0,y1,ynor,yp0,yp1,ypinf,ypsum,ypsup,ytot  
   REAL(8) z0,z1,znor,zp0,zp1,zpinf,zpsum,zpsup,ztot  
   INTEGER i,imaxx,j,np
!*******************************************************************
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
   trmoy=0.D0
   wcg=0.D0
   xcg=0.D0
   ycg=0.D0
   fnstp=100.D0
   do i=1,ngood
     trmoy=trmoy+f(6,i)
     wcg=wcg+f(7,i)
     xcg=xcg+f(2,i)
     ycg=ycg+f(4,i)
   enddo
   trmoy=trmoy/DBLE(ngood)
   wcg=wcg/DBLE(ngood)
   xcg=xcg/DBLE(ngood)
   ycg=ycg/DBLE(ngood)
   zcg=trmoy*fh
!  Isochronism correction (in case the bunch is not erect)
   xb2x=0.D0
   xb2z=0.D0
   xbxz=0.D0
   imaxx=0
   do np=1,ngood
     gnp=f(7,np)/xmat
     vnp=vl*sqrt(1.D0-1.D0/(gnp*gnp))
     zc(np)=(trmoy-f(6,np))*vnp/100.D0
     xc(np)=(f(2,np)-xcg)/100.D0
     xb2z=xb2z+zc(np)*zc(np)
     xb2x=xb2x+xc(np)*xc(np)
     xbxz=xbxz+zc(np)*xc(np)
     imaxx=imaxx+1
   enddo
   xb2z=xb2z/DBLE(imaxx)
   xb2x=xb2x/DBLE(imaxx)
   xbxz=xbxz/DBLE(imaxx)
   apl=atan(-2.D0*xbxz/(xb2x-xb2z))/2.D0
! coordinates of the particles at the point of time position
   xbar=0.D0
   ybar=0.D0
   zbar=0.D0
   imaxx=0
!  Divide by 100. to convert from centimeters to meters
   do np=1,ngood
     gnp=f(7,np)/xmat
     vnp=vl*sqrt(1.D0-1.D0/(gnp*gnp))
     znp=(trmoy-f(6,np))*vnp
     xnp=f(2,np)
     zc(np)=znp*cos(apl)+xnp*sin(apl)
     xnp=xnp*cos(apl)-znp*sin(apl)
!  convert from mrad to rad
     f3=f(3,np)*1.D-03
     f5=f(5,np)*1.D-03
!  convert from cm   to m
     xc(np)=(xnp+zc(np)*f3)/100.D0
     yc(np)=(f(4,np)+zc(np)*f5)/100.D0
     zc(np)=zc(np)/100.D0
! evaluate xbar , ybar , zbar
     xbar=xbar+xc(np)
     ybar=ybar+yc(np)
     zbar=zbar+zc(np)
   enddo
   eng=DBLE(ngood)
   xbar=xbar/eng
   ybar=ybar/eng
   zbar=zbar/eng
   do np=1,ngood
     xc(np)=xc(np)-xbar
     yc(np)=yc(np)-ybar
     zc(np)=zc(np)-zbar
   enddo
!  evaluate the rms sizes
   xsqsum=0.D0
   ysqsum=0.D0
   zsqsum=0.D0
   do j=1,ngood
     xsqsum=xsqsum+xc(j)*xc(j)
     ysqsum=ysqsum+yc(j)*yc(j)
     zsqsum=zsqsum+zc(j)*zc(j)
   enddo
   xrmsz=xsqsum/DBLE(ngood)
   yrmsz=ysqsum/DBLE(ngood)
   zrmsz=zsqsum/DBLE(ngood)
   xrmsz=sqrt(xrmsz)
   yrmsz=sqrt(yrmsz)
   zrmsz=sqrt(zrmsz)
! normalize the coordinates x, y and z
   do j=1,ngood
     xc(j)=xc(j)/xrmsz
     yc(j)=yc(j)/yrmsz
     zc(j)=zc(j)/zrmsz
   enddo
!   look for the limits of the cloud of particles in the plane (x/a, y/b, z/c)
!   these limits are assumed included within at most +/- 5 RMS
   fract=5.D0
   xinf=0.D0
   yinf=0.D0
   zinf=0.D0
!lower limits
   do i=1,ngood
     if((abs(xc(i)).le.fract).and.(abs(yc(i)).le.fract).and. &
         (abs(zc(i)).le.fract)) then
       if(xinf.gt.xc(i)) xinf=xc(i)
       if(yinf.gt.yc(i)) yinf=yc(i)
       if(zinf.gt.zc(i)) zinf=zc(i)
     endif
   enddo
! upper limits
   xsup=xinf
   ysup=yinf
   zsup=zinf
   do i=1,ngood
     if((abs(xc(i)).le.fract).and.(abs(yc(i)).le.fract).and. &
         (abs(zc(i)).le.fract)) then
       if(xsup.lt.xc(i)) xsup=xc(i)
       if(ysup.lt.yc(i)) ysup=yc(i)
       if(zsup.lt.zc(i)) zsup=zc(i)
     endif
   enddo
! maximal sizes in x, y, and z-directions
   pax=(xsup-xinf)
   pay=(ysup-yinf)
   paz=(zsup-zinf)
!  histogram in x-direction,the step (stepx) is: pax/50
   stepx=pax/fnstp
   do i=1,200
     xn(i)=0.D0
   enddo
   xtot=0.D0
   x0=xinf-stepx
   x1=x0+stepx
   j=1
!   xpos(j): position of the elementary cylinder j
!   xn(j)  : number of particles in the elementary cylinder j
!   xtot   : total number of particles in x-direction
   do
     if(x1.le.xsup+stepx) then
       do i=1,ngood
         if(xc(i).gt.x0.and.xc(i).le.x1) xn(j)=xn(j)+1.D0
       enddo
       xtot=xtot+xn(j)
       xpos(j)=x0+stepx/2.D0
       j=j+1
       sta=x1
       x1=x1+stepx
       x0=sta
     else
       exit
     endif
   enddo
!  normalize the number of particles in each step with regard to max.(xn(j))
   j=j-1
   ixt=j
   xnor=0.D0
   do i=1,j
     if(xnor.lt.xn(i)) xnor=xn(i)
   enddo
   do i=1,j
     xn(i)=xn(i)/xnor
   enddo
!   histogram in y-direction,the step (stepy) is: pay/50
   stepy=pay/fnstp
   do i=1,200
     yn(i)=0.D0
   enddo
   ytot=0.D0
   y0=yinf-stepy
   y1=y0+stepy
   j=1
!   ypos(j): position of the step j
!   yn(j)  : number of particles lying in the  j
!   ytot   : total number of particles in y-direction
   do
     if(y1.le.ysup+stepy) then
       do i=1,ngood
         if(yc(i).gt.y0.and.yc(i).le.y1) yn(j)=yn(j)+1.D0
       enddo
       ytot=ytot+yn(j)
       ypos(j)=y0+stepy/2.D0
       j=j+1
       sta=y1
       y1=y1+stepy
       y0=sta
     else
       exit
     endif
   enddo
   j=j-1
   iyt=j
   y0=yinf
!  normalize the number of particles in step with regard to max(yn(j))
   ynor=0.D0
   do i=1,j
     if(ynor.lt.yn(i)) ynor=yn(i)
   enddo
   do i=1,j
     yn(i)=yn(i)/ynor
   enddo
!  histogram in z-direction,the step (stepz) is: paz/50
   do i=1,200
     zn(i)=0.D0
   enddo
   stepz=paz/fnstp
   ztot=0.D0
   z0=zinf-stepz
   z1=z0+stepz
   j=1
!  of length :stepz and radius:ray
!   zpos(j): position of the step j
!   zn(j)  : number of particles in the step j
!   ztot   : total number of particles in z-direction
   do
     if(z1.le.zsup+2.D0*stepz) then
       do i=1,ngood
         if(zc(i).gt.z0.and.zc(i).le.z1)zn(j)=zn(j)+1.D0
       enddo
       ztot=ztot+zn(j)
       zpos(j)=z0+stepz/2.D0
       j=j+1
       sta=z1
       z1=z1+stepz
       z0=sta
     else
       exit
     endif
   enddo
   j=j-1
   izt=j
   z0=zinf
!  normalize the number of particles in each step with regard to max(zn(j))
   znor=0.D0
   do i=1,j
     if(znor.lt.zn(i)) znor=zn(i)
   enddo
   do i=1,j
     zn(i)=zn(i)/znor
   enddo
!   look for the limits of xp, yp, zp
   xpinf=f(3,1)
   ypinf=f(5,1)
!   zpinf=f(6,1)-trmoy
   zpinf=f(7,1)-wcg
!lower limits
   do i=1,ngood
     f3=f(3,i)
     f5=f(5,i)
!     f6=f(6,i)-trmoy
     f7=f(7,i)-wcg
     if(xpinf.gt.f3) xpinf=f3
     if(ypinf.gt.f5) ypinf=f5
     if(zpinf.gt.f7) zpinf=f7
   enddo
! upper limits
   xpsup=xpinf
   ypsup=ypinf
   zpsup=zpinf
   do i=1,ngood
     f3=f(3,i)
     f5=f(5,i)
     f7=f(7,i)-wcg
     if(xpsup.lt.f3) xpsup=f3
     if(ypsup.lt.f5) ypsup=f5
     if(zpsup.lt.f7) zpsup=f7
   enddo
! maximal sizes in xp, yp, and zp-directions
   paxp=(xpsup-xpinf)
   payp=(ypsup-ypinf)
! deal with a mono-kinetic beam       
   if(abs(zpsup-zpinf).le.fprec) then
     zpsup=zpsup+0.1D0*abs(zpsup)
     zpinf=zpinf-0.1D0*abs(zpinf)
   endif  
   pazp=(zpsup-zpinf)
!  evaluate the rms sizes in xp, yp, zp
   xpsum=0.D0
   ypsum=0.D0
   zpsum=0.D0
   do i=1,ngood
     f3=f(3,i)
     f5=f(5,i)
!     f6=f(6,i)-trmoy
     f7=f(7,i)-wcg
     xpsum=xpsum+f3*f3
     ypsum=ypsum+f5*f5
     zpsum=zpsum+f7*f7
   enddo
   xpsum=xpsum/DBLE(ngood)
   ypsum=ypsum/DBLE(ngood)
   zpsum=zpsum/DBLE(ngood)
   xpsum=sqrt(xpsum)
   ypsum=sqrt(ypsum)
   zpsum=sqrt(zpsum)
!  histogram in xp-direction,the step (stxp) is: paxp/50
   stpx=paxp/fnstp
   do i=1,200
     xpn(i)=0.D0
   enddo
   xp0=xpinf-stpx
   xp1=xp0+stpx
   j=1
!   xps(j): position of the step j
!   xpn(j): number of particles lying in the step j
   do
     if(xp1.le.xpsup+stpx) then
       do i=1,ngood
         if(f(3,i).gt.xp0.and.f(3,i).le.xp1) xpn(j)=xpn(j)+1.D0
       enddo
       xps(j)=xp0+stpx/2.D0
       j=j+1
       sta=xp1
       xp1=xp1+stpx
       xp0=sta
     else
       exit
     endif
   enddo
!   normalize the number of particles in each step with regard to max.(xpn(j))
   j=j-1
   ixpt=j
   xnor=0.D0
   do i=1,j
     if(xnor.lt.xpn(i)) xnor=xpn(i)
   enddo
   do i=1,j
     xpn(i)=xpn(i)/xnor
     xps(i)=xps(i)/xpsum
   enddo
!  histogram in yp-direction,the step (stpy) is: payp/50
   stpy=payp/fnstp
   do i=1,200
     ypn(i)=0.D0
   enddo
   yp0=ypinf-stpy
   yp1=yp0+stpy
   j=1
!   yps(j): position of the step j in mrd
!   ypn(j)  : number of particles lying in the  j
   do
     if(yp1.le.ypsup+stpy) then
       do i=1,ngood
         if(f(5,i).gt.yp0.and.f(5,i).le.yp1) ypn(j)=ypn(j)+1.D0
       enddo
       yps(j)=yp0+stpy/2.D0
       j=j+1
       sta=yp1
       yp1=yp1+stpy
       yp0=sta
     else
       exit
     endif
   enddo
   j=j-1
   iypt=j
   yp0=ypinf
!  normalize the number of particles in step with regard to max(ypn(j))
   ynor=0.D0
   do i=1,j
     if(ynor.lt.ypn(i)) ynor=ypn(i)
   enddo
   do i=1,j
     ypn(i)=ypn(i)/ynor
     yps(i)=yps(i)/ypsum
   enddo
!  histogram in zp-direction,the step (stpz) is: pazp/50
   do i=1,200
     zpn(i)=0.D0
   enddo
   stpz=pazp/fnstp
   zp0=zpinf-stpz
   zp1=zp0+stpz
   j=1
!  of length :stepz and radius:ray
!   zps(j): position of the step j (deg)
!   zpn(j)  : number of particles in the step j
   do
     if(zp1.le.zpsup+2.D0*stpz) then
       do i=1,ngood
         f7=f(7,i)-wcg
         if(f7.gt.zp0.and.f7.le.zp1) zpn(j)=zpn(j)+1.D0
       enddo
       zps(j)=zp0+stpz/2.D0
       j=j+1
       sta=zp1
       zp1=zp1+stpz
       zp0=sta
     else
       exit
     endif
   enddo
!  normalize the number of particles in each step with regard to max(zn(j))
   j=j-1
   izpt=j
   zpnor=0.D0
   do i=1,j
     if(zpnor.lt.zpn(i)) zpnor=zpn(i)
   enddo
   do i=1,j
     zpn(i)=zpn(i)/zpnor
     zps(i)=zps(i)/zpsum
   enddo
   deallocate(xc)
   deallocate(yc)
   deallocate(zc)   
END SUBROUTINE histgrm
!> *******************************************************************
!! SUBROUTINE ytzp
!! STORAGE OF PARTICLE COORDINATES FOR PLOTS
!< *******************************************************************
SUBROUTINE ytzp
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4chase, ONLY: ichas
   USE m4plots
   USE m4STIS
   USE m4FENE
   USE mCOMzones
   IMPLICIT NONE
   INTEGER i,j,k,iarg,init,igrtyp
   REAL(8) axx,ayy,bcog,bref,COR12,encog,enihrf,enprt,gcog,gref
   REAL(8) PENT12,PENT21,PHIHRF
   REAL(8) qdianp,qdiant,qdisp,qdita,qditay,qdp,qdpde,qmd,qmdw,quot,rmsmtp,rmssz
   REAL(8) step,surm,tcog,teps,trqpz,trqty,tta,ttb,ttc,ttcb,wcog,satref,savref,wref
   REAL(8) xii,yi,yii
   character(len=80) :: text
   REAL(8) slim(4,2)
   REAL(8), allocatable ::  xx(:),yy(:),cs(:)  
!*******************************************************************
   if (.not. allocated(xx)) allocate(xx(iptsz))
   if (.not. allocated(yy)) allocate(yy(iptsz))
   if (.not. allocated(cs)) allocate(cs(iptsz))
   satref=tref
   savref=vref
   init=0
   call area(init)
   if (igrprm.eq.0) then
!        READ GRAPH TITLE
     READ(IN,'(A)') TEXT
! idwdp=0 cog=ref in ZZ' plot (for instance for Alvarez structure)
! idwdp=1 cog<>ref in ZZ' plot (for instance for IH structrure)
     READ(IN,*) idwdp,rmsmtp
!       READ GRAPH LIMITS INTO GLIM(J,K), J=GRAPH NUMBER
!       K=1 HOR. LIMIT , K=2 VERT. LIMIT
     READ(IN,*) ((GLIM(J,K), K=1,2), J=1,4)
   endif
   if (igrprm.eq.1) then
     text=patitl
   endif
   if (igrprm.eq.2) then
     text=patitl
!  save limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         slim(j,k)=glim(j,k)
         glim(j,k)=glim1(j,k)
       enddo
     enddo
   endif
   if (igrprm.eq.3) then
     text=patitl
!  save limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         slim(j,k)=glim(j,k)
         glim(j,k)=glim2(j,k)
       enddo
     enddo
   endif
   do i=1,ngood
     ichas(i)=1
   enddo
   iarg=1
   call cdg(iarg)
   encog=cog(1)
   gcog=encog/xmat
   if(gcog.le.1) then
     write(6,*)
     write(ierr,*) 'Relativistic gamma of COG < 1 in graphics'
     STOP
   endif
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   enprt=encog-xmat
   teps=1.D-08
   rmssz=sqrt(rmsmtp)
   iarg=1
   call ext2(iarg)
   QDISP=rmssz*SQRT(exten(1))
   QMD=exten(1)*exten(3)-exten(2)*exten(2)
   QMDW=exten(10)*exten(3)-exten(11)*exten(11)
   SURM=rmsmtp*180.D0*SQRT(QMD)
   QDP=rmssz*SQRT(exten(3))
   if(exten(1)*exten(3).gt.fprec) then
     COR12=exten(2)/sqrt(exten(1)*exten(3))
     PENT12=SQRT(exten(1)/exten(3))/COR12
     PENT21=SQRT(exten(1)/exten(3))*COR12
   else
     COR12=0.D0
     PENT12=0.D0
     PENT21=0.D0
   ENDIF
   QDPDE=QDP*180.D0/pi
   TRQTY=exten(4)*exten(5)-exten(8)*exten(8)
   TRQPZ=exten(6)*exten(7)-exten(9)*exten(9)
   SURYTH=rmsmtp*PI*SQRT(TRQTY)
   SURZPH=rmsmtp*PI*SQRT(TRQPZ)
   QDITAY=rmssz*SQRT(exten(4))
   QDIANT=rmssz*SQRT(exten(5))
   QDITA=rmssz*SQRT(exten(6))
   QDIANP=rmssz*SQRT(exten(7))
   write(16,'(1x,a,a)') 'TITLE:     ',text
   if(rmsmtp.gt.teps) then
     write(16,'(a,f7.4,a)') ' *** PLOT Ellipse for ',rmsmtp,' RMS'
   else
     write(16,'(a,a,f7.4)') ' *** Ellipse will not be plotted: ', &
     'RMSMTP=',rmsmtp
   endif
   WRITE(16,'(1x,A,I8,A,I8,/)') '*** TOTAL NUMBER OF PARTICLES : ', &
    IMAX,' PARTICLES KEPT : ',ngood
   WRITE(16,'(A)') ' ***  HORIZONTAL phase plane '
   WRITE(16,'(6X,A,E12.5,A,E12.5,A,/)') 'COG :      X : ',cog(4), &
       ' CM  XP :',cog(5),' MRD'
   if(rmsmtp.gt.teps) then
     WRITE(16,'(6X,A,E12.5,A,/,6X,A,E12.5,A,4X,A,E15.8,A,/)') &
      '1/2 EXTENSION X  : ',QDITAY,' CM','1/2 EXTENSION XP : ',QDIANT,' MRD',&
      ' SURFACE : ',SURYTH,' CM.MRD'
   endif
   WRITE(16,'(A)') ' ***  VERTICAL phase plane '
   WRITE(16,'(6X,A,E12.5,A,E12.5,A,/)') 'COG :      Y : ',cog(6), &
       ' CM  YP :',cog(7),' MRD'
   if(rmsmtp.gt.teps) then
     WRITE(16,'(6X,A,E12.5,A,/,6X,A,E12.5,A,4X,A,E15.8,A,/)') &
      '1/2 EXTENSION Y  : ',QDITA,' CM','1/2 EXTENSION YP : ',QDIANP,' MRD',&
      ' SURFACE : ',SURZPH,' CM.MRD'         
   endif
! Store header and particle coordinates in binary file for
! graphics post-processor
!
! igrtyp is type of graph
!        igrtyp=1  for ytzp emittance plots
!        igrtyp=6  for ytzp emittance plots for multi-charge state beam
!        igrtyp=11 for ytzp emittance plots with ZONES card
!
   igrtyp=1
   if(nzone.ne.0)igrtyp=11
   if(imcs.eq.1) igrtyp=6
   WRITE(66,*) igrtyp
   if (igrtyp.eq.6)then
     write(66,*) ncstat
     write(66,*) (cstat(j),j=1,ncstat)
   endif
   if (igrtyp.eq.11)then
     write(66,*) nzone
     write(66,*) (frms(j),j=2,nzone),' 0.'
   endif
   WRITE(66,*) text
   xx(1)=GLIM(1,1)
   yy(1)=GLIM(1,2)
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
!  first store ellipse coordinates XX'
   step=qdiant/50.D0
   TTA=exten(5)
   do i=1,101
     xii=-qdiant+step*DBLE(i-1)
     yy(i)=xii+cog(5)
     yy(202-i)=yy(i)
     TTB=exten(8)*XII
     TTC=exten(4)*XII**2-TRQTY*rmsmtp
     TTCB=TTB**2-TTC*TTA
     IF(TTCB .LE. 0.D0) TTCB=0.D0
     IF(abs(TTA).le.fprec) then
       YI=0.D0
       YII=0.D0
     ELSE
       QUOT=TTCB/TTA**2
       YI=TTB/TTA-SQRT(quot)
       YII=TTB/TTA+SQRT(quot)
     ENDIF
     xx(i)=yi+cog(4)
     xx(202-i)=yii+cog(4)
   enddo
   do i=1,201
     WRITE(66,*) xx(i),yy(i)
   enddo
   do i=1,ngood
     xx(i)=F(2,I)
     yy(i)=F(3,I)
   enddo
   if (imcs.eq.1) then
     do i=1,ngood
       cs(i)=f(9,i)
     enddo
   endif
! write particle coordinates to graphics file
   WRITE(66,*) ngood
   if (imcs.eq.0) then
     if(nzone.eq.0) then
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i)
       enddo
     else
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i),f(10,i)
       enddo
     endif
   else
     do i=1,ngood
      WRITE(66,*) xx(i),yy(i),cs(i)
     enddo
   endif
! YY' next
   xx(1)=GLIM(2,1)
   yy(1)=GLIM(2,2)
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
!  first write ellipse coordinates
   step=qdianp/50.D0
   TTA=exten(7)
   do i=1,101
     xii=-qdianp+step*DBLE(i-1)
     yy(i)=xii+cog(7)
     yy(202-i)=yy(i)
     TTB=exten(9)*XII
     TTC=exten(6)*XII**2-TRQPZ*rmsmtp
     TTCB=TTB**2-TTC*TTA
     IF(TTCB .LE. 0.D0) TTCB=0.D0
     IF(abs(TTA).le.fprec) then
       YI=0.D0
       YII=0.D0
     ELSE
       QUOT=TTCB/TTA**2
       YI=TTB/TTA-SQRT(quot)
       YII=TTB/TTA+SQRT(quot)
     ENDIF
     xx(i)=yi+cog(6)
     xx(202-i)=yii+cog(6)
   enddo
   do i=1,201
    WRITE(66,*) xx(i),yy(i)
   enddo
   do i=1,ngood
     xx(i)=F(4,I)
     yy(i)=F(5,I)
   enddo
! write particle coordinates to graphics file
   WRITE(66,*) ngood
   if (imcs.eq.0) then
     if(nzone.eq.0) then
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i)
       enddo
     else
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i),f(10,i)
       enddo
     endif
   else
     do i=1,ngood
      WRITE(66,*) xx(i),yy(i),cs(i)
     enddo
   endif
!
!  TRACE GRAPHE ZZ'
   xx(1)=GLIM(3,1)
   yy(1)=GLIM(3,2)
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
!
   xx(1)=GLIM(4,1)
   yy(1)=GLIM(4,2)
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
!  TRACE DE L ELLIPSE  DE CONCENTRATION
   bref=vref/vl
   gref=1.D0/sqrt(1.D0-bref*bref)
   WREF=XMAT*(gref-1.D0)
   gcog=1.D0/sqrt(1.D0-bcog*bcog)
   WCOG=XMAT*(gcog-1.D0)
   WRITE(16,'(A)') ' ***  LONGITUDINAL phase plane'
   WRITE(16,'(4X,A,E15.8,A,E15.8,A,/,4X,A,E15.8,A,E15.8,A,/)') &
    '  REFERENCE :  ENERGY: ',WREF,' (MeV), TOF: ',TREF,' (SEC)', &
    '  COG       :  ENERGY: ',WCOG,' (MeV), TOF: ',tcog,' (SEC)'
   if(rmsmtp.gt.teps) then
     WRITE(16,'(6X,A,E12.5,A,E12.5,A)') 'ELLIPSE BASED ON 2nd ORDER MOMENTS :', &
      QMD,' (RD DP/P)**2    SURFACE : ',SURM,' (DEG DP/P)'
     WRITE(16,'(6x,A,E12.5,A,E12.5,A,/,6X,A,E15.8,A)') &
      '1/2 EXTENSION PHASE      : ',QDP,' RD  OR ',QDPDE,' DEG', &
      '1/2 EXTENSION DISPERSION : ',QDISP,' IN DP/P '
     WRITE(16,'(6X,A,E15.8,/,6x,A,E15.8,A,/,6x,A,E15.8,A)') &
     'CORRELATION COEF         : ',COR12,'DISPERSION SLOPE         : ',PENT12,&
     ' (DP/P)/RD ','PHASE SLOPE              : ',PENT21,' (DP/P)/RD '
   endif
!  GRAPHE DE L ELLIPSE
   step=qdpde/50.D0
   TTA=exten(3)*180.D0*180.D0/(pi*pi)
   do i=1,101
     xii=-qdpde+step*DBLE(i-1)
     xx(i)=xii
     xx(202-i)=xx(i)
     TTB=exten(11)*XII*180.D0/pi
     TTC=exten(10)*XII**2-QMDW*rmsmtp*180.D0*180.D0/(pi*pi)
     TTCB=TTB**2-TTC*TTA
     IF(TTCB .LE. 0.D0) TTCB=0.D0
!     IF(TTA.eq.0.) then
     IF(abs(TTA).le.fprec) then
       YI=0.D0
       YII=0.D0
     ELSE
       QUOT=TTCB/TTA**2
       YI=TTB/TTA-SQRT(quot)
       YII=TTB/TTA+SQRT(quot)
     ENDIF
     yy(i)=yi
     yy(202-i)=yii
   enddo
   enihrf=0.D0
   if(idwdp.eq.0) then
! Alvarez
     do i=1,201
       WRITE(66,*) xx(i),yy(i)
     enddo
   else
! IH
     bref=vref/vl
     gref=1.D0/sqrt(1.D0-bref*bref)
     ENIHRF=XMAT*(gref-1.D0)
     PHIHRF=FH*(tcog-tref)*180.D0/pi
     do i=1,201
       axx=phihrf
       ayy=encog-enihrf-xmat
       WRITE(66,*) xx(i)+axx,yy(i)+ayy
     enddo
   endif
   if (idwdp.eq.0) then
! Alvarez like
     do i=1,ngood
       xx(i)=fh*(f(6,i)-tcog)*180.D0/pi
       yy(i)=f(7,i)-encog
       if (imcs.eq.1) cs(i)=f(9,i)
     enddo
   endif
   IF(idwdp.eq.1) THEN
! IH like
     do i=1,ngood
       xx(i)=FH*(f(6,i)-tref)*180.D0/pi
       yy(i)=f(7,i)-enihrf-xmat
       if (imcs.eq.1) cs(i)=f(9,i)
     enddo
   endif
! write particle coordinates to graphics file
   WRITE(66,*) ngood
   if (imcs.eq.0) then
     if(nzone.eq.0) then
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i)
       enddo
     else
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i),f(10,i)
       enddo
     endif
   else
     do i=1,ngood
      WRITE(66,*) xx(i),yy(i),cs(i)
     enddo
   endif
! plot emittance  with chase (if applicable)
!       if (chasit) call ytzprc(glim,oldcog,idwdp)
   if (igrprm.eq.2.or.igrprm.eq.3) then
!  restore limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         glim(j,k)=slim(j,k)
       enddo
     enddo
   endif
   tref=satref
   vref=savref
   deallocate(xx)
   deallocate(yy)
   deallocate(cs)   
END SUBROUTINE ytzp
!> *******************************************************************
!! SUBROUTINE ytzp2d
!! STORAGE OF HISTOGRAMMED BEAM DATA FOR PLOTS
!< *******************************************************************
SUBROUTINE ytzp2d
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE m4STIS
   USE m4FENE
   USE sub4hist2d 
   IMPLICIT NONE
   INTEGER i,j,k,iarg,init,igrtyp,nx,ny
   REAL(8) bcog,bref,COR12,encog,enihrf,enprt,gcog,gref
   REAL(8) fmax,xmin,xmax,xpmin,xpmax,ymin,ymax,ypmin,ypmax,zmin,zmax,zpmin,zpmax
   REAL(8) PENT12,PENT21
   REAL(8) qdianp,qdiant,qdisp,qdita,qditay,qdp,qdpde,qmd,qmdw,rmsmtp,rmssz
   REAL(8) surm,tcog,teps,trqpz,trqty,wcog,satref,savref,wref
   character(len=80) :: text
   REAL(8) slim(4,2)
   REAL(8), allocatable ::  xx(:),yy(:)   
   REAL(8) array(100,100)
!*******************************************************************
   allocate(xx(iptsz))   
   allocate(yy(iptsz))   
   satref=tref
   savref=vref
   init=0
!  READ GRAPH TITLE
   READ(IN,'(A)') TEXT
! idwdp=0 cog=ref in ZZ' plot (for instance for Alvarez structure)
! idwdp=1 cog<>ref in ZZ' plot (for instance for IH structrure)
   READ(IN,*) idwdp,rmsmtp
!  READ GRAPH LIMITS INTO GLIM(J,K), J=GRAPH NUMBER
!  K=1 HOR. LIMIT , K=2 VERT. LIMIT
   READ(IN,*) ((GLIM(J,K), K=1,2), J=1,4)
   iarg=1
   call cdg(iarg)
   encog=cog(1)
   gcog=encog/xmat
   if(gcog.le.1) then
     write(6,*)
     write(ierr,*) 'Relativistic gamma of COG < 1 in graphics'
     STOP
   endif
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   enprt=encog-xmat
   teps=1.D-08
   rmssz=sqrt(rmsmtp)
   iarg=1
   call ext2(iarg)
   QDISP=rmssz*SQRT(exten(1))
   QMD=exten(1)*exten(3)-exten(2)*exten(2)
   QMDW=exten(10)*exten(3)-exten(11)*exten(11)
   SURM=rmsmtp*180.D0*SQRT(QMD)
   QDP=rmssz*SQRT(exten(3))
!   if(exten(1).ne.0. .and. exten(3).ne.0.) then
   if(exten(1)*exten(3).gt.fprec) then
     COR12=exten(2)/sqrt(exten(1)*exten(3))
     PENT12=SQRT(exten(1)/exten(3))/COR12
     PENT21=SQRT(exten(1)/exten(3))*COR12
   else
     COR12=0.D0
     PENT12=0.D0
     PENT21=0.D0
   ENDIF
   QDPDE=QDP*180.D0/pi
   TRQTY=exten(4)*exten(5)-exten(8)*exten(8)
   TRQPZ=exten(6)*exten(7)-exten(9)*exten(9)
   SURYTH=rmsmtp*PI*SQRT(TRQTY)
   SURZPH=rmsmtp*PI*SQRT(TRQPZ)
   QDITAY=rmssz*SQRT(exten(4))
   QDIANT=rmssz*SQRT(exten(5))
   QDITA=rmssz*SQRT(exten(6))
   QDIANP=rmssz*SQRT(exten(7))
   write(16,'(1x,a,a)') 'TITLE:     ',text
   if(rmsmtp.gt.teps) then
     write(16,'(a,f7.4,a)') ' *** PLOT Ellipse for ',rmsmtp,' RMS'
   else
     write(16,'(a,a,f7.4)') ' *** Ellipse will not be plotted: ', &
     'RMSMTP=',rmsmtp
   endif
   WRITE(16,'(1x,A,i8,A,i8,/,/,A)') '*** TOTAL NUMBER OF PARTICLES : ',IMAX, &
    ' PARTICLES KEPT : ',ngood,' ***  HORIZONTAL phase plane '
   WRITE(16,'(6x,A,5x,A,e12.5,A,e12.5,A,/)') 'COG :', &
    ' X : ',cog(4),' CM  XP :',cog(5),' MRD'
   if(rmsmtp.gt.teps) then
     WRITE(16,'(6x,A,e12.5,A,/,6x,A,e12.5,A,4x,A,e15.8,A,/)') &
      '1/2 EXTENSION X : ',QDITAY,' CM', &
      '1/2 EXTENSION XP : ',QDIANT,' MRD',' SURFACE : ',SURYTH,' CM.MRD'
   endif
   WRITE(16,'(A)') ' ***  VERTICAL phase plane '
   WRITE(16,'(6x,A,5x,A,e12.5,A,e12.5,A,/)') 'COG :', &
     ' Y : ',cog(6),' CM  YP :',cog(7),' MRD'
   if(rmsmtp.gt.teps) then
     WRITE(16,'(6x,A,e12.5,A,/,6x,A,e12.5,A,4x,A,e15.8,A,/)') &
      '1/2 EXTENSION Y : ',QDITA,' CM', &
      '1/2 EXTENSION YP : ',QDIANP,' MRD',' SURFACE : ',SURZPH,' CM.MRD'
   endif
! Store header and particle coordinates in binary file for
! graphics post-processor
!
! igrtyp is type of graph
!        igrtyp=16  for ytzp 2D emittance plots
!
   igrtyp=16
   WRITE(66,*) igrtyp
   WRITE(66,*) text
! GRAPH XX'
   xx(1)=GLIM(1,1)
   yy(1)=GLIM(1,2)
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
   xmin=F(2,1)
   xmax=F(2,1)
   xpmin=F(3,1)
   xpmax=F(3,1)
   do i=1,ngood
     xx(i)=F(2,I)
     if(xx(i).gt.xmax) xmax=xx(i)
     if(xx(i).lt.xmin) xmin=xx(i)
     yy(i)=F(3,I)
     if(yy(i).gt.xpmax) xpmax=yy(i)
     if(yy(i).lt.xpmin) xpmin=yy(i)
   enddo
   WRITE(66,*) xmin,xmax,xpmin,xpmax
   nx=20
   ny=20
! write histogrammed data to graphics file
   WRITE(66,*) ngood,nx,ny
!!!!********write histo data
   call hist2d(ngood,xx,yy,xmin,xmax,xpmin,xpmax,nx,ny,array)
   fmax=array(1,1)
   do i=1,nx
     do j=1,ny
       write(66,*) array(i,j)
       if(array(i,j).gt.fmax) fmax=array(i,j)
     enddo
   enddo
   write(66,*) fmax
!
! GRAPH YY' next
   xx(1)=GLIM(2,1)
   yy(1)=GLIM(2,2)
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
   ymin=F(4,1)
   ymax=F(4,1)
   ypmin=F(5,1)
   ypmax=F(5,1)
   do i=1,ngood
     xx(i)=F(4,I)
     if(xx(i).gt.ymax) ymax=xx(i)
     if(xx(i).lt.ymin) ymin=xx(i)
     yy(i)=F(5,I)
     if(yy(i).gt.ypmax) ypmax=yy(i)
     if(yy(i).lt.ypmin) ypmin=yy(i)
   enddo
   WRITE(66,*) ymin,ymax,ypmin,ypmax
! write histogrammed data to graphics file
!!!!********write histo data
   call hist2d(ngood,xx,yy,ymin,ymax,ypmin,ypmax,nx,ny,array)
   fmax=array(1,1)
   do i=1,nx
     do j=1,ny
       write(66,*) array(i,j)
       if(array(i,j).gt.fmax) fmax=array(i,j)
     enddo
   enddo
   write(66,*) fmax
!
! GRAPH XY
   xx(1)=GLIM(3,1)
   yy(1)=GLIM(3,2)
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
   do i=1,ngood
     xx(i)=F(2,I)
     yy(i)=F(4,I)
   enddo
   WRITE(66,*) xmin,xmax,ymin,ymax
! write histogrammed data to graphics file
!!!!********write histo data
   call hist2d(ngood,xx,yy,xmin,xmax,ymin,ymax,nx,ny,array)
   fmax=array(1,1)
   do i=1,nx
     do j=1,ny
       write(66,*) array(i,j)
       if(array(i,j).gt.fmax) fmax=array(i,j)
     enddo
   enddo
   write(66,*) fmax
!
! GRAPH ZZ'
   xx(1)=GLIM(4,1)
   yy(1)=GLIM(4,2)
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
   bref=vref/vl
   gref=1.D0/sqrt(1.D0-bref*bref)
   WREF=XMAT*(gref-1.D0)
   gcog=1.D0/sqrt(1.D0-bcog*bcog)
   WCOG=XMAT*(gcog-1.D0)
   WRITE(16,'(A,/,4x,A,e15.8,A,e15.8,A,/,4x,A,e15.8,A,e15.8,A,/)') &
    ' ***  LONGITUDINAL phase plane', &
    '  REFERENCE :  ENERGY: ',WREF,' (MeV), TOF: ',TREF,' (SEC)', &
    '  COG       :  ENERGY: ',WCOG,' (MeV), TOF: ',tcog,' (SEC)'
   if(rmsmtp.gt.teps) then
     WRITE(16,'(4x,A,e12.5,A,e12.5,A,/,6x,A,e12.5,A,A,e12.5,A)') &
      '  ELLIPSE BASED ON 2nd ORDER MOMENTS :',QMD,' (RD DP/P)**2    SURFACE : ', &
      SURM,' (DEG DP/P)','1/2 EXTENSION PHASE      : ',QDP,' RD ',' OR ',QDPDE, &
      ' DEG'
     WRITE(16,'(6x,A,E15.8,A,/,6x,A,E15.8,/,6x,A,E15.8,A,/,6x,A,e15.8,A)') & 
      '1/2 EXTENSION DISPERSION : ',QDISP,' IN DP/P ', &
      'CORRELATION COEF         : ',COR12, &
      'DISPERSION SLOPE         : ',PENT12,' (DP/P)/RD ', &
      'PHASE SLOPE              : ',PENT21,' (DP/P)/RD '
   endif
   enihrf=0.D0
! write histogrammed data to graphics file
   if (idwdp.eq.0) then
! Alvarez like
     zmin=fh*(f(6,1)-tcog)*180.D0/pi
     zmax=fh*(f(6,1)-tcog)*180.D0/pi
     zpmin=f(7,1)-encog
     zpmax=f(7,1)-encog
     do i=1,ngood
       xx(i)=fh*(f(6,i)-tcog)*180.D0/pi
       yy(i)=f(7,i)-encog
       if(xx(i).gt.zmax) zmax=xx(i)
       if(xx(i).lt.zmin) zmin=xx(i)
       if(yy(i).gt.zpmax) zpmax=yy(i)
       if(yy(i).lt.zpmin) zpmin=yy(i)
     enddo
   elseif(idwdp.eq.1) THEN
! IH like
     zmin=fh*(f(6,1)-tref)*180.D0/pi
     zmax=fh*(f(6,1)-tref)*180.D0/pi
     zpmin=f(7,1)-enihrf-xmat
     zpmax=f(7,1)-enihrf-xmat
     do i=1,ngood
       xx(i)=FH*(f(6,i)-tref)*180.D0/pi
       yy(i)=f(7,i)-enihrf-xmat
       if(xx(i).gt.zmax) zmax=xx(i)
       if(xx(i).lt.zmin) zmin=xx(i)
       if(yy(i).gt.zpmax) zpmax=yy(i)
       if(yy(i).lt.zpmin) zpmin=yy(i)
     enddo
   endif
   WRITE(66,*) zmin,zmax,zpmin,zpmax
! write particle coordinates to graphics file
!!!!********write histo data
   call hist2d(ngood,xx,yy,zmin,zmax,zpmin,zpmax,nx,ny,array)
   fmax=array(1,1)
   do i=1,nx
     do j=1,ny
!       write(66,*) i,j,array(i,j)
       write(66,*) array(i,j)
       if(array(i,j).gt.fmax) fmax=array(i,j)
     enddo
   enddo
   write(66,*) fmax
   if (igrprm.eq.2.or.igrprm.eq.3) then
!  restore limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         glim(j,k)=slim(j,k)
       enddo
     enddo
   endif
   tref=satref
   vref=savref
   deallocate(xx)   
   deallocate(yy)      
END SUBROUTINE ytzp2d
!> *******************************************************************
!! SUBROUTINE grcomp(text,iskale)
!! routine for plots
!< *******************************************************************
SUBROUTINE grcomp(text,iskale)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4plots
   USE m4STIS
   USE m4FENE
   USE m4histos
   USE mCOMzones
   IMPLICIT NONE
   INTEGER iskale,i,j,k
   REAL(8) slim(4,2)
   REAL(8), allocatable ::  xx(:),yy(:),cs(:)      
   REAL(8) bpai,gpai,DSTRLY,tcog,XLIX,XYLIZ,ZLIX,ZLIY
   INTEGER igrtyp
   character(len=80) :: text
!*******************************************************************
   if (.not. allocated(xx)) allocate(xx(iptsz))
   if (.not. allocated(yy)) allocate(yy(iptsz))
   if (.not. allocated(cs)) allocate(cs(iptsz))
   tcog=0.D0
   do i=1,ngood
     tcog=f(6,i)+tcog
   enddo
   tcog=tcog/DBLE(ngood)
   if (igrprm.eq.1) then
     text=patitl
   endif
   if (igrprm.eq.2) then
     text=patitl
!  save limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         slim(j,k)=glim(j,k)
         glim(j,k)=glim1(j,k)
       enddo
     enddo
   endif
   if (igrprm.eq.3) then
     text=patitl
!  save limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         slim(j,k)=glim(j,k)
         glim(j,k)=glim2(j,k)
       enddo
     enddo
   endif
   write(16,*)
   write(16,*) 'LIMITS',((GLIM(J,K), K=1,2), J=1,4)
! X-Z start
   XYLIZ=GLIM(4,1)*VREF*PI/(180.D0*fh)
   ZLIX=XYLIZ
   XLIX=GLIM(3,1)
   DSTRLY=GLIM(4,2)
!
! Store header and particle coordinates in binary file for
! graphics post-processor
!
! igrtyp is type of graph
!        igrtyp=2  for grcomp extra plots
!        igrtyp=7  for grcomp extra plots with multi charge state beam
!        igrtyp=12 for grcomp extra plots with ZONES card
   igrtyp=2
   if(nzone.ne.0) igrtyp=12
   if (imcs.eq.1)igrtyp=7
! igrtyp=2,7,12   --> normal scale in envelopes
! igrtyp=17,22,27 --> log    scale in envelopes
   if(iskale.eq.1) then
     WRITE(66,*) igrtyp+15
     write(66,*) dstrly
   else
     WRITE(66,*) igrtyp
   endif
   if (igrtyp.eq.7)then
     write(66,*) ncstat
     write(66,*) (cstat(j),j=1,ncstat)
   endif
   if (igrtyp.eq.12)then
     write(66,*) nzone
     write(66,*) (frms(j),j=2,nzone),' 0.'
   endif
   WRITE(66,*) text
   xx(1)=zlix
   yy(1)=xlix
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
   if (imcs.eq.1) then
     do i=1,ngood
       cs(i)=f(9,i)
     enddo
   endif
   if(idwdp.eq.0) then
! Alvarez type (plot w.r.t. reference)
     DO I=1,ngood
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       xx(i)=(tcog-f(6,i))*vl*bpai
       yy(i)=F(2,I)
     ENDDO
   else
! IH type (plot w.r.t. centre of gravity)
     DO I=1,ngood
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       xx(i)=(tref-f(6,i))*vl*bpai
       yy(i)=F(2,I)
     ENDDO
   endif
! write particle coordinates to graphics file
   WRITE(66,*) ngood
   if (imcs.eq.0) then
     if(nzone.eq.0) then
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i)
       enddo
     else
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i),f(10,i)
       enddo
     endif
   else
     do i=1,ngood
      WRITE(66,*) xx(i),yy(i),cs(i)
     enddo
   endif
! Y-Z start
   ZLIY=XYLIZ
   ZLIY=GLIM(3,2)
   xx(1)=zlix
   yy(1)=zliy
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
   if(idwdp.eq.0) then
! Alvarez type (plot w.r.t. reference)
     do i=1,ngood
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       xx(i)=(tcog-f(6,i))*vl*bpai
       yy(i)=F(4,I)
     enddo
   else
! IH type (plot w.r.t. centre of gravity)
     do i=1,ngood
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       xx(i)=(tref-f(6,i))*vl*bpai
       yy(i)=F(4,I)
     enddo
   endif
! write particle coordinates to graphics file
   WRITE(66,*) ngood
   if (imcs.eq.0) then
     if(nzone.eq.0) then
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i)
       enddo
     else
       do i=1,ngood
         WRITE(66,*) xx(i),yy(i),f(10,i)
       enddo
     endif
   else
     do i=1,ngood
      WRITE(66,*) xx(i),yy(i),cs(i)
     enddo
   endif
! beam profile plots for X,Y & Z
   call histgrm
   write(66,*) ixt
   do i=1,ixt
     write(66,*) xpos(i),xn(i)
   enddo
   write(66,*) iyt
   do i=1,iyt
     write(66,*) ypos(i),yn(i)
   enddo
   write(66,*) izt
   do i=1,izt
     write(66,*) zpos(i),zn(i)
   enddo
! beam profile plots for Xp,Yp & Zp
   write(66,*) ixpt
   do i=1,ixpt
     write(66,*) xps(i),xpn(i)
   enddo
   write(66,*) iypt
   do i=1,iypt
     write(66,*) yps(i),ypn(i)
   enddo
   write(66,*) izpt
   do i=1,izpt
     write(66,*) zps(i),zpn(i)
   enddo
   if (igrprm.eq.2.or.igrprm.eq.3) then
!  restore limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         glim(j,k)=slim(j,k)
       enddo
     enddo
   endif
   deallocate(xx)     
   deallocate(yy)     
   deallocate(cs)     
END SUBROUTINE grcomp
!> *******************************************************************
!! SUBROUTINE grcomp2d(text,iskale)
!! routine for plots
!< *******************************************************************
SUBROUTINE grcomp2d(text,iskale)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4plots
   USE m4STIS
   USE m4FENE
   USE m4histos
   USE sub4hist2d 
   IMPLICIT NONE
   INTEGER iskale,i,j,k,nx,ny
   REAL(8) slim(4,2)
   REAL(8), allocatable ::  xx(:),yy(:)   
   REAL(8) bpai,gpai,DSTRLY,tcog,XLIX,XYLIZ,ZLIX,ZLIY
   REAL(8) fmax,xmin,xmax,ymin,ymax,zmin,zmax
   INTEGER igrtyp
   character(len=80) :: text
   REAL(8) array(100,100)
!*******************************************************************
   if (.not. allocated(xx)) allocate(xx(iptsz))
   if (.not. allocated(yy)) allocate(yy(iptsz))
   tcog=0.D0
   do i=1,ngood
     tcog=f(6,i)+tcog
   enddo
   tcog=tcog/DBLE(ngood)
   if (igrprm.eq.1) then
     text=patitl
   endif
   if (igrprm.eq.2) then
     text=patitl
!  save limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         slim(j,k)=glim(j,k)
         glim(j,k)=glim1(j,k)
       enddo
     enddo
   endif
   if (igrprm.eq.3) then
     text=patitl
!  save limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         slim(j,k)=glim(j,k)
         glim(j,k)=glim2(j,k)
       enddo
     enddo
   endif
   write(16,*)
   write(16,*) 'LIMITS',((GLIM(J,K), K=1,2), J=1,4)
! X-Z start
   XYLIZ=GLIM(4,1)*VREF*PI/(180.D0*fh)
   ZLIX=XYLIZ
   XLIX=GLIM(3,1)
   DSTRLY=GLIM(4,2)
! igrtyp is type of graph
!        igrtyp=18  for grcompd extra plots
   igrtyp=18
! igrtyp=18   --> normal scale in envelopes
! igrtyp=19   --> log    scale in envelopes
   if(iskale.eq.1) then
     WRITE(66,*) igrtyp+1
     write(66,*) dstrly
   else
     WRITE(66,*) igrtyp
   endif
   WRITE(66,*) text
   xx(1)=zlix
   yy(1)=xlix
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
   xmin=F(2,1)
   xmax=F(2,1)
   if(idwdp.eq.0) then
! Alvarez type (plot w.r.t. reference)
     gpai=f(7,1)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     zmin=(tcog-f(6,1))*vl*bpai
     zmax=(tcog-f(6,1))*vl*bpai
     DO I=1,ngood
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       xx(i)=(tcog-f(6,i))*vl*bpai
       if(xx(i).gt.zmax) zmax=xx(i)
       if(xx(i).lt.zmin) zmin=xx(i)
       yy(i)=F(2,I)
       if(yy(i).gt.xmax) xmax=yy(i)
       if(yy(i).lt.xmin) xmin=yy(i)
     ENDDO
   else
! IH type (plot w.r.t. centre of gravity)
     gpai=f(7,1)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     zmin=(tref-f(6,1))*vl*bpai
     zmax=(tref-f(6,1))*vl*bpai
     DO I=1,ngood
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       xx(i)=(tref-f(6,i))*vl*bpai
       if(xx(i).gt.zmax) zmax=xx(i)
       if(xx(i).lt.zmin) zmin=xx(i)
       yy(i)=F(2,I)
       if(yy(i).gt.xmax) xmax=yy(i)
       if(yy(i).lt.xmin) xmin=yy(i)
     ENDDO
   endif
   WRITE(66,*) zmin,zmax,xmin,xmax
   nx=20
   ny=20
! write histogrammed data to graphics file
   WRITE(66,*) ngood,nx,ny
!!!!********write histo data
   call hist2d(ngood,xx,yy,zmin,zmax,xmin,xmax,nx,ny,array)
   fmax=array(1,1)
   do i=1,nx
     do j=1,ny
       write(66,*) array(i,j)
       if(array(i,j).gt.fmax) fmax=array(i,j)
     enddo
   enddo
   write(66,*) fmax
! Y-Z start
   ZLIY=XYLIZ
   ZLIY=GLIM(3,2)
   xx(1)=zlix
   yy(1)=zliy
   WRITE(66,*) -xx(1),xx(1),-yy(1),yy(1)
   ymin=F(4,1)
   ymax=F(4,1)
   if(idwdp.eq.0) then
! Alvarez type (plot w.r.t. reference)
     do i=1,ngood
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       xx(i)=(tcog-f(6,i))*vl*bpai
       yy(i)=F(4,I)
       if(yy(i).gt.ymax) ymax=yy(i)
       if(yy(i).lt.ymin) ymin=yy(i)
     enddo
   else
! IH type (plot w.r.t. centre of gravity)
     do i=1,ngood
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       xx(i)=(tref-f(6,i))*vl*bpai
       yy(i)=F(4,I)
       if(yy(i).gt.ymax) ymax=yy(i)
       if(yy(i).lt.ymin) ymin=yy(i)
     enddo
   endif
   WRITE(66,*) zmin,zmax,ymin,ymax
!!!!********write histo data
   call hist2d(ngood,xx,yy,zmin,zmax,ymin,ymax,nx,ny,array)
   fmax=array(1,1)
   do i=1,nx
     do j=1,ny
!       write(66,*) i,j,array(i,j)
       write(66,*) array(i,j)
       if(array(i,j).gt.fmax) fmax=array(i,j)
     enddo
   enddo
   write(66,*) fmax
! beam profile plots for X,Y & Z
   call histgrm
   write(66,*) ixt
   do i=1,ixt
     write(66,*) xpos(i),xn(i)
   enddo
   write(66,*) iyt
   do i=1,iyt
     write(66,*) ypos(i),yn(i)
   enddo
   write(66,*) izt
   do i=1,izt
     write(66,*) zpos(i),zn(i)
   enddo
! beam profile plots for Xp,Yp & Zp
   write(66,*) ixpt
   do i=1,ixpt
     write(66,*) xps(i),xpn(i)
   enddo
   write(66,*) iypt
   do i=1,iypt
     write(66,*) yps(i),ypn(i)
   enddo
   write(66,*) izpt
   do i=1,izpt
     write(66,*) zps(i),zpn(i)
   enddo
   if (igrprm.eq.2.or.igrprm.eq.3) then
!  restore limits in GLIM(j,k)
     do j=1,4
       do k=1,2
         glim(j,k)=slim(j,k)
       enddo
     enddo
   endif
   deallocate(xx)     
   deallocate(yy)     
END SUBROUTINE grcomp2d
!> *******************************************************************
!! SUBROUTINE profil
!! Store header and envelopes in a binary file for
!! graphics post-processor
!< *******************************************************************
SUBROUTINE profil
   USE m4input
   USE mCOMdplt
   IMPLICIT NONE
!*******************************************************************
   CALL PLPRF1
   CALL PLPRF2
END SUBROUTINE profil
!> *******************************************************************
!! SUBROUTINE plprf1
!!     IPRF  : POINTEUR
!!     RMSN  :envelope size in multiples of RMS size
!!     SPRFX :half horizontal extent (cm)
!!     SPRFY :half vertical extent (cm)
!!     SPRFW :half energy extent (MeV)
!!     SPRFP :half phase extent    (deg)
!!     SPRFL :position along Z(m)
!!     ZDEB : Starting position of the plot
!!     ZFIN : End of the plot
!< *******************************************************************
SUBROUTINE plprf1
   USE m4plots
   USE m4input
   USE mCOMdplt
   USE mCOMprof
   IMPLICIT NONE
   REAL(8) XXMAX,XYMAX
   INTEGER i,IDEB,IFIN,icnt,igrtyp
   REAL(8) xx(3000),yy(3000)
   character(len=80) :: text
!*******************************************************************
   READ(IN,'(A80)')CAR(1:80)
   READ(IN,*) RMSN
   READ(IN,*) ZDEB,ZFIN
   READ(IN,*) XXMAX,XYMAX,YWMAX,YPMAX
   IPRF=IPRF-1
   IDEB=1
   IFIN=IPRF
   IF(ZFIN.GT.SPRFL(IPRF))ZFIN=SPRFL(IPRF)
   write(16,*) ' Envelope related parameters:'
   write(16,*) ' IPRF ZFIN ',iprf,zfin
   DO I=2,IPRF
     IF((ZDEB.GT.SPRFL(I-1)).AND.(ZDEB.LE.SPRFL(I)))IDEB=I
     IF((ZFIN.GE.SPRFL(I-1)).AND.(ZFIN.LT.SPRFL(I)))IFIN=I-1
   ENDDO
   if (xxmax.le. 0.D0) then
     XXMAX=0.D0
     DO I=IDEB,IFIN
!2022FIX needed due to common removal
!           IF(0.5D0*SPRFY(I)*RMSN .GT. XXMAX) XXMAX=0.5D0*SPRFY(I)*RMSN
       IF(0.5D0*SPRFX(I)*RMSN .GT. XXMAX) XXMAX=0.5D0*SPRFX(I)*RMSN
     ENDDO
   endif
   if (xymax.le. 0.D0) then
     XYMAX=0.D0
     DO I=IDEB,IFIN
!2022FIX needed due to common removal
!           IF(0.5D0*SPRFZ(I)*RMSN.GT.XYMAX) XYMAX=0.5D0*SPRFZ(I)*RMSN
       IF(0.5D0*SPRFY(I)*RMSN.GT.XYMAX) XYMAX=0.5D0*SPRFY(I)*RMSN
     ENDDO
   endif
! Store header and envelopes in binary file for
! graphics post-processor
!
! igrtyp is type of graph (igrtyp=3 for x,y envelope plots)
   igrtyp=3
   text='X and Y envelopes   '
   text(21:80)=car(1:60)
   WRITE(66,*) igrtyp
   WRITE(66,*) text
   xx(1)=zdeb
   xx(2)=zfin
   yy(1)=-xymax
   yy(2)=xxmax
   write(16,*) ' XMAX YMAX ',xxmax,xymax
   WRITE(66,*) xx(1),xx(2),yy(1),yy(2)
!   GRADX=XXMAX/3.
!   YFAXE=XXMAX
   icnt=0
   DO I=IDEB,IFIN
     icnt=icnt+1
     xx(icnt)=sprfl(i)
!2022FIX needed due to common removal
!     yy(icnt)=0.5D0*sprfy(i)*RMSN
     yy(icnt)=0.5D0*sprfx(i)*RMSN
   ENDDO
! write envelope coordinates to graphics file
   WRITE(66,*) icnt
   DO I=1,icnt
     WRITE(66,*) xx(i),yy(i)
   ENDDO
   icnt=0
   DO I=IDEB,IFIN
     icnt=icnt+1
     xx(icnt)=sprfl(i)
!2022FIX needed due to common removal
!     yy(icnt)=-0.5D0*sprfz(i)*RMSN
     yy(icnt)=-0.5D0*sprfy(i)*RMSN
   ENDDO
! write envelope coordinates to graphics file
   WRITE(66,*) icnt
   DO I=1,icnt
     WRITE(66,*) xx(i),yy(i)
   ENDDO
END SUBROUTINE plprf1
!> *******************************************************************
!! SUBROUTINE plprf2
!! Store header and envelopes in binary file for
!! graphics post-processor
!< *******************************************************************
SUBROUTINE plprf2
   USE m4plots
   USE m4input
   USE mCOMdplt
   USE mCOMprof
   IMPLICIT NONE
   REAL(8) XXMAX,XYMAX
   INTEGER i,IDEB,IFIN,icnt,igrtyp
   REAL(8) xx(3000),yy(3000)
   character(len=80) :: text
!*******************************************************************
   IDEB=1
   IFIN=IPRF
   DO I=2,IPRF
     IF((ZDEB.GT.SPRFL(I-1)).AND.(ZDEB.LE.SPRFL(I)))IDEB=I
     IF((ZFIN.GE.SPRFL(I-1)).AND.(ZFIN.LT.SPRFL(I)))IFIN=I-1
   ENDDO
   xxmax=ywmax/1000.D0
   xymax=ypmax
   if (xxmax.le. 0.D0) then
     XXMAX=0.D0
     DO I=IDEB,IFIN
       IF(0.5D0*SPRFW(I)*RMSN.GT.XXMAX) XXMAX=0.5D0*SPRFW(I)*RMSN
     ENDDO
   endif
   if (xymax.le. 0.D0) then
     XYMAX=0.D0
     DO I=IDEB,IFIN
       IF(0.5D0*SPRFP(I)*RMSN.GT.XYMAX) XYMAX=0.5D0*SPRFP(I)*RMSN
     ENDDO
   endif
! Store header and envelopes in binary file for
! graphics post-processor
!
! igrtyp is type of graph (igrtyp=4 for dW/W envelope plots)
   igrtyp=4
   text='dW/W envelope       '
   text(21:80)=car(1:60)
   WRITE(66,*) igrtyp
   WRITE(66,*) text
   xx(1)=zdeb
   xx(2)=zfin
   yy(1)=0.D0
   yy(2)=xxmax*1000.D0
   WRITE(66,*) xx(1),xx(2),yy(1),yy(2)
   icnt=0
   DO I=IDEB,IFIN
     icnt=icnt+1
     xx(icnt)=sprfl(i)
     yy(icnt)=0.5D0*sprfw(i)*1000.D0*RMSN
   ENDDO
! write envelope coordinates to graphics file
   WRITE(66,*) icnt
   DO I=1,icnt
     WRITE(66,*) xx(i),yy(i)
   ENDDO
! Store header and envelopes in binary file for
! graphics post-processor
!
! igrtyp is type of graph (igrtyp=5 for dPHI envelope plots)
   igrtyp=5
   text='dPHI envelope       '
   text(21:80)=car(1:60)
   WRITE(66,*) igrtyp
   WRITE(66,*) text
   xx(1)=zdeb
   xx(2)=zfin
   yy(1)=0.D0
   yy(2)=xymax
   write(16,*) ' dW/WMAX dPhiMAX ',xxmax,xymax
   WRITE(66,*) xx(1),xx(2),yy(1),yy(2)
   icnt=0
   DO I=IDEB,IFIN
     icnt=icnt+1
     xx(icnt)=sprfl(i)
     yy(icnt)=0.5D0*sprfp(i)*RMSN
   ENDDO
! write envelope coordinates to graphics file
   WRITE(66,*) icnt
   DO I=1,icnt
     WRITE(66,*) xx(i),yy(i)
   ENDDO
   IPRF=IPRF+1
END SUBROUTINE plprf2
!> *******************************************************************
!! SUBROUTINE area(init)
!! selection of the regions in the space x/a, y/b and z/c. The values
!! a,b and c are the RMS of the bunch in the space x, y, and z
!! The particles lying in any one region are affected with the same
!! color.
!< *******************************************************************
SUBROUTINE area(init)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4plots
   USE m4prtcls, ONLY: xc,yc,zc
   USE mCOMzones
   REAL(8) trmoy,vnp,gnp,f3,f5,xbar,ybar,zbar,eng,xcj,ycj,zcj
   REAL(8) xrmsz,yrmsz,zrmsz,xcp,ycp,zcp,rxyz,xsqsum,ysqsum,zsqsum
   INTEGER i
   dimension inzonn(6)
!*******************************************************************
   if (.not. allocated(xc)) allocate(xc(iptsz))
   if (.not. allocated(yc)) allocate(yc(iptsz))
   if (.not. allocated(zc)) allocate(zc(iptsz))
   if(init.eq.1) then
!  set to -1. the last column of the table f(10,iptsz)
     do i=1,ngood
       f(10,i)=-1.D0
     enddo
! read: ityp and nzone; the number of regions
!       ityp=0, the zones are defined in the 3-d space (x/a,y/b,z/c)
!       ityp=1, the zones are defined in the plane (x/a,y/b)
     read(in,*) ityp,nzone
     write(16,*)'Number of zones selected:',nzone
     if(nzone.gt.5) then
       write(16,*) 'Number of zones is greater than 5, namely ',nzone
       stop
     endif
! The regions are selected in the space x/xrms,y/yrms and z/zrms
! limits of the zones ; read the upper limits of the regions
     frms(1)=0.D0
     if(nzone.ne.0) then
       read(in,*) (frms(i), i=2,nzone)
       frms(nzone+1)=100.D0
       do i=1,nzone
         write(16,*) 'Zone: ',i,' lower limit: ',frms(i), &
                   ' upper limit:',frms(i+1)
       enddo
     else
       read(in,*) frms(2)
     endif
   endif
   if(nzone.ge.2) then
     trmoy=0.D0
     do i=1,ngood
       trmoy=trmoy+f(6,i)
     enddo
     trmoy=trmoy/DBLE(ngood)
     xbar=0.D0
     ybar=0.D0
     zbar=0.D0
     imaxx=0
!   Divide by 100. to convert from centimeters to meters
     do np=1,ngood
       gnp=f(7,np)/xmat
       vnp=vl*sqrt(1.D0-1.D0/(gnp*gnp))
       zc(np)=(trmoy-f(6,np))*vnp
!   convert from mrad to rad
       f3=f(3,np)*1.D-03
       f5=f(5,np)*1.D-03
!   convert from cm   to m
       xc(np)=(f(2,np)+zc(np)*f3)/100.D0
       yc(np)=(f(4,np)+zc(np)*f5)/100.D0
       zc(np)=zc(np)/100.D0
! evaluate xbar , ybar , zbar
       xbar=xbar+xc(np)
       ybar=ybar+yc(np)
       zbar=zbar+zc(np)
     enddo
     eng=DBLE(ngood)
     xbar=xbar/eng
     ybar=ybar/eng
     zbar=zbar/eng
     do np=1,ngood
       xc(np)=xc(np)-xbar
       yc(np)=yc(np)-ybar
       zc(np)=zc(np)-zbar
     enddo
!evaluate the rms sizes
     xsqsum=0.D0
     ysqsum=0.D0
     zsqsum=0.D0
     do j=1,ngood
       xcj=xc(j)
       ycj=yc(j)
       zcj=zc(j)
       xsqsum=xsqsum+xcj*xcj
       ysqsum=ysqsum+ycj*ycj
       zsqsum=zsqsum+zcj*zcj
     enddo
     xrmsz=xsqsum/DBLE(ngood)
     yrmsz=ysqsum/DBLE(ngood)
     zrmsz=zsqsum/DBLE(ngood)
     xrmsz=sqrt(xrmsz)
     yrmsz=sqrt(yrmsz)
     zrmsz=sqrt(zrmsz)
!  select the particles in the regions and count them
     if(ityp.eq.0) then
!       ityp=0, the zones are defined in the 3-d space (x/a,y/b,z/c)
       do i=1,nzone
         inzonn(i)=0
         do j=1,ngood
           xcp=xc(j)/xrmsz
           ycp=yc(j)/yrmsz
           zcp=zc(j)/zrmsz
           rxyz=sqrt((xcp*xcp+ycp*ycp+zcp*zcp)/3.D0)
           if(rxyz.lt.frms(i+1).and.rxyz.ge.frms(i)) then
             inzonn(i)=inzonn(i)+1
             if(init.eq.1) f(10,j)=frms(i+1)
           endif
!           if(f(10,j).eq.100. .and. init.eq.1) f(10,j)=0.D0
           if(abs(f(10,j)-100.D0).le.fprec .and. init.eq.1) f(10,j)=0.D0
         enddo
         if(init.eq.1) then
           write(16,*) inzonn(i),' particles initially in zone ',i
         else
           write(16,*) inzonn(i),' particles in zone ',i
         endif
       enddo
     else
!      ityp=1, the zones are defined in the plane (x/a,y/b)
       do i=1,nzone
         inzonn(i)=0
         do j=1,ngood
           xcp=xc(j)/xrmsz
           ycp=yc(j)/yrmsz
           zcp=zc(j)/zrmsz
           rxyz=sqrt((xcp*xcp+ycp*ycp)/2.D0)
           if(rxyz.lt.frms(i+1).and.rxyz.ge.frms(i)) then
             inzonn(i)=inzonn(i)+1
             if(init.eq.1) f(10,j)=frms(i+1)
           endif
!           if(f(10,j).eq.100. .and. init.eq.1) f(10,j)=0.
           if(abs(f(10,j)-100.D0).le.fprec .and. init.eq.1) f(10,j)=0.D0
         enddo
         if(init.eq.1) then
           write(16,*) inzonn(i),' particles initially in zone ',i
         else
           write(16,*) inzonn(i),' particles in zone ',i
         endif
       enddo
     endif
     deallocate(xc)
     deallocate(yc)
     deallocate(zc)
   endif
END SUBROUTINE area
!*********************************************************************
! Supporting routines for beam line elements start here
!*********************************************************************
!
!> *******************************************************************
!! SUBROUTINE boucle(ipas,gamref,saphi,dcum,delphr)
!! RESTAY or ETGAP ==> GAP ==> BOUCLE
!! compute the dynamics of the fictitious reference and of particles
!< *******************************************************************
SUBROUTINE boucle(ipas,gamref,saphi,dcum,delphr)
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4cavs2
   USE m4gap
   USE m4gap2
   USE m4gapiter
   USE m4cavsc
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE fun4cavscmc, ONLY: gamci 
   USE m4gaprestay
   USE m4RESTAYfun, ONLY: YLG
   USE m4restayMIDGAP
   USE m4FENE
   USE m4ITVOLE, ONLY: ttvols
   USE m4wforsc, ONLY: DWP
   USE m4prtcls, ONLY: FS
   USE mCOMtranrs
   USE mCOMblvl
   USE mCOMttfcb
   IMPLICIT NONE
   REAL(8) gamref,saphi,dcum,delphr
   REAL(8) A11,A12,A21,A22,AMORT
   REAL(8) bcog,BECR,beini,BEKK0,BEMPY,beref,BESOR,BETPS,CETF,CETF1,CETI,CETM
   REAL(8) CFV1,CFV2,cort,cort1,CXV1,CXV2,DBEK21,DDWP,DELGAM,DELPHI,DELSC,DET,DETRE
   REAL(8) DFTIL,dispr,DITEMP,DPHCI0,DRADIU,DTS,CXLG,DWCI,DWPI,DXDPI,DXDPT,DXDTE
   REAL(8) DXKI0,ENPMT,ENRC,ENRPRIN,F0,F1,F2,f6dg,f6i,FTIL,FXT1,FXT2,FXT3,FXT4
   REAL(8) GACR,GAMKK0,GAMPS,GAMSOR,gcog,gini,GX,PCRESI,PHASE,PHITSI,PHITTI,PHSLIL
   REAL(8) r1,RADIU,RP,RPP,RRP,RRPP,S1KC,S2KC,S3KC,S4KC,SAA11,SAA12,SAA21,SAA22
   REAL(8) SAUPHC,SKC,STTA11,STTA12,STTA21,STTA22,SV1,SV2,SXV1,SXV2,T11,T12,T21,T22
   REAL(8) T1KC,T2KC,T3KC,T4KC,tcog,TEGL,TEGL1,TEGL2,TIL2,TILTAL,TKC,TMA,ttvol
   REAL(8) V1,V2,VR11,VR12,VR21,VR22,XI0,XI1,XI2,XIE01,XIE02,XIE0I,XIE11,XIE12,XIE1I
   REAL(8) XIE21,XIE22,XIE2I,XJF0I,XJF1I,XJF2I,XK2I,XLH01,XLH02,XLH0I,XLH11,XLH112
   REAL(8) XLH113,XLH1I,XLH21,XLH212,XLH213,XLP11,XLP12,XLP21,XLP22,XLP1I,XLP2I
   REAL(8) XLREI,XMN0I,XMN1I,XMN2I,XQ0,XQ01,XQ1,XQ12,XQ2,XV1,XV2,ZA,ZB,ZC,ZD
   REAL(8) vphasi,wcg,FH0
   INTEGER i,IIII,ijk,istc,len             
   INTEGER ipas,istm
!  TRANSIT TIME COEFFICIENTS
!   COMMON/TTFCB/T3K,T4K,S3K,S4K
!   COMMON/TYPL1/YH1K0,YH1K1,YP1K1,YP1K2,YH1K00,YH1K01,YP1K01, &
!   COMMON/TYPL2/YH2K0,YH2K1,YP2K1,YP2K2,YH2K00,YH2K01,YP2K01, &
!   COMMON/TYPI1/YE1K0,YE1K1,YE1K2,YE1KC0,YE1KC1,YE1KC2, &
!   COMMON/TYPI2/YE2K0,YE2K1,YE2K2,YE2KC0,YE2KC1,YE2KC2, &
!   COMMON/THAD2/H0AKI,H0AKIM,H0AKM,H0BKI,H0BKIM,H0BKM, &
! --- routine XTYPLP1
!   COMMON/TYPLP1/YH1P1,YH2P1,HAPI,HBPI
! --- routine XTYPL2
!   COMMON/TYPLP2/HAPPI,HBPPI
! --- routine XTYLPK
!   COMMON/TYPLPK/YH10PK,YH11PK,YH20PK,YH21PK
!     integrals of E(z)**2
! --- routine XTYPJ
!   COMMON/TYPJ/YFSK0,YFSK1,YFSK2,YFSP0,YFSP1,YFSP2, &
!     E(z)**2 INTEGRALS (COMPLEMENTARY ELECTRIC FIELD)
! --- routine XTYPM
!   COMMON/TYPM/YNSK0,YNSK1,YNSK2,YNSP0,YNSP1,YNSP2, &
!
!   common/tcav/SV1P(iptsz),SV2P(iptsz),SXV1P(iptsz),SXV2P(iptsz), &
!         DWCIS(iptsz),BEINI1(iptsz),PHIP(iptsz), &
!         TEGLP(iptsz),DXDPIP(iptsz),DXDKIP(iptsz), &
!         DXDPTP(iptsz),DXK00P(iptsz),DPHIIP(iptsz),sauphcs(iptsz)
   REAL(8), allocatable :: SV1P(:),SV2P(:),SXV1P(:),SXV2P(:), &
         DWCIS(:),BEINI1(:),PHIP(:),TEGLP(:),DXDPIP(:),DXDKIP(:), &
         DXDPTP(:),DXK00P(:),DPHIIP(:),sauphcs(:) 
   REAL(8) vecx(1)
   character(len=8) :: PRTLAB
   INTEGER, allocatable ::  lossreason(:)   
!*********************************************************************
   if (.not. allocated(DWP))        allocate(DWP(iptsz))   
   if (.not. allocated(lossreason)) allocate(lossreason(iptsz))
   if (.not. allocated(SV1P))       allocate(SV1P(iptsz))
   if (.not. allocated(SV2P))       allocate(SV2P(iptsz))
   if (.not. allocated(SXV1P))      allocate(SXV1P(iptsz))
   if (.not. allocated(SXV2P))      allocate(SXV2P(iptsz))
   if (.not. allocated(DWCIS))      allocate(DWCIS(iptsz))
   if (.not. allocated(BEINI1))     allocate(BEINI1(iptsz))
   if (.not. allocated(PHIP))       allocate(PHIP(iptsz))
   if (.not. allocated(TEGLP))      allocate(TEGLP(iptsz))
   if (.not. allocated(DXDPIP))     allocate(DXDPIP(iptsz))
   if (.not. allocated(DXDKIP))     allocate(DXDKIP(iptsz))
   if (.not. allocated(DXDPTP))     allocate(DXDPTP(iptsz))
   if (.not. allocated(DXK00P))     allocate(DXK00P(iptsz))
   if (.not. allocated(DPHIIP))     allocate(DPHIIP(iptsz))
   if (.not. allocated(sauphcs))    allocate(sauphcs(iptsz))
! lossreason= -2 --> energy
! lossreason= -1 --> phase
! lossreason=  0 --> not lost
! lossreason=  1 --> radius
! lossreason=  2 --> x position
! lossreason=  3 --> y position
   PRTLAB='CAV     '
   ttvol=ttvols*fh
   FH0=FH/VL
   beref=sqrt(1.D0-1.D0/(gamref*gamref))
   call cogetc
   tcog=0.D0
   gcog=0.D0
   do i=1,ngood
     gcog=gcog+f(7,i)/xmat
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   gcog=gcog/DBLE(ngood)
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   wcg=(gcog-1.D0)*xmat
! ----- convert wdisp in dp/p (window control)
! ---- ifw = 0  ===> wdisp = dW/W, where this is w.r.t. the COG
! ---- ifw = 1  ===> wdisp = dW (MeV), where this is w.r.t. the COG
! ---- ifw = 10 ===> wdisp = dW/W, where this is w.r.t. the reference
! ---- ifw = 11 ===> wdisp = dW (MeV), where this is w.r.t. the reference
! ----- convert wdisp in dp/p
   if(ifw.eq.0) dispr=gcog*gcog*wdisp/(gcog*(gcog+1.D0))
   if(ifw.eq.1) dispr=gcog*gcog*wdisp/(gcog*(gcog+1.D0)*wcg)
   if(ifw.eq.10)dispr=gamref*gamref*wdisp/(gamref*(gamref+1.D0))
   if(ifw.eq.11)dispr=gamref*gamref*wdisp/(gamref*(gamref+1.D0)*wcg)

   DO I=1,ngood
     IF(I.EQ.ICONT) THEN
       WRITE(16,*)'******************************************'
       IF(IPAS.EQ.1) &
           WRITE(16,*) '*** FOLLOWED PARTICLE NUMBER: ',I,' AT SPACE CHARGE POSITION'
       IF(IPAS.EQ.2) WRITE(16,*) '*** FOLLOWED PARTICLE NUMBER: ',I,' AT OUTPUT '
       WRITE(16,*)'******************************************'
     ENDIF
     if(iavp) then
       gini=f(7,i)/xmat
       beini=sqrt(1.D0-1.D0/(gini*gini))
       fd(i)=(gini*beini)/(gcog*bcog)
       f6i=0.D0
       do istc=1,netac
!         if(int(f(9,i)).eq.int(charm(istc))) &
!         if(f(9,i).eq.charm(istc)) &
         if(abs(f(9,i)-charm(istc)).le.fprec) &
          f6i=f(6,i)-cgtdv(istc)
       enddo
!   LONGITUDINAL WINDOW CONTROL
       if(fh*abs(f6i).ge.wphas) then
         f(8,i)=0.D0
         lossreason(i)=-1
       endif
       IF(ABS(FD(I)-1.D0).GE.DISPR) then
         f(8,i)=0.D0
         lossreason(i)=-2
       endif
!   TRANSVERSE WINDOW CONTROL
       RADIU=SQRT(F(2,I)*F(2,I)+F(4,I)*F(4,I))
       if(RADIU.gt.rlim) then
         f(8,i)=0.D0
         lossreason(i)=1
       endif
       if(abs(f(2,i)).gt.wx) then
         f(8,i)=0.D0
         lossreason(i)=2
       endif
       if(abs(f(4,i)).gt.wy) then
         f(8,i)=0.D0
         lossreason(i)=3
       endif
       if(int(f(8,i)).eq.0) then
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,A25)') &
         PRTLAB,NRRES,davtot/100.D0,i,int(f(1,i)), &
         f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180.D0/pi,f(7,i)-xmat, &
         f(9,i),lossreason(i),uden
         ilost=ilost+1
         if(ilost.ge.ngood) stop
         cycle
       endif
!   COMPUTATION OF AVERAGE K AND JUMP OF PHASE FOR THE CELL
!  START IF BLOCK on ICONT
       IF(I.EQ.ICONT) THEN
         WRITE(16,'(1x,A,2(/,1x,A,e12.5,A,e12.5,A))') &
           '* INPUT OF THE ELEMENT: ', &
           '* X :',F(2,I),' CM  XP :',F(3,I),' MRD', &
           '* Y :',F(4,I),' CM  YP: ',F(5,I),' MRD'
          f6dg=fh*f(6,i)*180.D0/pi
         WRITE(16,*)'* TOF(deg): ',f6dg,' ENERGY(MeV) ',f(7,i)-xmat
       ENDIF
       RADIU=SQRT(F(2,I)*F(2,I)+F(4,I)*F(4,I))
       IF(RADIU.LT.1.D-06) THEN
         DRADIU=.001D0*SQRT(F(3,I)*F(3,I)+F(5,I)*F(5,I))
       ELSE
         DRADIU=F(3,I)*.001D0*F(2,I)/RADIU+F(4,I)*F(5,I)*.001D0/RADIU
       ENDIF
! --- retph: phase delay between the actual particle  and the reference
       RETPH=FH*(f(6,i)-TREF)
! --- systematic or random defaults on the phase RF (not for the reference)
       if(ierpf.ne.0) then
         vphasi=vphase*pi/180.D0
! --- systematic default on the phase offset
         if(ierpf.eq.1) retph=retph+vphasi
! --- random error on  phase offset
         if(ierpf.gt.1) then
           len=1
           call rlux(vecx,len)
           r1=(2.D0*vecx(1)-1.D0)*vphasi
           retph=retph+r1
         endif
       endif
       PHI=SAPHI+RETPH
       IF(I.EQ.ICONT) write(16,*) &
        '* PHASE DELAY RELATIVE TO REFERENCE ',retph*180.D0/pi,' DEG'
! --- the TTF are the ones of the reference particle based on the charge state qst (input)
! ---  They are corrected in order to take into account the charge state of the current particle
! ****       cort=-(1.D0-(qst/f(9,i)))
       cort=0.D0
       TKC=TK*cort+TK
       T1KC=T1K*cort+T1K
       T2KC=T2K*cort+T2k
       T3KC=T3K*cort+T3k
       T4KC=T4K*cort+T4k
       SKC=SK*cort+SK
       S1KC=S1K*cort+S1K
       S2KC=S2K*cort+S2K
       S3KC=S3K*cort+S3K
       S4KC=S4K*cort+S4K
!   cort1=qst/f(9,i)
       cort1=1.D0
! ************************************
!   Predictor
       PHASE=PHI
!  DXKI0 : difference of energy betwen the reference and the actual particle
       DXKI0=FH0*(1.D0/BEINI-1.D0/BEREF)
       DXDTE=DXKI0
       TKE=TKC+DXDTE*T1KC+DXDTE*DXDTE*T2KC/2.D0+DXDTE**3*T3KC/6.D0+ &
       DXDTE**4*T4KC/24.D0
       SKE=SKC+DXDTE*S1KC+DXDTE*DXDTE*S2KC/2.D0+DXDTE**3*S3KC/6.D0+ &
       DXDTE**4*S4KC/24.D0
!  ******************************************
! --- systematic or random defaults on the field level (not for the reference)
       if(ierpf.ne.0) then
         if(ierpf.eq.1) then
           TKE=TKE*(1.D0+vfield)
           SKE=SKE*(1.D0+vfield)
         endif
         if(ierpf.gt.1) then
           len=1
           call rlux(vecx,len)
           r1=(2.D0*vecx(1)-1.D0)*vfield
           TKE=TKE*(1.D0+r1)
           SKE=SKE*(1.D0+r1)
         endif
       endif
       PHIWC=PHI+PAVPH
! *****************************************************
       DDWP=abs(f(9,i))*(TKE*COS(PHIWC)-SKE*SIN(PHIWC))
       ENPMT=f(7,i)+DDWP
       GAMPS=ENPMT/XMAT
       if(gamps.le.1.D0) f(8,i)=0.D0
       if(int(f(8,i)).eq.0) then
         ilost=ilost+1
         if(ilost.ge.ngood) stop
         cycle
       endif
       BETPS=SQRT(1.D0-1.D0/(GAMPS*GAMPS))
       XK1II=FH0/BEINI
       XK2II=FH0/BETPS
       XKMI=XK2II+(XK2II-XK1II)*ASDL/EQVL + DELPHR/EQVL
       XK1I=XK1II-XKMI
       XK2I=XK2II-XKMI
       BEMPY=FH0/XKMI
       SAUPHC=DELPHR
       DXDKI=XKMI-XKM
       DPHII=(XK1II-XK2II)*EQVL/10.D0+(XKP1+XKP2)/120.D0*EQVL**2 &
            + XK1I*ASDL
       DO IJK=1,3
! --- boucle IJK to improve  TTF
         TKE=TKC+DXDKI*T1KC+DXDKI*DXDKI*T2KC/2.D0+DXDKI**3*T3KC/6.D0+ &
             DXDKI**4*T4KC/24.D0
         T1KE=T1KC+DXDKI*T2KC+DXDKI*DXDKI*T3KC/2.D0+DXDKI**3*T4KC/6.D0
         SKE=SKC+DXDKI*S1KC+DXDKI*DXDKI*S2KC/2.D0+DXDKI**3*S3KC/6.D0+ &
             DXDKI**4*S4KC/24.D0
         S1KE=S1KC+DXDKI*S2KC+DXDKI*DXDKI*S3KC/2.D0+DXDKI**3*S4KC/6.D0
! **********************************************************
! --- systematic or random defaults on the field level (not for the reference)
         if(ierpf.eq.1) then
           TKE=TKE*(1.D0+vfield)
           SKE=SKE*(1.D0+vfield)
           T1KE=T1KE*(1.D0+vfield)
           S1KE=S1KE*(1.D0+vfield)
         endif
         if(ierpf.gt.1) then
           len=1
           call rlux(vecx,len)
           r1=(2.D0*vecx(1)-1.D0)*vfield
           TKE=TKE*(1.D0+r1)
           SKE=SKE*(1.D0+r1)
           T1KE=T1KE*(1.D0+r1)
           S1KE=S1KE*(1.D0+r1)
         endif
         PCRESI=0.D0
         DPHCI0=0.D0
!         if(f(9,i).ne.qst) then
! --- new crest phase is PCRESI
!cc              PCRESI=ATAN(-SKE/TKE)
!cc              DDWC=abs(f(9,i))*(TKE*COS(PCRESI)-SKE*SIN(PCRESI))
!cc              IF(DDWC.lt. 0.D0) PCRESI=PCRESI+PI
! --- DPHCI0 is the difference between the previous crest phase and the present one
!cc              DPHCI0=PCREST-PCRESI
!             endif
         PHIWC=PHI+DPHII
! ***********************************
         DWCI=abs(f(9,i))*(TKE*COS(PHIWC)-SKE*SIN(PHIWC))
         ENRC=f(7,i)+DWCI
         GACR=ENRC/XMAT
         if(GACR.lt.1D0) then
           GACR=1.0000001D0
           BECR=0.000001D0
         else
           BECR=SQRT(1.D0-1.D0/(GACR*GACR))
         endif           
         XK2II=FH0/BECR
         CXLG=abs(f(9,i))/(4.D0*XMAT*EQVL)
         DXDPI=RETPH-DPHCI0
! --- see Part. Acc., 1994, vol 44., pp. 215-255
! ----     relation 86
         DXDPT=DXDPI+DXK00*(1.D0-DKMSKE)*ASDL-DXDPI*DKMSPHI*ASDL
         DXK00=FH0*(1.D0/BEINI-1.D0/BEREF)
         XLH11=(YH11T+DXK00*(DKMSKE*YH1K1T+YH1K01T))*COS(DXDPT)
         XLH11=XLH11+DXDPI*YH1P1T*COS(DXDPT)
!        second derivative of Ha0(Z) (division by 2 has been made)
         XLH112=DXK00*DXK00*(H1AKIT+H1AKIMT*DKMSKE+ &
                H1AKMT*DKMSKE*DKMSKE)*COS(DXDPT)
         XLH112=XLH112+DXDPI*DXDPI*HAPIT*COS(DXDPT)
         XLH112=XLH112+DXDPI*DXK00*(YH10PKT+ &
              DKMSKE*YH11PKT)*COS(DXDPT)
!        third derivative of Ha0(Z)
         XLH113=(DXDPI**3)/3.D0*HAPPIT*COS(DXDPT)
         XLH11=XLH11+XLH112+XLH113
!        first derivative of Hb0(Z)
         XLH21=(YH21T+DXK00*(DKMSKE*YH2K1T+YH2K01T))*SIN(DXDPT)
         XLH21=XLH21+DXDPI*YH2P1T*SIN(DXDPT)
!        second derivative of Hb0(Z) (division by 2 has been made)
         XLH212=DXK00*DXK00*(H1BKIT+H1BKIMT*DKMSKE + &
                H1BKMT*DKMSKE**2)*SIN(DXDPT)
         XLH212=XLH212+DXDPI*DXDPI*HBPIT*SIN(DXDPT)
         XLH212=XLH212+DXDPI*DXK00*(YH20PKT+ &
                DKMSKE*YH21PKT)*SIN(DXDPT)
!      third derivative of of Hb0(Z)
         XLH213=(DXDPI**3)/3.D0*HBPPIT*SIN(DXDPT)
         XLH21=XLH21+XLH212+XLH213
         XLH1I=CXLG*(XLH11-XLH21)
! --- SAUPHC is the jump of phase
             SAUPHC=FH0*XLH1I
! ---     XKMI:  AVERAGE factor k (k = frequency/velovity)
         XKMI=XK2II+SAUPHC/EQVL+(XK2II-XK1II)*ASDL/EQVL
         BEMPY=FH0/XKMI
         XK1I=XK1II-XKMI
         DXDKI=XKMI-XKM
         DPHII=(XK1II-XK2II)*EQVL/10.D0+(XKP1+XKP2)/120.D0*EQVL**2 &
              + XK1I*ASDL
       ENDDO
! ****       ENDDO IJK=1,3
       if(GACR.lt.1.0000002D0) f(8,i)=0.D0
       if(int(f(8,i)).eq.0) then
         ilost=ilost+1
         if(ilost.ge.ngood) stop
         cycle
       endif
!    Compute the shift of phase: PHSLIL
       DTS=(TKE*T1KE+SKE*S1KE)/(TKE*TKE+SKE*SKE)
       TILTAL=-4.D0*ATAN(DTS*3.2D0/EQVL)
!       IF(TILTAL.NE.0.) THEN
       IF(abs(TILTAL).GT.fprec) THEN
         TIL2=TILTAL/2.D0
         XLREI=EQVL
         DO IIII=1,4
           FTIL=1.D0/TAN(TIL2) - 1.D0/TIL2 -DTS*2.D0/XLREI
           DFTIL=-1.D0/(SIN(TIL2)*SIN(TIL2)) + 1.D0/(TIL2*TIL2)
!           IF(DFTIL.NE.6.*0.) then
           IF(abs(DFTIL).GT.fprec) then
             TIL2=TIL2 - FTIL/DFTIL
             GX=1.D0/TAN(TIL2) - 1.D0/TIL2
             XLREI=2.D0*DTS/GX
           endif
         ENDDO
         TILTAL=TIL2*2.D0
       ENDIF
       PHSLIL=TILTAL
       TEGL1=PHSLIL*PHSLIL/(SIN(PHSLIL/2.D0)*SIN(PHSLIL/2.D0))
       TEGL2=(TKE*TKE+SKE*SKE)
       TEGL=TEGL1*TEGL2/(EQVL*32.D0)
       TEGL=TEGL/EQVL
! ---   Transverse motion  (field E(z)**2)
       PHITTI=PHIWC+XK1I*ASDL-PHSLIP/2.D0
       PHITSI=PHIWC+XK2I*ASDL+PHSLIP/2.D0
       CETF1=f(9,i)*f(9,i)/(16.D0*XMAT*XMAT*EQVL*EQVL)
! **************************
       CFV1=(GINI*GINI+2.D0)/((GINI*GINI-1.D0)**2)
       CFV2=(GACR*GACR+2.D0)/((GACR*GACR-1.D0)**2)
       SV1=CFV1*(TKE*COS(PHITTI)-SKE*SIN(PHITTI))**2
       SV1=CETF1*SV1*(PHSLIL/SIN(PHSLIL/2.D0))**2
       SV2=CFV2*(TKE*COS(PHITSI)-SKE*SIN(PHITSI))**2
       SV2=CETF1*SV2*(PHSLIL/SIN(PHSLIL/2.D0))**2
!       Transverse motion  (field dE(z)/dt)
       CETI=FH0*abs(f(9,i))/(4.D0*XMAT*EQVL)
! **************************
       CXV1=(GINI*GINI-1.D0)**1.5D0
       CXV2=(GACR*GACR-1.D0)**1.5D0
       SXV1=(TKE*SIN(PHITTI)+SKE*COS(PHITTI))*PHSLIL/SIN(PHSLIL/2.D0)
       SXV1=-CETI*SXV1/CXV1
       SXV2=(TKE*SIN(PHITSI)+SKE*COS(PHITSI))*PHSLIL/SIN(PHSLIL/2.D0)
       SXV2=-CETI*SXV2/CXV2
! --- save all parameters
       SV1P(I)=SV1
       SV2P(I)=SV2
       SXV1P(I)=SXV1
       SXV2P(I)=SXV2
       DWCIS(I)=DWCI
       sauphcs(i)=SAUPHC
       BEINI1(I)=BEINI
       PHIP(I)=PHI
       TEGLP(I)=TEGL
       DXDPIP(I)=DXDPI
       DXDKIP(I)=DXDKI
       DXDPTP(I)=DXDPT
       DXK00P(I)=DXK00
       DPHIIP(I)=DPHII
!  END IF BLOCK  on APV
     ENDIF
! --- ipas = 2: the dynamics is computed over the full element
     if(ipas.eq.2) then
!    Recover all previous parameters
       SAUPHC=sauphcs(i)
       XLH1I=SAUPHC/FH0
       DWCI=DWCIS(I)
       SV1=SV1P(I)
       SV2=SV2P(I)
       SXV1=SXV1P(I)
       SXV2=SXV2P(I)
       BEINI=BEINI1(I)
       GINI = 1.D0/SQRT(1.D0-BEINI*BEINI)
       PHI=PHIP(I)
       TEGL=TEGLP(I)
       DXDPI=DXDPIP(I)
       DXDKI=DXDKIP(I)
       DXDPT=DXDPTP(I)
       DXK00=DXK00P(I)
       DPHII=DPHIIP(I)
     else
!  compute the jump of phase at position of space charge computation
       CXLG=abs(f(9,i))/(4.D0*XMAT*EQVL)
!     FUNCTION Ha0(Z)
       XLH11=(YH11+DXK00*(DKMSKE*YH1K1+YH1K01))*COS(DXDPT)
       XLH11=XLH11+DXDPI*YH1P1*COS(DXDPT)
!     SECOND DERIVATIVES OF Ha0(Z) (division by 2 has been made)
       XLH112=DXK00*DXK00*(H1AKI+H1AKIM*DKMSKE+ &
            H1AKM*DKMSKE*DKMSKE)*COS(DXDPT)
       XLH112=XLH112+DXDPI*DXDPI*HAPI*COS(DXDPT)
       XLH112=XLH112+DXDPI*DXK00*(YH10PK+ &
            DKMSKE*YH11PK)*COS(DXDPT)
!      THIRD DERIVATIVE of Ha0(Z)
       XLH113=(DXDPI**3)/3.D0*HAPPI*COS(DXDPT)
       XLH11=XLH11+XLH112+XLH113
!     FUNCTION Hb0(Z)
       XLH21=(YH21+DXK00*(DKMSKE*YH2K1+YH2K01))*SIN(DXDPT)
       XLH21=XLH21+DXDPI*YH2P1*SIN(DXDPT)
!     SECOND DERIVATIVE OF Hb0(Z) (division by 2 has been made)
       XLH212=DXK00*DXK00*(H1BKI +H1BKIM*DKMSKE+ &
            H1BKM*DKMSKE**2)*SIN(DXDPT)
       XLH212=XLH212+DXDPI*DXDPI*HBPI*SIN(DXDPT)
       XLH212=XLH212+DXDPI*DXK00*(YH20PK+ &
            DKMSKE*YH21PK)*SIN(DXDPT)
!      THIRD DERIVATIVE OF Hb0(Z)
       XLH213=(DXDPI**3)/3.D0*HBPPI*SIN(DXDPT)
       XLH21=XLH21+XLH212+XLH213
       XLH1I=CXLG*(XLH11-XLH21)
       SAUPHC=FH0*XLH1I
     endif
     CXLG=abs(f(9,i))/(4.D0*XMAT*EQVL)
     XLH01=(YH10+DXDKI*YH1K0+DXK00*YH1K00)*COS(DXDPT)
     XLH02=(YH20+DXDKI*YH2K0+DXK00*YH2K00)*SIN(DXDPT)
     XLH0I=CXLG*(XLH01-XLH02)
! -- COUPLING INTEGRALS
     XLP11=(YP11+ DXDKI*YP1K1 + DXK00*YP1K01)*COS(DXDPT)
     XLP21=(YP21+ DXDKI*YP2K1 + DXK00*YP2K01)*SIN(DXDPT)
     XLP1I=CXLG*(XLP11-XLP21)
     XLP12=(YP12+ DXDKI*YP1K2 + DXK00*YP1K02)*COS(DXDPT)
     XLP22=(YP22+ DXDKI*YP2K2 + DXK00*YP2K02)*SIN(DXDPT)
     XLP2I=CXLG*(XLP12-XLP22)
     RADIU=SQRT(F(2,I)*F(2,I)+F(4,I)*F(4,I))
     IF(RADIU.LT.1.D-06) THEN
       DRADIU=.001D0*SQRT(F(3,I)*F(3,I)+F(5,I)*F(5,I))
     ELSE
       DRADIU=F(3,I)*.001D0*F(2,I)/RADIU+F(4,I)*F(5,I)*.001D0/RADIU
     ENDIF
     RP=RADIU
     RPP=DRADIU
!    Picht coordinates
     RRP=RP*SQRT(BEINI*GINI)
     RRPP=RPP*SQRT(BEINI*GINI)
! --- ipas = 1: the dynamics is computed until the position of space charge computation
!       gain of energy at the position of space charge computation (not for the reference)
     if(ipas.eq.1) then
! *****           PHIWC=PHI+DPHII-DPHCI0
       PHIWC=PHI+DPHII
!       istm: flag ==> the energy is computed at the position of space charge computation
       istm=ist-1
       GACR=GAMCI(PHIWC,PCRESI,GINI,ISTM,abs(f(9,i)))
       DWCI=(GACR-GINI)*XMAT
     endif
     DWPI=DWCI+XMAT*FH0*FH0*RRP*RRP/4.D0*XLH0I + &
          XMAT*RRP*RRPP*FH0*FH0/2.D0 *XLH1I
!   PHASE JUMP
     DELPHI=SAUPHC+ FH0**3*RRP*RRP/4.D0 *XLP1I + &
            FH0**3*RRP*RRPP/2.D0 *XLP2I
     IF(IPAS.EQ.2) THEN
!kicks of energy from space charge effects are in dwp(i)
       IF(ICHAES) THEN
         F(7,i)=F(7,I)+DWPI+DWP(I)
         GAMSOR = F(7,i)/XMAT
         IF(GAMSOR.le.1.D0) f(8,i)=0.D0
! particle is lost
         IF(int(F(8,i)).EQ.0) cycle
         BESOR=SQRT(1.D0-1.D0/(GAMSOR*GAMSOR))
!   phase jump resulting from space charge
         DELGAM=DWP(I)/XMAT
         GAMKK0=F(7,I)/XMAT
         BEKK0=SQRT(1.D0-1.D0/(GAMKK0*GAMKK0))
         DBEK21=DELGAM/(BEKK0**3 * GAMKK0**3)
         DELSC=FH0*SCDIST*DBEK21/2.D0
         DELPHI=DELPHI+DELSC
         DITEMP=YLG/(BESOR*VL)+DELPHI/FH
         f(6,i)=fs(6,i)+ditemp
       ELSE
         f(7,i)=f(7,i)+DWPI
         GAMSOR = f(7,i)/XMAT
         IF(GAMSOR.le.1.D0) f(8,i)=0.D0
! particle is lost
         if(int(f(8,i)).eq.0) then
           f6i=f(6,i)-tcog
           lossreason(i)=-1
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
           PRTLAB,NRRES,davtot/100.D0,i,int(f(1,i)), &
           f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180.D0/pi,f(7,i)-xmat, &
           f(9,i),lossreason(i),uden
           if(ilost.ge.ngood) stop
           ilost=ilost+1
           cycle
         ENDIF
         BESOR=SQRT(1.D0-1.D0/(GAMSOR*GAMSOR))
         DITEMP=YLG/(besor*vl)+DELPHI/FH
         f(6,i)=f(6,i)+DITEMP
       ENDIF
     ENDIF
     IF(ipas.eq.1) THEN
       f(7,i)=f(7,i)+DWPI
       GAMSOR = f(7,i)/XMAT
       if(GAMSOR.le.1.D0) f(8,i)=0.D0
       if(int(f(8,i)).eq.0) then
         lossreason(i)=-2
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
         PRTLAB,NRRES,davtot/100.D0,i,int(f(1,i)), &
         f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180.D0/pi,f(7,i)-xmat, &
         f(9,i),lossreason(i),uden
         if(ilost.ge.ngood) stop
         ilost=ilost+1
         cycle
       endif
       BESOR=SQRT(1.D0-1.D0/(GAMSOR*GAMSOR))
       DITEMP=YLG/(2.D0*BESOR*VL)+DELPHI/FH
! ****************************
       f(6,i)=f(6,i)+DITEMP
     ENDIF
     IF(I.EQ.ICONT) THEN
       IF(IPAS.EQ.2) THEN
         WRITE(16,*) '* DYNAMICS AT THE OUTPUT :'
         WRITE(16,'(A,e12.5,A,e12.5,A,e12.5)') ' * PHASE JUMP ',DELPHI*180.D0/pi, &
           ' DEG  CORRECTED BY :', DELSC*180.D0/pi,' DEG  SC KICK(MeV) ',DWP(I)
         ENRPRIN=f(7,i)-XMAT
         WRITE(16,'(A,E14.7,A,E14.7,A,/,A,e12.5,/,A,F5.0,A,e12.5,A,/,A)') &
           ' * ENERGY GAIN : ',DWPI,' MeV   ENERGY :',ENRPRIN,' MeV', &
           ' * BETA :',BESOR, &
           ' * CHARGE :',f(9,i),' TRANSIT TIME :',DITEMP,' SEC', &
           ' *'
        write(16,*) '* TK TKE ',TK,TKE
        write(16,*) '* SK SKE ',SK,SKE
        write(16,*) '* PCREST  PCRESI',PCREST,PCRESI
       ENDIF
       if(ipas.eq.1) then
         WRITE(16,*) '* DYNAMICS AT THE POSITION OF SPACE CHARGE :'
         ENRPRIN=f(7,i)-XMAT
         WRITE(16,'(A,E12.5,A,E14.7,A,E14.7,A,/,A,e12.5,A,/,A)') &
           ' * PHASE JUMP ',DELPHI*180.D0/pi,' DEG  ENERGY GAIN : ',DWPI, &
           ' MeV ENERGY :',ENRPRIN,' MEV', &
           ' * TRANSIT TIME :',DITEMP,' SEC', &
           ' *'
       ENDIF
     ENDIF
     AMORT=SQRT(BEINI*GINI/(BESOR*GAMSOR))
!     INTEGRALS OF THE TRANSVERSE MOTION (not computed for the reference)
!     ******************
! ******       if(i.ne.ngdrf) then
! ----  integrals of E(Z)**2
! ----     (G**2+2/(G**2-1)**2)*E(z)**2
     CETF=f(9,i)*f(9,i)*SQCTTF*SQCTTF/(16.D0*XMAT*XMAT*EQVL*EQVL)
! *************************************
     XJF0I=YFS0+DXDKI*(YFSK0+YFSCK0) + DXDPI*(YFSP0 +YFSCP0) + &
           DXK00*YFSKC0
     XJF0I=XJF0I*CETF
     XJF1I=YFS1+DXK00*DKMSKE*(YFSK1+YFSCK1)+DXDPI*(YFSP1+YFSCP1)+ &
           DXK00*YFSKC1
     XJF1I=XJF1I*CETF
     XJF2I=YFS2+DXK00*DKMSKE*(YFSK2+YFSCK2)+DXDPI*(YFSP2+YFSCP2)+ &
           DXK00*YFSKC2
     XJF2I=XJF2I*CETF
     V1=SV1
     V2=SV2
! ----     (G**2+2/(G**2-1)**2)
     CETM=f(9,i)*f(9,i)*TEGL/(XMAT*XMAT)
! *************************************
     XMN0I=YNS0+DXDKI*YNSK0+DXDPI*YNSP0+DXK00*YNSK0C
     XMN0I=XMN0I*CETM
     XMN1I=YNS1+DXK00*DKMSKE*YNSK1+DXDPI*YNSP1+DXK00*YNSK1C
     XMN1I=XMN1I*CETM
     XMN2I=YNS2+DXK00*DKMSKE*YNSK2 + DXDPI*YNSP2 +DXK00*YNSK2C
     XMN2I=XMN2I*CETM
     F0=XJF0I + XMN0I
     F1=XJF1I + XMN1I
     F2=XJF2I + XMN2I
! ---     1/(B*G)**3 *dE(z)/dt
     CETI=FH0*abs(f(9,i))/(8.D0*XMAT*EQVL)
! **************************
     XIE01= (YE10+DXDKI*YE1K0+DXK00*YE1KC0)*COS(DXDPT)
     XIE02= (YE20+DXDKI*YE2K0+DXK00*YE2KC0)*SIN(DXDPT)
     XIE0I=-CETI*(XIE01+XIE02)
     XIE11= (YE11+DXDKI*YE1K1+DXK00*YE1KC1)*COS(DXDPT)
     XIE12= (YE21+DXDKI*YE2K1+DXK00*YE2KC1)*SIN(DXDPT)
     XIE1I=-CETI*(XIE11+XIE12)
     XIE21= (YE12+DXDKI*YE1K2+DXK00*YE1KC2)*COS(DXDPT)
     XIE22= (YE22+DXDKI*YE2K2+DXK00*YE2KC2)*SIN(DXDPT)
     XIE2I=-CETI*(XIE21+XIE22)
     XV1=SXV1
     XV2=SXV2
     XI0=XIE0I
     XI1=XIE1I
     XI2=XIE2I
!  Transport matrix in 'PICHT' coordonates
     XQ0=XI0-F0
     XQ1=XI1-F1
     XQ2=XI2-F2
     XQ01=(XQ1+ASDL*XQ0)
     XQ12=(XQ2+ASDL*XQ1)
     V1=XV1-V1
     V2=XV2-V2
     A11=-XQ01*(1.D0+ (V1+V2)*EQVL*EQVL/120.D0)
     A12=-(XQ2+2.D0*ASDL*XQ1+ASDL*ASDL*XQ0 + &
         EQVL*EQVL*((V1+V2)/120.D0 + EQVL*V2/120.D0)*XQ01)
     ZA=-(XQ12/EQVL +V2*EQVL*EQVL*XQ01/120.D0)
     ZB=-((EQVL+ASDL)*XQ12/EQVL - &
         EQVL*XQ01/10.D0 +V2*(EQVL+ASDL)*EQVL*EQVL*XQ01/120.D0)
     A21=XQ0*(1.D0+ (V1+V2)*EQVL*EQVL/120.D0)
     A22= XQ1 + XQ0*(ASDL+ASDL*EQVL*EQVL*(V1+V2)/120.D0 + &
         EQVL**3*V2/120.D0)
     ZC=XQ1/EQVL + V2*EQVL*EQVL*XQ0/120.D0
     ZD= (ASDL+EQVL)*XQ1/EQVL - &
        ( EQVL/10.D0 + V2*(EQVL+ASDL)*EQVL*EQVL/120.D0)*XQ0
!
     TMA=1.D0/(1.D0-ZA-ZC*ZB/(1.D0-ZD))
     T11=(A11+ZB*A21/(1.D0-ZD)) *TMA
     T12=(A12+ZB*A22/(1.D0-ZD) )*TMA
     T21=(A21+ZC*T11)/(1.D0-ZD)
     T22=(A22+ZC*T12)/(1.D0-ZD)
     VR11=(1.D0+T11+DCUM*T21)
     VR12=(T12+DCUM*(1.D0+T22))
     VR21=T21
     VR22=1.D0+T22
     IF(I.EQ.ICONT) THEN
       DETRE=VR11*VR22-VR12*VR21
       WRITE(16,'(A,/,2(A,e12.5,A,e12.5,/),A,e12.5,/,A)') &
         ' * TRANSVERSE CANONICAL MATRIX:(cm,radian) ', &
         ' * VR11:',VR11,'   VR12:',VR12, &
         ' * VR21:',VR21,'   VR22:',VR22, &
         ' * DETERMINANT       :',DETRE, &
         ' *'
     ENDIF
!   REAL MATRIX
     A11=VR11*AMORT
     A12=VR12*AMORT
     A21=VR21*AMORT
     A22=VR22*AMORT
!   BEAM COORDINATES
     FXT1=A11*F(2,I)+A12*F(3,I)*1.D-03
     FXT2=A21*F(2,I)+A22*F(3,I)*1.D-03
     FXT3=A11*F(4,I)+A12*F(5,I)*1.D-03
     FXT4=A21*F(4,I)+A22*F(5,I)*1.D-03
     F(2,I)=FXT1
     F(3,I)=FXT2*1.D3
     F(4,I)=FXT3
     F(5,I)=FXT4*1.D3
     IF(I.EQ.ICONT) THEN
!    ** CURRENT MATRIX
       STTA11=VR11*SACT11+VR12*SACT21
       STTA12=VR11*SACT12+VR12*SACT22
       STTA21=VR21*SACT11+VR22*SACT21
       STTA22=VR21*SACT12+VR22*SACT22
       SACT11=STTA11
       SACT12=STTA12
       SACT21=STTA21
       SACT22=STTA22
       SAA11=SACT11*AMORT
       SAA12=SACT12*AMORT
       SAA21=SACT21*AMORT
       SAA22=SACT22*AMORT
       DET=A11*A22-A12*A21
       WRITE(16,'(A,/,2(A,e12.5,3x,e12.5,/),A,e12.5,A,e12.5)') &
         ' * TRANSVERSE MATRIX (cm,mrd)', &
         ' *',A11,A12*1.D-3, &
         ' *',A21*1.D3,A22, &
         ' * DETERMINANT :',DET,' DUMPING OF ENERGY :',AMORT
       write(16,*)'*'
       WRITE(16,'(A,/,A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A)') &
         ' * TRANSVERSE COORDINATES AT OUTPUT  ', &
         ' * X :',F(2,I),' CM  XP :',F(3,I),' MRD ', &
         ' * Y :',F(4,I),' CM  YP :',F(5,I),' MRD'
       WRITE(16,*)'******************************************'
       IF(IPAS.EQ.2) &
         WRITE(16,*) '********* END OF FOLLOWED PARTICLE *******'
     ENDIF
   ENDDO
!   deallocate(lossreason)
!   deallocate(SV1P)
!   deallocate(SV2P)
!   deallocate(SXV1P)
!   deallocate(SXV2P)
!   deallocate(DWCIS)
!   deallocate(BEINI1)
!   deallocate(PHIP)
!   deallocate(TEGLP)
!   deallocate(DXDPIP)
!   deallocate(DXDKIP)
!   deallocate(DXDPTP)
!   deallocate(DXK00P)
!   deallocate(DPHIIP)
!   deallocate(sauphcs)   
END SUBROUTINE boucle
!> *******************************************************************
!! SUBROUTINE xtypl1(GAMI,SAPHI,QSC,DCG)
!! called by ETGAP and RESTAY
!! INTEGRALS  E(z)*(BG)**-3 *z**n   n=0,1
!! INTEGRALS  dE(z)/dT*(BG)**-3 *z**n   n=0,1,2
!! INTEGRALS FUNCTIONS HA0(Z) and HB0(Z)
!! INTEGRALS OF THE FIRST DERIVATIVES OF HA0(Z) and HB0(Z)
!< *******************************************************************
SUBROUTINE xtypl1(GAMI,SAPHI,QSC,DCG)
   USE DynacConstants
   USE m4cavs
   USE m4mcs
   USE m4beam
   USE m4gaprestay
   USE m4gap, ONLY: YH1K0,YH1K1,YP1K1,YP1K2,YH1K00,YH1K01,YP1K01,YP1K02, &
       YH10,YH11,YP11,YP12, YH2K0,YH2K1,YP2K1,YP2K2,YH2K00,YH2K01,YP2K01, &
       YP2K02,YH20,YH21,YP21,YP22, YE1K0,YE1K1,YE1K2,YE1KC0,YE1KC1,YE1KC2, &
       YE10,YE11,YE12, YE2K0,YE2K1,YE2K2,YE2KC0,YE2KC1,YE2KC2,YE20,YE21,YE22
   USE m4gap2, ONLY: GAKS,IST
   IMPLICIT NONE
   REAL(8) GAMI,SAPHI,QSC,DCG
   REAL(8) BETI,BI,CGAM10,CGI,DHA01,DHA02,DHA03,DHB01,DHB02,DHB03,DPA01,DPA02,DPA03
   REAL(8) DPB01,DPB02,DPB03,DTILK,GAK,GAK1,GAK2,GAK3,GAM2,GI,GIC,GIS,GIT
   REAL(8) HA0,HB0,PA0,PB0,PHCRTK,PHIT0,PHIT0K,PHIT1,PHTZ0,TILTA2,XCC,XCC1,XINT
   REAL(8) XK1,FH0
   INTEGER i
!  TRANSVERSAL dE(z)/dt
!   COMMON/TYPI1/YE1K0,YE1K1,YE1K2, &
!   COMMON/TYPI2/YE2K0,YE2K1,YE2K2, &
   REAL(8) H(17),T(17)
   DATA T /-.990575473D0,-.950675522D0,-.880239154D0, &
            -.781514004D0,-.657671159D0,-.512690537D0, &
            -.351231763D0,-.178484181D0, 0.D0, &
             .178484181D0, .351231763D0, .512690537D0, &
             .657671159D0, .781514004D0, .880239154D0, &
             .950675522D0, .990575473D0/
   DATA H /.024148303D0,.055459529D0,.085036148D0, &
           .111883847D0,.135136368D0,.154045761D0, &
           .168004102D0,.176562705D0,.179446470D0, &
           .176562705D0,.168004102D0,.154045761D0, &
           .135136368D0,.111883847D0,.085036148D0, &
           .055459529D0,.024148303D0/
!*******************************************************************
   FH0=FH/VL
   CGI=QSC/XMAT
! Circular cosinus functions
! In longitudinal direction
   YH1K0=0.D0
   YH1K1=0.D0
   YP1K1=0.D0
   YP1K2=0.D0
   YH1K00=0.D0
   YH1K01=0.D0
   YP1K01=0.D0
   YP1K02=0.D0
   YH10=0.D0
   YH11=0.D0
   YP11=0.D0
   YP12=0.D0
!  In transverse direction ( dE(z)/dt )
   YE1K0=0.D0
   YE1K1=0.D0
   YE1K2=0.D0
   YE1KC0=0.D0
   YE1KC1=0.D0
   YE1KC2=0.D0
   YE10=0.D0
   YE11=0.D0
   YE12=0.D0
! Circular sinus functions
! In longitudinal direction
   YH2K0=0.D0
   YH2K1=0.D0
   YP2K1=0.D0
   YP2K2=0.D0
   YH2K00=0.D0
   YH2K01=0.D0
   YP2K01=0.D0
   YP2K02=0.D0
   YH20=0.D0
   YH21=0.D0
   YP21=0.D0
   YP22=0.D0
!  In transverse direction ( dE(z)/dt )
   YE2K0=0.D0
   YE2K1=0.D0
   YE2K2=0.D0
   YE2KC0=0.D0
   YE2KC1=0.D0
   YE2KC2=0.D0
   YE20=0.D0
   YE21=0.D0
   YE22=0.D0
!Calculates the integrals
   DTILK=EQVL
   GAM2=GAMI**2
   BETI=SQRT(1.D0-1.D0/GAM2)
   XK1=FH0/BETI
   TILTA2=PHSLIP/(2.D0*EQVL)
   CGAM10=((GAMI*GAMI-1.D0)**1.5D0)/FH0
   PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
   ist=0
   do i=1,17
     ist=ist+1
     XCC= EQVL*(1.D0+T(I))/2.D0
     XCC1=XCC+ASDL
     IF(XCC1.GT.DCG) EXIT
     PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.D0*EQVL)+PAVPH
!   FONCTION GAMMA (Z)
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
       GIS =  SIN(XCC*TILTA2)
     ELSE
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
       GIS =  XCC/(2.D0*EQVL)
     ENDIF
     GI=GAMI+GIT * GIS
     BI=SQRT(1.D0-1.D0/(GI*GI))
!   Derivative of  G0(Z) relative to the equivalent k
     PHIT0K=-DTILK*(1.D0-XCC/EQVL)/2.D0
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIC =  COS(XCC*TILTA2)
       GAK1 = DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
       GAK2 = SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
       GAK3 = DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.D0*PHSLIP*EQVL)
       GAK = CGI * SQCTTF* (-GAK1-GAK2+GAK3)
     ELSE
       GAK1 = SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
       GAK = -CGI * SQCTTF* GAK1
     ENDIF
     IF(I.EQ.17) GAKS=GAK
!  Calculate the integrals of  HA0(Z) and HB0(Z)
     XINT=1.D0/(BI*BI*BI*GI*GI*GI)
     PHIT1=PHIT0+XCC*PHSLIP/(2.D0*EQVL)
     PHTZ0=(XCC/EQVL-0.5D0)*DTILK
     HA0=2.D0*SQCTTF*COS(PHIT1-PCREST)*XINT
     HB0=2.D0*SQCTTF*SIN(PHIT1-PCREST)*XINT
!  n=0
!   Longitudinal direction
     YH10=YH10+H(I)*HA0
     YH20=YH20+H(I)*HB0
!    Transverse direction
     YE10=YH20
     YE20=YH10
!  n=1
!    Longitudinal direction
     YH11=YH11+H(I)*HA0*XCC1
     YH21=YH21+H(I)*HB0*XCC1
!    Transverse direction
     YE11=YE11+H(I)*HB0*XCC
     YE21=YE21+H(I)*HA0*XCC
!  n=2
     YE12=YE12+H(I)*HB0*XCC*XCC
     YE22=YE22+H(I)*HA0*XCC*XCC
!  Calculate the integrals of the derivative of HA0(Z)
     DHA01=SQCTTF*COS(PHIT1-PCREST)*GI/((GI*GI-1.D0)**2.5D0)
     DHA02=SQCTTF*COS(PHIT1-PCREST)*GI*GAK/((GI*GI-1.D0)**2.5D0)
     DHA03=SQCTTF*SIN(PHIT1-PCREST)/((GI*GI-1.D0)**1.5D0)
!  n=0
!  Longitudinal direction
     YH1K00=YH1K00+H(I)*DHA01*6.D0*CGAM10
     YH1K0=YH1K0+H(I)*(-6.D0*DHA02+ &
           2.D0*(PHCRTK-PHTZ0)*DHA03)
!  Transverse direction
     YE2KC0=YH1K00
     YE2K0=YH1K0
!  n=1
!  Longitudinal direction
     YH1K01=YH1K01+H(I)*DHA01*XCC1*6.D0*CGAM10
     YH1K1=YH1K1+H(I)*XCC1*(-6.D0*DHA02+ &
          2.D0*(PHCRTK-PHTZ0)*DHA03)
!  Transverse direction
     YE2KC1=YE2KC1+H(I)*DHA01*XCC*6.D0*CGAM10
     YE2K1=YE2K1+H(I)*XCC*(-6.D0*DHA02- &
         2.D0*(PHCRTK-PHTZ0)*DHA03)
!  n=2
     YE2KC2=YE2KC2+H(I)*DHA01*XCC*XCC*6.D0*CGAM10
     YE2K2=YE2K2+H(I)*XCC*XCC*(-6.D0*DHA02- &
         2.D0*(PHCRTK-PHTZ0)*DHA03)
!  INTEGRALS Of  HB0(Z)
     DHB01=SQCTTF*SIN(PHIT1-PCREST)*GI/((GI*GI-1.D0)**2.5D0)
     DHB02=SQCTTF*SIN(PHIT1-PCREST)*GI*GAK/((GI*GI-1.D0)**2.5D0)
     DHB03=SQCTTF*COS(PHIT1-PCREST)/((GI*GI-1.D0)**1.5D0)
!  n=0
!  LONGITUDINAL
     YH2K00=YH2K00+H(I)*DHB01*6.D0*CGAM10
     YH2K0=YH2K0+H(I)*(-6.D0*DHB02- &
            2.D0*(PHCRTK-PHTZ0)*DHB03)
!  TRANSVERSE
     YE1KC0=YH2K00
     YE1K0=YH2K0
!  n=1
!  LONGITUDINAL
     YH2K01=YH2K01+H(I)*DHB01*XCC1*6.D0*CGAM10
     YH2K1=YH2K1+H(I)*XCC1*(-6.D0*DHB02- &
         2.D0*(PHCRTK-PHTZ0)*DHB03)
!  TRANSVERSE
     YE1KC1=YE1KC1+H(I)*DHB01*XCC*6.D0*CGAM10
     YE1K1=YE1K1+H(I)*XCC*(-6.D0*DHB02- &
         2.D0*(PHCRTK-PHTZ0)*DHB03)
!  n=2
     YE1KC2=YE1KC2+H(I)*DHB01*XCC*XCC*6.D0*CGAM10
     YE1K2=YE1K2+H(I)*XCC*XCC*(-6.D0*DHB02- &
         2.D0*(PHCRTK-PHTZ0)*DHB03)
!  Calculate the integrals of PA0(Z) et PB0(Z)
     PA0=2.D0*SQCTTF*COS(PHIT1-PCREST)*XINT*XINT
     PB0=2.D0*SQCTTF*SIN(PHIT1-PCREST)*XINT*XINT
!  n=1
     YP11=YP11+H(I)*PA0*XCC1
     YP21=YP21+H(I)*PB0*XCC1
!  n=2
     YP12=YP12+H(I)*PA0*XCC1*XCC1
     YP22=YP22+H(I)*PB0*XCC1*XCC1
!  Calculate the integrals of the derivatives of PA0(Z)
     DPA01=SQCTTF*COS(PHIT1-PCREST)*GI/((GI*GI-1.D0)**4)
     DPA02=SQCTTF*COS(PHIT1-PCREST)*GI*GAK/((GI*GI-1.D0)**4)
     DPA03=SQCTTF*SIN(PHIT1-PCREST)/((GI*GI-1.D0)**3)
!  n=1
     YP1K01=YP1K01+H(I)*DPA01*12.D0*CGAM10*XCC1
     YP1K1=YP1K1+H(I)*XCC1*(-12.D0*DPA02+ &
           2.D0*(PHCRTK-PHTZ0)*DPA03)
!  n=2
     YP1K02=YP1K02+H(I)*DPA01*12.D0*CGAM10*XCC1*XCC1
     YP1K2=YP1K2+H(I)*XCC1*XCC1*(-12.D0*DPA02 + &
           2.D0*(PHCRTK-PHTZ0)*DPA03)
!  INTEGRALES DERIVES PB0(Z)
     DPB01=SQCTTF*SIN(PHIT1-PCREST)*GI/((GI*GI-1.D0)**4)
     DPB02=SQCTTF*SIN(PHIT1-PCREST)*GI*GAK/((GI*GI-1.D0)**4)
     DPB02=DPB02
     DPB03=SQCTTF*COS(PHIT1-PCREST)/((GI*GI-1.D0)**3)
!  n=1
     YP2K01=YP2K01+H(I)*DPB01*12.D0*CGAM10*XCC1
     YP2K1=YP2K1+H(I)*XCC1*(-12.D0*DPB02- &
           2.D0*(PHCRTK-PHTZ0)*DPB03)
!  n=2
     YP2K02=YP2K02+H(I)*DPB01*12.D0*CGAM10*XCC1*XCC1
     YP2K2=YP2K2+H(I)*XCC1*XCC1*(-12.D0*DPB02 - &
           2.D0*(PHCRTK-PHTZ0)*DPB03)
   enddo
!in COS
! LONGITUDINAL INTEGRALS
   YH1K00=YH1K00/2.D0 *EQVL
   YH1K01=YH1K01/2.D0 *EQVL
   YH1K0=YH1K0/2.D0 *EQVL
   YH1K1=YH1K1/2.D0 *EQVL
   YP1K1=YP1K1/2.D0 *EQVL
   YP1K2=YP1K2/2.D0 *EQVL
   YP1K01=YP1K01/2.D0 *EQVL
   YP1K02=YP1K02/2.D0 *EQVL
   YH10=YH10*EQVL/2.D0
   YH11=YH11*EQVL/2.D0
   YP11=YP11*EQVL/2.D0
   YP12=YP12*EQVL/2.D0
! Transverse integrals
   YE1K0=YE1K0/2.D0 *EQVL
   YE1KC0=YE1KC0/2.D0 *EQVL
   YE1K1=YE1K1/2.D0 *EQVL
   YE1KC1=YE1KC1/2.D0 *EQVL
   YE1K2=YE1K2/2.D0 *EQVL
   YE1KC2=YE1KC2/2.D0 *EQVL
   YE10=YE10*EQVL/2.D0
   YE11=YE11*EQVL/2.D0
   YE12=YE12*EQVL/2.D0
!in SIN
! LONGITUDINAL INTEGRALS
   YH2K00=YH2K00/2.D0 *EQVL
   YH2K01=YH2K01/2.D0 *EQVL
   YH2K0=YH2K0/2.D0 *EQVL
   YH2K1=YH2K1/2.D0 *EQVL
   YP2K1=YP2K1/2.D0 *EQVL
   YP2K2=YP2K2/2.D0 *EQVL
   YP2K01=YP2K01/2.D0 *EQVL
   YP2K02=YP2K02/2.D0 *EQVL
   YH20=YH20*EQVL/2.D0
   YH21=YH21*EQVL/2.D0
   YP21=YP21*EQVL/2.D0
   YP22=YP22*EQVL/2.D0
! TRANSVERSE INTEGRALS
   YE2K0=YE2K0/2.D0 *EQVL
   YE2KC0=YE2KC0/2.D0 *EQVL
   YE2K1=YE2K1/2.D0 *EQVL
   YE2KC1=YE2KC1/2.D0 *EQVL
   YE2K2=YE2K2/2.D0 *EQVL
   YE2KC2=YE2KC2/2.D0 *EQVL
   YE20=YE20*EQVL/2.D0
   YE21=YE21*EQVL/2.D0
   YE22=YE22*EQVL/2.D0
END SUBROUTINE xtypl1
!> *******************************************************************
!! SUBROUTINE xtypl2(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! integrals of the second derivative of the functions HA0(z) and HB0(z)
!! ZB = Z+ASDL
!< *******************************************************************
SUBROUTINE xtypl2(GAMI,SAPHI,QSC,DCG)
   USE DynacConstants
   USE m4cavs
   USE m4mcs
   USE m4beam
   USE m_h_t_h1_t1
   USE m4gaprestay
   USE m4gap, ONLY: H0AKI,H0AKIM,H0AKM,H0BKI,H0BKIM,H0BKM, &
                    H1AKI,H1AKIM,H1AKM,H1BKI,H1BKIM,H1BKM
   IMPLICIT NONE
   REAL(8) GAMI,SAPHI,QSC,DCG
   INTEGER i
   REAL(8) BIM1,DGAK,DGAM10,DPHC1,DPHC2,DPHCRTK,DPHTZ0,GAKM1,GITC,HAKI1,HAKI2,HAKI3
   REAL(8) HAKIM1,HAKIM2,HAKIM3,HAKM1,HAKM2,HAKM3,HAKM4,HAKM5,HAKM6,HBKI1,HBKI2,HBKI3
   REAL(8) HBKIM1,HBKIM2,HBKIM3,HBKM1,HBKM2,HBKM3,HBKM4,HBKM5,HBKM6,PHCRZ0,GAIT                
   REAL(8) BETI,BI,CGAM10,CGI
   REAL(8) DTILK,GAK,GAK1,GAK2,GAK3,GAM2,GI,GIC,GIS,GIT
   REAL(8) PHCRTK,PHIT0,PHIT0K,PHIT1,PHTZ0,TILTA2,XCC,XCC1
   REAL(8) XK1,FH0
!*******************************************************************
   FH0=FH/VL
   CGI=QSC/XMAT
   GAM2=GAMI**2
   BETI=SQRT(1.D0-1.D0/GAM2)
   XK1=FH0/BETI
! circular functions in cos
   H0AKI=0.D0
   H0AKIM=0.D0
   H0AKM=0.D0
   H1AKI=0.D0
   H1AKIM=0.D0
   H1AKM=0.D0
! circular functions in sin
   H0BKI=0.D0
   H0BKIM=0.D0
   H0BKM=0.D0
   H1BKI=0.D0
   H1BKIM=0.D0
   H1BKM=0.D0
!
   DTILK=EQVL
   TILTA2=PHSLIP/(2.D0*EQVL)
   CGAM10=((GAMI*GAMI-1.D0)**3)/(FH0*FH0)
   DGAM10=GAMI*((GAMI*GAMI-1.D0)**2)/(FH0*FH0)
   PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
   DPHC1=(T2K*SK-S2K*TK)/(TK*TK+SK*SK)
   DPHC2=(T1K*TK+S1K*SK)*(T1K*SK-S1K*TK)/ &
   ((TK*TK+SK*SK)**2)
   DPHCRTK=DPHC1-2.D0*DPHC2
   BIM1=BETI
   GAKM1=0.D0
   GAIT=GAMI
   do i=1,17
     XCC= EQVL*(1.D0+H1(I))/2.D0
     XCC1=XCC+ASDL
     IF(XCC1.GT.DCG) EXIT
     PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.D0*EQVL)+PAVPH
!    Function GAMMA (Z)
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
       GIS =  SIN(XCC*TILTA2)
     ELSE
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
       GIS =  XCC/(2.D0*EQVL)
     ENDIF
     GITC=GIT * GIS
     GI=GAMI+GIT * GIS
     BI=SQRT(1.D0-1.D0/(GI*GI))
!    FONCTION DERIVE G0(Z) RELATIF A K MOYEN
     PHIT0K=-DTILK*(1.D0-XCC/EQVL)/2.D0
!    DERIVE PREMIERE FONGTION GAMMA
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIC =  COS(XCC*TILTA2)
       GAK1=DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
       GAK2=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
       GAK3=DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.D0*PHSLIP*EQVL)
       GAK =CGI * SQCTTF* (-GAK1-GAK2+GAK3)
     ELSE
       GAK1=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
       GAK =-CGI * SQCTTF* GAK1
     ENDIF
!  Second derivative of GAMMA(z)
!     if(gi.ne.gait) then
     if(abs(gi-gait).gt.fprec) then
       DGAK=(GAK-GAKM1)/(GI-GAIT) *GAK
     else
       dgak=0.D0
     endif
     GAKM1=GAK
     GAIT=GI
     XCC1=XCC+ASDL
     PHIT1=PHIT0+XCC*PHSLIP/(2.D0*EQVL)
     PHTZ0=(XCC/EQVL-0.5D0)*DTILK
     DPHTZ0=DTILK/EQVL
     PHCRZ0=(PHTZ0-PHCRTK)
!  INTEGRALES FONCTIONS HAKI(Z) (a multipler par (k1i-k10)**2 )
     HAKI1=SQCTTF*COS(PHIT1-PCREST)/((GI*GI-1.D0)**2.5D0)
     HAKI2=SQCTTF*COS(PHIT1-PCREST)*GI/((GI*GI-1.D0)**2.5D0)
     HAKI3=SQCTTF*COS(PHIT1-PCREST)*GI*GI/((GI*GI-1.D0)**3.5D0)
!    n=0
     H0AKI=H0AKI+T1(I)*CGAM10*(-3.D0*HAKI1+15*HAKI3)- &
           T1(I)*DGAM10*9.D0*HAKI2
!    n=1
     H1AKI=H1AKI+T1(I)*CGAM10*XCC1*(-3.D0*HAKI1+15.D0*HAKI3)- &
           T1(I)*DGAM10*9.D0*HAKI2*XCC1
!  Integral of HAKIM(Z) (to be multiplied by (k1i-k10)*(kmi-km0) )
     HAKIM1=SQCTTF*COS(PHIT1-PCREST)*GAK/((GI*GI-1.D0)**2.5D0)
     HAKIM2=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAK/((GI*GI-1.D0)**3.5D0)
     HAKIM2=HAKIM2
     HAKIM3=SQCTTF*SIN(PHIT1-PCREST)*GI/((GI*GI-1.D0)**2.5D0)
!    n=0
     H0AKIM=H0AKIM+T1(I)*SQRT(CGAM10)*(6.D0*HAKIM1-30.D0*HAKIM2 - &
            3.D0*PHCRZ0*HAKIM3)
!    n=1
     H1AKIM=H1AKIM+T1(I)*SQRT(CGAM10)*(6.D0*HAKIM1-30.D0*HAKIM2 - &
            3.D0*PHCRZ0*HAKIM3)*XCC1
!  Integral of HAKM(Z) (to be multiplied by (kmi-km0)**2  )
     HAKM1=SQCTTF*COS(PHIT1-PCREST)*GAK*GAK/((GI*GI-1.D0)**2.5D0)
     HAKM2=SQCTTF*COS(PHIT1-PCREST)*DGAK*GI/((GI*GI-1.D0)**2.5D0)
     HAKM3=SQCTTF*COS(PHIT1-PCREST)*GAK*GAK*GI*GI/ &
           ((GI*GI-1.D0)**3.5D0)
     HAKM4=SQCTTF*SIN(PHIT1-PCREST)*GAK*GI/ &
           ((GI*GI-1.D0)**2.5D0)
     HAKM5=SQCTTF*COS(PHIT1-PCREST)/ &
           ((GI*GI-1.D0)**1.5D0)
     HAKM6=SQCTTF*SIN(PHIT1-PCREST)/ &
           ((GI*GI-1.D0)**1.5D0)
!    n=0
     H0AKM=H0AKM+T1(I)*(-3.D0*HAKM1-3.D0*HAKM2+15.D0*HAKM3 + &
           3.D0*PHCRZ0*HAKM4 - &
           PHCRZ0*PHCRZ0*HAKM5+DPHCRTK*HAKM6)
!    n=1
     H1AKM=H1AKM+T1(I)*XCC1*(-3.D0*HAKM1-3.D0*HAKM2+15.D0*HAKM3 + &
           3.D0*PHCRZ0*HAKM4 - &
           PHCRZ0*PHCRZ0*HAKM5+DPHCRTK*HAKM6)
!
!  INTEGRALES FONCTIONS HBKI(Z) (a multipler par (k1i-k10)**2 )
     HBKI1=SQCTTF*SIN(PHIT1-PCREST)/((GI*GI-1.D0)**2.5D0)
     HBKI2=SQCTTF*SIN(PHIT1-PCREST)*GI/((GI*GI-1.D0)**2.5D0)
     HBKI3=SQCTTF*SIN(PHIT1-PCREST)*GI*GI/((GI*GI-1.D0)**3.5D0)
!    n=0
     H0BKI=H0BKI+T1(I)*CGAM10*(-3.D0*HBKI1+15.D0*HBKI3) - &
                 T1(I)*DGAM10*9.D0*HBKI2
!    n=1
     H1BKI=H1BKI+T1(I)*CGAM10*XCC1*(-3.D0*HBKI1+15.D0*HBKI3) - &
                T1(I)*DGAM10*9.D0*HBKI2*XCC1
!  Integral of HBKIM(Z) (to be multiplied by (k1i-k10)*(kmi-km0) )
     HBKIM1=SQCTTF*SIN(PHIT1-PCREST)*GAK/((GI*GI-1.D0)**2.5D0)
     HBKIM2=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAK/((GI*GI-1.D0)**3.5D0)
     HBKIM2=HBKIM2
     HBKIM3=SQCTTF*COS(PHIT1-PCREST)*GI/((GI*GI-1.D0)**2.5D0)
!    n=0
     H0BKIM=H0BKIM+T1(I)*SQRT(CGAM10)*(6.D0*HAKIM1-30.D0*HAKIM2 + &
            3.D0*PHCRZ0*HAKIM3)
!    n=1
     H1BKIM=H1BKIM+T1(I)*SQRT(CGAM10)*(6.D0*HAKIM1-30.D0*HAKIM2 + &
            3.D0*PHCRZ0*HAKIM3)*XCC1
!  Integral of HBKM(Z) (to be multiplied by (kmi-km0)**2  )
     HBKM1=SQCTTF*SIN(PHIT1-PCREST)*GAK*GAK/((GI*GI-1.D0)**2.5D0)
     HBKM2=SQCTTF*SIN(PHIT1-PCREST)*DGAK*GI/((GI*GI-1.D0)**2.5D0)
     HBKM3=SQCTTF*SIN(PHIT1-PCREST)*GAK*GAK*GI*GI/ &
           ((GI*GI-1.D0)**3.5D0)
     HBKM4=SQCTTF*COS(PHIT1-PCREST)*GAK*GI/ &
           ((GI*GI-1.D0)**2.5D0)
     HBKM5=SQCTTF*SIN(PHIT1-PCREST)/ &
           ((GI*GI-1.D0)**1.5D0)
     HBKM6=SQCTTF*COS(PHIT1-PCREST)/ &
           ((GI*GI-1.D0)**1.5D0)
!   n=0
     H0BKM=H0BKM+T1(I)*(-3.D0*HBKM1-3.D0*HBKM2+15.D0*HBKM3 - &
           3.D0*PHCRZ0*HBKM4 - &
           PHCRZ0*PHCRZ0*HBKM5-DPHCRTK*HBKM6)
!   n=1
     H1BKM=H1BKM+T1(I)*XCC1*(-3.D0*HBKM1-3.D0*HBKM2+15.D0*HBKM3- &
           3.D0*PHCRZ0*HBKM4 - &
           PHCRZ0*PHCRZ0*HBKM5-DPHCRTK*HBKM6)
   enddo
!integrals in cos
   H0AKI=H0AKI/2.D0 *EQVL
   H0AKIM=H0AKIM/2.D0 *EQVL
   H0AKM=H0AKM/2.D0 *EQVL
   H1AKI=H1AKI/2.D0 *EQVL
   H1AKIM=H1AKIM/2.D0 *EQVL
   H1AKM=H1AKM/2.D0 *EQVL
!integrals in sin
   H0BKI=H0BKI/2.D0 *EQVL
   H0BKIM=H0BKIM/2.D0 *EQVL
   H0BKM=H0BKM/2.D0 *EQVL
   H1BKI=H1BKI/2.D0 *EQVL
   H1BKIM=H1BKIM/2.D0 *EQVL
   H1BKM=H1BKM/2.D0 *EQVL
END SUBROUTINE xtypl2
!> *******************************************************************
!! SUBROUTINE xtyplp1(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! Integrals of functions  HA0(Z) and HB0(Z)
!! Integrals of the first and second derivative of HA0(Z) et HB0(Z)(with PH01)
!! Integrals of the third derivative of HA0(Z) et HB0(Z)(with PH01)
!! zb = z+ASDL
!< *******************************************************************
SUBROUTINE xtyplp1(GAMI,SAPHI,QSC,DCG)
   USE DynacConstants
   USE m4cavs
   USE m4mcs
   USE m4beam
   USE m_h_t_h1_t1, ONLY: H1,T1  
   USE m4gaprestay
   USE m4gap, ONLY: YH1P1,YH2P1,HAPI,HBPI,HAPPI,HBPPI
   USE m4gap2, ONLY: GAPS
   IMPLICIT NONE
   REAL(8) GAMI,SAPHI,QSC,DCG
   REAL(8) DDGAP,DGAP,DHA01,DHA02,DHB01,DHB02,XINT,GAP
   REAL(8) HAPI1,HAPI2,HAPI3,HAPPI1,HAPPI2,HAPPI3,HAPPI4,HAPPI5,HAPPI6,HAPPI7,HAPPI8
   REAL(8) HBPI1,HBPI2,HBPI3,HBPPI1,HBPPI2,HBPPI3,HBPPI4,HBPPI5,HBPPI6,HBPPI7,HBPPI8
   INTEGER i
   REAL(8) BETI,BI,CGI
   REAL(8) DTILK,GAM2,GI,GIS,GIT
   REAL(8) PHIT0,PHIT1,PHTZ0,TILTA2,XCC,XCC1
   REAL(8) XK1,FH0
!*******************************************************************
   FH0=FH/VL
   CGI=QSC/XMAT
   GAM2=GAMI**2
   BETI=SQRT(1.D0-1.D0/GAM2)
   XK1=FH0/BETI
   DTILK=EQVL
! circular functions in cos
   YH1P1=0.D0
   HAPI=0.D0
   HAPPI=0.D0
! circular functions in sin
   YH2P1=0.D0
   HBPI=0.D0
   HBPPI=0.D0
   TILTA2=PHSLIP/(2.D0*EQVL)
!   IF(PHSLIP.NE.0.) DESY=PHSLIP/SIN(PHSLIP/2.D0)
!   IF(PHSLIP.EQ.0.) DESY=2.D0
!2019       IF(abs(PHSLIP).GT.fprec) DESY=PHSLIP/SIN(PHSLIP/2.D0)
!2019       IF(abs(PHSLIP).LE.fprec) DESY=2.D0
   do i=1,17
     XCC= EQVL*(1.D0+H1(I))/2.D0
     XCC1=XCC+ASDL
     IF(XCC1.GT.DCG) EXIT
     PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.D0*EQVL)+PAVPH
!    FONCTION GAMMA (Z)
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
       GIS =  SIN(XCC*TILTA2)
     ELSE
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
       GIS =  XCC/(2.D0*EQVL)
     ENDIF
     GI=GAMI+GIT * GIS
     BI=SQRT(1.D0-1.D0/(GI*GI))
!    FONCTION DERIVE G0(Z) RELATIF A PH01
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GAP=-CGI*SQCTTF*SIN(PHIT0-PCREST)*GIS/PHSLIP
!      DERIVE TROISIEME
       DDGAP=-GAP
     ELSE
       GAP = SIN(PHIT0-PCREST)*GIS
       GAP = -CGI * SQCTTF* GAP
       DDGAP=-GAP
     ENDIF
     IF(I.EQ.17) GAPS=GAP
!    Second derivative of G0(Z) in relation with  PH01
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       DGAP=-CGI*SQCTTF*COS(PHIT0-PCREST)*GIS/PHSLIP
     ELSE
       DGAP = COS(PHIT0-PCREST)*GIS
       DGAP = -CGI * SQCTTF*DGAP
     ENDIF
!    INTEGRALES FONCTIONS HA0(Z) et HB0(Z)
     XINT=1.D0/(BI*BI*BI*GI*GI*GI)
     PHIT1=PHIT0+XCC*PHSLIP/(2.D0*EQVL)
     PHTZ0=(XCC/EQVL-0.5D0)*DTILK
!    INTEGRALES DERIVES HA0(Z)
     DHA01=SQCTTF*COS(PHIT1-PCREST)*GI*GAP/((GI*GI-1.D0)**2.5D0)
     DHA02=0.D0
!    n=1
     YH1P1=YH1P1+T1(I)*XCC1*(-6.D0*DHA01-2.D0*DHA02)
!    INTEGRALES DERIVES  HB0(Z)
     DHB01=SQCTTF*SIN(PHIT1-PCREST)*GI*GAP/((GI*GI-1.D0)**2.5D0)
     DHB02=0.D0
!    n=1
     YH2P1=YH2P1+T1(I)*XCC1*(-6.D0*DHB01+2.D0*DHB02)
!    INTEGRALES HAPI(Z) (multiplies par (ph1i-ph10)**2 )
     HAPI1=SQCTTF*COS(PHIT1-PCREST)*GAP*GAP/((GI*GI-1.D0)**2.5D0)
     HAPI2=SQCTTF*COS(PHIT1-PCREST)*GI*DGAP/((GI*GI-1.D0)**2.5D0)
     HAPI3=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAP*GAP/ &
           ((GI*GI-1.D0)**3.5D0)
!    n=1
     HAPI=HAPI+T1(I)*XCC1*(-3.D0*HAPI1-3.D0*HAPI2+15.D0*HAPI3)
!    INTEGRALES HAPPI(Z) (multiplies par (ph1i-ph10)**3 )/3
     HAPPI1=SQCTTF*COS(PHIT1-PCREST)*GAP*DGAP/ &
           ((GI*GI-1.D0)**2.5D0)
     HAPPI2=SQCTTF*COS(PHIT1-PCREST)*GAP*GAP*GAP*GI/ &
           ((GI*GI-1.D0)**3.5D0)
     HAPPI3=SQCTTF*COS(PHIT1-PCREST)*GAP*DGAP/ &
           ((GI*GI-1.D0)**2.5D0)
     HAPPI4=SQCTTF*COS(PHIT1-PCREST)*GI*DDGAP/ &
           ((GI*GI-1.D0)**2.5D0)
     HAPPI5=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAP*DGAP/ &
           ((GI*GI-1.D0)**3.5D0)
     HAPPI6=SQCTTF*COS(PHIT1-PCREST)*GI*GAP**3/ &
           ((GI*GI-1.D0)**3.5D0)
     HAPPI7=SQCTTF*COS(PHIT1-PCREST)*GI*GI*DGAP*GAP/ &
           ((GI*GI-1.D0)**3.5D0)
     HAPPI8=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GI*GAP*GAP*GAP/ &
           ((GI*GI-1.D0)**4.5D0)
!    n=1
     HAPPI=HAPPI+T1(I)*XCC1*(-6.D0*HAPPI1+15.D0*HAPPI2-3.D0*HAPPI3 - &
     3.D0*HAPPI4 +15.D0*HAPPI5 +30.D0*HAPPI6 +30.D0*HAPPI7 -105.D0*HAPPI8)
!
!    INTEGRAL OF HBPI(Z) (to be multiplied by (ph1i-ph10)**2 )
     HBPI1=SQCTTF*SIN(PHIT1-PCREST)*GAP*GAP/((GI*GI-1.D0)**2.5D0)
     HBPI2=SQCTTF*SIN(PHIT1-PCREST)*GI*DGAP/((GI*GI-1.D0)**2.5D0)
     HBPI3=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAP*GAP/ &
           ((GI*GI-1.D0)**3.5D0)
!    n=1
     HBPI=HBPI+T1(I)*XCC1*(-3.D0*HBPI1-3.D0*HBPI2+15.D0*HBPI3 )
!    INTEGRALS of HBPPI(Z) (to be multiplied by(ph1i-ph10)**3 )/3
     HBPPI1=SQCTTF*SIN(PHIT1-PCREST)*GAP*DGAP/ &
           ((GI*GI-1.D0)**2.5D0)
     HBPPI2=SQCTTF*SIN(PHIT1-PCREST)*GAP*GAP*GAP*GI/ &
           ((GI*GI-1.D0)**3.5D0)
     HBPPI3=SQCTTF*SIN(PHIT1-PCREST)*GAP*DGAP/ &
           ((GI*GI-1.D0)**2.5D0)
     HBPPI4=SQCTTF*SIN(PHIT1-PCREST)*GI*DDGAP/ &
           ((GI*GI-1.D0)**2.5D0)
     HBPPI5=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAP*DGAP/ &
           ((GI*GI-1.D0)**3.5D0)
     HBPPI6=SQCTTF*SIN(PHIT1-PCREST)*GI*GAP**3/ &
           ((GI*GI-1.D0)**3.5D0)
     HBPPI7=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*DGAP*GAP/ &
           ((GI*GI-1.D0)**3.5D0)
     HBPPI8=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GI*GAP*GAP*GAP/ &
           ((GI*GI-1.D0)**4.5D0)
!    n=1
     HBPPI=HAPPI+T1(I)*XCC1*(-6.D0*HBPPI1+15.D0*HBPPI2-3.D0*HBPPI3 - &
     3.D0*HBPPI4 +15.D0*HBPPI5 +30.D0*HBPPI6 +30.D0*HBPPI7 -105.D0*HBPPI8)
   enddo
!    INTEGRALS to be multiplied by cos
   YH1P1=YH1P1/2.D0 *EQVL
   HAPI=HAPI/2.D0 *EQVL
   HAPPI=HAPPI/2.D0 *EQVL
!    INTEGRALS to be multiplied by sin
   YH2P1=YH2P1/2.D0 *EQVL
   HBPI=HBPI/2.D0 *EQVL
   HBPPI=HBPPI/2.D0 *EQVL
END SUBROUTINE xtyplp1
!> *******************************************************************
!! SUBROUTINE xtylpk(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! INTEGRALS of HA0(Z) and HB0(Z)
!! INTEGRALS of the second derivative of HA0(Z) and HB0(Z)
!! zb = z+ASDL
!< *******************************************************************
SUBROUTINE xtylpk(GAMI,SAPHI,QSC,DCG)
   USE DynacConstants
   USE m4cavs
   USE m4mcs
   USE m4beam
   USE m_h_t_h1_t1, ONLY: H1,T1  
   USE m4gaprestay
   USE m4gap, ONLY: YH10PK,YH11PK,YH20PK,YH21PK
   IMPLICIT NONE
   REAL(8) GAMI,SAPHI,QSC,DCG
   REAL(8) CGAM10,DHA01,DHA02,DHB01,DHB02,GAK,GAK1,GAK2,GAK3
   REAL(8) GAP,GAKP,GAKP1,GAKP2,GAKP3,GIC,HAPI1,HAPI2,HAPI3,HBPI1,HBPI2,HBPI3
   REAL(8) PHCRTK,PHIT0K,XINT
   INTEGER i
   REAL(8) BETI,BI,CGI
   REAL(8) DTILK,GAM2,GI,GIS,GIT
   REAL(8) PHIT0,PHIT1,TILTA2,XCC,XCC1
   REAL(8) XK1,FH0
!*******************************************************************
   FH0=FH/VL
   CGI=QSC/XMAT
   GAM2=GAMI**2
   BETI=SQRT(1.D0 - 1.D0/GAM2 )
   XK1=FH0/BETI
   DTILK=EQVL
! CIRCULAIRES EN COS
   YH10PK=0.D0
   YH11PK=0.D0
! CIRCULAIRES EN SIN
   YH20PK=0.D0
   YH21PK=0.D0
   TILTA2=PHSLIP/(2.D0*EQVL)
!   IF(PHSLIP.NE.0.) DESY=PHSLIP/SIN(PHSLIP/2.)
!   IF(PHSLIP.EQ.0.) DESY=2.D0
!2019       IF(abs(PHSLIP).GT.fprec) DESY=PHSLIP/SIN(PHSLIP/2.D0)
!2019       IF(abs(PHSLIP).LE.fprec) DESY=2.D0
   CGAM10=((GAMI*GAMI-1.D0)**1.5D0)/FH0
   PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
   do i=1,17
     XCC= EQVL*(1.D0+H1(I))/2.D0
     XCC1=XCC+ASDL
     IF(XCC1.GT.DCG) EXIT
     PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.D0*EQVL)+PAVPH
!    FONCTION GAMMA (Z)
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
       GIS =  SIN(XCC*TILTA2)
     ELSE
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
       GIS =  XCC/(2.D0*EQVL)
     ENDIF
     GI=GAMI+GIT * GIS
     BI=SQRT(1.D0-1.D0/(GI*GI))
!    Derivative of G0(Z) in relation with: PH01
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GAP=-CGI*SQCTTF*SIN(PHIT0-PCREST)*GIS/PHSLIP
     ELSE
       GAP = SIN(PHIT0-PCREST)*GIS
       GAP = -CGI * SQCTTF* GAP
     ENDIF
!    Derivative of G0(Z) in relation with the equivalent K
     PHIT0K=-DTILK*(1.D0-XCC/EQVL)/2.D0
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIC =COS(XCC*TILTA2)
       GAK1=DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
       GAK2=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
       GAK3=DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.D0*PHSLIP*EQVL)
       GAK =CGI * SQCTTF* (-GAK1-GAK2+GAK3)
     ELSE
       GAK1=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
       GAK =-CGI * SQCTTF* GAK1
     ENDIF
!    derivative of G0(Z) in relation with the equivalent k and the phase PHI
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIC = COS(XCC*TILTA2)
       GAKP1=DTILK*SIN(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
       GAKP2=COS(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
       GAKP3=DTILK*SIN(PHIT0-PCREST)*XCC*GIC/(2.D0*PHSLIP*EQVL)
       GAKP =CGI * SQCTTF* (GAKP1-GAKP2-GAKP3)
     ELSE
       GAKP1 = COS(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
       GAKP = -CGI * SQCTTF* GAKP1
     ENDIF
!    INTEGRALS of HA0(Z) and HB0(Z)
     XINT=1.D0/(BI*BI*BI*GI*GI*GI)
     PHIT1=PHIT0+XCC*PHSLIP/(2.D0*EQVL)
!    INTEGRALES DERIVE HA0(Z) HB0(Z)  k0 ET PHI
     DHA01=SQCTTF*COS(PHIT1-PCREST)*GAP/((GI*GI-1.D0)**2.5D0)
     DHA02=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAP/ &
           ((GI*GI-1.D0)**3.5D0)
     DHB01=SQCTTF*SIN(PHIT1-PCREST)*GAP/((GI*GI-1.D0)**2.5D0)
     DHB02=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAP/ &
           ((GI*GI-1.D0)**3.5D0)
!    n=1
     YH10PK=YH10PK+T1(I)*XCC1*CGAM10*(3.D0*DHA01-15.D0*DHA02)
     YH20PK=YH20PK+T1(I)*XCC1*CGAM10*(3.D0*DHB01-15.D0*DHB02)
!    Integrals of HA(Z) (multiplied by (ph1i-ph10)*(kmi-km0)
     HAPI1=SQCTTF*COS(PHIT1-PCREST)*GAP*GAK/((GI*GI-1.D0)**2.5D0)
     HAPI2=SQCTTF*COS(PHIT1-PCREST)*GI*GAKP/((GI*GI-1.D0)**2.5D0)
     HAPI3=SQCTTF*COS(PHIT1-PCREST)*GI*GI*GAP*GAK/ &
           ((GI*GI-1.D0)**3.5D0)
!    n=1
     YH11PK=YH11PK+T1(I)*XCC1*(-3.D0*HAPI1-3.D0*HAPI2+15.D0*HAPI3)
!    Integrals of HB(Z) (multiplied by (ph1i-ph10)*(kmi-km0)
     HBPI1=SQCTTF*SIN(PHIT1-PCREST)*GAP*GAK/((GI*GI-1.D0)**2.5D0)
     HBPI2=SQCTTF*SIN(PHIT1-PCREST)*GI*GAKP/((GI*GI-1.D0)**2.5D0)
     HBPI3=SQCTTF*SIN(PHIT1-PCREST)*GI*GI*GAP*GAK/ &
           ((GI*GI-1.D0)**3.5D0)
!    n=1
     YH21PK=YH21PK+T1(I)*XCC1*(-3.D0*HBPI1-3.D0*HBPI2+15.D0*HBPI3)
   enddo
!Cosinus integrals
   YH10PK=YH10PK/2.D0 *EQVL
   YH11PK=YH11PK/2.D0 *EQVL
!Sinus integrals
   YH20PK=YH20PK/2.D0 *EQVL
   YH21PK=YH21PK/2.D0 *EQVL
END SUBROUTINE xtylpk
!> *******************************************************************
!! SUBROUTINE xtypj(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! INTEGRALS of g(G)*Ez(**2) *z**n   n=0,1,2
!< *******************************************************************
SUBROUTINE xtypj(GAMI,SAPHI,QSC,DCG)
   USE DynacConstants
   USE m4cavs
   USE m4mcs
   USE m4beam
   USE m_h_t_h1_t1, ONLY: H1,T1  
   USE m4gaprestay
   USE m4gap, ONLY: YFSK0,YFSK1,YFSK2,YFSP0,YFSP1,YFSP2,YFSKC0,YFSKC1, &
       YFSKC2,YFSCK0,YFSCK1,YFSCK2,YFSCP0,YFSCP1,YFSCP2,YFS0,YFS1,YFS2
   IMPLICIT NONE
   REAL(8) GAMI,SAPHI,QSC,DCG
   REAL(8) HA0,HB0,PHTZ0,XFK1
   REAL(8) CGAM10,GAK,GAK1,GAK2,GAK3
   REAL(8) GAP,GIC
   REAL(8) PHCRTK,PHIT0K,XINT
   INTEGER i
   REAL(8) BETI,BI,CGI
   REAL(8) DTILK,GAM2,GI,GIS,GIT
   REAL(8) PHIT0,PHIT1,TILTA2,XCC,XCC1
   REAL(8) XK1,FH0
!*******************************************************************
   FH0=FH/VL
   CGI=QSC/XMAT
   GAM2=GAMI**2
   BETI=SQRT(1.D0-1.D0/GAM2)
   XK1=FH0/BETI
   DTILK=EQVL
   YFS0=0.D0
   YFS1=0.D0
   YFS2=0.D0
   YFSKC0=0.D0
   YFSKC1=0.D0
   YFSKC2=0.D0
   YFSK0=0.D0
   YFSK1=0.D0
   YFSK2=0.D0
   YFSCK0=0.D0
   YFSCK1=0.D0
   YFSCK2=0.D0
   YFSCP0=0.D0
   YFSCP1=0.D0
   YFSCP2=0.D0
   YFSP0=0.D0
   YFSP1=0.D0
   YFSP2=0.D0
   TILTA2=PHSLIP/(2.D0*EQVL)
!  IF(PHSLIP.NE.0.) DESY=PHSLIP/SIN(PHSLIP/2.)
!  IF(PHSLIP.EQ.0.) DESY=2.D0
!2019       IF(abs(PHSLIP).GT.fprec) DESY=PHSLIP/SIN(PHSLIP/2.D0)
!2019       IF(abs(PHSLIP).LE.fprec) DESY=2.D0
   CGAM10=((GAMI*GAMI-1.D0)**1.5D0)/FH0
   PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
   do i=1,17
     XCC= EQVL*(1.D0+H1(I))/2.D0
     XCC1=XCC+ASDL
     IF(XCC1.GT.DCG) EXIT
     PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.D0*EQVL)+PAVPH
!    Function GAMMA (Z)
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
       GIS =  SIN(XCC*TILTA2)
     ELSE
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
       GIS =  XCC/(2.D0*EQVL)
     ENDIF
     GI=GAMI+GIT * GIS
     BI=SQRT(1.D0-1.D0/(GI*GI))
!    Derivative of G0(Z) with regard to the average k
     PHIT0K=-DTILK*(1.D0-XCC/EQVL)/2.D0
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIC =COS(XCC*TILTA2)
       GAK1=DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
       GAK2=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
       GAK3=DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.D0*PHSLIP*EQVL)
       GAK =CGI * SQCTTF* (-GAK1-GAK2+GAK3)
     ELSE
       GAK1=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
       GAK =-CGI * SQCTTF* GAK1
     ENDIF
     PHIT1=PHIT0+XCC*PHSLIP/(2.D0*EQVL)
     PHTZ0=(XCC/EQVL-0.5D0)*DTILK
     XINT=(GI*GI+2.D0)/((GI*GI-1.D0)**2)
     XFK1=2.D0*GI*(1.D0-2.D0*(GI*GI+2.D0)/(GI*GI-1.D0))/((GI*GI-1.D0)**2)
     HA0=COS(PHIT1-PCREST)
     HB0=SIN(PHIT1-PCREST)
!n=0
     YFS0=YFS0+T1(I)*HA0*HA0*XINT
     YFSKC0=YFSKC0-T1(I)*HA0*HA0*XFK1*CGAM10
     YFSK0=YFSK0+T1(I)*HA0*HA0*XFK1*GAK
     YFSCK0=YFSCK0-2.D0*T1(I)*HA0*HB0*XINT*(PHTZ0-PHCRTK)
!n=1
     YFS1=YFS1+T1(I)*HA0*HA0*XINT*XCC
     YFSKC1=YFSKC1-T1(I)*HA0*HA0*XFK1*CGAM10*XCC
     YFSK1=YFSK1+T1(I)*HA0*HA0*XFK1*GAK*XCC
     YFSCK1=YFSCK1-2.D0*T1(I)*HA0*HB0*XINT*(PHTZ0-PHCRTK)*XCC
!n=2
     YFS2=YFS2+T1(I)*HA0*HA0*XINT*XCC*XCC
     YFSKC2=YFSKC2-T1(I)*HA0*HA0*XFK1*CGAM10*XCC*XCC
     YFSK2=YFSK2+T1(I)*HA0*HA0*XFK1*GAK*XCC*XCC
     YFSCK2=YFSCK2-2.D0*T1(I)*HA0*HB0*XINT*(PHTZ0-PHCRTK)*XCC*XCC
!  Derivative of G0(Z) with regard to PH01
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GAP = -CGI*SQCTTF*SIN(PHIT0-PCREST)*GIS/PHSLIP
     ELSE
       GAP=SIN(PHIT0-PCREST)*GIS
       GAP=-CGI*SQCTTF*GAP
     ENDIF
!n=0
     YFSP0=YFSP0+T1(I)*XFK1*GAP*HA0*HA0
     YFSCP0=YFSCP0-2.D0*T1(I)*XINT*HA0*HB0
!n=1
     YFSP1=YFSP1+T1(I)*XFK1*GAP*HA0*HA0*XCC
     YFSCP1=YFSCP1-2.D0*T1(I)*XINT*HA0*HB0*XCC
!n=2
     YFSP2=YFSP2+T1(I)*XFK1*GAP*HA0*HA0*XCC*XCC
     YFSCP2=YFSCP2-2.D0*T1(I)*XINT*HA0*HB0*XCC*XCC
   enddo
!   IST=IAST
   YFS0=YFS0/2.D0 *EQVL
   YFS1=YFS1/2.D0 *EQVL
   YFS2=YFS2/2.D0 *EQVL
   YFSKC0=YFSKC0/2.D0 *EQVL
   YFSKC1=YFSKC1/2.D0 *EQVL
   YFSKC2=YFSKC2/2.D0 *EQVL
   YFSK0=YFSK0/2.D0 *EQVL
   YFSK1=YFSK1/2.D0 *EQVL
   YFSK2=YFSK2/2.D0 *EQVL
   YFSCK0=YFSCK0/2.D0 *EQVL
   YFSCK1=YFSCK1/2.D0 *EQVL
   YFSCK2=YFSCK2/2.D0 *EQVL
   YFSCP0=YFSCP0/2.D0 *EQVL
   YFSCP1=YFSCP1/2.D0 *EQVL
   YFSCP2=YFSCP2/2.D0 *EQVL
   YFSP0=YFSP0/2.D0 *EQVL
   YFSP1=YFSP1/2.D0 *EQVL
   YFSP2=YFSP2/2.D0 *EQVL
END SUBROUTINE xtypj
!> *******************************************************************
!! SUBROUTINE xtypm(GAMI,SAPHI,QSC,DCG)
!! called by RESTAY and ETGAP
!! INTEGRALS of g(G)*z**n  with n=0,1,2
!< *******************************************************************
SUBROUTINE xtypm(GAMI,SAPHI,QSC,DCG)
   USE DynacConstants
   USE m4cavs
   USE m4mcs
   USE m4beam
   USE m_h_t_h1_t1, ONLY: H1,T1  
   USE m4gaprestay
   USE m4gap, ONLY: YNSK0,YNSK1,YNSK2,YNSP0,YNSP1,YNSP2,YNSK0C,YNSK1C, &
                    YNSK2C,YNS0,YNS1,YNS2
   IMPLICIT NONE
   REAL(8) GAMI,SAPHI,QSC,DCG
   REAL(8) XNK1
   REAL(8) CGAM10,GAK,GAK1,GAK2,GAK3
   REAL(8) GAP,GIC
   REAL(8) PHCRTK,PHIT0K,XINT
   INTEGER i
   REAL(8) BETI,BI,CGI
   REAL(8) DTILK,GAM2,GI,GIS,GIT
   REAL(8) PHIT0,TILTA2,XCC,XCC1
   REAL(8) XK1,FH0
!*******************************************************************
   FH0=FH/VL
   CGI=QSC/XMAT
   DTILK=EQVL
   YNS0=0.D0
   YNS1=0.D0
   YNS2=0.D0
   YNSK0C=0.D0
   YNSK1C=0.D0
   YNSK2C=0.D0
   YNSK0=0.D0
   YNSK1=0.D0
   YNSK2=0.D0
   YNSP0=0.D0
   YNSP1=0.D0
   YNSP2=0.D0
   GAM2=GAMI**2
   BETI=SQRT(1.D0-1.D0/GAM2)
   XK1=FH0/BETI
   TILTA2=PHSLIP/(2.D0*EQVL)
!   IF(PHSLIP.NE.0.) DESY=PHSLIP/SIN(PHSLIP/2.)
!   IF(PHSLIP.EQ.0.) DESY=2.D0
!2019       IF(abs(PHSLIP).GT.fprec) DESY=PHSLIP/SIN(PHSLIP/2.D0)
!2019       IF(abs(PHSLIP).LE.fprec) DESY=2.D0
   CGAM10=((GAMI*GAMI-1.D0)**1.5D0)/FH0
   PHCRTK=(T1K*SK-S1K*TK)/(TK*TK+SK*SK)
   do i=1,17
     XCC= EQVL*(1.D0+H1(I))/2.D0
     XCC1=XCC+ASDL
     IF(XCC1.GT.DCG) EXIT
     PHIT0=SAPHI-PHSLIP*(EQVL-XCC)/(2.D0*EQVL)+PAVPH
!    Function GAMMA (Z)
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIT=CGI * SQCTTF*COS(PHIT0-PCREST)/PHSLIP
       GIS=SIN(XCC*TILTA2)
     ELSE
       GIT = CGI * SQCTTF*COS(PHIT0-PCREST)
       GIS =  XCC/(2.D0*EQVL)
     ENDIF
     GI=GAMI+GIT * GIS
     BI=SQRT(1.D0-1.D0/(GI*GI))
!    Derivative of G0(Z) with regard to the average k
     PHIT0K=-DTILK*(1.D0-XCC/EQVL)/2.D0
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GIC =COS(XCC*TILTA2)
       GAK1=DTILK*COS(PHIT0-PCREST)*GIS/(PHSLIP*PHSLIP)
       GAK2=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)/PHSLIP
       GAK3=DTILK*COS(PHIT0-PCREST)*XCC*GIC/(2.D0*PHSLIP*EQVL)
       GAK=CGI * SQCTTF* (-GAK1-GAK2+GAK3)
     ELSE
       GAK1=SIN(PHIT0-PCREST)*GIS*(PHIT0K-PHCRTK)
       GAK =-CGI * SQCTTF* GAK1
     ENDIF
     XINT=(GI*GI+2.D0)/((GI*GI-1.D0)**2)
     XNK1=2.D0*GI*(1.D0-2.D0*(GI*GI+2.D0)/(GI*GI-1.D0))/((GI*GI-1.D0)**2)
!n=0
     YNS0=YNS0+T1(I)*XINT
     YNSK0C=YNSK0C-T1(I)*XNK1*CGAM10
     YNSK0=YNSK0+T1(I)*XNK1*GAK
!n=1
     YNS1=YNS1+T1(I)*XINT*XCC
     YNSK1C=YNSK1C-T1(I)*XNK1*CGAM10*XCC
     YNSK1=YNSK1+T1(I)*XNK1*GAK*XCC
!n=2
     YNS2=YNS2+T1(I)*XINT*XCC*XCC
     YNSK2C=YNSK2C-T1(I)*XNK1*CGAM10*XCC*XCC
     YNSK2=YNSK2+T1(I)*XNK1*GAK*XCC*XCC
!  DERIVE G0(Z) RELATIF A PH01
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       GAP = -CGI*SQCTTF*SIN(PHIT0-PCREST)*GIS/PHSLIP
     ELSE
       GAP=SIN(PHIT0-PCREST)*GIS
       GAP=-CGI*SQCTTF*GAP
     ENDIF
     YNSP0=YNSP0+T1(I)*XNK1*GAP
     YNSP1=YNSP1+T1(I)*XNK1*GAP*XCC
     YNSP2=YNSP2+T1(I)*XNK1*GAP*XCC*XCC
   enddo
   YNS0=YNS0/2.D0 *EQVL
   YNS1=YNS1/2.D0 *EQVL
   YNS2=YNS2/2.D0 *EQVL
   YNSK0C=YNSK0C/2.D0 *EQVL
   YNSK1C=YNSK1C/2.D0 *EQVL
   YNSK2C=YNSK2C/2.D0 *EQVL
   YNSK0=YNSK0/2.D0 *EQVL
   YNSK1=YNSK1/2.D0 *EQVL
   YNSK2=YNSK2/2.D0 *EQVL
   YNSP0=YNSP0/2.D0 *EQVL
   YNSP1=YNSP1/2.D0 *EQVL
   YNSP2=YNSP2/2.D0 *EQVL
END SUBROUTINE xtypm
!*********************************************************************
! Beam line elements start here
!*********************************************************************
!
!> *******************************************************************
!! SUBROUTINE drift(dl)
!! DRIFT LENGHT (cm)
!! space charge computation at the middle of the drift
!< *******************************************************************
SUBROUTINE drift(dl)
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4FENE
   USE m4ITVOLE
   USE m4ble, ONLY: iemgrw,iemqesg   
   IMPLICIT NONE
   REAL(8) dl,bpai,dg2,F2,F4,fcpi,FH0,gpai,tcog
   REAL(8) vpai
   INTEGER i,il,ilost
   character(len=8) :: PRTLAB
   character(len=256) :: wfile
   logical fromrfq
!*******************************************************************
   ilost=0
   FH0=FH/VL
   fcpi=fh*180.D0/pi
   write(16,*) '********************************'
   write(16,*)'*** DRIFT of length ',dl,' cm'
!   if(itvol)write(16,10) ttvols*fcpi,davtot
!   10  FORMAT(' ** tof for adjustments at input: ',e12.5, &
!              ' deg at position: ',e12.5,' cm in the lattice')
   if(itvol)write(16,'(A,e12.5,A,e12.5,A)') ' ** tof for adjustments at input: ', &
            ttvols*fcpi,' deg at position: ',davtot,' cm in the lattice'
!  STATISTICS
   IF(IPRF.EQ.1) then
     ELNAM(IPRF)=trim(uden)   
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
! check if a .dst file is requested at the input
   if (nodflocs.gt.0) then
     do i=1,nodflocs
!       write(16,*) ' DBX1: ',trim(dflnames(i)),' DBX2: ',trim(adjustl(UDEN))  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then
         write(16,*) i,'ELEMENT NAME: ',uden           
         if(idflio(i).eq.1 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_in.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at input of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif
!   random error in position only if dl is positif
!    Beam at the half drift
   dg2=dl/2.D0
! 2016-Nov-04 test
!
!       bref=vref/vl
!       gref=sqrt(1./(1.D0-bref*bref))
!       R56ref=dg2/(gref*gref)
!       write(97,*) 'DRIFT,test ',dg2
!       write(97,*) 'DRIFT, R56 ',R56ref
   do i=1,ngood
!   conversion mrad ===> rad
     F2=F(3,I)*.001D0
     F4=F(5,I)*.001D0
     F(2,I)=F(2,I)+DG2*TAN(F2)
     F(4,I)=F(4,I)+DG2*TAN(F4) / COS(F2)
     gpai=f(7,i)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     vpai=vl*bpai
     f(6,i)=f(6,i)+dg2/(vpai*cos(f2)*cos(f4))
!! 2016-Nov-04 new
!         SF5=dg2/(cos(f2)*cos(f4))
!         R56SF6=(FD(i)-1.D0)*SF5/(bpai2*gpai2)
!         R56SF6=SF5/(gpai*gpai)
!         R56SF6=(FD(i))*SF5/(gpai*gpai)
!         F(6,i)=F(6,i)+(SF5+R56SF6)/VPAI
!         F(6,i)=F(6,i)+(SF5)/VPAI
   enddo
!  ENVEL
!  start prints in file 'short.data'
   davtot=davtot+dl
   if(dl.gt. 0.D0) then
!     nlength=nlength+1
     idav=idav+1
     iitem(idav)=7
     dav1(idav,1)=dl*10.D0
     dav1(idav,4)=davtot*10.D0
   endif
!  Space charge   (if dl >1.D-04)
   if(ichaes.and.dl.ge.1.D-04) then
     if(int(sce10).eq.3) then
       iesp=.true.
       write(16,'(A)') ' Space charge at the middle  '
       call cesp(dl)
       iesp=.false.
!  Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
     endif
   endif
! Test window after the first half drift
   tref=tref+dl/(vref*2.D0)
   PRTLAB='DRIFT   '
   call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
   il=ilost
!  Beam for the second half drift
   do i=1,ngood
     f2=f(3,i)*.001D0
     f4=f(5,i)*.001D0
     f(2,i)=f(2,i)+dg2*tan(f2)
     f(4,i)=f(4,i)+dg2*tan(f4) / cos(f2)
     gpai=f(7,i)/xmat
     if(gpai.lt.1.D0) gpai=1.D0     
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     vpai=vl*bpai
     if(vpai.gt.0.0D0) f(6,i)=f(6,i)+dg2/(vpai*cos(f2)*cos(f4))
! 2016-Nov-04 new
!         SF5=dg2/(cos(f2)*cos(f4))
!         R56SF6=(FD(i)-1.D0)*SF5/(gpai*gpai)
!         R56SF6=(FD(i))*SF5/(gpai*gpai)
!         R56SF6=SF5/(gpai*gpai)
!         F(6,i)=F(6,i)+(SF5+R56SF6)/VPAI
!         F(6,i)=F(6,i)+(SF5)/VPAI
   enddo
! Test window after the second half drift (only in transverse directions and phase)
   tref=tref+dl/(vref*2.D0)
   call reject(ilost,PRTLAB)
   il=il+ilost
!  Change the reference and the TOF
   if(itvol) ttvols=tref
   if(dl.gt. 0.D0)then
     dav1(idav,36)=DBLE(ngood)
!  envelope
     PRLAB(IPRF)='DRIFT   '
     ELNAM(IPRF)=trim(uden)     
     call stapl(davtot*10.D0)
   endif
   tcog=0.D0
   do i=1,ngood
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   if(itvol) then
     write(16,'(A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A)') ' ** tof for adjustments : ', &
       ttvols*fcpi,' deg at position: ',davtot,' cm in the lattice', &
       '    tof of the reference: ',tref*fcpi,' deg tof of the cog: ',tcog*fcpi,' deg'
   else
     write(16,'(A,e12.5,A,e12.5,A)') ' ** tof of the reference: ',tref*fcpi, &
       ' deg tof of the cog: ',tcog*fcpi,' deg'
   endif
   write(16,*) 'particles lost in drift: ',il
   if(iemgrw.and.dl.gt. 0.D0) then
     if(iemqesg.eq.2) call emiprt(0)
   endif
! check if a .dst file is requested at the output
   if (nodflocs.gt.0) then
     do i=1,nodflocs
!       write(16,*) ' DBX1: ',trim(dflnames(i)),' DBX2: ',trim(adjustl(UDEN))  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then
         write(16,*) i,'ELEMENT NAME: ',uden           
         if(idflio(i).eq.2 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_out.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at output of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif                      
END SUBROUTINE drift
!> *******************************************************************
!! SUBROUTINE fdrift(xl,npart,imit)
!! DIVIDE A DRIFT LENGHT OF :XL CM  IN :NPART PARTIAL DRIFTS
!! This will allow several space charge computations in the drift
!< *******************************************************************
SUBROUTINE fdrift(xl,npart,imit)
   IMPLICIT NONE
   REAL(8) xl,dl
   INTEGER npart,imit,i
!*******************************************************************
   dl=xl/DBLE(npart)
   do i=1,npart
     call drift(dl)
     if(imit.ne.0) call emiprt(0)
   enddo
END SUBROUTINE fdrift
!> *******************************************************************
!! SUBROUTINE fldsol(dbs,step)
!! solenoidal field
!< *******************************************************************
SUBROUTINE fldsol(dbs,step)
   USE DynacConstants, ONLY: VL,PI,RPEL,FPREC
   USE m4beam, ONLY: XMAT,QST,f,ngood
   USE m4FENE
   USE mCOMsole   
   IMPLICIT NONE
   REAL(8) dbs,step
   REAL(8) b,bpai,gpai,ri,xmco
   INTEGER ii,ilost
   character(len=8) :: PRTLAB
!*******************************************************************
   l=step
   b=dbs
   gpai=0.D0
   do ii=1,ngood
    gpai=gpai+f(7,ii)/xmat
   enddo
   gpai=gpai/DBLE(ngood)
   bpai=sqrt(1.D0-1.D0/(gpai*gpai))
   xmco=xmat*bpai*gpai
   ri=33.356D0*xmco*1.D-01/qst
   ko = b /ri
   IF(abs(KO) .LE. fprec) KO=1.D-16
   kl = ko*l
! half step
!omment       kl=kl/2.D0
   call clear
   call elsol
   do ii=1,ngood
!   **********
     call clear
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     RI=33.356D0*XMCO*1.D-01/f(9,ii)
     KO = B /RI
     IF(KO .EQ. 0.) KO=1.D-16
     kl=ko*l
     call elsol
!   ***************
     call cobeam(ii,l)
!     evolution of the t.o.f has been made in the routine cobeam
!omment         f(6,ii)=f(6,ii)+step/(bpai*vl)
   enddo
! test window after the step (only in the transverse directions)
   call cogetc
   PRTLAB='FSOLE   '
   call reject(ilost,PRTLAB)
END SUBROUTINE fldsol
!> *******************************************************************
!! SUBROUTINE mfordre(rc,ra,rb)
!! Calculates RC=RA*RB
!< *******************************************************************
SUBROUTINE mfordre(rc,ra,rb)
   IMPLICIT NONE
   REAL(8)  RA(6,6), RB(6,6), RC(6,6), GHOST
   INTEGER I1,I2,I3       
!*******************************************************************
   DO I1 = 1, 6
     DO I2 = 1, 6
       GHOST = 0.D0
       DO I3 = 1, 6
         GHOST = GHOST + RA(I1,I3)*RB(I3,I2)
       ENDDO
       RC(I1,I2) = GHOST
     ENDDO
   ENDDO
END SUBROUTINE mfordre
!> *******************************************************************
!! SUBROUTINE solfield(bcret,intgr)
!! Solenoid with an arbitrary magnetic field
!< *******************************************************************
SUBROUTINE solfield(bcret,intgr)
   USE DynacConstants
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4plots
   USE m4output
   USE m4mcs
   USE m4tmatrix
   USE m4spacecharge
   USE fun4rfq, ONLY : spline     
   USE m4SPLfun
   USE m4FENE
   USE m4ble
   IMPLICIT NONE
   REAL(8) bcret
   REAL(8) fh0,temp
   REAL(8) bsol,bisol,bisol2,crest,davti,dscm,dscm2,dsol,fnpas,skl,xlsol,zc,zcf,zcf2
   REAL(8) zinf,zsup
   INTEGER intgr
   INTEGER i,ilost
   INTEGER ncord,ia,ib,npas
   LOGICAL fromrfq
   REAL(8) rs(6,6),rcul(6,6)
   character(len=256) :: wfile
!*******************************************************************
!    print out on terminal of transport element # on one and the same line
   NRTRE=NRTRE+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
   write(16,*) '    SOLENOID NAME : ',UDEN
! check if a .dst file is requested at the input
   if (nodflocs.gt.0) then
     do i=1,nodflocs  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then          
         if(idflio(i).eq.1 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_in.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at input of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif             
!       read the magnetic field from file
   read(25,*) ncord
   if(ncord.eq.0) then
    rewind(25)
    read(25,*)ncord
   endif
   crest=0.D0
   do i=1,ncord
    read(25,*) xspl(i),yspl(i)
    if(yspl(i).gt.crest) crest=yspl(i)
   enddo
   zinf=xspl(1)
   zsup=xspl(ncord)
   call deriv2(ncord)
   npas=intgr
   dsol=(zsup-zinf)/DBLE(npas)
   xlsol=(zsup-zinf)*100.D0
   write(16,'(5x,A,f7.3,A,/,5x,A,f10.4,A,/,5x,A,f10.4,/)') 'Field length =',xlsol,' cm ', &
     'Crest of the field =',crest,' kG' ,'Attenuation factor =',bcret
   FH0=FH/VL
!  random errors in alignment
   if(ialin) call randali
! test window
   ilost=0
!      PLOT
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
!  start prints in file 'short.data'
   idav=idav+1
   iitem(idav)=5
   dav1(idav,1)=xlsol*10.D0
   dav1(idav,2)=crest*bcret
   davti=davtot
   davtot=davtot+xlsol
   dav1(idav,4)=davtot*10.D0
   zc=zinf
   iesp=.true.
   do ia=1,6
     do ib=1,6
      if(ia.eq.ib) rcul(ia,ib)=1.D0
      if(ia.ne.ib) rcul(ia,ib)=0.D0
     enddo
   enddo
   bisol=0.D0
   bisol2=0.D0
   fnpas=DBLE(npas)
   do i=1,npas
     zcf=zc+dsol
     zcf2=zc+dsol/2.D0
     bsol=bcret*spline(ncord,zcf2)
     dscm=dsol*100.D0
     tref=tref+xlsol/(vref*fnpas)
     call fldsol(bsol,dscm)
     write(16,'(1x,A,i2,A,f7.5,A,f7.5,A,e12.5)') &
       '** STEP: ',i,' LIMITS: inf(m)= ',zc,' sup(m)= ',zcf,' AVERAGE FIELD(kG): ',bsol
     bisol=bisol+bsol*dsol
     bisol2=bisol2+bsol*bsol*dsol
!    save equivalent transport matrix
     do ia=1,6
       do ib=1,6
         rs(ia,ib)=rcul(ia,ib)
       enddo
     enddo
     call mfordre(rcul,r,rs)
!   ************TEST******************
!   print first order matrix
!omment         write(16,*) ' EQUIVALENT FIRST order MATRIX TRANSFORM (m-rad)'
!omment       skl=0.5D0*acos(2.D0*r(1,1)-1.D0)*57.29578
!omment       write(16,*) '**** K*LENGTH: ',skl,' degrees'
!omment       DO IA=1,6
!omment        write(16,100) (r(ia,ib),ib=1,6)
!omment       ENDDO
!omment        write(16,*) '*******cumul***************'
!omment         DO IA=1,6
!omment         write(16,100) (rcul(ia,ib),ib=1,6)
!omment         ENDDO
!      **********END TEST********************
!  SPACE CHARGE
     if(.not.iesp) then
       iesp=.true.
     else
       if(ichaes.and.xlsol.gt. 0.D0) then
         if(int(sce10).eq.1 .or. int(sce10).eq.3) then
           dscm2=dscm*2.D0
           call cesp(dscm2)
           iesp=.false.
!     dispersion dE/E with respect to the C.O.G of the bunch
           call disp
         endif
       endif
     endif
!  envelope sol
     write(16,*) 'distance',davti,dsol
     davti=davti+dsol*100.D0
     PRLAB(IPRF)='FSOLE   '
     ELNAM(IPRF)=trim(uden)
     call stapl((davti)*10.D0)
     zc=zcf
   enddo
   write(16,'(/,4(1x,A,e12.5,/))') &
     'Field length                 (m): ',zc, &
     'Field integral            (kG.m): ',bisol, &
     'Field squared integral (kG**2.m): ',bisol2, &
     'Field squared integral/L (kG**2): ',bisol2/zc
!   print first order matrix
   write(16,*) ' EQUIVALENT FIRST order MATRIX TRANSFORM (m-rad)'
   temp=2.D0*rcul(1,1)-1.D0
   if(temp.lt.-1.D0) temp=-1.D0
!   skl=0.5D0*acos(2.D0*rcul(1,1)-1.D0)*180.D0/pi
   skl=0.5D0*acos(temp)*180.D0/pi
   write(16,*) ' ******* K*LENGTH: ',skl,' degrees'
   DO IA=1,6
     write(16,'(6(3x,e12.5))') (rcul(ia,ib),ib=1,6)
   ENDDO
! **************************************************
!   evolution of the t.o.f of the reference (moved inside loop - Alt)
!       TREF=TREF+XLSOL/VREF
   dav1(idav,36)=DBLE(ngood)
!  plots
   PRLAB(IPRF)='FSOLE   '
   ELNAM(IPRF)=trim(uden)   
   CALL STAPL(davtot*10.D0)
   if(iemgrw) call emiprt(0)
   WRITE(16,*) 'Particles lost in solenoid',ilost
! check if a .dst file is requested at the output
   if (nodflocs.gt.0) then
     do i=1,nodflocs  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then          
         if(idflio(i).eq.2 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_out.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at output of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif             
END SUBROUTINE solfield
!> *******************************************************************
!! SUBROUTINE solnoid(imks,arg,xlsol)
!! SOLENOID (fringe-fields are included in the transport matrix)
!!          space charge computations at the middle of the lens
!!     IMKS: IFLAG (see ARG)
!!     ARG:  IMKS = 0 then ARG is K (cm-1), otherwise ARG is the
!!           field BSOL (kG)
!!     XLSOL : EFFECTIVE LENGHT (CM )
!< *******************************************************************
SUBROUTINE solnoid(imks,arg,xlsol)
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4tmatrix
   USE m4FENE
   USE m4ITVOLE
   USE m4ble
   USE mCOMsole   
   IMPLICIT NONE
   REAL(8) xlsol,arg,dg,xkql
   REAL(8) b,bcour,bpa,bpai,fcpi,fh0,gcour,gpa,gpai
   REAL(8) tcog,wcg,xmco,ri
   INTEGER i,imks,ii,ilost
   LOGICAL fromrfq
   character(len=8) :: PRTLAB
   character(len=256) :: wfile
!*******************************************************************
   NRTRE=NRTRE+1
! print out on terminal of transport element # on one and the same line
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
   write(16,*) ' ****** SOLENOID *********'
   write(16,*) '    SOLENOID NAME : ',UDEN       
! check if a .dst file is requested at the input
   if (nodflocs.gt.0) then
     do i=1,nodflocs  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then          
         if(idflio(i).eq.1 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_in.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at input of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif      
!  PLOT
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
   ilost=0
   FH0=FH/VL
   fcpi=fh*180.D0/pi
!  random errors in alignment
   if(ialin) call randali
!    print out transport matrix (cog)
   gpa=0.D0
   do ii=1,ngood
    gpa=gpa+f(7,ii)/xmat
   enddo
   gpa=gpa/DBLE(ngood)
   l=xlsol
   bpa=sqrt(1.D0-1.D0/(gpa*gpa))
   xmco=xmat*bpa*gpa
   ri=33.356D0*xmco*1.D-01/qst
   if(imks.ne.0) then
!    ARG is the field B (kG)
     b=arg
!    KO = 2 * K (see ELSOL)
     KO = B /RI
     IF(abs(KO) .LE. fprec) KO=1.D-16
   else
!    ARG is the strength K (cm-1)
!    KO = 2 * K (see ELSOL)
     ko = 2.D0*arg
     IF(abs(KO) .LE. fprec) KO=1.D-16
     b=ko*ri
   endif
   KL = KO*L
   call clear
   call elsol
!   xkql=(kl/2.D0)*57.29578D0
   xkql=kl*90.D0/pi
! trace3d
   kt3t=kt3t+1
   write(tif,'(A,i4,A,i4,A,f12.5,A,f9.5)') &
     '  nt(',kt3t,')= 5, a(1,',kt3t,')= ',B*1000.D0,' , ',10.D0*XLSOL
   trace3t(kt3t)=tif
!
   WRITE(16,'(A,f7.3,A,/,A,f10.4,A,/,A,e12.5,A,/,A,e12.5,A,/,A,e12.5,A,/)') &
     '  LENGTH = ',XLSOL,' CM ','  FIELD = ',B,' KG' ,'  K = ',ko/2.D0,' cm-1', &
     '  MOMENTUM = ',ri,' kG.cm','  TRANSVERSE COORDINATES ROTATION = ',xkql,' deg'
   call matrix
   write(16,'(A,e12.5,A,e12.5,A)') ' ** time of flight (input): ',ttvols*fcpi, &
            ' deg  position: ',davtot,' cm'
!  start prints in file 'short.data'
   idav=idav+1
   iitem(idav)=5
   dav1(idav,1)=xlsol*10.D0
   dav1(idav,2)=b
   dav1(idav,3)=ko/2.D0
   davtot=davtot+xlsol
   dav1(idav,4)=davtot*10.D0
   dav1(idav,5)=ri
! first half solenoid
   dg=xlsol
   l=xlsol/2.D0
   do ii=1,ngood
     call clear
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     RI=33.356D0*XMCO*1.D-01/f(9,ii)
     KO = B /RI
     IF(abs(KO) .LE. fprec) KO=1.D-16
     KL = KO*L
     CALL ELSOL
     CALL cobeam(ii,l)
! evolution of the t.o.f is made in routine cbeam
!omment         f(6,ii)=f(6,ii)+l/(bpai*vl)
   enddo
!  space charge computations (only if l >0)
   if(ichaes.and.l.gt.0.D0) then
     if(int(sce10).eq.1 .or. int(sce10).eq.3) then
       iesp=.true.
       write(16,'(A)') ' Space charge at the middle  '
       call cesp(xlsol)
       iesp=.false.
! Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
     endif
   endif
! test window after the first half solenoid
   call cogetc
   bcour=0.D0
   do i=1,ngood
     gpai=f(7,i)/xmat
     bcour=sqrt(1.D0-1.D0/(gpai*gpai))+bcour
   enddo
   bcour=bcour/DBLE(ngood)
   gcour=1.D0/sqrt(1.D0-bcour*bcour)
   wcg=(gcour-1.D0)*xmat
! ----- window control
   tref=tref+xlsol/(vref*2.D0)
   PRTLAB='SOLENO  '
   call reject(ilost,PRTLAB)
!  second half solenoid
   do ii=1,ngood
     CALL CLEAR
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     RI=33.356D0*XMCO*1.D-01/f(9,ii)
     KO = B /RI
     IF(abs(KO) .LE. fprec) KO=1.D-16
     KL = KO*L
     CALL ELSOL
     CALL cobeam(ii,l)
   enddo
!      t.o.f
   TREF=TREF+XLSOL/(VREF*2.D0)
   call reject(ilost,PRTLAB)
   if(itvol) ttvols=tref
   tcog=0.D0
   do i=1,ngood
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   if(itvol) then
     write(16,'(A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A)') ' ** tof for adjustments : ', &
       ttvols*fcpi,' deg at position: ',davtot,' cm in the lattice', &
       '    tof of the reference: ',tref*fcpi,' deg tof of the cog: ',tcog*fcpi,' deg'         
   else
         write(16,'(A,e12.5,A,e12.5,A)') ' ** tof of the reference: ',tref*fcpi, &
                 ' deg tof of the cog: ',tcog*fcpi,' deg'
   endif
   dav1(idav,36)=DBLE(ngood)
!   plots
   PRLAB(IPRF)='SOLENO  '
   CALL STAPL(davtot*10.D0)
   if(iemgrw) call emiprt(0)
   WRITE(16,*) 'Particles lost in solenoid',ilost
! check if a .dst file is requested at the output
   if (nodflocs.gt.0) then
     do i=1,nodflocs  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then          
         if(idflio(i).eq.2 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_out.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at output of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif             
END SUBROUTINE solnoid
!> *******************************************************************
!! SUBROUTINE elsol
!! first order and second order R and T solenoid matrix
!< *******************************************************************
SUBROUTINE elsol
   USE m4tmatrix
   USE mCOMsole   
   IMPLICIT NONE
   REAL(8) SN,CS,SAKO,SAL,TEMP
!   COMMON /BLOC11/ R(6,6), T(6,6,6)
!*******************************************************************
!  PURE SOLENOID FIELD, MATRIX R AND T  ARE IN  (M,RD)
!  SAVE KO AND L
   SAKO=KO
   SAL=L
!  convert (cm,rd) ==> (m,rd)
   KO=KO*100.D0
   L=L*1.D-02
   SN  = SIN(KL)
   CS  = COS(KL)
   R(4,4)  =  0.5D0 + 0.5D0*CS
   R(3,3)   = R(4,4)
   R(2,2)   = R(4,4)
   R(1,1)   = R(4,4)
   R(1,4)    =   (1.D0- CS)/KO
   R(3,2)    =  -R(1,4)
   R(4,1)    =  0.25D0*KO*(1.D0- CS)
   R(2,3)    =  -R(4,1)
   R(4,2)    =  -0.5D0*SN
   R(3,1)    =  R(4,2)
   R(2,4)    =  -R(3,1)
   R(1,3)    =  R(2,4)
   R(3,4)    =  R(1,3)*2.D0/KO
   R(1,2)    =  R(3,4)
   R(4,3)    =  -0.25D0*KO*SN
   R(2,1)    =  R(4,3)
! see element 16;  3.  in TRANSPORT USER MANUAL for SM (here: SM=0)
!omment       R(5,6) = R(5,6)  +  L * SM**2/(RI**2 + SM**2)
   IF(ISEOR) THEN
     TEMP = 0.5D0*KO*L*SN
     T(1,1,6) = TEMP
     T(2,2,6) = TEMP
     T(3,3,6) = TEMP
     T(4,4,6) = TEMP
     T(1,2,6) = SN/KO - L*CS
     T(3,4,6) = T(1,2,6)
     TEMP = - 0.5D0*KO*L*CS
     T(1,3,6) = TEMP
     T(2,4,6) = TEMP
     T(4,2,6) = - TEMP
     T(3,1,6) = - TEMP
     T(1,4,6) = (1.D0 - CS)/KO - L*SN
     T(3,2,6) = -T(1,4,6)
     T(2,1,6) = 0.25D0*KO*(KO*L*CS + SN)
     T(4,3,6) =T(2,1,6)
     T(2,3,6) = 0.25D0*KO*(1.D0 - CS + KO*L*SN)
     T(4,1,6) = - T(2,3,6)
     T(5,2,2) =  0.5D0*L
     T(5,4,4) =  0.5D0*L
   ENDIF
!  RESTORE KO AND L
   KO=SAKO
   L=SAL
!
!  PATH LENGTH TERMS
! see element 16;  3.  in TRANSPORT USER MANUAL for SM here one takes: SM=0
!omment  T(5,6,6) = T(5,6,6) - L*(SM**2 + 1.5D0*RI**2)*SM**2/
!omment     1 (SM**2 + RI**2)**2
!omment  T(5,5,6) = SM**2/(SM**2 + RI**2)
END SUBROUTINE elsol
!> *******************************************************************
!! SUBROUTINE elsq
!! FIRST AND SECOND order MATRIX R AND T  (m,rd)
!!      quadrupole field combined with a solenoid field
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE REAL UNLESS
!!                OTHERWIZE DECLARED *********
!< *******************************************************************
SUBROUTINE elsq
   USE m4tmatrix
   USE DynacConstants, ONLY: fprec
   USE mCOMslq   
   IMPLICIT NONE
   REAL(8) AL,AKQ,AKS,AKQ4,AKS2,AKS3,AKS4,AKS5,AKS6,Q2,Q2I
   REAL(8) SK1,SK3,AIBC2,AIBS2,AISC2,AISCBC,AISCBS,AISS2,AISSBC,AISSBS
   REAL(8) SS,SC,BS,BC,SKP,SKM,SKP2,SKP3,SKP4,SKP5,SKP6,SKM2,SKM3,SKM4,SKM5,SKM6
   REAL(8) DAKS,DAKS2,DAKS3,DAKS4,DSC
   REAL(8) DAKQ,DAKQ4,AISSSC,AIBSBC,DSKM,DSKM2,DSKM3,DSKP2,DSKP3,DBC,DBS
   REAL(8) DQ2,DQ2I,DSK1,DSK3,DSKP,DSS,Q2I2,Q4I
!      COMMON/RIGID/BORO
!      COMMON /BLOC11/ R(6,6), T(6,6,6)
!      COMMON/SECDR/ISEOR
!      LOGICAL ISEOR
!*******************************************************************
   AL=L*1.D-02
   AKQ= KQO*1.D4
   AKS= KSO*1.D2
   AKS=AKS/2.D0
   AKQ4=AKQ*AKQ
   AKS2=AKS*AKS
   AKS3=AKS2*AKS
   AKS4=AKS2*AKS2
   Q2=DSQRT(AKQ4+4.D0*AKS4)
   Q2I=1.D00/Q2
   SK1=SQRT(2.D0*AKS2+Q2)
   SK3=SQRT(ABS(Q2-2.D0*AKS2))
   SS=SIN(SK1*AL)
   SC=COS(SK1*AL)
   BS=SINH(SK3*AL)
   BC=COSH(SK3*AL)
   SKP=0.5D0*(SK1+SK3)
   SKM=0.5D0*(SK1-SK3)
   SKP2=SKP*SKP
   SKP3=SKP2*SKP
   SKM2=SKM*SKM
   SKM3=SKM2*SKM
   R(1,1)=Q2I*(SKP2*SC+SKM2*BC)
   R(1,2)=Q2I*(SKP*SS-SKM*BS)
   R(1,3)=Q2I*AKS*(SKM*SS+SKP*BS)
   R(1,4)=Q2I*AKS*(BC-SC)
   R(2,1)=Q2I*(-SKP3*SS-SKM3*BS)
   R(2,2)=Q2I*(SKP2*SC+SKM2*BC)
   R(2,3)=Q2I*AKS3*(SC-BC)
   R(2,4)=Q2I*AKS*(SKP*SS-SKM*BS)
   R(3,1)=Q2I*AKS*(SKM*BS-SKP*SS)
   R(3,2)=Q2I*AKS*(SC-BC)
   R(3,3)=Q2I*(SKM2*SC+SKP2*BC)
   R(3,4)=Q2I*(SKM*SS+SKP*BS)
   R(4,1)=Q2I*AKS3*(BC-SC)
   R(4,2)=Q2I*AKS*(-SKM*SS-SKP*BS)
   R(4,3)=Q2I*(SKP3*BS-SKM3*SS)
   R(4,4)=Q2I*(SKM2*SC+SKP2*BC)
   IF(.NOT.ISEOR) RETURN
   DAKS=-AKS
   DAKQ=-AKQ
   DAKQ4=2.D0*AKQ*DAKQ
   DAKS2=2.D0*AKS*DAKS
   DAKS3=3.D0*AKS2*DAKS
   DAKS4=4.D00*AKS3*DAKS
   DQ2=0.5D0*Q2I*(DAKQ4+4.D0*DAKS4)
   Q2I2=Q2I*Q2I
   DQ2I=-Q2I2*DQ2
   DSK1=(2.D0*DAKS2+DQ2)/(2.D0*SK1)
   DSK3=0.D0
 !  IF(SK3.NE.6.*0)DSK3=(DQ2-2.D0*DAKS2)/(2.D0*SK3)
   IF(abs(SK3).GT.fprec)DSK3=(DQ2-2.D0*DAKS2)/(2.D0*SK3)
   DSS=SC*DSK1*AL
   DSC=-SS*DSK1*AL
   DBS=BC*DSK3*AL
   DBC=BS*DSK3*AL
   DSKP=0.5D0*(DSK1+DSK3)
   DSKM=0.5D0*(DSK1-DSK3)
   DSKP2=2.D0*SKP*DSKP
   DSKP3=3.D0*SKP2*DSKP
   DSKM2=2.D0*SKM*DSKM
   DSKM3=3.D0*SKM2*DSKM
   T(1,1,6)=DQ2I*(SKP2*SC+SKM2*BC)+ &
    Q2I*(DSKP2*SC+SKP2*DSC+DSKM2*BC+SKM2*DBC)
   T(1,2,6)=DQ2I*(SKP*SS-SKM*BS)+ &
    Q2I*(DSKP*SS+SKP*DSS-DSKM*BS-SKM*DBS)
   T(1,3,6)=(DQ2I*AKS+Q2I*DAKS)*(SKM*SS+SKP*BS) &
    +Q2I*AKS*(DSKM*SS+SKM*DSS+DSKP*BS+SKP*DBS)
   T(1,4,6)=(DQ2I*AKS+Q2I*DAKS)*(BC-SC) &
    +Q2I*AKS*(DBC-DSC)
   T(2,1,6)=DQ2I*(-SKP3*SS-SKM3*BS) &
    +Q2I*(-DSKP3*SS-SKP3*DSS-DSKM3*BS-SKM3*DBS)
   T(2,2,6)=T(1,1,6)
   T(2,3,6)=(DQ2I*AKS3+Q2I*DAKS3)*(SC-BC) &
    +Q2I*AKS3*(DSC-DBC)
   T(2,4,6)=(DQ2I*AKS+Q2I*DAKS)*(SKP*SS-SKM*BS) &
    +Q2I*AKS*(DSKP*SS+SKP*DSS-DSKM*BS-SKM*DBS)
   T(3,1,6)=-T(2,4,6)
   T(3,2,6)=-T(1,4,6)
   T(3,3,6)=DQ2I*(SKM2*SC+SKP2*BC) &
    +Q2I*(DSKM2*SC+SKM2*DSC+DSKP2*BC+SKP2*DBC)
   T(3,4,6)=DQ2I*(SKM*SS+SKP*BS) &
    +Q2I*(DSKM*SS+SKM*DSS+DSKP*BS+SKP*DBS)
   T(4,1,6)=-T(2,3,6)
!omment      AMAT(17,4,MATADR)=-AMAT(21,1,MATADR)
   T(4,2,6)=-T(1,3,6)
   T(4,3,6)=DQ2I*(SKP3*BS-SKM3*SS) &
    +Q2I*(DSKP3*BS+SKP3*DBS-DSKM3*SS-SKM3*DSS)
   T(4,4,6)=T(3,3,6)
   AISSSC=0.D0
!   IF(SK1.NE.0.0)AISSSC=SS*SS/(2.D0*SK1)
   IF(abs(SK1).GT.fprec)AISSSC=SS*SS/(2.D0*SK1)
   AIBSBC=0.D0
!   IF(SK3.NE.0.0)AIBSBC=BS*BS/(2.D0*SK3)
   IF(abs(SK3).GT.fprec)AIBSBC=BS*BS/(2.D0*SK3)
   AISSBC=Q2I*(SK3*SS*BS-SK1*SC*BC+SK1)
   AISCBS=Q2I*(SK3*SC*BC+SK1*SS*BS-SK3)
   AISS2=0.D0
   AISC2=AL
   AIBS2=0.D0
   AIBC2=AL
!   IF(SK1.NE.0.0)AISS2=0.5D0*(AL-SS*SC/SK1)
!   IF(SK1.NE.0.0)AISC2=0.5D0*(AL+SS*SC/SK1)
   IF(abs(SK1).GT.fprec)AISS2=0.5D0*(AL-SS*SC/SK1)
   IF(abs(SK1).GT.fprec)AISC2=0.5D0*(AL+SS*SC/SK1)
!   IF(SK3.NE.0.0)AIBS2=0.5D0*(BS*BC/SK3 - AL)
!   IF(SK3.NE.0.0)AIBC2=0.5D0*(AL+BS*BC/SK3)
   IF(abs(SK3).GT.fprec)AIBS2=0.5D0*(BS*BC/SK3 - AL)
   IF(abs(SK3).GT.fprec)AIBC2=0.5D0*(AL+BS*BC/SK3)
   AISSBS=Q2I*(SK3*SS*BC-SK1*SC*BS)
   AISCBC=Q2I*(SK1*SS*BC+SK3*SC*BS)
   AKS5=AKS4*AKS
   AKS6=AKS5*AKS
   SKP4=SKP3*SKP
   SKP5=SKP4*SKP
   SKP6=SKP5*SKP
   SKM4=SKM3*SKM
   SKM5=SKM4*SKM
   SKM6=SKM5*SKM
   Q4I=Q2I*Q2I
   T(5,1,1)=Q4I*0.5D0*(SKP6*AISS2+SKM6*AIBS2-2.D0*SKP3*SKM3 &
      *AISSBS+AKS6*(AISC2+AIBC2-2.D0*AISCBC))
   T(5,1,2)=Q4I*(-SKP5*AISSSC-SKP3*SKM2*AISSBC &
         -SKM3*SKP2*AISCBS &
         -SKM5*AIBSBC-AKS4*(-SKM*AISSSC-SKP*AISCBS+ &
         SKM*AISSBC+SKP*AIBSBC))
   T(5,1,3)=Q4I*AKS3*((SKP3-SKM3)*(AISSBC-AISSSC) &
     +(SKP3+SKM3)*(AIBSBC-AISCBS))
   T(5,1,4)=Q4I*(AKS*(-SKP4*AISS2-(SKP3*SKM+SKM3*SKP)*AISSBS &
     +SKM4*AIBS2)+AKS3*(-SKM2*AISC2-(SKP2-SKM2)*AISCBC+SKP2*AIBC2))
   T(5,2,2)=Q4I*0.5D0*(SKP4*AISC2+2.D0*SKP2*SKM2*AISCBC &
     +SKM4*AIBC2+AKS2*(SKM2*AISS2+2.D0*SKP*SKM*AISSBS+SKP2*AIBS2))
   T(5,2,3)=Q4I*(AKS3*(SKP2*AISC2-(SKP2-SKM2)*AISCBC &
     -SKM2*AIBC2)-AKS*(-SKM4*AISS2+(SKM*SKP3-SKP*SKM3)*AISSBS+ &
     SKP4*AIBS2))
   T(5,2,4)=Q4I*AKS*((SKP3-SKM3)*AISSSC-(SKP2*SKM+SKP*SKM2) &
     *AISCBS+(SKM2*SKP-SKM*SKP2)*AISSBC-(SKM3+SKP3)*AIBSBC)
   T(5,3,3)=Q4I*0.5D0*(AKS6*(AISC2-2.D0*AISCBC+AIBC2) &
     +SKM6*AISS2-2.D0*SKM3*SKP3*AISSBS+SKP6*AIBS2)
   T(5,3,4)=Q4I*(AKS4*(SKP*AISSSC-SKM*AISCBS-SKP*AISSBC &
     +SKM*AIBSBC)-SKM5*AISSSC-SKM3*SKP2*AISSBC+SKP3*SKM2*AISCBS &
     +SKP5*AIBSBC)
   T(5,4,4)=Q4I*0.5D0*(AKS2*(SKP2*AISS2-2.D0*SKP*SKM*AISSBS &
    +SKM2*AIBS2)+SKM4*AISC2+2.D0*SKM2*SKP2*AISCBC+SKP4*AIBC2)
END SUBROUTINE elsq
!> *******************************************************************
!! SUBROUTINE deflect(fdtot)
!! Electrostatic deflector: Transport matrix
!! first order transport matrix (M,RD)
!!     drad: horizontal deflector radius (cm)
!!     l: length of the central trajectory (cm)
!!     kx2, ky2: matrix terms arguments (cm-2)
!!     avb: average relativistic beta
!!        in this routine drad, l kx2, ky2 are converted to m
!! With matrix elements from F.Hinterberger to Triumf note TRI-DN-05-7
!< *******************************************************************
SUBROUTINE deflect(fdtot)
   USE m4tmatrix, ONLY: R
   USE DynacConstants, ONLY: fprec
   USE mCOMedef
   IMPLICIT NONE
   REAL(8) fdtot,SX,SY,CX,CY,SXP,SYP,h,h2,AL,ARGX,ARGY,KX,KY,avg,avb2,avg2,dx,dxp
!*******************************************************************
! --- convert drad, kx2 , ky2 in m
   h=100.D0/drad
   h2=h*h
   AL=L*1.D-02
   KX2=KX2*1.D4
   KY2=KY2*1.D4
   KX=SQRT(ABS(KX2))
   KY=SQRT(ABS(KY2))
   ARGX=KX*AL
   ARGY=KY*AL
   avb2=avb*avb
   avg=sqrt(1.D0-avb2)
   avg=1.D0/avg
   avg2=avg*avg
   dx=(2.D0-avb2)*h/kx
   dxp=(2.D0-avb2)*h/kx2
! ***** variante:(???)
!      dx=h/kx
!      dxp=h/kx2
! ************************
!  kx2 < 0
   IF (kx2 .lt. 0.D0) then
     CX=COSH(ARGX)
     SX=SINH(ARGX)/KX
     SXP=sinh(argx)*kx
! ---------------------------------
!    First order Matrix R (plane (X,XP)
     R(1,1)=CX
     R(1,2)=SX
     R(1,6)=DXP*(1.D0-cx)
     R(2,1)=SXP
     R(2,2)=CX
     R(2,6)=DX*SX*KX
     R(5,1)=-DX*SX*KX
     R(5,2)=-DXP*(1.D0-CX)
     R(5,5)=1.D0
     R(5,6)=fdtot*AL/avg2-(2.D0-avb2)*DXP*H*(AL-SX)
     R(6,6)=1.D0
   ENDIF
!  kx2 > 0
   IF (kx2 .GT. 0.D0) then
     CX=COS(ARGX)
     SX=SIN(ARGX)/KX
     SXP=sin(argx)*kx
!    First order Matrix R (plane (X,XP)
     R(1,1)=CX
     R(1,2)=SX
     R(1,6)=DXP*(1.D0-cx)
     R(2,1)=-SXP
     R(2,2)=CX
     R(2,6)=DX*SX*KX
     R(5,1)=DX*SX*KX
     R(5,2)=DXP*(1.D0-CX)
     R(5,5)=1.D0
     R(5,6)=fdtot*AL/avg2-(2.D0-avb2)*DXP*H*(AL-SX)
     R(6,6)=1.D0
   ENDIF
!  kx2 = 0
   IF (abs(kx2).le.fprec) then
     R(1,1)=1.D0
     R(1,2)=AL
     R(1,6)=0.D0
     R(2,1)=0.D0
     R(2,2)=1.D0
     R(2,6)=L*H*(2.D0-avb2)
     R(5,1)=-L*H*(2.D0-avb2)
     R(5,2)=0.D0
     R(5,5)=1.D0
     R(5,6)=AL/avg2
   ENDIF
! ky2 < 0
   IF (ky2 .lt. 0.D0) then
     CY=COSH(ARGY)
     SY=SINH(ARGY)/KY
     SYP=sinh(argy)*ky
     R(3,3)=CY
     R(3,4)=SY
     R(4,3)=SYP
     R(4,4)=CY
   ENDIF
! ky2 > 0
   IF (ky2 .GT. 0.D0) then
     CY=COS(ARGY)
     SY=SIN(ARGY)/KY
     SYP=sin(argy)*ky
     R(3,3)=CY
     R(3,4)=SY
     R(4,3)=-SYP
     R(4,4)=CY
   ENDIF
!  ky2 = 0
   IF (abs(ky2).le.fprec) then
     CY=1.D0
     SY=AL
     SYP=0.D0
     R(3,3)=CY
     R(3,4)=SY
     R(4,3)=SYP
     R(4,4)=CY
   ENDIF
END SUBROUTINE deflect
!> *******************************************************************
!! SUBROUTINE e_deflec
!! characteristics of the deflector (central trajectory)
!! input parameters
!!   nsector: nombre of sectors in the deflector
!!   rm0: radial radius (cm)
!!   devtot: bend angle (deg)
!!   radii: vertical (radial) radii of curvature (cm)
!!   elecf: nominal electric field
!!   characteristics of the synchronous particle
!!   wt0 :total energy (MeV)
!!   qst: electric charge
!< *******************************************************************
 SUBROUTINE e_deflec
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4tmatrix
   USE m4FENE
   USE m4ITVOLE, ONLY: ITVOL,ttvols
   USE m4ble
   USE mCOMedef
   IMPLICIT NONE
   REAL(8) gpai,AILONG,DEVI
   REAL(8) bcog,bpai,devr,devtot
   REAL(8) fdtot,gcog,pnsec,r51,rip
   REAL(8) scl,sdavtot
   REAL(8) xlsy
   REAL(8) tcog,wcg
   REAL(8) abet,bd0,ec,edfnom,edr0,oo1,rm0,radii,elecf,rmoy2,wt0,wt0c,efd0,findex,gd0
   INTEGER ist,nii,nsec,nsector
   INTEGER i,ii,ilost
   real(8) xmoy(20),ymoy(20),rmoy(20),rig(20),ncs(20)
   real(8) xpmoy(20),ypmoy(20),avbt(20),charge(20),alp(20)
   character(len=8) :: PRTLAB
!   COMMON/ERIGID/edr0
   LOGICAL sseor
!*******************************************************************
! print out on terminal of transport element # on one and the same line
   NRTRE=NRTRE+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
!  ---- save iseor in sseor
   sseor=iseor
!   iseor = false ---> second ordre transport matrix not available for the deflector
   iseor=.false.
!
   read(in,*) nsector
   read(in,*) rm0,devtot,radii,elecf
   bd0=vref/vl
   gd0=sqrt(1.D0-bd0*bd0)
   gd0=1.D0/gd0
   wt0=gd0*xmat
   wt0c=(wt0-xmat)
!   edr0: electric rigidity (kV)
   edr0=wt0*bd0*bd0*1.D03/qst
!     efd0: radial electric field (in kV/cm)
   efd0=edr0/rm0
   edfnom=efd0
   if(elecf .ge. 0.D0) efd0=elecf
   WRITE(16,'(A,7(/,A,e12.5,A),/)') '    ELECTROSTATIC DEFLECTOR************', &
     '  BENDING RADIUS:  ',RM0,' cm ', &
     '  BEND ANGLE:      ',DEVTOT,' deg', &
     '  VERTICAL RADII OF CURVATURE: ',RADII,' cm', &
     '  RIGIDITY: ',EDR0,' kV ', &
     '  RADIAL ELECTRIC FIELD (nominal): ',EDFNOM,' kV/cm', &
     '  RADIAL ELECTRIC FIELD (applied): ',EFD0,' kV/cm', &
     '  INPUT ENERGY: ',WT0C,' MeV'
   if(ichaes) then
     write(16,*)'***** beam current: ',BEAMC*fhinit/fh,' mA'
     if((iscsp.lt.3).and.(ncstat.gt.1)) then
       write(6,*) '****************************'
       write(6,'(A,/,A)') ' CAUTION: In the case of multiple charge states', &
         ' HERSC and SCHERM can not be used for electrostatic bends'
       write(16,'(A,/,A)') ' CAUTION: In the case of multiple charge states', &
         ' HERSC and SCHERM can not be used for electrostatic bends'
       STOP  
      endif
   endif
!  start prints in file 'short.data'
   findex=1.D0+rm0/radii
   idav=idav+1
   iitem(idav)=21
   dav1(idav,2)=devtot
   dav1(idav,3)=rm0*10.D0
   dav1(idav,5)=radii*10.D0
   dav1(idav,6)=findex
   dav1(idav,7)=edr0
   dav1(idav,8)=efd0*0.1D0
!   convert bend angle in rad
   devtot=devtot*pi/180.D0
   l=devtot*rm0
   dav1(idav,1)=l*10.D0
   sdavtot=davtot
   davtot=davtot+l
   dav1(idav,4)=davtot*10.D0
! --- space charge computation: nsector must be g.t. 1
   if(ichaes.and.(nsector.eq.1) ) nsector = 2
   devi=devtot/DBLE(nsector)
   devr=devtot/DBLE(nsector)
! ----------------------------------------------------------
! -- scl effective length for space charge computation
!     scl is the path length of the C.T. over two following sectors
   scl=2.D0*devi*rm0
   do ist=1,ncstat
    rmoy(ist)=0.D0
    rig(ist)=0.D0
    alp(ist)=devi
   enddo
! -------------------
! ---- nsector: number of sectors in the deflector
   do nsec=1,nsector
!     write(6,*) ' ******** deflector sector ',nsec
     xlsy=devi*rm0
     sdavtot=sdavtot+xlsy
! ------------------------------------------------------------
! --- nsctat: number of charge states in the beam
     do ist=1,ncstat
       charge(ist)=cstat(ist)
       xmoy(ist)=0.D0
       xpmoy(ist)=0.D0
       ymoy(ist)=0.D0
       ypmoy(ist)=0.D0
       ncs(ist)=0
       rig(ist)=0.D0
       avbt(ist)=0.D0
       do i=1,ngood
!         if(int(f(9,i)).eq.int(charge(ist))) then
         if(f(9,i).eq.charge(ist)) then
           xmoy(ist)=xmoy(ist)+f(2,i)
           ymoy(ist)=ymoy(ist)+f(4,i)
           xpmoy(ist)=xpmoy(ist)+f(3,i)
           ypmoy(ist)=ypmoy(ist)+f(5,i)
           gpai=f(7,i)/xmat
           bpai=sqrt(1.D0-1.D0/(gpai*gpai))
           avbt(ist)=avbt(ist)+bpai
!      electric rigidity (kV)
           rip=f(7,i)*bpai*bpai/f(9,i) *1.D3
           rig(ist)=rip+rig(ist)
           ncs(ist)=ncs(ist)+1
         endif
       enddo
       xmoy(ist)=xmoy(ist)/DBLE(ncs(ist))
       ymoy(ist)=ymoy(ist)/DBLE(ncs(ist))
       xpmoy(ist)=xpmoy(ist)/DBLE(ncs(ist))
       ypmoy(ist)=ypmoy(ist)/DBLE(ncs(ist))
       rig(ist)=rig(ist)/DBLE(ncs(ist))
       rmoy(ist)=rig(ist)/efd0
       avbt(ist)=avbt(ist)/DBLE(ncs(ist))
!   dispersion in dp/p relative to the cog of the bunch
       gcog=sqrt(1.D0-avbt(ist)*avbt(ist))
       fdtot=0.D0
       nii=0
       do i=1,ngood
!         if(int(f(9,i)).eq.int(charge(ist))) then
         if(f(9,i).eq.charge(ist)) then
           gpai=f(7,i)/xmat
           bpai=sqrt(1.D0-1.D0/(gpai*gpai))
           fd(i)=(gpai*bpai)/(gcog*avbt(ist))
           fdtot=fdtot+fd(i)
           nii=nii+1
         endif
       enddo
       fdtot=fdtot/DBLE(nii)
! --- local deflector
!       alp(ist): angle of the local deflector
!        parametres kx2 and ky2
!  eq.11
       oo1=rm0-rmoy(ist)+xmoy(ist)
!  eq.10
       abet=oo1*sin(alp(ist))/rmoy(ist)
       abet=asin(abet)
!  eq.12 (angle of the local central trajectory)
       alp(ist)=alp(ist)+abet
!  eq.14 (field index)
       findex=1.D0+rmoy(ist)/radii
!  eq.15 (parameters kx, ky)
       kx2=3.D0-findex-avbt(ist)*avbt(ist)
       rmoy2=rmoy(ist)*rmoy(ist)
       kx2=kx2/rmoy2
       ky2=(findex-1.D0)/rmoy2
! ----  Transport matrix
       devi=alp(ist)
       AILONG=devi*rmoy(ist)
       L=AILONG
!     drad: horizontal deflector radius (cm)
!     l: length of the central trajectory (cm)
!     kx2, ky2: DIMENSIONLESS coefficients depending on the field indice
!     avb: average relativistic beta
       avb=avbt(ist)
       drad=rmoy(ist)
! --- deflector matrix
       WRITE(16,'(/,A,/,A,f9.5,A,/,A)') &
         '  *******************************************', &
         '  *CENTRAL TRAJECTORY for charge: ',charge(ist),' *', &
         '  *******************************************'
       WRITE(16,'(A,i4,A,i5,A,2(/,A,e12.5,A),/,A,e12.5,A,e12.5,A,e12.5,A)') &
         '  SECTOR ',nsec,' OF ',nsector,' SECTORS IN TOTAL', &
         '  RADIAL FIELD:   ',efd0,' kV*cm-1: ', &
         '  RIGIDITY:   ',rig(ist),' kV ', &
         '  FIELD INDEX: ',findex,' PARAMETER Kx: ',kx2, &
         ' cm-2  PARAMETER Ky: ',ky2,' cm-2'
       WRITE(16,'(A,e12.5,A,A,e12.5,A,/,A,e12.5,A,/)') &
         '  BENDING RADIUS:  ',rmoy(ist),' cm ', &
         '  BENDING ANGLE:   ',devi*180.D0/pi,' deg', &
         '  LENGTH: ',AILONG,' cm'
!   CLEAR R AND T
       CALL CLEAR
       CALL deflect(fdtot)
! ---  :print the transport matrix
       call matrix
       r51=r(5,1)
!  ----  transport of particles
       DO II=1,NGOOD
!          if(int(f(9,ii)).eq.int(charge(ist))) then
         if(f(9,ii).eq.charge(ist)) CALL COBEAM(II,L)
       enddo
! ----------------------------------------------------------------------
! --- get back the particles coordinates in the coordinates system of the synchronous particle
!   eq.33
       ec=-rmoy(ist)*cos(abet)-oo1*sin(devi)+rm0
       do ii=1,ngood
!         if(int(f(9,ii)).eq.int(charge(ist))) then
         if(f(9,ii).eq.charge(ist)) then
!   eq.36
           f(2,ii)=f(2,ii)*cos(abet)-ec
!   eq.41
           f(3,ii)=f(3,ii)-abet*1.D3
!   eq.45
           gpai=f(7,ii)/xmat
           bpai=sqrt(1.D0-1.D0/(gpai*gpai))
           f(6,ii)=f(6,ii)+r51*xmoy(ist)/(bpai*vl)
         endif
       enddo
!    enddo for ist (number of charges in the beam)
     enddo
! --------------------------------------------------------------
!  Space charge computation
     if(ichaes) then
! --- check the parity of nsec
       pnsec=DBLE(nsec)/2.D0-DBLE(nsec/2)
!    nsec is odd:---> space charge computation
!      if((pnsec.ne.0.).and.(nsec.lt.nsector)) then
       if((abs(pnsec).gt.fprec).and.(nsec.lt.nsector)) then
         call cesp(scl)
         write(16,*) ' space charge after sector: ',nsec
       endif
     endif
! ------------------------------------------------------------
!  enveloppe
     PRLAB(IPRF)='EDFLEC  '
     CALL STAPL(sdavtot*10.D0)
!  enddo for nsec (sectors numbers)
   enddo
! ------------------------------------------------------
!  random error in alignment
   if(ialin) call randali
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
   call disp
   call cogetc
! --- Test window after the bending magnet
   tcog=0.D0
   gcog=0.D0
   do i=1,ngood
     gcog=gcog+f(7,i)/xmat
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   gcog=gcog/DBLE(ngood)
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   wcg=(gcog-1.D0)*xmat
! devtot: total angle of the deflector (computation of tref)
   devi=devtot
   ailong=devi*rm0
   TREF=TREF+AILONG/VREF
!    ----- window control
   PRTLAB=PRLAB(IPRF)
   call reject(ilost,PRTLAB)
! ---------------------------------------------------
   dav1(idav,36)=DBLE(ngood)
   if(itvol) ttvols=tref
   if(itvol) write(16,*) ' tof for adjustments: ',ttvols,' sec'
   if(iemgrw) call emiprt(0)
!  ---- restore iseor (from sseor)
   iseor=sseor
END SUBROUTINE e_deflec
!> *******************************************************************
!! SUBROUTINE POFAR1(GAP)
!!   POLE FACE ROTATION AT ENTRANCE OR EXIT OF A BENDING MAGNET
!!
!!   H      : INVERSE OF THE MAGNET RADIUS (1./CM)
!!   NB     : DIMENSIONLESS TRANSPORT n coefficient
!!   BDB    : TRANSPORT beta coefficient
!!   APB( ) : HALF GAP (CM)
!!   L      : LENGTH OF THE MAGNET (CM)
!!   BE     : ANGLE OF INLINATION (RAD)
!!   LAYL   : K1 TRANSPORT COEFFICIENT
!!   LAYX   : K2 TRANSPORT COEFFICIENT
!!   RABT   : INVERSE OF THE RADIUS OF CURVATURE (1/CM)
!!
!!   MATRIX R AND T ARE IN (M,RD)
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE OF TYPE REAL
!!                 UNLESS OTHERWIZE DECLARED *********
!< *******************************************************************
SUBROUTINE POFAR1(GAP)
   USE DynacConstants
   USE m4tmatrix
   USE m4aimalv, ONLY : BE, LAYL, LAYX, RABT, H, NB
   IMPLICIT NONE
   REAL(8) GAP,SAH,SARABT,SAGAP,TB,CB,TCOR,BE1,TB1,TB2,SB,SB2,SB3,SEC2
!*******************************************************************
!  SAVE H, GAP AND RABT BEFORE CONVERSION IN M UNITS
   SAH=H
   SARABT=RABT
   SAGAP=GAP
   H=H*100.D0
   GAP=GAP*1.D-02
   RABT=RABT*100.D0
   TB = TAN(BE)
   CB = COS(BE)
   SB = (1.0D0 + SIN(BE)**2)/CB
   TCOR = 2.0D0*H*GAP*LAYL
   BE1 = BE -TCOR* SB* (  1.D0 -LAYX*TCOR * TB )
   TB1  =  TAN(BE1)
   TB2 = TB**2
   R(2,1) = H*TB
   R(4,3) = - H*TB1
   IF(ISEOR) THEN
     SB=1.D0/CB
     SB2 = SB**2
     SB3 = SB2*  SB
     T(1,1,1)=- 0.5D0*H*TB2
     T(1,3,3)=0.5D0*H*SB2
     T(2,1,1)=0.5D0*H*RABT*SB3- TB*NB*H**2
     T(2,1,2)=H*TB2
     T(2,1,6)=-H*TB
     T(2,3,3)=H**2*(NB+0.5D0+TB2)*TB-0.5D0*H*RABT*SB3
     T(2,3,4)=-H*TB2
     T(3,1,3)=H*TB2
     T(4,1,3)=-H*RABT*SB3+2.D0*H**2*NB*TB
     T(4,1,4)=-H*TB2
     T(4,2,3)=-H*SB2
     SEC2=COS(BE1)*COS(BE1)
     SEC2=1.D0/SEC2
     T(4,3,6)=H*TB-H*TCOR*SEC2
   ENDIF
!  RESTORE H , RABT, APB(2)
   H=SAH
   RABT=SARABT
   GAP=SAGAP
END SUBROUTINE POFAR1
!> *******************************************************************
!! SUBROUTINE POFAR2(GAP)
!!         -- POLE FACE ROTATION OF BENDING MAGNET
!!            FIRST AND SECOND order MATRIX R AND T
!!
!!   H      : INVERSE OF THE MAGNET RADIUS (1./CM)
!!   NB     : DIMENSIONLESS TRANSPORT n coefficient
!!   BDB    : TRANSPORT beta coefficient
!!   APB( ) : HALF GAP (CM)
!!   L      : LENGTH OF THE MAGNET (CM)
!!   BE     : ANGLE OF INLINATION (RAD)
!!   LAYL   : K1 TRANSPORT COEFFICIENT
!!   LAYX   : K2 TRANSPORT COEFFICIENT
!!   RABT   : INVERSE OF THE RADIUS OF CURVATURE (1/CM)
!!
!!     SAVE H, GAP AND RABT BEFORE CONVERSION IN M UNITY
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE OF TYPE REAL
!!                 UNLESS OTHERWIZE DECLARED *********
!< *******************************************************************
SUBROUTINE POFAR2(GAP)
   USE DynacConstants
   USE m4tmatrix
   USE m4aimalv, ONLY : BE, LAYL, LAYX, RABT, H, NB
   IMPLICIT NONE
   REAL(8) GAP,SAH,SARABT,SAGAP,TB,CB,TCOR,BE1,TB1,TB2,SB,SB2,SB3,SEC2
!*******************************************************************
   SAH=H
   SARABT=RABT
   SAGAP=GAP
   H=H*100.D0
   GAP=GAP*1.D-02
   RABT=RABT*100.D0
   TB = TAN(BE)
   CB = COS(BE)
   SB = (1.0D0 + SIN(BE)**2)/CB
   TCOR = 2.0D0*H*GAP*LAYL
   BE1 = BE -TCOR* SB* (  1.D0 -LAYX*TCOR * TB )
   TB1  =  TAN(BE1)
   TB2 = TB**2
   R(2,1) = H*TB
   R(4,3) = - H*TB1
   IF(ISEOR) THEN
     SB=1.D0/CB
     SB2 = SB**2
     SB3 = SB2*  SB
     T(1,1,1)=0.5D0*H*TB2
     T(1,3,3)=-0.5D0*H*SB2
     T(2,1,1)=0.5D0*H*RABT*SB3- TB*(NB+0.5D0*TB2)*H**2
     T(2,1,2)=-H*TB2
     T(2,1,6)=-H*TB
     T(2,3,3)=H**2*(NB-0.5D0*TB2)*TB-0.5D0*H*RABT*SB3
     T(2,3,4)=H*TB2
     T(3,1,3)=-H*TB2
     T(4,1,3)=-H*RABT*SB3+H**2*(2.D0*NB+SB2)*TB
     T(4,1,4)=H*TB2
     T(4,2,3)=H*SB2
     SEC2=COS(BE1)*COS(BE1)
     SEC2=1.D0/SEC2
     T(4,3,6)=H*TB-H*TCOR*SEC2
   ENDIF
!  RESTORE H , RABT, APB(2)
   H=SAH
   RABT=SARABT
   GAP=SAGAP
END SUBROUTINE POFAR2
!> *******************************************************************
!! SUBROUTINE BENMAG(sbet,fdtot)
!!     IDEAL MAGNET, MATRIX R AND T ARE IN (M,RD)
!!
!!      H      : INVERSE OF THE MAGNET RADIUS (1./CM)
!!      NB     : DIMENSIONLESS TRANSPORT n coefficient
!!      BDB    : TRANSPORT beta coefficient
!!      APB( ) : HALF GAP (CM)
!!      L      : LENGTH OF THE MAGNET (CM)
!!      BE     : ANGLE OF INLINATION (RAD)
!!      LAYL   : K1 TRANSPORT COEFFICIENT
!!      LAYX   : K2 TRANSPORT COEFFICIENT
!!      RABT   : INVERSE OF THE RADIUS OF CURVATURE (1/CM)
!!
!!  **** WARNING : IN THIS ROUTINE ALL VARIABLES ARE OF TYPE REAL
!!                 UNLESS OTHERWIZE DECLARED *********
!< *******************************************************************
SUBROUTINE BENMAG(sbet,fdtot)
   USE m4tmatrix
   USE DynacConstants, ONLY: fprec
   USE m4aimalv, ONLY : H, NB, BDB,L
   IMPLICIT NONE
   REAL(8) sbet,fdtot
   REAL(8) H2,H3,H4,H5,H6,sgam2,SAH,FIELDN,RAD
   REAL(8) KX,KY,KX2,KY2,KX3,KX4,KX5,KX6,KX7,KY3,KY4
   REAL(8) B,BETA,BN1,BN2,BN3,C,CX,DX,SX,CY,SY,CHX,CHY,CH2X,CH2Y,COS2X,COS2Y,COSX,COSY
   REAL(8) CPX,CPY,DPX,J1XL,ARGX,ARGY,SINX,SHX,SHY,SH2X,SH2Y,SIN2X,SIN2Y,SINY
   REAL(8) A,AL,AL2,AL3,AL4,AL5,AL6,AL7,SPX,SPY,SY2,TARGX,TARGY
   REAL(8) j2xl,j3xl,j4xl,j5xl,j7xl,j9xl,j10xl,j11xl,j12xl,j13xl,j14xl,j15xl,j16xl,j17xl
   REAL(8) j1l,j2l,j3l,j4l,j5l,j6l
   REAL(8) I10,I11,I12,I111,I112,I116,I122,I126,I133,I134,I144,I166
   REAL(8) I20,I21,I22,I26,I27,I211,I212,I216,I222,I226,I233,I234,I244,I266
   REAL(8) I33,I34,I313,I314,I323,I324,I336,I346
   REAL(8) I43,I44,I413,I414,I423,I424,I436,I446
!   INTEGER ist,nii,nsec,nsector,nsprint
!*******************************************************************
! sbet is relativistic beta of the charge state of interest
   sgam2=1.D0/(1.D0-sbet*sbet)
!     SAVE H BEFORE CONVERSION IN m
   SAH=H
   H=H*100.D0
   FIELDN=NB
   BETA=BDB
   AL=L*1.D-02
   RAD=1.0D0/H
   H2=H*H
   H3=H2*H
   H4=H3*H
   H5=H4*H
   H6=H5*H
   KX2=(1.0D0-FIELDN)*H2
   KY2=FIELDN*H2
   KX=SQRT(ABS(KX2))
   KY=SQRT(ABS(KY2))
   KX3=KX2*KX
   ARGX=KX*AL
   ARGY=KY*AL
   SINX=SIN(ARGX)
   SHX=SINH(ARGX)
   AL2=AL*AL
   AL3=AL2*AL
   CX=0.D0
   SX=0.D0
   DX=0.D0
   J1XL=0.D0
   IF (kx2.lt. 0.D0) then
    CX=COSH(ARGX)
    SX=SINH(ARGX)/KX
    DX=H*(1.0D0-CX)/KX2
    J1XL=(ARGX-SHX)/KX3
   ENDIF
!   IF (KX2.EQ.6.*0) THEN
   IF (abs(KX2).LE.fprec) THEN
    CX=1.D0
    SX=AL
    DX=H*AL2/2.0D0
    J1XL=AL3/6.0D0
   ENDIF
   IF (KX2.GT. 0.D0) THEN
    CX=COS(ARGX)
    SX=SIN(ARGX)/KX
    DX=H*(1.0D0-CX)/KX2
    J1XL=(ARGX-SINX)/KX3
   ENDIF
   CPX=-KX2*SX
   SPX=CX
   DPX=H*SX
   CY=0.D0
   SY=0.D0
   IF(KY2.LT. 0.D0) THEN
    CY=COSH(ARGY)
    SY=SINH(ARGY)/KY
   ENDIF
!   IF(KY2.EQ.6.*0) THEN
   IF(abs(KY2).LE.fprec) THEN
    CY=1.0D0
    SY=AL
   ENDIF
   IF(KY2.GT. 0.D0) THEN
    CY=COS(ARGY)
    SY=SIN(ARGY)/KY
   ENDIF
   CPY=-KY2*SY
   SPY=CY
!  First order Matrix R
   R(1,1)=CX
   R(1,2)=SX
   R(1,6)=DX
   R(2,1)=CPX
   R(2,2)=SPX
   R(2,6)=DPX
   R(3,3)=CY
   R(3,4)=SY
   R(4,3)=CPY
   R(4,4)=SPY
   R(5,1)=H*SX
   R(5,2)=DX
   R(5,6)=H2*J1XL
!  Carey eq.2.41 p 34
   R(5,6)=R(5,6)-AL*fdtot/sgam2
! ************************
   IF(ISEOR) THEN
!   Second order Matrix T
     COSX=COS(ARGX)
     CHX=COSH(ARGX)
     KX4=KX2*KX2
     KX6=KX4*KX2
     ARGY=KY*AL
     SINY=SIN(ARGY)
     COSY=COS(ARGY)
     SHY=SINH(ARGY)
     CHY=COSH(ARGY)
     KY3=KY2*KY
     KY4=KY2*KY2
     TARGX=ARGX+ARGX
     SIN2X=SIN(TARGX)
     COS2X=COS(TARGX)
     SH2X=SINH(TARGX)
     CH2X=COSH(TARGX)
     KX3=KX*KX2
     KX5=KX3*KX2
     KX7=KX5*KX2
     TARGY=ARGY+ARGY
     SIN2Y=SIN(TARGY)
     COS2Y=COS(TARGY)
     SH2Y=SINH(TARGY)
     CH2Y=COSH(TARGY)
     AL4=AL3*AL
     AL5=AL4*AL
     AL6=AL5*AL
     AL7=AL6*AL
     C=1.0D0/(KX2-4.0D0*KY2)
     j1l=0.D0
     j2l=0.D0
     j3l=0.D0
     j2xl=0.D0
     j3xl=0.D0
     j4xl=0.D0
     j5xl=0.D0
     j7xl=0.D0
     j9xl=0.D0
     j10xl=0.D0
     j11xl=0.D0
     j12xl=0.D0
     j13xl=0.D0
     j14xl=0.D0
     j15xl=0.D0
     j16xl=0.D0
     j17xl=0.D0
     IF(kx2.gt. 0.D0) THEN
       CX=DCOS(KX*AL)
       SX=DSIN(KX*AL)/KX
       DX=H*(1.0D0-CX)/KX2
       J1XL=(ARGX-SINX)/KX3
       J2XL=(1.0D0-COSX-.5D0*ARGX*SINX)/KX4
       J3XL=0.5D0*(SINX-ARGX*COSX)/KX3
       J4XL=(0.5D0*ARGX-2.0D0*SINX/3.0D0+SIN2X/12.D0)/KX5
       J5XL=(0.25D0-COSX/3.0D0+COS2X/12.0D0)/KX4
       J10XL=(ARGX-1.5D0*SINX+.5D0*ARGX*COSX)/KX5
       J11XL=(-2.0D0*ARGX+3.0D0*SINX-ARGX*COSX)/KX5
       J12XL=(4.0D0*ARGX-5.5D0*SINX+1.5D0*ARGX*COSX)/KX3
       J13XL=(0.75D0-2.0D0*COSX/3.0D0-COS2X/12.0D0-.5D0*ARGX*SINX) &
             /KX6
       J14XL=(1.5D0-4.0D0*COSX/3.0D0-COS2X/6.0D0-ARGX*SINX)/KX6
       J15XL=(-1.75D0+4.0D0*COSX/3.0D0+5.0D0*COS2X/12.0D0+1.5D0*ARGX &
             *SINX)/KX4
       J16XL=(1.5D0*ARGX-7.0D0*SINX/3.0D0-SIN2X/12.0D0+ARGX*COSX)/ &
             KX7
       J17XL=(-1.75D0*ARGX+17.0D0*SINX/6.0D0+5.0D0*SIN2X/24.0D0-1.5D0 &
             *ARGX*COSX)/KX5
       J1L=(0.5D0*ARGX-0.25D0*SIN2X)/KX3
       J2L=(0.5D0*ARGX+0.25D0*SIN2X)/KX
       J3L=.25D0*(1.0D0-COS2X)/KX2
       if(ky2.lt. 0.D0) then
         J7XL=0.5D0*(ARGX-SINX+KX2*C*(SINX-0.5D0*KX*SH2Y/KY))/(KX3*KY2)
         J9XL=C*((COSX-1.0D0)/KX2+(1.0D0-CH2Y)/(4.0D0*KY2))
       endif
!       if(ky2.eq.6.*0) then
       if(abs(ky2).le.fprec) then
         J7XL=(2.0D0*(SINX-ARGX)/KX3+AL3/3.0D0)/KX2
         J9XL=AL2/(2.0D0*KX2)+(COSX-1.0D0)/KX4
       endif
       if(ky2.gt. 0.D0) then
         J7XL=0.5D0*(ARGX-SINX+KX2*C*(SINX-.5D0*KX*SIN2Y/KY))/(KX3*KY2)
         J9XL=C*((COSX-1.0D0)/KX2+(1.0D0-COS2Y)/(4.0D0*KY2))
       endif
!    endif kx2.gt.0.
     ENDIF
     IF (kx2.lt. 0.D0) then
       CX=COSH(KX*AL)
       SX=SINH(KX*AL)/KX
       DX=H*(1.0D0-CX)/KX2
       J1XL=(ARGX-SHX)/KX3
       J2XL=(1.0D0-CHX+.5D0*ARGX*SHX)/KX4
       J3XL=0.5D0*(SHX-ARGX*CHX)/KX3
       J4XL=(0.5D0*ARGX-2.0D0*SHX/3.0D0+SH2X/12.0D0)/KX5
       J5XL=(0.25D0-CHX/3.0D0+CH2X/12.0D0)/KX4
       J10XL=(ARGX-1.5D0*SHX+.5D0*ARGX*CHX)/KX5
       J11XL=(-2.0D0*ARGX+3.0D0*SHX-ARGX*CHX)/KX5
       J12XL=(4.0D0*ARGX-5.5D0*SHX+1.5D0*ARGX*CHX)/KX3
       J13XL=(.75D0-2.0D0*CHX/3.0D0-CH2X/12.0D0+.5D0*ARGX*SHX) &
             /KX6
       J14XL=(1.5D0-4.0D0*CHX/3.0D0-CH2X/6.0D0+ARGX*SHX)/KX6
       J15XL=(-1.75D0+4.0D0*CHX/3.0D0+5.0D0*CH2X/12.0D0-1.5D0*ARGX*SHX) &
             /KX4
       J16XL=(1.5D0*ARGX-7.0D0*SHX/3.0D0-SH2X/12.0D0+ARGX*CHX)/ &
             KX7
       J17XL=(-1.75D0*ARGX+17.0D0*SHX/6.0D0+5.0D0*SH2X/24.0D0-1.5D0 &
             *ARGX*CHX)/KX5
       J1L=(0.5D0*ARGX-0.25D0*SH2X)/KX3
       J2L=(0.5D0*ARGX+0.25D0*SH2X)/KX
       J3L=.25D0*(1.0D0-CH2X)/KX2
       IF(KY2.LT. 0.D0) THEN
         J7XL=0.5D0*(ARGX-SHX+KX2*C*(SHX-0.5D0*KX*SH2Y/KY))/(KX3*KY2)
         J9XL=C*((CHX-1.D0)/KX2+(1.0D0-CH2Y)/(4.0D0*KY2))
       ENDIF
!       IF(KY2.EQ.6.*0) THEN
       if(abs(KY2).le.fprec) then
         J7XL=(2.0D0*(SINX-ARGX)/KX3+AL3/3.0D0)/KX2
         J9XL=AL2/(2.0D0*KX2)+(CHX-1.0D0)/KX4
       ENDIF
       IF(KY2.GT. 0.D0) THEN
        J7XL=0.5D0*(ARGX-SHX+KX2*C*(SHX-0.5D0*KX*SIN2Y/KY))/(KX3*KY2)
        J9XL=C*((CHX-1.0D0)/KX2+(1.0D0-COS2Y)/(4.0D0*KY2))
       ENDIF
!    end kx2.lt.0.
     ENDIF
!        IF (KX2.EQ.6.*0) THEN
     IF(abs(KX2).LE.fprec) THEN
       CX=1
       SX=AL
       DX=H*AL*AL/2.0D0
       J1XL=AL3/6.0D0
       J2XL=AL4/24.0D0
       J3XL=AL3/6.0D0
       J4XL=AL5/60.0D0
       J5XL=AL4/24.0D0
       J7XL=(AL3/12.0D0-AL/(8.0D0*KY2)-SIN2Y/(16.0D0*KY3))/KY2
       J10XL=-AL5/24.0D0
       J11XL=-AL5/60.0D0
       J12XL=AL3/6.0D0
       J9XL=AL2/(8.0D0*KY2)-(1.0D0-COS2Y)/(16.0D0*KY4)
       J13XL=AL6/240.0D0
       J14XL=AL6/1080.0D0
       J15XL=AL4/12.0D0
       J16XL=AL7/840.0D0
       J17XL=AL5/60.0D0
       J1L=AL3/3.0D0
       J2L=AL
       J3L=AL2/2.0D0
!    end kx2.eq.0.
     ENDIF
     CPX=-KX2*SX
     SPX=CX
     DPX=H*SX
     j4l=0.D0
     j5l=0.D0
     j6l=0.D0
     IF (KY2.LT. 0.D0) THEN
       CY=COSH(KY*AL)
       SY=SINH(KY*AL)/KY
       J4L=(.5D0*ARGY-.25D0*SH2Y)/KY3
       J5L=(.5D0*ARGY+.25D0*SH2Y)/KY
       J6L=.25D0*(1.0D0-CH2Y)/KY2
     ENDIF
!     IF (KY2.EQ.6.*0) THEN
     IF(abs(KY2).LE.fprec) THEN
       CY=1.0D0
       SY=AL
       J4L=AL3/3.0D0
       J5L=AL
       J6L=AL2/2.0D0
     ENDIF
     IF (KY2.GT. 0.D0) THEN
       CY=COS(KY*AL)
       SY=SIN(KY*AL)/KY
       J4L=(.5D0*ARGY-.25D0*SIN2Y)/KY3
       J5L=(.5D0*ARGY+.25D0*SIN2Y)/KY
       J6L=.25D0*(1.0D0-COS2Y)/KY2
     ENDIF
     CPY=-KY2*SY
     SPY=CY
     SY2=SY*SY
     A=2.0D0*FIELDN-1.0D0-BETA
     B=(2.0D0-FIELDN)
     BN1=2.0D0*FIELDN-1.0D0-BETA
     BN2=2.5D0*FIELDN-BETA-1.5D0
     BN3=2.0D0*BETA-FIELDN
!  tabulation of the integrals (notations TRANSPORT SLAC R-75 table VIb)
     I10=DX/H
     I11=0.5D0*AL*SX
     I111=1.0D0*(SX**2+DX*RAD)/3.0D0
     I112=SX*DX*RAD/3.0D0
     I133=DX/H-(KY2/(KX2-4.0D0*KY2))*(SY2-2.0D0*DX*RAD)
     I134=C*(SY*CY-SX)
     I144=(SY2-2.0D0*DX*RAD)*C
     I20=SX
     I21=(SX+AL*CX)/2.0D0
     I22=I11
     I211=SX*(1.0D0+2.0D0*CX)/3.0D0
     I212=(2.0D0*SX**2-DX/H)/3.0D0
     I222=2.0D0*SX*DX*RAD/3.0D0
     I233=SX-2.0D0*KY2*(SY*CY-SX)*C
     I234=(KX2*DX*RAD-2.0D0*KY2*SY2)*C
     I244=2.0D0*C*(SY*CY-SX)
     I33=0.5D0*AL*SY
!     IF(KY2.EQ.6.*0) I34=AL3/6.0
!     IF(KY2.NE.6.*0) I34=0.5D0*(SY-AL*CY)/KY2
     IF(abs(KY2).LE.fprec) I34=AL3/6.0D0
     IF(abs(KY2).GT.fprec) I34=0.5D0*(SY-AL*CY)/KY2
     I314=(2.0D0*SX*CY-SY*(1.D0+CX))*C
     I324=C*(2.0D0*CY*DX*RAD-SX*SY)
     I43=0.5D0*(SY+AL*CY)
     I44=I33
     I413=C*((KX2-2.0D0*KY2)*SX*CY-KY2*SY*(1.0D0+CX))
     I414=C*((KX2-2.0D0*KY2)*SX*SY-CY*(1.0D0-CX))
     I424=C*(CY*SX-CX*SY-2.0D0*KY2*SY*DX*RAD)
     I12=(SX-AL*CX)*0.5D0/KX2
     I27=(DX*RAD-.5D0*AL*SX)/KX2
     I313=C*(KX2*CY*DX*RAD-2.0D0*SX*SY*KY2)
     I314=(2.0D0*SX*CY-SY*(1.0D0+CX))*C
     I324=C*(2.0D0*CY*DX*RAD-SX*SY)
     I43=0.5D0*(SY+AL*CY)
     I44=I33
     I413=C*((KX2-2.0D0*KY2)*SX*CY-KY2*SY*(1.0D0+CX))
     I414=C*((KX2-2.0D0*KY2)*SX*SY-CY*(1.0D0-CX))
     I424=C*(CY*SX-CX*SY-2.0D0*KY2*SY*DX*RAD)
!     IF (KX.NE.6.*0) THEN
     IF (abs(KX).GT.fprec) THEN
       I12=(SX-AL*CX)*0.5D0/KX2
       I27=(DX*RAD-.5D0*AL*SX)/KX2
       I116=(0.5D0*AL*SX-(SX**2+DX/H)/3.0D0)*H/KX2
       I122=(2.0D0*DX/H-SX**2)/3.0D0/KX2
       I126=H*(SX+2.0D0*SX*CX-3.0D0*AL*CX)/6.0D0/KX2**2
       I166=H2*(4.0D0*DX*RAD/3.0D0+SX**2/3.0D0-AL*SX)/KX2**2
       I216=H*(AL*CX/2.0D0+SX/6.0D0-2.0D0*SX*CX/3.0D0)/KX2
       I226=H*(0.5D0*AL*SX-2.0D0*SX**2/3.0D0+DX*RAD/3.0D0)/KX2
       I266=H2*(SX/3.0D0+2.0D0*SX*CX/3.0D0-AL*CX)/KX2**2
       I323=C*(2.0D0*KY2*SY*(1.0D0+CX)/KX2-SX*CY)+SY/KX2
       I336=H*(0.5D0*AL*SY-C*(CY*(1.0D0-CX)-2.0D0*KY2*SX*SY))/KX2
       I346=H*(I34-C*(2.0D0*SX*CY-SY*(1.0D0+CX)))/KX2
       I423=C*(2.0D0*KY2*CY*(1.0D0+CX)/KX2-CX*CY-KY2*SX*SY)+CY/KX2
       I436=H*(0.5D0*AL*CY+0.5D0*SY+C*(KY2*SY*(1.0D0+CX) &
            -(KX2-2.0D0*KY2)*SX*CY))/KX2
       I446=H*(AL*SY*0.5D0-C*((KX2-2.0D0*KY2)*SX*SY-CY*(1.0D0-CX)))/KX2
       I26=I12*H
     ELSE
       I12=AL3/6.0D0
       I27=AL4/12.0D0
       I116=H*AL4/24.0D0
       I122=AL4/12.0D0
       I126=H*AL5/40.0D0
       I166=H2*AL2/120.0D0
       I216=H*AL3/6.0D0
       I226=H*AL4/8.0D0
       I266=H2*AL5/20.0D0
       I323=AL2*SY/4.0D0
       I336=H*AL*(AL2*SY/12.0D0+(AL*CY-SY)/(KY2*8.0D0))
       I346=H*AL2*(SY/(KY2*8.0D0)-AL*CY/(KY2*12.0D0))
       I423=(AL2*CY+AL*SY)/4.0D0
       I436=H*AL2*(SY/8.0D0+CY*AL/12.0D0)
       I446=H*AL*(AL2*SY/12.0D0+(SY-AL*CY)/(KY2*8.0D0))
       I26=I12*H
     ENDIF
!     MATRIX T(i,j,k), TRANSPORT SLAC R-75 table VIa
!
     T(1,1,1)=A*H3*I111+0.5D0*KX2**2*I122*H
     T(1,1,2)=2.0D0*A*H3*I112-KX2*H*I112+H*SX
     T(1,1,6)=B*H2*I11+2.0D0*A*H3*I116-KX2*H2*I122
     T(1,2,2)=A*H3*I122+0.5D0*H*I111
     T(1,2,6)=B*H2*I12+2.0D0*A*H3*I126+H2*I112
     T(1,3,3)=BETA*H3*I133-0.5D0*KY2*H*I10
     T(1,3,4)=2.0D0*BETA*H3*I134
     T(1,4,4)=BETA*H3*I144-0.5D0*H*I10
     T(1,6,6)=B*H2*H*I27+A*H3*I166+0.5D0*H3*I122- &
              H*I10
!
     T(2,1,1)=A*H3*I211+0.5D0*KX2**2*H*I222-H*CX*CPX
     T(2,1,2)=H*SPX+2.0D0*A*H3*I212-KX2*H*I212 &
          -H*(CX*SPX+CPX*SX)
     T(2,1,6)=B*H2*I21+2.0D0*A*H3*I216-KX2*H2*I222-H* &
          (CX*DPX+CPX*DX)
     T(2,2,2)=A*H3*I222+0.5D0*H*I211-H*SX*SPX
     T(2,2,6)=B*H2*I22+2.0D0*A*H3*I226+H2*I212 &
           -H*(SX*DPX+SPX*DX)
     T(2,3,3)=BETA*H3*I233-0.5D0*KY2*H*I20
     T(2,3,4)=2.0D0*BETA*H3*I234
     T(2,4,4)=BETA*H3*I244-0.5D0*H*I20
     T(2,6,6)=B*H2*I26+A*H3*I266+0.5D0*H3*I222-H*DX*DPX-H*I20
!
!     VALUE OF "B" IS CHANGED.
!
     B=BETA-FIELDN
!
     T(3,1,3)=2.0D0*B*H3*I313+KX2*KY2*H*I324
     T(3,1,4)=H*SY+2.0D0*B*H3*I314-KX2*H*I323
     T(3,2,3)=2.0D0*B*H3*I323-KY2*H*I314
     T(3,2,4)=2.0D0*B*H3*I324+H*I313
     T(3,3,6)=KY2*I33+2.0D0*B*H3*I336-KY2*H2*I324
     T(3,4,6)=KY2*I34+2.0D0*B*H3*I346+H2*I323
!
     T(4,1,3)=2.0D0*B*H3*I413+KX2*KY2*H*I424-H*CX*CPY
     T(4,1,4)=H*SPY+2.0D0*H3*B*I414-KX2*H*I423-H*CX*SPY
     T(4,2,3)=2.0D0*B*H3*I423-KY2*H*I414-H*SX*CPY
     T(4,2,4)=2.0D0*B*H3*I424+H*I413-H*SX*SPY
     T(4,3,6)=KY2*I43+2.0D0*B*H3*I436-KY2*H2*I424-H*DX*CPY
     T(4,4,6)=KY2*I44+2.0D0*B*H3*I446+H2*I423-H*DX*SPY
!
     T(5,1,1)=H4*(BN1*J1XL-BN2*KX2*J4XL)+0.5D0*KX4*J1L
     T(5,1,2)=H4*2.0D0*BN2*J5XL-KX2*J3L+H*DX
     T(5,1,6)=H5*J11XL+H3*J12XL+H*KX2*J3XL &
      +H5*2.0D0*BN2*J4XL+2.D0*BETA*H5*J10XL-H*KX2*J1L
! Carey eq. 7.45  p.143
     T(5,1,6)=T(5,1,6)-R(5,1)/sgam2
!
     T(5,2,2)=0.5D0*(H2*J1XL+H4*2.0D0*BN2*J4XL+J2L)
     T(5,2,6)=-2.0D0*BETA*H5*J13XL+H5*J14XL+H3*J15XL+H*KX2* &
     J2XL+H*J3L
! Carey eq. 7.45  p.143
     T(5,2,6)=T(5,2,6)-R(5,2)/sgam2
!
     T(5,3,3)=0.5D0*(H4*(BN3*J1XL-2.0D0*BETA*KY2*J7XL)+KY4*J4L)
     T(5,3,4)=2.0D0*BETA*H4*J9XL-KY2*J6L
     T(5,4,4)=BETA*H4*J7XL-0.5D0*(H2*J1XL-J5L)
     T(5,6,6)=(1.0D0-BETA)*H6*J16XL+H4*J17XL-H2*J3XL &
           +0.5D0*H2*J1L
! Carey eq. 7.45  p.143
     T(5,6,6)=T(5,6,6)-R(5,6)/sgam2
     T(5,6,6)=T(5,6,6)+AL*((1.D0/sgam2)**2+1.5D0*sbet*sbet/sgam2)
! Carey eq.7.46 p.143
     T(5,5,6)=-1.D0/sgam2
!  ENDIF Second order Matrix T
   ENDIF
!   RESTORE H
   H=SAH
END SUBROUTINE BENMAG
!> *******************************************************************
!! SUBROUTINE syrout(ii)
!! SYNCHROTRON RADIATION EXCITATION FOR PARTICLE ii
!!
!! The method is described in 'synchrotron radiation in DYNAC'
!!   TRT   : t.o.f in sec for a particle crossing the bending magnet
!!   RMOY  : average radius of the bending magnet in the magnetic plane
!!   XINTF : integral of (u/uc) * S(u/uc) where S(u/uc) is the spectral function
!!            ( see Synchrotron radiation in DYNAC)
!!   CRAE    : classical electron radius (cm)
!!   PGAM  : Instantaneous radiation power (MeV/sec)
!!   ETA   : eta=u/uc
!!   uc    :  critical quanta energy (eV)
!!   u     :  quanta energy (eV) considered
!! The most significant quanta are assumed emitted between: 0.1<eta<3.
!!
!< *******************************************************************
SUBROUTINE syrout(ii)
   USE DynacConstants
   USE m4tmatrix
   USE m4beam, ONLY : f,XMAT
   USE mCOMradia
   IMPLICIT NONE
   REAL(8) e4ii,gpaii,cgam,pgam,elost,dmo
   INTEGER ii
!*******************************************************************
   e4ii=f(7,ii)**4
   gpaii=f(7,ii)/xmat
   cgam=(4.D0*pi/3.D0)*crae/(xmat**3)
   pgam=vl*cgam*e4ii/(2.D0*pi*rmoy*rmoy)
!   ELOST  : Total energy lost due to radiation (MeV)
   elost=xintf*pgam*trt
!  variation of the momentum (only available for relativistic electrons)
   dmo=-elost/f(7,ii)
!  change the total energy (MeV)
   f(7,ii)=f(7,ii)-elost
!  change f(2,ii) and f(3,ii)
!   dmo*r(1,6) is given in m and  dmo*r(2,6) in rad, convert in cm and mrad
   f(2,ii)=f(2,ii)+dmo*r(1,6)*100.D0
   f(3,ii)=f(3,ii)+dmo*r(2,6)*1000.D0
END SUBROUTINE syrout
!> *******************************************************************
!! SUBROUTINE syref
!! SYNCHROTRON RADIATION EXCITATION FROM PARTICLE REFERENCE
!! The method is described in 'synchrotron radiation in DYNAC'
!< *******************************************************************
SUBROUTINE syref
   USE DynacConstants
   USE m4tmatrix
   USE m4beam, ONLY : TREF,VREF,XMAT
   USE m4ITVOLE, ONLY: ITVOL,ttvols
   USE m4aimalv, ONLY : L
   USE mCOMradia
   IMPLICIT NONE
   REAL(8) beref,gamref,ener,e4,elost,fener,cgam,pgam,fgam,fberef
!*******************************************************************
   beref=vref/vl
   gamref=1.D0/sqrt(1.D0-beref*beref)
   ener=xmat*gamref*beref
   trt=l/vref
   e4=ener**4
   cgam=(4.D0*pi/3.D0)*crae/(xmat**3)
   pgam=vl*cgam*e4/(2.D0*pi*rmoy*rmoy)
!   ELOST  : Total energy lost due to radiation (MeV)
!   change vref and tref of the reference
   elost=xintf*pgam*trt
   fener=ener-elost
   fgam=fener/xmat
   fberef=sqrt(1.D0-1.D0/(fgam*fgam))
   vref=fberef*vl
   tref=tref+l/vref
   if(itvol) ttvols=tref
   write(16,'(//,A,/,A,e12.5,/,A,e12.5,/,A,e12.5)') & 
     ' REFERENCE AFTER RADIATION EXCITATION*****', &
     '    ENERGY LOST (MeV):  ',elost, &
     '    OLD ENERGY  (MeV):  ',ener, &
     '    NEW ENERGY  (MeV):  ',fener
!   write(16,250) elost,ener,fener
!  250  format(//,' REFERENCE AFTER RADIATION EXCITATION*****',/, &
!              '    ENERGY LOST (MeV):  ',e12.5,/, &
!              '    OLD ENERGY  (MeV):  ',e12.5,/, &
!              '    NEW ENERGY  (MeV):  ',e12.5)
END SUBROUTINE syref
!> *******************************************************************
!! SUBROUTINE aimalv(ANGL,RMO,BAIM,XN,XB,EK1,EK2,PENT1,RAB1,
!!                   SK1,SK2,PENT2,RAB2)
!! FIRST AND SECOND order Bending Magnet
!! WEDGE BENDING MAGNET
!!   ANGL : DEG  bend angle of the central trajectory
!!   RMO  : CM   radius of curvature of the central trajectory
!!   BAIM : KG   field of the bending magnet
!!     BAIM = 0  the field is computed from the momentum of the
!!               reference; otherwise the momentum is computed from
!!               the field
!!   XN   :      FIELD GRADIENT (dimensionless,TRANSPORT: n)
!!   XB   :      NORMALIZED SECOND DERIVATIVE OF B (TRANSPORT : beta)
!!   AP(1) = AP(2) CM vertical half aperture (only if IPOLE = 0)
!! ENTRANCE FACE
!!  PENT1 EK1 EK2 RAB1
!!   PENT1: DEG   angle of pole face rotation  (deg)
!!   RAB1 : CM    radius of curvature
!!   EK1  :       integral related to the extent of the fringing field
!!                (TRANSPORT K1)
!!   EK2  :       integral related to the extent of the fringing field
!!                (TRANSPORT K2)
!!   AP(1) : CM   vertical half aperture
!! EXIT FACE
!!  PENT2 SK1 SK2  RAB2
!!   PENT2: DEG   angle of pole face rotation
!!   RAB2 : CM  radius of curvature
!!   SK1  :     integral related to the extent of the fringing field
!!   SK2  :     integral related to the extent of the fringing field
!!   AP(2) : CM   vertical half aperture
!< *******************************************************************
SUBROUTINE aimalv(ANGL,RMO,BAIM,XN,XB,EK1,EK2,PENT1,RAB1,SK1,SK2,PENT2,RAB2)
   USE DynacConstants
   USE m4aimalv
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4tmatrix
   USE m4FENE
   USE m4ITVOLE, ONLY: ITVOL,ttvols
   USE m4ble
   IMPLICIT NONE
   REAL(8) ANGL,RMO,BAIM,XN,XB,EK1,EK2,PENT1,RAB1,SK1,SK2,PENT2,RAB2
   REAL(8) fh0,gpai,a1b1,AILONG
   REAL(8) argu,arg1,bcog,BEREF,bpai,ctan,devis,devit,devr,devrs,devtot,ek1s,ek2s
   REAL(8) eo1,eta,fdtot,gamref,gap,gcog,omga,pent1s,pent2s,pnsec,r51,radia,rih,rip
   REAL(8) sa1b1,sbet,scl,sdavtot,sk1s,sk2s,tbe,thet,TLONG,ttt,RSYNC,xeb1,xeo1,xep,xepc
   REAL(8) xk2b1,XLL,xlsy
   REAL(8) tcog,wcg,xmco,ri
   INTEGER ist,nii,nsec
   INTEGER i,ii,ilost
   logical fromrfq
   real(8) xmoy(20),ymoy(20),rmoy(20),rig(20),ncs(20)
   real(8) xpmoy(20),ypmoy(20)
   real(8) xcl1(20),xcl2(20),alp(20),sxeb1(20),charge(20)
   real(8) xsa1b1(20),baims(20)
   real(8) sbeta(20)
   character(len=8) :: PRTLAB
   character(len=256) :: wfile 
!*******************************************************************
   WRITE(16,'(A)') ' ****** BENDING MAGNET: input list ****** '
   WRITE(16,'(A,i2)') ' Number of sectors: ',nsector
   if(abs(baim).le.fprec) then
! BORO: momentum of reference (kG.cm)
     ri=boro
! --- BAIM: bend field (KG)
     baim=abs(ri/rmo)
     write(16,'(A,F9.5,A,F12.5,A)')' Based on reference charge ', &
           qst,' momentum ',boro,' (kG.cm)'
   else
! --- RI momentum kG.cm
     ri=baim*rmo
   endif
   DEVI=ANGL
   NB=XN
   BDB=XB
   RSYNC=rmo
   gap=wy
! print out on terminal of transport element # on one and the same line
   NRTRE=NRTRE+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
! check if a .dst file is requested at the input
   if (nodflocs.gt.0) then
     do i=1,nodflocs  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then         
         write(16,*) ' BENDING MAGNET NAME: ',trim(UDEN)             
         if(idflio(i).eq.1 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_in.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at input of the element: ',&
                       trim(wfile)
           fromrfq=.false.                           
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif  
   if(ichaes) then
     write(16,*)'***** beam current: ',BEAMC*fhinit/fh,' mA'
   endif
   WRITE(16,'(A,/,A,e12.5,A,/,A,e12.5,A,/,A,2(2x,e12.5),/,A,e12.5,A)') &
    '    ENTRANCE FACE ******','  ANGLE OF POLE FACE ROTATION  ',PENT1,' DEG', &
    '  RADIUS OF CURVATURE          ',RAB1,' CM', & 
    '  FRINGE FIELD CORRECTIONS K1  K2',EK1,EK2, &
    '  VERTICAL HALF-APERTURE       ',APB(1),' CM'

   WRITE(16,'(A,/,A,e12.5,A,/,A,e12.5,A,/,A,e12.5,A,/,A,e12.5,A,E12.5)') &
    '    WEDGE MAGNET************','  BENDING RADIUS:  ',RMO,' CM ', &    
    '  BEND ANGLE:      ',DEVI,' DEG','  FIELD:           ',BAIM,' KG', &
    '  FIELD GRADIENTS: N ',NB,' BETA:',BDB
   
   WRITE(16,'(A,/,A,e12.5,A,/,A,e12.5,A,/,A,2(2x,e12.5),/,A,e12.5,A)') &
    '    EXIT FACE******','  ANGLE OF POLE FACE ROTATION  ',PENT2,' DEG', &
    '  RADIUS OF CURVATURE          ',RAB2,' CM', & 
    '  FRINGE FIELD CORRECTIONS K1  K2',SK1,SK2, &
    '  VERTICAL HALF-APERTURE       ',APB(2),' CM'
   
!  start prints in file 'short.data'
   idav=idav+1
   iitem(idav)=4
   dav1(idav,2)=devi
   dav1(idav,3)=rmo*10.D0
   dav1(idav,5)=APB(1)*10.D0
   dav1(idav,6)=PENT1
   dav1(idav,7)=EK1
   dav1(idav,8)=EK2
   dav1(idav,9)=RAB1*10.D0
   dav1(idav,10)=PENT2
   dav1(idav,11)=SK1
   dav1(idav,12)=SK2
   dav1(idav,13)=RAB2*10.D0
   dav1(idav,14)=nb
   dav1(idav,15)=bdb
   dav1(idav,16)=baim*.1D0
   dav1(idav,17)=APB(2)*10.D0
   FH0=FH/VL
!  Conversion deg--->rad
   radia=pi/180.D0
   pent1=pent1*radia
   devi=devi*radia
   devr=devi
   l=devr*rmo
   dav1(idav,1)=l*10.D0
   sdavtot=davtot
   davtot=davtot+l
   dav1(idav,4)=davtot*10.D0
   pent2=pent2*radia
   devtot=devi
! ----------------------------
!  define the bending angle of the synchronous particle over each sector
   devit=devi/DBLE(nsector)
! --- devit must be different from pent2
!       if(devit.eq.pent2) nsector=nsector+1
   if(abs(devit-pent2).le.fprec) nsector=nsector+1
! --- space charge computation: nsector must be g.t. 1
   if(ichaes.and.(nsector.eq.1) ) nsector = 2
   devi=devi/DBLE(nsector)
   devr=devr/DBLE(nsector)
! ----------------------------------------------------------
! -- scl effective length for space charge computation
!     scl is the path length of the C.T. over two following sectors
   scl=2.D0*devi*rmo
!   save pent1 , pent2 , devi, ek1, ek2 ,sk1 , sk2 ,
   pent1s=pent1
   pent2s=pent2
   devis=devi
   devrs=devr
   ek1s=ek1
   ek2s=ek2
   sk1s=sk1
   sk2s=sk2
! --------------------
   do ist=1,ncstat
    xcl2(ist)=0.D0
    rmoy(ist)=0.D0
    rig(ist)=0.D0
    baims(ist)=baim
   enddo
! -------------------
! ---- nsector: number of sectors in the bending magnet
   do nsec=1,nsector
!     write(6,*) '********'
!     write(6,*) ' BENDING MAGNET sector ',nsec
     devi=devis
     devr=devrs
     xlsy=devi*rmo
     sdavtot=sdavtot+xlsy
     if(nsector.gt.1) then
       if(nsec.eq.1) then
        pent1=pent1s
        pent2=0.D0
        ek1=ek1s
        ek2=ek2s
        sk1=0.D0
        sk2=0.D0
       endif
       if(nsec.eq.nsector) then
        pent1=0.D0
        pent2=pent2s
        ek1=0.D0
        ek2=0.D0
        sk1=sk1s
        sk2=sk2s
       endif
       if((nsec.gt.1).and.(nsec.lt.nsector)) then
        pent1=0.D0
        pent2=0.D0
        ek1=0.0001D0
        ek2=0.D0
        sk1=0.0001D0
        sk2=0.D0
       endif
     endif
! ------------------------------------------------------------
! --- nsctat: number of charges in the beam
     do ist=1,ncstat
       charge(ist)=cstat(ist)
       devi=devis
       devr=devrs
       xcl1(ist)=pent1-xcl2(ist)
       xmoy(ist)=0.D0
       xpmoy(ist)=0.D0
       ymoy(ist)=0.D0
       ypmoy(ist)=0.D0
       ncs(ist)=0
       rig(ist)=0.D0
       sbeta(ist)=0.D0
       do i=1,ngood
!         if(int(f(9,i)).eq.int(charge(ist))) then
!         if(f(9,i).eq.charge(ist)) then
         if(abs(f(9,i)-charge(ist)).le.fprec) then
           xmoy(ist)=xmoy(ist)+f(2,i)
           ymoy(ist)=ymoy(ist)+f(4,i)
           xpmoy(ist)=xpmoy(ist)+f(3,i)
           ypmoy(ist)=ypmoy(ist)+f(5,i)
           gpai=f(7,i)/xmat
           bpai=sqrt(1.D0-1.D0/(gpai*gpai))
           sbeta(ist)=sbeta(ist)+bpai
           xmco=xmat*bpai*gpai
           rip=33.356D0*xmco*1.D-01/f(9,i)
           rig(ist)=rip+rig(ist)
!old         rmoy(ist)=rmoy(ist)+rip
           ncs(ist)=ncs(ist)+1
         endif
       enddo
       sbeta(ist)=sbeta(ist)/DBLE(ncs(ist))
       xmoy(ist)=xmoy(ist)/DBLE(ncs(ist))
       ymoy(ist)=ymoy(ist)/DBLE(ncs(ist))
       xpmoy(ist)=xpmoy(ist)/DBLE(ncs(ist))
       ypmoy(ist)=ypmoy(ist)/DBLE(ncs(ist))
       rig(ist)=rig(ist)/DBLE(ncs(ist))
!old      rmoy(ist)=rig(ist)/baim
       rmoy(ist)=rig(ist)/baims(ist)
! eq.14
       ctan=cos(devi-pent2)/sin(devi-pent2)
       xep=rmo*(sin(devi)*ctan-cos(devi))
       xepc=xep+rmo-rmoy(ist)+xmoy(ist)
! eq.15 and eq.16
       argu=-xmoy(ist)*tan(pent1)/xepc
! eq.16
       omga=atan(argu)
! eq.15
       thet=omga+devi-pent2
! eq.18
       eo1=xepc/cos(omga)
! eq.17
       arg1=eo1*sin(thet)/rmoy(ist)
       eta=asin(arg1)
! eq.13
       xeb1=xepc*cos(thet)/cos(omga)+rmoy(ist)*cos(eta)
       sxeb1(ist)=xeb1
! eq.12
       xk2b1=-xmoy(ist)*tan(xcl1(ist))+xeb1*sin(devi-pent2)
! eq.11  (bend angle)
       alp(ist)=asin(xk2b1/rmoy(ist))
! eq.18
       xeo1=xepc/cos(omga)
! eq.19 (angle of inclination exit)
       argu=eo1/rmoy(ist) * sin(thet)
       xcl2(ist)=asin(argu)
       sa1b1=-rmo*sin(devr)
       sa1b1=sa1b1/sin(devr-pent2)
       xsa1b1(ist)=sa1b1+sxeb1(ist)
! --- field
!     first order
       baims(ist)=baim*(1.D0-nb*xsa1b1(ist)/rmo)
!     second order
       rih=1.D0/(rmo*rmo)
       baims(ist)=baims(ist)+xb*rih*xsa1b1(ist)*xsa1b1(ist)
! -----------------------------------------------------
! ----  Transport matrix
       sbet=sbeta(ist)
       devi=alp(ist)
       AILONG=devi*rmoy(ist)
       WRITE(16,'(/,A,/,A,f9.5,A,/,A,/,A,i4,A,i5,A)') &
        '  *******************************************', &
        '  *CENTRAL TRAJECTORY for charge: ',charge(ist),' *', &
        '  *******************************************', &
        '  SECTOR ',nsec,' OF ',nsector,' SECTORS TOTAL'
       WRITE(16,'(A,e12.5,A,e12.5,A,/,A,e12.5,A,/,A,e12.5,A,/,A,e12.5,A,e12.5,A)') &
        '  BENDING FIELD:   ',baims(ist),' kG  at: ',xsa1b1(ist),' cm', &
        '  BENDING RADIUS:  ',rmoy(ist),' CM ', &
        '  BENDING ANGLE:   ',devi*180.D0/pi,' DEG', &
        '  length: ',AILONG,' cm  rigidity: ',rig(ist),' kG.cm'
       L=AILONG
       H=1.D0/rmoy(ist)
!   ENTRANCE FACE OF THE BENDING MAGNET
!   CLEAR R AND T
       CALL CLEAR
       GAP=APB(1)
       BE= xcl1(ist)
       LAYL =EK1
       LAYX =EK2
       RABT=0.D0
       IF(ABS(RAB1).GT. 0.D0)RABT=1.D0/RAB1
! -----------------------------------------
       gcog=0.D0
       nii=0
       do ii=1,ngood
!         if(f(9,ii).eq.charge(ist)) then
!         if(int(f(9,ii)).eq.int(charge(ist))) then
         if(abs(f(9,ii)-charge(ist)).le.fprec) then
           gcog=gcog+f(7,ii)/xmat
           nii=nii+1
         endif
       enddo
       gcog=gcog/DBLE(nii)
       bcog=sqrt(1.D0-1.D0/(gcog*gcog))
       fdtot=0.D0
       DO II=1,NGOOD
!         if(f(9,ii).eq.charge(ist)) then
!         if(int(f(9,ii)).eq.int(charge(ist))) then
         if(abs(f(9,ii)-charge(ist)).le.fprec) then
           tbe=tan(be)
           f(2,ii)=f(2,ii)-xmoy(ist)
           gpai=f(7,ii)/xmat
           bpai=sqrt(1.D0-1.D0/(gpai*gpai))
           f(6,ii)=f(6,ii)+xmoy(ist)*tbe/(bpai*vl)
           fd(ii)=(gpai*bpai)/(gcog*bcog)
           fdtot=fdtot+fd(ii)
         endif
       enddo
       fdtot=fdtot/DBLE(nii)-1.D0
! --------------------------------------------------
       CALL POFAR1(GAP)
       write(16,'(A,e12.5,A,f9.5)') &
        '  ****INPUT FACE*** SLOPE: ',be*180.D0/pi,' deg CHARGE: ',charge(ist)
       call matrix
       XLL=0.D0
       DO II=1,NGOOD
!         if(f(9,ii).eq.charge(ist)) then
!         if(int(f(9,ii)).eq.int(charge(ist))) then
         if(abs(f(9,ii)-charge(ist)).le.fprec) then
           CALL COBEAM(II,XLL)
         endif
       enddo
! *******************************************************
!  WEDGE BENDING MAGNET
!   CLEAR R AND T
       CALL CLEAR
       CALL BENMAG(sbet,fdtot)
! ---  :print the transport matrix
       write(16,'(A,f9.5)') '  ****BENDING MAGNET for charge ',charge(ist)
       call matrix
       r51=r(5,1)
!  ----  transport of particles
       DO II=1,NGOOD
!         if(f(9,ii).eq.charge(ist)) then
!         if(int(f(9,ii)).eq.int(charge(ist))) then
         if(abs(f(9,ii)-charge(ist)).le.fprec) then
           CALL COBEAM(II,L)
         endif
!      synchrotron radiation (only for electrons, i.e. erest = 0.511 Mev)
         IF(IRAYSH .and. abs(xmat-0.511D0).le.0.001D0) CALL SYROUT(II)
       ENDDO
! *******************************************************
! --- EXIT FACE OF THE BENDING MAGNET
!   CLEAR R AND T
       CALL CLEAR
       xll=0.D0
       GAP=APB(2)
       BE= xcl2(ist)
       LAYL =SK1
       LAYX =SK2
       RABT=0.D0
       IF(ABS(RAB2).GT.1.D-10)RABT=1.D0/RAB2
       CALL POFAR2(GAP)
! ---- :print the transport matrix
       write(16,'(A,e12.5,A,f9.5)') &
        '  ****EXIT FACE*** SLOPE: ',be*180.D0/pi,' deg CHARGE: ',charge(ist)
       call matrix
!     transport of particles
       XLL=0.D0
       DO II=1,NGOOD
!        if(f(9,ii).eq.charge(ist)) then
!        if(int(f(9,ii)).eq.int(charge(ist))) then
         if(abs(f(9,ii)-charge(ist)).le.fprec) CALL COBEAM(II,XLL)
       ENDDO
! ----------------------------------------------------------------------
! --- get back the particles coordinates in the coordinates system of the synchronous particle
       sa1b1=-rmo*sin(devr)
       sa1b1=sa1b1/sin(devr-pent2)
       ttt=xcl2(ist)-pent2
       ttt=ttt*1.D3
       do ii=1,ngood
!         if(f(9,ii).eq.charge(ist)) then
!         if(int(f(9,ii)).eq.int(charge(ist))) then
         if(abs(f(9,ii)-charge(ist)).le.fprec) then
! EQ.29
           a1b1=sa1b1+sxeb1(ist)
! EQ.28
           f(2,ii)=(a1b1+f(2,ii)/cos(xcl2(ist))) * cos(pent2)
! EQ.30
           f(3,ii)=f(3,ii)-ttt
! EQ.31
           gpai=f(7,ii)/xmat
           bpai=sqrt(1.D0-1.D0/(gpai*gpai))
           f(6,ii)=f(6,ii)+r51*xmoy(ist)/(bpai*vl)
!cc              f(6,ii)=f(6,ii)-r51*xmoy(ist)/(bpai*vl)
! **** allow plotting the beam after the sector number nsprint in file 13 (see the MAIN)
!cc            if(nsec.eq.nsprint) then
!cc       write(13,2587) nsec,ist,charge(ist),f(2,ii),f(3,ii),f(4,ii),
!cc     *                   f(5,ii),xmoy(ist),ymoy(ist),rmoy(ist)
!cc2587   format(2x,i3,2x,i3,8(2x,e12.5))
!cc            endif
! **********************************************************************
         endif
       enddo
!    enddo for ist (number of charges in the beam)
     enddo
! --------------------------------------------------------------
!  Space charge computation
     if(ichaes) then
! --- check the parity of nsec
       pnsec=DBLE(nsec)/2.D0-DBLE(nsec/2)
!    nsec is odd:---> space charge computation
!       if((pnsec.ne.0.).and.(nsec.lt.nsector)) then
       if(abs(pnsec).gt.fprec .and. nsec.lt.nsector) then
         write(16,*) ' Space charge after sector: ',nsec
         call cesp(scl)
       endif
     endif
! ------------------------------------------------------------
!    synchronous radiation (only for electrons i.e. erest = 0.511 Mev)
     IF(IRAYSH .and. abs(xmat-0.511D0).le.0.001D0) CALL SYREF
!     The routine SYREF changes vref and tref (reference)
!  envelope
     PRLAB(IPRF)='BMAGNET '
     CALL STAPL(sdavtot*10.D0)
!  enddo for nsec (sectors numbers)
   enddo
! ------------------------------------------------------
!  random error in alignment
   if(ialin) call randali
! Change the dispersion dE/E with respect to the C.O.G of the bunch
   call disp
   call cogetc
! --- Test window after the bending magnet
   tcog=0.D0
   gcog=0.D0
   do i=1,ngood
     gcog=gcog+f(7,i)/xmat
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   gcog=gcog/DBLE(ngood)
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   wcg=(gcog-1.D0)*xmat
! devtot: total angle of the bending magnet(computation of tref)
   devi=devtot
   ailong=devi*rmo
   IF(IRAYSH .and. abs(xmat-0.511D0).le.0.001D0) then
! electrons with synchrotron radiation
   ELSE
! ions
     TREF=TREF+AILONG/VREF
!    ----- window control
     PRLAB(IPRF)='BMAGNET '
     PRTLAB=PRLAB(IPRF)
     call reject(ilost,PRTLAB)
! ---------------------------------------------------
     dav1(idav,37)=DBLE(ngood)
     if(itvol) ttvols=tref
   ENDIF
   BEREF=VREF/VL
   GAMREF=1.D0/sqrt(1.D0-beref*beref)
   XMCO=XMAT*BEREF*GAMREF
   BORO=33.356D0*XMCO*1.D-01/QST
   TLONG = TREF*VREF
   WRITE(16,'(/,/,3X,A,/A,e12.5,A,e12.5,/,A,e12.5,A,e12.5,/,A,e12.5,/,A,i8,/)') &
    ' *** REFERENCE AT THE EXIT :', &
    '   BETA :',BEREF,' GAMMA :',GAMREF,'   T.O.F (SEC): ',TREF, &
    '   T.O.F (CM): ',TLONG, &
    '   RIGIDITY(KGAUSS.CM) :',BORO, &
    '   NUMBER OF PARTICLES :',NGOOD
   if(itvol) write(16,*) ' tof for adjustments: ',ttvols,' sec'
   if(iemgrw) call emiprt(0)
! check if a .dst file is requested at the output
   if (nodflocs.gt.0) then
     do i=1,nodflocs
!       write(16,*) ' DBX1: ',trim(dflnames(i)),' DBX2: ',trim(adjustl(UDEN))  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then         
         if(idflio(i).eq.2 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_out.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at output of the element: ',&
                       trim(wfile)
           fromrfq=.false.                           
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif                       
END SUBROUTINE aimalv
!> *******************************************************************
!! SUBROUTINE steer(fld,nvf)
!! TRANSFORM BEAM THRU THIN STEERER
!!  ---- MAGNETIC STEERER
!!  ---- PARAMETERS: fld (Tm), nvf
!!     where fld is the integrated field
!!     if nvf=0,  horizontal magnetic steerer
!!     if nvf=1,  vertical magnetic steerer
!!
!!  ---- ELECTROSTATIC STEERER
!!     This is a zero length element: the length shown below is
!!     ONLY used for kick calculation.
!!  ---- PARAMETERS: fld (kV*m/m), nvf
!!     where fld is Plate Voltage * plate length/plate separation.
!!     if nvf=2, horziontal electrostatic steerer
!!     if nvf=3, vertical electrostatic steerer
!!
!!  -----ANGULAR DISPLACEMENTS DUE TO STEERING
!< *******************************************************************
SUBROUTINE steer(fld,nvf)
   USE DynacConstants
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE m4ble, ONLY: cr
   IMPLICIT NONE
   REAL(8) fld,gpai
   REAL(8) bpai,const,dispx,dispy
   INTEGER nvf,i
   character(len=8) :: PRTLAB
!*******************************************************************
!     4/15/14 - Daniel Alt: Added electrostatic steerers.
!      ENVELOPE
   PRLAB(IPRF)='STEER   '
   PRTLAB=PRLAB(IPRF)
   call stapl(davtot*10.D0)       
! print out on terminal of transport element # on one and the same line
   NRTRE=NRTRE+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
   if (nvf.eq.0) then
! horizontal magnetic steerer
     write(16,*) 'Horizontal magnetic steerer: ',fld,' Tm'
     do i=1,ngood
       const=xmat*1.D8/(f(9,i)*vl)
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       DISPX=fld/(const*gpai*bpai)*1000.D0
       f(3,i)=f(3,i)+dispx
     enddo
   else if (nvf.eq.1) then
! vertical magnetic steerer
     write(16,*) 'Vertical magnetic steerer: ',fld,' Tm'
     do i=1,ngood
       const=xmat*1.D8/(f(9,i)*vl)
       gpai=f(7,i)/xmat
       bpai=sqrt(1.D0-1.D0/(gpai*gpai))
       DISPY=fld/(const*gpai*bpai)*1000.D0
       f(5,i)=f(5,i)+dispy
     enddo
   else if (nvf.eq.2) then
! horizontal electrostatic steerer
     write (16,*) 'Horizontal electrostatic steerer: ',fld,' kV*m/m'
     do i=1,ngood
       gpai=f(7,i)/xmat
       const=(gpai/(gpai*gpai-1.D0))*f(9,i)
       DISPX=const*fld/xmat
       f(3,i)=f(3,i)+dispx
     enddo
   else if (nvf.eq.3) then
! vertical electrostatic steerer
     write (16,*) 'Vertical electrostatic steerer: ',fld,' kV*m/m'
     do i=1,ngood
       gpai=f(7,i)/xmat
       const=(gpai*gpai/(gpai*gpai-1.D0))*f(9,i)
       DISPY=const*fld/xmat
       f(5,i)=f(5,i)+dispy
     enddo
   else
! error on input
     write(ierr,*)'Wrong value for NVF in STEERER'
     write(16,*) 'Wrong value for NVF in STEERER'
     STOP
   endif
END SUBROUTINE steer
!> *******************************************************************
!! SUBROUTINE rfkick(v,dp,harm,nvf)
!! RFKICK  (NO SPACE CHARGE EFFECT)
!!
!! Contributing Author: Daniel Alt, NSCL/MSU, East Lansing,  MI, USA
!! Date: 23-May-2014
!!
!! Electric RF kicker.  Simulates a sine wave chopper consisting
!! of two plates deflecting the beam in the transverse direction.
!! This is a zero length element.
!!
!! V:    Voltage Factor.  Consists of plate voltage in kV, times
!!       the electrode length divided by the gap between them.
!! DP:   RF phase offset in radians
!! Harm: Kicker harmonic number relative to current reference
!!       frequency
!! NVF:  Kicker axis: 0 = horziontal, 1= vertical (use negative
!!       voltage for negative deflection)
!< *******************************************************************
SUBROUTINE rfkick(v,dp,harm,nvf)
   USE DynacConstants
   USE m4input
   USE m4output
   USE m4beam
   USE m4cavs
   USE m4cavs2
   USE m4chase
   USE m4FENE
   USE m4ITVOLE, ONLY: IMAMIN,SHIFT,ttvols
   USE m4ble, ONLY: cr
   USE mCOMcorec
   IMPLICIT NONE
   REAL(8) twopi,freq,wavel,fcpi,v,dp,harm,tcog,bcog,gpa,gcog,encog,xkpi,ttvpi
   REAL(8) a,bcour,beref,bg,bpai,gpai,cay,caysq,con,const,disp,e0t,ENRPRIN
   REAL(8) gamref,wsync,w,s
   REAL(8) ixkpi,older,otref,ovref,rad
   INTEGER nvf,np,ilost
   character(len=8) :: PRTLAB
!*******************************************************************
!  ENVELOPE
!   PRLAB(IPRF)='RFKICK  '
   call stapl(davtot*10.D0)
!xx   ilost=0
   twopi=2.D0*pi
   freq=fh/twopi
   wavel=vl/freq
   fcpi=fh*180.D0/pi
! print out on terminal of transport element # on one and the same line
   WRITE(6,"(A,i5,A1)",advance='no') 'Transport element:',NRTRE,cr
   flush(6)
   if (harm .LE. 0.D0) harm=1.D0
!   test window - unneccesary at START of element - Alt
!       call reject(ilost,PRTLAB)
!   Calculate tof, beta, gamma, k.e. for c.o.g.
   tcog=0.D0
   bcog=0.D0
   do np=1,ngood
     tcog=tcog+f(6,np)
     gpa=f(7,np)/xmat
     bcog=sqrt(1.D0-1.D0/(gpa*gpa))+bcog
   enddo
   tcog=tcog/DBLE(ngood)
   bcog=bcog/DBLE(ngood)
   gcog=1.D0/sqrt(1.D0-bcog*bcog)
   encog=xmat*gcog-xmat
! adjustement of the phase of RF w.r.t. the T.O.F.
   xkpi=0.D0
   if(imamin) then
     ttvpi=harm*ttvols*fcpi
     xkpi=ttvpi/360.D0
     ixkpi=int(xkpi)
     xkpi=(xkpi-DBLE(ixkpi))*360.D0
     write(16,*) ' *** TOF correction:',-xkpi,' deg'
     dp=dp-xkpi*pi/180.D0
     write(16,*)' ***phase of RF adjusted : ',dp*180.D0/pi,' deg'
   endif
!  start of write to file '.short' for kicker
   idav=idav+1
   iitem(idav)=22
   dav1(idav,1)=v
   dav1(idav,2)=dp*180.D0/pi
   dav1(idav,3)=DBLE(nvf)
   dav1(idav,4)=davtot*10.D0
!   if(itvol) dav1(idav,5)=-xkpi
   dav1(idav,5)=harm
!  end
   WRITE(16,'(/,A,/,8x,A)') ' Longitudinal parameters',&
     'BETA     GAMMA      ENERGY(MeV)        TOF(deg)     TOF(sec)'      
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') &
     ' COG ',bcog,gcog,encog,tcog*fcpi,tcog
!   WRITE(16,178)
!  178  FORMAT(/,' Longitudinal parameters',/, &
!       5X,'   BETA     GAMMA      ENERGY(MeV) ', &
!       '       TOF(deg)     TOF(sec)')
!   WRITE(16,1788) bcog,gcog,encog,tcog*fcpi,tcog
! 1788  FORMAT(' COG ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
   e0t=harm*v/(bcog*wavel)
   cay=harm*twopi/(bcog*gcog*wavel)
   caysq=cay**2
   con=twopi*e0t*qmoy/xmat
   rad=pi/180.D0
! shift=true => reference and COG seperated, otherwise reference=COG
! --- save the reference
   ovref=vref
   otref=tref
! --- shift = false: the reference particle is the cog
   if(shift) then
     ovref=vref
     beref=vref/vl
     gamref=1.D0/sqrt(1.D0-beref*beref)
     older=xmat*gamref
   else
     tref=tcog
     vref=bcog*vl
     ovref=vref
     beref=bcog
     gamref=1.D0/sqrt(1.D0-beref*beref)
     older=xmat*gamref
   endif
! ---  if imamin = false: phase setting has been forced equal to dp, otherwise phase setting has been adjusted
   ENRPRIN=older-xmat
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') &
     ' REF ',beref,gamref,ENRPRIN,tref*fh*180.D0/pi,tref
!   WRITE(16,165) beref,gamref,ENRPRIN,tref*fh*180.D0/pi,tref
!  165  FORMAT(' REF ',F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)
   wsync=0.D0
   bcour=0.D0
   tcog=0.D0
   do np=1,ngood
     a=harm*(f(6,np)-tref+ttvols)*fh+dp
     s=sin(a)
     w=f(7,np)-xmat
     gpai=f(7,np)/xmat
     bg=sqrt(w/xmat*(2.D0+w/xmat))
     bpai=bg/gpai
     const=(gpai/(gpai*gpai-1.D0))*f(9,np)
     disp=const*v/xmat*s
     bcour=bcour+bpai
     tcog=tcog+f(6,np)
     if (nvf.eq.0) then
       f(3,np)=f(3,np)+disp
     else if (nvf.eq.1) then
       f(5,np)=f(5,np)+disp
     else
       write(ierr,*) 'Invalid parameter NVF in RFKICK'
     endif
     wsync=wsync+w
   enddo
   wsync=wsync/DBLE(ngood)
   bcour=bcour/DBLE(ngood)
   tcog=tcog/DBLE(ngood)
! Test window
   PRTLAB='RFKICK  '
   call reject(ilost,PRTLAB)
! dave start for kicker
   dav1(idav,36)=DBLE(ngood)
   call emiprt(0)
END SUBROUTINE rfkick
!> *******************************************************************
!! SUBROUTINE qelec(volt,xlqua,rs)
!! electrostatic quadrupole
!! space charge computation at the middle of the lens
!!       VOLT: electric voltage at pole tip (kV)
!!       XLQUA: effective length  (cm)
!!       RS: radial distance of pole tip from axis (cm)
!< *******************************************************************
SUBROUTINE qelec(volt,xlqua,rs)
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4FENE
   USE m4ITVOLE
   USE m4ble
   USE m4QSEX
   USE mCOMqskew
   IMPLICIT NONE
   REAL(8) xlqua,bcour,fcpi,fh0,gcour,gpa,gpai
   REAL(8) sign,sqtwist,tcog,wcg,qtwrad,rdcf,volt,rs
   REAL(8) bet,eni,qi,rigi,rigid,xgrad
   INTEGER i,ii,ilost,len,nlost
   character(len=8) :: PRTLAB
   REAL(8) trans(1)
!*******************************************************************
   ilost=0
!  statistics
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
   write(16,*) ' ***QUADRUPOLE (electrostatic)***'
   write(16,*)
   fcpi=fh*180.D0/pi
   if(itvol) write(16,'(A,e12.5,A,e12.5,A)') ' ** tof for adjustments at input: ', &
                   ttvols*fcpi,' deg at position: ',davtot,' cm in lattice'
! print out on terminal of transport element # on one and the same line
   NRTRE=NRTRE+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
!  if itwist=.true. skews the quadrupole before misalignments (only if abs(volt) gt 1.D-13)
!     len = 1 level 1 in rlux routine
   len=1
   sqtwist=0.D0
   if(abs(volt).gt.1.D-13) then
     if(itwist) then
       if(iqrand.eq.0) then
         qtwrad=qtwist
         sqtwist=qtwrad
         call zrotat(qtwrad)
       else
         rdcf=0.5D0
         call rlux(trans,len)
         if(trans(1).le.rdcf) sign=-1.D0
         if(trans(1).gt.rdcf) sign=1.D0
         call rlux(trans,len)
         qtwrad=qtwist*sign*trans(1)
         sqtwist=qtwrad
         call zrotat(qtwrad)
       endif
     endif
!   misalignments
     if(ialin) call randali
   endif
   idav=idav+1
   iitem(idav)=18
   dav1(idav,1)=xlqua*10.D0
   davtot=davtot+xlqua
   dav1(idav,4)=davtot*10.D0
   fh0=fh/vl
   gpa=0.D0
   do ii=1,ngood
     gpa=gpa+f(7,ii)/xmat
   enddo
   gpa=gpa/DBLE(ngood)
   bet=sqrt(gpa*gpa-1.D0)/gpa
   l=xlqua
   eni=gpa*xmat
   qi=qst
!  electric rigidity (kV)
   rigid=eni*bet*bet/qi *1.D3
! electric field gradient: xgrad (kV/cm-2)
   xgrad=2.D0*volt/rs**2
   dav1(idav,2)=volt
   dav1(idav,3)=rigid
   dav1(idav,5)=xgrad
!  qk2 (cm-2)
   kq2=xgrad/rigid
   dav1(idav,6)=kq2
   dav1(idav,7)=rs*10.D0
   write(16,'(A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A,e12.5,A,/A,e12.5,A,/)') &
        ' LENGTH = ',xlqua,' cm   APERTURE RADIUS= ',rs,' cm', &
        ' VOLTAGE = ',volt,' kV  K2 = ',kq2,' cm-2  GRADIENT = ',xgrad,' kV/cm2', &
        ' RIGIDITY = ',rigid,' kV'
   call clear
   call elqua(gpa)
!    print out the transport matrix (cog)
   call matrix
!  first half quadrupole
   l=xlqua/2.D0
   do ii=1,ngood
     call clear
     gpai=f(7,ii)/xmat
     bet=sqrt(gpai*gpai-1.D0)/gpai
     qi=f(9,ii)
!  electric rigidity (kV)
     rigi=f(7,ii)*bet*bet/qi *1.D3
!   qk2 (cm-2)
     kq2=xgrad/rigi
     call elqua(gpai)
     call cobeam(ii,l)
   enddo
!  space charge computations (if l >0)
   if(ichaes .and. l .gt. 0.D0) then
     if(int(sce10).eq.1 .or. int(sce10).eq.3) then
       iesp=.true.
       write(16,'(A)') ' Space charge at the middle of the lens'
       call cesp(xlqua)
       iesp=.false.
!  Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
     endif
   endif
! Test window after the first half quadrupole (after s.c. computations)
   call cogetc
   bcour=0.D0
   do i=1,ngood
     gpai=f(7,i)/xmat
     bcour=sqrt(1.D0-1.D0/(gpai*gpai))+bcour
   enddo
   bcour=bcour/DBLE(ngood)
   gcour=1.D0/sqrt(1.D0-bcour*bcour)
   wcg=(gcour-1.D0)*xmat
! ----- window control
   tref=tref+xlqua/(2.D0*vref)
   PRTLAB='QUAELEC '
   call reject(nlost,PRTLAB)
!    second half quadrupole
   do ii=1,ngood
     call clear
     gpa=f(7,ii)/xmat
     bet=sqrt(gpa*gpa-1.D0)/gpa
     qi=f(9,ii)
     rigi=f(7,ii)*bet*bet/qi *1.D3
     kq2=xgrad/rigi
     call elqua(gpa)
     call cobeam(ii,l)
   enddo
! Test window after the second half quadrupole
   call cogetc
   tref=tref+xlqua/(2.D0*vref)
   call reject(ilost,PRTLAB)
   ilost=ilost+nlost
!  Change the t.o.f
   if(itvol) ttvols=tref
!  envelope
   PRLAB(IPRF)='QUAELEC '
   call stapl(davtot*10.D0)
   tcog=0.D0
   do i=1,ngood
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   if(itvol) then
     write(16,'(A,e12.5,A,e12.5,A,/,3x,A,e12.5,A,e12.5,A,e12.5,A)') &
       ' ** tof for adjustments: ',ttvols*fcpi,' deg at position: ',davtot, &
       ' cm in the lattice','tof of the reference: ',tref*fcpi,' deg tof of the cog: ', &
       tcog*fcpi,' deg'
   else
     write(16,'(A,e12.5,A,e12.5,A)') &
       ' ** tof of the reference: ',tref*fcpi,' deg tof of the cog: ',tcog*fcpi,' deg'
   endif
   dav1(idav,36)=DBLE(ngood)
   write(16,*)' particles lost :',ilost
!  returns coordinates to the initial orientation
   if(itwist) then
     if(abs(volt).gt.1.D-13) then
       qtwrad=-sqtwist
       call zrotat(qtwrad)
     endif
   endif
   if(iemgrw) call emiprt(0)
!  envelope
   PRLAB(IPRF)='QUAELEC '
   call stapl(davtot*10.D0)
END SUBROUTINE qelec
!> *******************************************************************
!! SUBROUTINE qfk (ityqu,arg,xlqua,rs)
!! electrostatic or magnetic quadrupole based on the strength K2
!! space charge computation at the middle of the lens
!!       ITYQU: ITYQU = 0 electric quadrupole, otherwise magnetic
!!              quadrupole
!!       ARG: strength K (cm-2)
!!       XLQUA: effective length  (cm)
!!       RS: radial distance of pole tip from the axis (cm)
!< *******************************************************************
SUBROUTINE qfk(ityqu,arg,xlqua,rs)
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4FENE   
   USE m4ITVOLE, ONLY: ITVOL, ttvols
   USE m4ble
   USE m4QSEX
   USE mCOMqfkd
   USE mCOMqskew
   IMPLICIT NONE
   REAL(8) xlqua,bcour,fcpi,fh0,gcour,gpa,gpai
   REAL(8) sign,sqtwist,tcog,wcg,xmco,qtwrad,rdcf
   REAL(8) arg,rs,bet,bgaus,bgrad,eni,qi,rigi,rigid,volt,xfqu,xgrad
   INTEGER i,ii,ilost,len,nlost,ityqu
   character(len=8) :: PRTLAB
   REAL(8) trans(1)
!*******************************************************************
   ilost=0
   if(ityqu.eq.0) ityq=.true.
   if(ityqu.ne.0) ityq=.false.
   if(ityq) then
     write(16,*) ' ***QUADRUPOLE (electrostatic)***'
   else
     write(16,*) ' ***QUADRUPOLE (magnetic)***'
   endif
!  statistics
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
   xfqu=arg
   fcpi=fh*180.D0/pi
   if(itvol) write(16,'(A,e12.5,A,e12.5,A)') &
      ' ** tof at input: ',ttvols*fcpi,' deg  position in the lattice: ',davtot,' cm '
! print out on terminal of transport element # on one and the same line
   NRTRE=NRTRE+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
!  if itwist=.true. skews the quadrupole before misalignments (only if abs(arg) gt 1.D-13)
!  len = 1 level 1 in rlux routine
   len=1
   sqtwist=0.D0
   if(abs(xfqu).gt.1.D-13) then
     if(itwist) then
       if(iqrand.eq.0) then
         qtwrad=qtwist
         sqtwist=qtwrad
         call zrotat(qtwrad)
       else
         rdcf=0.5D0
         call rlux(trans,len)
         if(trans(1).le.rdcf) sign=-1.D0
         if(trans(1).gt.rdcf) sign=1.D0
         call rlux(trans,len)
         qtwrad=qtwist*sign*trans(1)
         sqtwist=qtwrad
         call zrotat(qtwrad)
       endif
     endif
!  misalignments
     if(ialin) call randali
   endif
   idav=idav+1
   iitem(idav)=19
   dav1(idav,1)=xlqua*10.D0
   davtot=davtot+xlqua
   dav1(idav,4)=davtot*10.D0
   fh0=fh/vl
   gpa=0.D0
   do ii=1,ngood
     gpa=gpa+f(7,ii)/xmat
   enddo
   gpa=gpa/DBLE(ngood)
   bet=sqrt(gpa*gpa-1.D0)/gpa
   l=xlqua
   eni=gpa*xmat
   qi=qst
   if(ityq) then
!    electrostatic quadrupole
!    rigid: electric momentum (kV)
     rigid=eni*bet*bet/qi * 1.D3
!    compute the electric voltage VOLT (kV) from K(cm-2)
     volt=xfqu*rs*rs*rigid
     volt=volt/2.D0
!   kq2 (cm-2)
     kq2=xfqu
!     electric field gradient: xgrad (kV/cm2)
     xgrad=kq2*rigid
     dav1(idav,2)=volt
     dav1(idav,3)=rigid
     dav1(idav,5)=xgrad
     dav1(idav,6)=xfqu
     dav1(idav,7)=rs*10.D0
     call clear
     call elqua(gpa)
     write(16,'(A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A,e12.5,A,/,A,e12.5,A,/)') &
       ' LENGTH = ',xlqua,' cm   APERTURE RADIUS= ',rs,' cm', &
       ' VOLTAGE = ',volt,' kV  K2 = ',xfqu,' cm-2  GRADIENT = ',xgrad,' kV/cm2', &
       ' MOMENTUM = ',rigid,' kV'
!    print the transport matrix (of the cog)
     call matrix
   else
!    magnetic quadrupole
     xmco=xmat*bet*gpa
!    rigid: magnetic rigidity (kG.cm)
     rigid=33.356D0*xmco*1.D-01/qst
     kq2=xfqu
!   bgrad: gradient (kG/cm)
     bgrad=kq2*rigid
!    bgaus: field (kG)
     bgaus=bgrad*rs
     dav1(idav,2)=bgaus
     dav1(idav,3)=rigid
     dav1(idav,5)=bgrad
     dav1(idav,6)=xfqu
     dav1(idav,7)=rs*10.D0
     call clear
     call elqua(gpa)
     write(16,'(A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A,e12.5,A,/,A,e12.5,A,/)') &
       ' LENGTH = ',xlqua,' cm   APERTURE RADIUS= ',rs,' cm', &
       ' FIELD = ',bgaus,' kG  K2 = ',xfqu,' cm-2  GRADIENT = ',bgrad,' kG/cm', &
       ' MOMENTUM = ',rigid,' kG.cm'
!     write(16,3300) xlqua,rs,bgaus,xfqu,bgrad,rigid
! 3300   format(' LENGTH = ',e12.5,' cm   APERTURE RADIUS= ',e12.5, &
!        ' cm',/,' FIELD = ',e12.5,' kG  K2 = ',e12.5,' cm-2  ', &
!        'GRADIENT = ',e12.5,' kG/cm',/,' MOMENTUM = ',e12.5, &
!        ' kG.cm',/)
     call matrix
   endif
!  first half quadrupole
   l=xlqua/2.D0
   do ii=1,ngood
     call clear
     gpai=f(7,ii)/xmat
     bet=sqrt(gpai*gpai-1.D0)/gpai
     qi=f(9,ii)
     if(ityq) then
! electric quadrupole
!   rigi: momentum (kV)
       rigi=f(7,ii)*bet*bet/qi * 1.D3
!   qk2 (cm-2)
       kq2=xgrad/rigi
       call elqua(gpai)
       call cobeam(ii,l)
     else
! magnetic quadrupole
       xmco=xmat*bet*gpa
!    rigi: momentum (kG.cm)
       rigi=3.3356D0*xmco/f(9,ii)
!    kq2 (cm-2)
       kq2=bgrad/rigi
       call elqua(gpai)
       call cobeam(ii,l)
     endif
   enddo
!  space charge computations (if l >0)
   if(ichaes .and. l .gt. 0.D0) then
     if(int(sce10).eq.1 .or. int(sce10).eq.3) then
       iesp=.true.
       write(16,'(A)') ' Space charge at the middle  '
       call cesp(xlqua)
       iesp=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
     endif
   endif
! Test window after the first half quadrupole (after s.c. computations)
   call cogetc
   bcour=0.D0
   do i=1,ngood
     gpai=f(7,i)/xmat
     bcour=sqrt(1.D0-1.D0/(gpai*gpai))+bcour
   enddo
   bcour=bcour/DBLE(ngood)
   gcour=1.D0/sqrt(1.D0-bcour*bcour)
   wcg=(gcour-1.D0)*xmat
! ----- convert window control
   tref=tref+xlqua/(2.D0*vref)
   PRTLAB='QUAFK   '
   call reject(nlost,PRTLAB)
!    second half quadrupole
   do ii=1,ngood
     call clear
     gpai=f(7,ii)/xmat
     bet=sqrt(gpai*gpai-1.D0)/gpai
     qi=f(9,ii)
     if(ityq) then
! electric quadrupole
!     rigi (kV)
       rigi=f(7,ii)*bet*bet/qi * 1.D3
!   qk2 (cm-2)
       kq2=xgrad/rigi
       call elqua(gpai)
       call cobeam(ii,l)
     else
! magnetic quadrupole
       xmco=xmat*bet*gpa
!    rigi: momentum (kG.cm)
       rigi=3.3356D0*xmco/f(9,ii)
!    kq2 (cm-2)
       kq2=bgrad/rigi
       call elqua(gpai)
       call cobeam(ii,l)
     endif
   enddo
! Test window after the second half quadrupole
   call cogetc
   tref=tref+xlqua/(2.D0*vref)
   call reject(ilost,PRTLAB)
   ilost=ilost+nlost
!  Change the t.o.f
   if(itvol) ttvols=tref
!  envelope
   PRLAB(IPRF)='QUAFK   '
   call stapl(davtot*10.D0)
   tcog=0.D0
   do i=1,ngood
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   if(itvol) then
     write(16,'(A,e12.5,A,e12.5,A,/,3x,A,e12.5,A,e12.5,A,e12.5,A)') &
       ' ** tof for adjustments: ',ttvols*fcpi,' deg at position: ',davtot, &
       ' cm in the lattice','tof of the reference: ',tref*fcpi,' deg tof of the cog: ', &
       tcog*fcpi,' deg'
   else
     write(16,'(A,e12.5,A,e12.5,A)') &
       ' ** tof of the reference: ',tref*fcpi,' deg tof of the cog: ',tcog*fcpi,' deg'
   endif
   dav1(idav,36)=DBLE(ngood)
   write(16,*)' particles lost :',ilost
!  returns coordinates to the initial orientation
   if(itwist) then
     if(abs(xfqu).gt.1.D-13) then
       qtwrad=-sqtwist
       call zrotat(qtwrad)
     endif
   endif
   if(iemgrw) call emiprt(0)
!  envelope
   PRLAB(IPRF)='QUAFK   '
   call stapl(davtot*10.D0)
END SUBROUTINE qfk
!> *******************************************************************
!! SUBROUTINE qalva(bquad,xlqua,rg)
!! QUADRUPOLE
!! space charge computations at the middle of the lens
!!   BQUAD: field at pole tip (kG)
!!          If BQUAD positive = focalisation in the H-plane (x,z)
!!   XLQUA: EFFECTIVE LENGHT (cm )
!!   RG:    APERTURE RADIUS (cm)
!< *******************************************************************
SUBROUTINE qalva(bquad,xlqua,rg)
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4FENE
   USE m4ITVOLE
   USE m4ble
   USE m4QSEX
   USE mCOMqskew
   IMPLICIT NONE
   REAL(8) bquad,xlqua,rg,b,bcour,bpa,bpai,fcpi,fh0,gcour,gpa,gpai
   REAL(8) sign,sqtwist,tcog,wcg,xmco,qtwrad,rdcf,ri
   INTEGER i,ii,ilost,len,nlost
   logical fromrfq
   character(len=8) :: PRTLAB
   character(len=256) :: wfile   
   REAL(8) trans(1)
!*******************************************************************
! print out on terminal of transport element # on one and the same line
   NRTRE=NRTRE+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
   ilost=0
!  B : GRADIENT IN kG/cm
   b=bquad/rg
!  statistics
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
   write(16,*) ' ***QUADRUPOLE (magnetic) ***'
   write(16,*) '    QUADRUPOLE NAME : ',UDEN       
! check if a .dst file is requested at the input
   if (nodflocs.gt.0) then
     do i=1,nodflocs  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then          
         if(idflio(i).eq.1 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_in.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at input of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif        
   fcpi=fh*180.D0/pi
   if(itvol) write(16,'(A,e12.5,A,e12.5,A)') ' ** TOF (input of the lens): ', &
               ttvols*fcpi,' deg at: ',davtot,' cm in the lattice'
!  if itwist=.true: skews the quadrupole before misalignments (if b ne 0)
!     len = 1 level in rlux routine
   len=1
   if(itwist .and. abs(b).gt.fprec) then
     if(iqrand.eq.0) then
       qtwrad=qtwist
       sqtwist=qtwrad
       call zrotat(qtwrad)
     else
       rdcf=0.5D0
       call rlux(trans,len)
       if(trans(1).le.rdcf) sign=-1.D0
       if(trans(1).gt.rdcf) sign=1.D0
       call rlux(trans,len)
       qtwrad=qtwist*sign*trans(1)
       sqtwist=qtwrad
       call zrotat(qtwrad)
     endif
   else
     sqtwist=0.D0
   endif
   if(ialin) call randali
   fh0=fh/vl
!    print transport matrix (cog)
   gpa=0.D0
   do ii=1,ngood
    gpa=gpa+f(7,ii)/xmat
   enddo
   gpa=gpa/DBLE(ngood)
   l=xlqua
   bpa=sqrt(1.D0-1.D0/(gpa*gpa))
   xmco=xmat*bpa*gpa
   ri=33.356D0*xmco*1.D-01/qst
   kq2=b/ri
   call clear
   call elqua(gpa)
   write(16,'(A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A,e12.5,A,/,A,e12.5,A,/)') &
    ' LENGTH = ',xlqua,' cm  APERTURE RADIUS= ',rg,' cm', &
    ' FIELD = ',bquad,' kG  K2 = ',kq2,' cm-2  GRADIENT = ',b,' kG/cm', &
    ' MOMENTUM = ',ri,' kG.cm'
   call matrix
!  Daves start
   idav=idav+1
   iitem(idav)=2
   dav1(idav,1)=xlqua*10.D0
   dav1(idav,2)=bquad
   davtot=davtot+xlqua
   dav1(idav,4)=davtot*10.D0
   dav1(idav,3)=kq2
   dav1(idav,5)=b
   dav1(idav,6)=ri
   dav1(idav,7)=rg*10.D0
!  first half quadrupole
   l=xlqua/2.D0
   do ii=1,ngood
     call clear
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     ri=33.356D0*xmco*1.D-01/f(9,ii)
     kq2=b/ri
     call elqua(gpai)
     call cobeam(ii,l)
   enddo
!  Charge space computations (if dl >0)
   if(ichaes.and.l.gt.0.D0) then
     if(int(sce10).eq.1 .or. int(sce10).eq.3) then
       iesp=.true.
       write(16,'(A)') ' Space charge at the middle  '
       call cesp(xlqua)
       iesp=.false.
!  Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
     endif
   endif
! Test window after the first half quadrupole (after s.c. computations)
   call cogetc
   bcour=0.D0
   do i=1,ngood
     gpai=f(7,i)/xmat
     bcour=sqrt(1.D0-1.D0/(gpai*gpai))+bcour
   enddo
   bcour=bcour/DBLE(ngood)
   gcour=1.D0/sqrt(1.D0-bcour*bcour)
   wcg=(gcour-1.D0)*xmat
! ----- window control
!  Change the t.o.f of the reference
   tref=tref+xlqua/(2.D0*vref)
   PRTLAB='QUADRUPO'
   call reject(nlost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!    second half quadrupole
   do ii=1,ngood
     call clear
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     ri=33.356D0*xmco*1.D-01/f(9,ii)
     kq2=b/ri
     call elqua(gpai)
!   ********CONTROL :print matrix for particle number 1 (only for tests)
!omment        if(ii.eq.1) then
!omment        write(16,*) ' *****second half quadrupole'
!omment         xkq2=sqrt(abs(kq2))
!omment         xkql=xkq2*l*57.29578
!omment         write(16,3300) ri,xkq2,xkql
!omment                call matrix
!omment        endif
     call cobeam(ii,l)
   enddo
! Test window after the second half quadrupole
   call cogetc
!  Change the t.o.f of the reference
   tref=tref+xlqua/(2.D0*vref)
   call reject(ilost,PRTLAB)
   ilost=ilost+nlost
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
   if(itvol) ttvols=tref
   tcog=0.D0
   do i=1,ngood
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   if(itvol) then
!     write(16,11) ttvols*fcpi,davtot,tref*fcpi,tcog*fcpi
!   11    FORMAT(' ** tof: ',e12.5, &
!              ' deg at: ',e12.5,' cm in the lattice', &
!       /,3x,'tof of the reference: ',e12.5,' deg tof of the cog: ', &
!       e12.5,' deg')
     write(16,'(A,e12.5,A,e12.5,A,/,3x,A,e12.5,A,e12.5,A,e12.5,A)') &
       ' ** tof: ',ttvols*fcpi,' deg at: ',davtot, &
       ' cm in the lattice','tof of the reference: ',tref*fcpi,' deg tof of the cog: ', &
       tcog*fcpi,' deg'       
   else
     write(16,'(A,e12.5,A,e12.5,A)') ' ** tof of the reference: ',tref*fcpi, &
       ' deg tof of the cog: ',tcog*fcpi,' deg'
   endif
   dav1(idav,36)=DBLE(ngood)
   write(16,*)' particles lost in quadrupole :',ilost
!  returns coordinates to the initial orientation
!   if(itwist.and.b.ne.0.) then
   if(itwist .and. abs(b).gt.fprec) then
     qtwrad=-sqtwist
     call zrotat(qtwrad)
   endif
   if(iemgrw) call emiprt(0)
!  envelope
   PRLAB(IPRF)='QUADRUPO'
   call stapl(davtot*10.D0)
! check if a .dst file is requested at the output
   if (nodflocs.gt.0) then
     do i=1,nodflocs
!       write(16,*) ' DBX1: ',trim(dflnames(i)),' DBX2: ',trim(adjustl(UDEN))  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then         
         if(idflio(i).eq.2 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_out.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at output of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif               
END SUBROUTINE qalva
!> *******************************************************************
!! SUBROUTINE solquad(iksq,args,argq,xlsol,rg)
!! SOLENOID FIELD ASSOCIATED WITH QUADRUPOLE FIELD
!! space charge computations at the middle of the lens
!! --IKSQ: IFLAG
!! --ARGS: STRENGTH or FIELD OF SOLENOID
!!     If IKSQ = 0 then ARGS is the STRENGTH (cm-1), otherwise ARGS
!!     is the FIELD (kG)
!! --ARGQ: STRENGTH or FIELD of QUADRUPOLE
!!     If IKSQ = 0 then ARGQ is the STRENGTH (cm-2), otherwise ARGQ
!!     is the FIELD (kG)
!!   SIGN CONVENTIONS:
!!     SOLENOID: ARGS positive = rotate the transverse coordinates
!!               about the z-axis in the clockwise direction.
!!     QUADRUPOLE: ARGQ positive = focusing in the plane (x,z)
!! --XLSOL : EFFECTIVE LENGHT OF THE LENS(cm)
!! --RG : APERTURE RADIUS OF THE LENS (cm)
!< *******************************************************************
SUBROUTINE solquad(iksq,args,argq,xlsol,rg)
   USE DynacConstants
   USE m4cavs
   USE m4beam
   USE m4input
   USE m4plots
   USE m4spacecharge
   USE m4output
   USE m4mcs
   USE m4FENE
   USE m4ble
   USE mCOMslq   
   IMPLICIT NONE
   REAL(8) args,argq,rg,bcour,bpa,bpai,bq,bs,dg,fq,gcour,gpa,gpai,ri,strq
   REAL(8) strs,wcg,xks,xksl,xmco,xlsol
   REAL(8) fh0
   INTEGER ii,irot
   INTEGER iksq,i,ilost
   character(len=8) :: PRTLAB
!*******************************************************************
! print out on terminal of transport element # on one and the same line
   NRTRE=NRTRE+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
   FH0=FH/VL
!  PLOT
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
!  random errors in alignment
   if(ialin) call randali
   ilost=0
!   magnetic rigidity (cog)
   gpa=0.D0
   do ii=1,ngood
    gpa=gpa+f(7,ii)/xmat
   enddo
   gpa=gpa/DBLE(ngood)
   l=xlsol
   bpa=sqrt(1.D0-1.D0/(gpa*gpa))
   xmco=xmat*bpa*gpa
   ri=33.356D0*xmco*1.D-01/qst
   if(iksq.ne.0) then
!  argq: quadrupole field (kG), args:solenoid field:(kG)
!   quadrupole
     fq=argq
     bq=fq/rg
     kqo=bq/ri
     strq=kqo
!   solenoid (KSO = 2 * K, see ELSQ)
     bs=args
     kso=bs/ri
     strs=kso/2.D0
   else
!  argq: quadupole strength (cm-2), args: solenoid strength (cm-1)
!    quadrupole
     kqo=argq
     strq=argq
     bq=argq*ri
     fq=bq*rg
!   solenoid (KSO = 2 * K, see ELSQ)
     strs=args
     bs=2.D0*strs*ri
     kso=bs/ri
   endif
   xks=kso/2.D0
!   xksl=xks*l*57.29578
   xksl=xks*l*180.D0/pi
   write(16,*) '****SOLENOID+QUADRUPOLE*******'
   write(16,'(A,F7.3,A,e12.5,/,A,F10.4,A,e12.5,A,e12.5,A,/,A,F10.4,A,e12.5,A,/,A,e12.5,A,/)')&
     '  LENGTH =',xlsol,' cm  APERTURE RADIUS=',rg,' cm', &
     '  SOLENOID: FIELD = ',bs,' kG  K = ',strs, &
     ' cm-1  ROTATING ANGLE = ',xksl,' deg', &
     '  QUADRUPOLE: FIELD  =',fq,' kG   K2 =',strq,' cm-2 ', &
     '  RIGIDITY = ',ri,' kG.cm'
!   write(16,101) xlsol,rg,bs,strs,xksl,fq,strq,ri
!  101  FORMAT('  LENGTH =',F7.3,' cm  APERTURE RADIUS=',e12.5,' cm',/, &
!          '  SOLENOID: FIELD = ',F10.4,' kG  K = ',e12.5, &
!          ' cm-1  ROTATING ANGLE = ',e12.5,' deg',/, &
!          '  QUADRUPOLE: FIELD  =',F10.4,' kG   K2 =',e12.5, &
!          ' cm-2 ',/, &
!          '  RIGIDITY = ',e12.5,' kG.cm',/)
!    print transport matrix (c.o.g.)
!     For convenience, the matrix R and T are computed for a positive KQO = (B/r)*(1/BRO)
!     if KQO is negative one has seting up 90 degree rotation on the beam
   CALL elsq
   write (16,*)' The matrix R and T are shown for a positive strength'
   write (16,*)' For a negative strength set up 90 deg rotation on the beam'
   call matrix
!  start prints in file 'short.data'
   idav=idav+1
   iitem(idav)=11
   dav1(idav,1)=xlsol*10.D0
   dav1(idav,2)=bs
   dav1(idav,3)=fq
   dav1(idav,5)=strq
   dav1(idav,6)=kso/2.D0
   dav1(idav,7)=rg*10.D0
   dav1(idav,8)=ri
   davtot=davtot+xlsol
   dav1(idav,4)=davtot*10.D0
! first half lens
   dg=xlsol
   l=xlsol/2.D0
   do ii=1,ngood
     CALL CLEAR
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     RI=33.356D0*XMCO*1.D-01/f(9,ii)
! KSO =K/2, see ELSQ
     KSO = BS / RI
!    IF(KSO .EQ. 6.*0) KSO=1.D-16
     IF(abs(KSO) .LE. fprec) KSO=1.D-16
     KQO = BQ / RI
     CALL ELSQ
! the matrix R and T are computed for a positive KQO = (B/rg)*(1/BRO)
! if KQO is negative set up 90 degree rotation on the beam
     IF(KQO .LT. 0.D0) THEN
       irot=ii
       CALL rotat(irot)
       CALL cobeam(ii,l)
!   return the coordinates to their initial orientation
       irot=-ii
       CALL rotat(irot)
     ELSE
       CALL cobeam(ii,l)
     ENDIF
   enddo
!  Charge space effect (if l >0)
!   if(ichaes.and.l.gt. 0.D0) then
   if(ichaes .and. abs(l).gt.fprec) then
     if(int(sce10).eq.1 .or. int(sce10).eq.3) then
       iesp=.true.
       write(16,'(A)') ' Space charge at the middle  '
       call cesp(xlsol)
       iesp=.false.
! Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
     endif
   endif
! test window after the first half solquad
   call cogetc
   bcour=0.D0
   do i=1,ngood
     gpai=f(7,i)/xmat
     bcour=sqrt(1.D0-1.D0/(gpai*gpai))+bcour
   enddo
   bcour=bcour/DBLE(ngood)
   gcour=1.D0/sqrt(1.D0-bcour*bcour)
   wcg=(gcour-1.D0)*xmat
! ----- convert wdisp in dp/p (for window control)
   tref=tref+xlsol/(2.D0*vref)
   PRTLAB='SOQUAD  '
   call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!   beam after the second half lens
   do ii=1,ngood
     CALL CLEAR
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     RI=33.356D0*XMCO*1.D-01/f(9,ii)
     KSO = BS / RI
!   KSO =K/2, see ELSQ
!    IF(KSO .EQ. 0.) KSO=1.D-16
     IF(abs(KSO) .LE. fprec) KSO=1.D-16
     KQO = BQ / RI
     CALL ELSQ
!     the matrix R and T are computed for a positive KQO = (B/r)*(1/BRO)
!     if KQO is negative set up 90 degree rotation on the beam
     IF(KQO .LT. 0.D0) THEN
       IROT=II
       CALL rotat(irot)
       CALL cobeam(ii,l)
       IROT=-II
       CALL rotat(irot)
     ELSE
       CALL cobeam(ii,l)
     ENDIF
   enddo
!t.o.f of reference
   TREF=TREF+XLSOL/(VREF*2.D0)
   call reject(ilost,PRTLAB)
   dav1(idav,36)=DBLE(ngood)
!   plots
   PRLAB(IPRF)='SOQUAD  '
   CALL STAPL(davtot*10.D0)
   if(iemgrw) call emiprt(0)
   WRITE(16,*) 'Particles lost in solenoid + quad',ilost
END SUBROUTINE solquad
!> *******************************************************************
!! SUBROUTINE qasex(iksq,args,argq,xlqua,rg)
!! quadrupole associated sextupole field
!! space charge computation at the middle of the lens
!!   IKSQ: IFLAG (see ARGS and ARGQ)
!!   ARGS: strength of SEXTUPOLE
!!     IKSQ = 0, then ARGS =KS2 (cm-3), otherwise ARGS = FIELD FS(kG)
!!   ARGQ: strength of QUADRUPOLE
!!   If IKSQ = 0, then ARGQ=KQ2 (cm-2), otherwise ARGQ = FIELD FQ(kG)
!!   XLQUA : EFFECTIVE LENGHT OF THE LENS(cm)
!!   RG : APERTURE RADIUS OF THE LENS (cm)
!< *******************************************************************
SUBROUTINE qasex(iksq,args,argq,xlqua,rg)
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4FENE
   USE m4ITVOLE
   USE m4ble
   USE m4QSEX
   USE mCOMqskew
   IMPLICIT NONE
   REAL(8) xlqua,rg,bcour,bpa,bpai,fh0,gcour,gpa,gpai
   REAL(8) wcg,xmco,ri
   INTEGER i,ii,ilost,nlost
   character(len=8) :: PRTLAB
   REAL(8) args,argq,bq,bs,fq,fs,rgorge
   INTEGER iksq
!*******************************************************************
! print out on terminal of transport element # on one and the same line
   NRTRE=NRTRE+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)             
   rgorge=rg
   ilost=0
!  statistics
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
!  if itwist=.true. skews the quasex before misalignments
!omment       len=1
!omment       if(itwist.and.b.ne.0.) then
!omment         if(iqrand.eq.0) then
!omment           qtwrad=qtwist
!omment           sqtwist=qtwrad
!omment           call zrotat(qtwrad)
!omment         else
!omment           rdcf=0.5D0
!omment           call rlux(trans,len)
!omment           if(trans.le.rdcf) sign=-1.D0
!omment           if(trans.gt.rdcf) sign=1.D0
!omment           call rlux(trans,len)
!omment           qtwrad=qtwist*sign*trans
!omment           sqtwist=qtwrad
!omment           call zrotat(qtwrad)
!omment         endif
!omment       endif
!   misalignments
   if(ialin) call randali
   gpa=0.D0
   do ii=1,ngood
    gpa=gpa+f(7,ii)/xmat
   enddo
   gpa=gpa/DBLE(ngood)
   l=xlqua
   bpa=sqrt(1.D0-1.D0/(gpa*gpa))
   xmco=xmat*bpa*gpa
   ri=33.356D0*xmco*1.D-01/qst
   if(iksq.ne.0) then
!  --- quadrupole: argq = field fq (kG)
     fq=argq
     bq=fq/rg
! kq2: strength (cm-2)
     kq2=bq/ri
! --- sextupole: args = field fs (kG)
     fs=args
     bs=fs/(rg*rg)
! ks2 strength (cm-3)
     ks2=bs/ri
   else
! --- quadrupole: argq is kq2 (cm-2)
     kq2=argq
     fq=kq2*rg*ri
     bq=kq2*ri
! --- sextupole: args is ks2 (cm-3)
     ks2=args
     bs=ks2*ri
     fs=bs*(rg*rg)
   endif
   call clear
   call elqsex
   write(16,*) ' *****LENS QUADRUPOLE+SEXTUPOLE ********'
   write(16,'(A,e12.5,A,e12.5,A,/,A,e12.5,A,e12.5,A,e12.5,A)') &
     ' LENS: LENGTH = ',xlqua,' cm APERTURE RADIUS = ',rg,' cm', &
     ' QUADRUPOLE: FIELD = ',fq,' kG   KQ2 = ',kq2,' cm-2  GRADIENT = ',bq,' kG/cm'
   write(16,'(A,e12.5,A,e12.5,A,e12.5,A,/,A,e12.5,A,/)') &
     ' SEXTUPOLE : FIELD = ',fs,' kG   KS2 = ',ks2,' cm-3  GRADIENT = ',bs, &
     ' kG/(cm*cm)',' MOMENTUM = ',ri,' kG.cm'
   FH0=FH/VL
   write(16,*)'TOF at input:',tref*fh*180.D0/pi,' deg'
!    print transport matrix  (c.o.g.)
   call matrix
!  start Daves
   idav=idav+1
   iitem(idav)=12
   dav1(idav,1)=xlqua*10.D0
   dav1(idav,6)=rg*10.D0
   dav1(idav,2)=fq
   dav1(idav,3)=kq2
! gradient (quad)       dav1(idav,5)=bq
   dav1(idav,7)=fs
   dav1(idav,8)=ks2
! gradient (sol)       dav1(idav,9)=bs
   dav1(idav,10)=ri
   davtot=davtot+xlqua
   dav1(idav,4)=davtot*10.D0
!  first half quasex
   l=xlqua/2.D0
   do ii=1,ngood
     CALL CLEAR
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     RI=33.356D0*XMCO*1.D-01/f(9,ii)
     KQ2  =  BQ/RI
     KS2  =  BS/RI
     CALL ELQSEX
!   ********CONTROL :print matrix for particle number 1 (only for tests)
!omment        if(ii.eq.5) then
!omment         write(16,*) ' *****first half quasex'
!omment         xkq2=sqrt(abs(kq2))
!omment         xkql=xkq2*l*57.29578
!omment         xks=sqrt(abs(ks2))
!omment         xksl=xks*l**(1.5D0)*57.29578
!omment         write(16,3300) ri,xkq2,xkql,xks,xksl
!omment             call matrix
!omment        endif
!       ********END CONTROL
     CALL cobeam(ii,l)
   enddo
!      Charge space effect (if dl >0)
   if(ichaes.and.l.gt.0.D0) then
     if(int(sce10).eq.1 .or. int(sce10).eq.3) then
       iesp=.true.
       write(16,'(A)') ' Space charge at the middle  '
       call cesp(xlqua)
       iesp=.false.
! Change the dispersion dE/E with respect to the C.O.G of the bunch
       call disp
     endif
   endif
! Test window after the first half quasex (after s.c. computations)
   bcour=0.D0
   do i=1,ngood
     gpai=f(7,i)/xmat
     bcour=sqrt(1.D0-1.D0/(gpai*gpai))+bcour
   enddo
   bcour=bcour/DBLE(ngood)
   gcour=1.D0/sqrt(1.D0-bcour*bcour)
   wcg=(gcour-1.D0)*xmat
! ----- window control
   call cogetc
!  Change the t.o.f of the reference
   tref=tref+xlqua/(2.D0*vref)
   PRTLAB='QUADSXT '
   call reject(nlost,PRTLAB)
!    second half quasex
   do ii=1,ngood
     call clear
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     ri=33.356D0*xmco*1.D-01/f(9,ii)
     kq2  =  bq/ri
     ks2  =  bs/ri
     call elqsex
!    ********CONTROL :print matrix for particle number 1 (only for tests)
!omment        if(ii.eq.5) then
!omment         write(16,*) ' *****second half quasex'
!omment         xkq2=sqrt(abs(kq2))
!omment         xkql=xkq2*l*57.29578
!omment         xks=sqrt(abs(ks2))
!omment         xksl=xks*l**(1.5D0)*57.29578
!omment         write(16,3300) ri,xkq2,xkql,xks,xksl
!omment                call matrix
!omment        endif
!       ********END CONTROL
     call cobeam(ii,l)
   enddo
! Test window after the second half quasex (only in transverse directions and phase)
   call cogetc
!  Change the t.o.f of the reference
   tref=tref+xlqua/(2.D0*vref)
   call reject(ilost,PRTLAB)
   ilost=ilost+nlost
   dav1(idav,36)=DBLE(ngood)
   write(16,*)'TOF at output:',tref*fh*180.D0/pi,' deg'
   write(16,*)' particles lost:',ilost
!  returns coordinates to the initial orientation
!omment       if(itwist.and.b.ne.0.) then
!omment         qtwrad=-sqtwist
!omment         call zrotat(qtwrad)
!omment       endif
       if(iemgrw) call emiprt(0)
       PRLAB(IPRF)='QUADSXT '
       CALL STAPL(davtot*10.D0)
END SUBROUTINE qasex
!> *******************************************************************
!! SUBROUTINE sextu(imk2,arg,xlsex,rg)
!! magnetic sextupole
!! Space charge at the middle of the lens
!< *******************************************************************
SUBROUTINE sextu(imk2,arg,xlsex,rg)
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff
   USE m4plots
   USE m4FENE
   USE m4ITVOLE
   USE m4ble
   USE m4QSEX
   USE mCOMqskew
   IMPLICIT NONE
   REAL(8) rg,bcour,bpa,bpai,fh0,gcour,gpa,gpai,qtwrad,rdcf,sign,sqtwist
   REAL(8) wcg,xmco,ri,arg,xlsex,b,dispr,fb
   INTEGER i,ii,ilost,nlost,imk2,len
   character(len=8) :: PRTLAB
   REAL(8) trans(2)
!*******************************************************************
   ilost=0
   write(16,*) ' ******SEXTUPOLE*********'
!  statistics
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
   NRTRE=NRTRE+1
! print out on terminal of transport element # on one and the same line
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
   len=1
!  if itwist=.true. skews the sextupole before misalignments
   sqtwist=0.D0
!   if(itwist.and.arg.ne.0.) then
   if(itwist .and. abs(arg).gt.fprec) then
     if(iqrand.eq.0) then
       qtwrad=qtwist
       sqtwist=qtwrad
       call zrotat(qtwrad)
     else
       rdcf=0.5D0
       call rlux(trans,len)
       if(trans(1).le.rdcf) sign=-1.D0
       if(trans(1).gt.rdcf) sign=1.D0
       call rlux(trans,len)
       qtwrad=qtwist*sign*trans(1)
       sqtwist=qtwrad
       call zrotat(qtwrad)
     endif
   endif
   if(ialin) call randali
   FH0=FH/VL
   write(16,*)'TOF at input:',tref*fh*180.D0/pi,' deg'
!
   gpa=0.D0
   do ii=1,ngood
    gpa=gpa+f(7,ii)/xmat
   enddo
   gpa=gpa/DBLE(ngood)
   l=xlsex
   bpa=sqrt(1.D0-1.D0/(gpa*gpa))
   xmco=xmat*bpa*gpa
   ri=33.356D0*xmco*1.D-01/qst
   if(imk2.ne.0) then
!   arg: field B (kG)
     fb=arg
     b=arg/(rg*rg)
     ks2=b/ri
   else
!  arg: KS2 (cm-3)
     ks2=arg
     b=ks2*ri
     fb=b*(rg*rg)
   endif
   write(16,'(A,e12.3,A,e12.5,A,/A,e12.5,A,e12.5,A,e12.5,A,/,A,e12.5,A,/)') &
     ' LENGTH = ',xlsex,' cm  APERTURE RADIUS= ',rg,' cm', &
     ' FIELD = ',fb,' kG  KS2 = ',ks2,' cm-3  GRADIENT = ',b,' kG/(cm*cm)', &
     ' MOMENTUM = ',ri,' kG.cm'
   call clear
   call elsex
!    print transport matrix (c.o.g.)
   call matrix
!     start daves
   idav=idav+1
   iitem(idav)=10
   dav1(idav,1)=xlsex*10.D0
   dav1(idav,2)=b
   dav1(idav,3)=fb
   davtot=davtot+xlsex
   dav1(idav,4)=davtot*10.D0
   dav1(idav,5)=ks2
   dav1(idav,6)=rg
   dav1(idav,7)=ri
!  first half sextupole
   l=xlsex/2.D0
   do ii=1,ngood
     CALL CLEAR
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     ri=33.356D0*xmco*1.D-01/f(9,ii)
     KS2  =  B/RI
     CALL ELSEX
     CALL cobeam(ii,l)
!   the evolution of the t.o.f is made in routine cobeam)
!omment      f(6,ii)=f(6,ii)+l/(bpai*vl)
   enddo
!      Charge space effect (if dl >0)
   if(ichaes.and.l.gt.0.D0) then
     if(int(sce10).eq.1 .or. int(sce10).eq.3) then
       iesp=.true.
       write(16,'(A)') ' Space charge at the middle  '
       call cesp(xlsex)
       iesp=.false.
     endif
   endif
   bcour=0.D0
   do i=1,ngood
     gpai=f(7,i)/xmat
     bcour=sqrt(1.D0-1.D0/(gpai*gpai))+bcour
   enddo
   bcour=bcour/DBLE(ngood)
   gcour=1.D0/sqrt(1.D0-bcour*bcour)
   wcg=(gcour-1.D0)*xmat
! ----- convert wdisp in dp/p (window control)
! ---- ifw = 0 ===> wdisp = dW/W
! ---- ifw = 1 ===> wdisp = dW (MeV)
   if(ifw.eq.0) dispr=gcour*gcour*wdisp/(gcour*(gcour+1.D0))
   if(ifw.eq.1) dispr=gcour*gcour*wdisp/(gcour*(gcour+1.D0)*wcg)
! ---- Change the dispersion with the new energy
   do i=1,ngood
     gpai=f(7,i)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     fd(i)=bpai/bcour * gpai/gcour
   enddo
! Test window after the first half sextupole
   call cogetc
!  Change the t.o.f of the reference
   tref=tref+xlsex/(2.D0*vref)
   PRTLAB='SEXTUPO '
   call reject(nlost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
!  second half sextupole
   do ii=1,ngood
     CALL CLEAR
     gpai=f(7,ii)/xmat
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     xmco=xmat*bpai*gpai
     RI=33.356D0*XMCO*1.D-01/f(9,ii)
     KS2  =  B/RI
     CALL ELSEX
     CALL COBEAM(II,L)
   enddo
! Test window after the second half sextupole (only in transverse directions and phase)
   call cogetc
!  Change the t.o.f of the reference
   tref=tref+xlsex/(2.D0*vref)
   call reject(ilost,PRTLAB)
   ilost=ilost+nlost
   dav1(idav,36)=DBLE(ngood)
   write(16,*)'TOF at output:',tref*fh*180.D0/pi,' deg'
   write(16,*)' particles lost in sextupole :',ilost
!  returns coordinates to the initial orientation
!       if(itwist.and.b.ne.0.) then
   if(itwist .and. abs(b).gt.fprec) then
     qtwrad=-sqtwist
     call zrotat(qtwrad)
   endif
   if(iemgrw) call emiprt(0)
   PRLAB(IPRF)='SEXTUPO '
   CALL STAPL(davtot*10.D0)
END SUBROUTINE sextu
!> *******************************************************************
!! SUBROUTINE bunparm(v,dp,harm,prlim)
!! BUNCHER  (NO SPACE CHARGE EFFECT)
!< *******************************************************************
SUBROUTINE bunparm(v,dp,harm,prlim)
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4cavs2
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE m4FENE
   USE m4ITVOLE
   USE m4ble, ONLY: cr
   USE mCOMcorec
   IMPLICIT NONE
   REAL(8) v,dp,harm,prlim,twopi,freq,wavel,fcpi
   REAL(8) a,arg,bav,bcog,bcour,beref,bg,bgav,bgf,bgx,bgy,cay,caysq,cayrsq,con
   REAL(8) del,dgr,dw,e0t,emns,encog,engain,enref,ENRPRIN,older,ewer,f2,f3,f4,f5
   REAL(8) gamref,gav,gcog,gor,gpa,otref,ovref,xkpi,pveff,r1,rs,rad
   REAL(8) rhs,s,tcog,trnsms,w,wb,wf,wsync
   REAL(8) xi0,xi1okr,ttvpi
   INTEGER np,ixkpi,ilost,len
   character(len=8) :: PRTLAB
   REAL(8) vecx(1)
!*******************************************************************
!  ENVELOPE
   PRLAB(IPRF)='BUNCHER '
   PRTLAB=PRLAB(IPRF)
   call stapl(davtot*10.D0)
!xx   ilost=0
   twopi=2.D0*pi
   freq=fh/twopi
   wavel=vl/freq
   fcpi=fh*180.D0/pi
! print out on terminal of transport element # on one and the same line
   nrbunc=nrbunc+1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Buncher             :',nrbunc,cr
   if (harm .LE. 0.D0) harm=1.D0
   rhs=prlim*prlim
!   test window
   call reject(ilost,PRTLAB)
   tcog=0.D0
   bcog=0.D0
   do np=1,ngood
     tcog=tcog+f(6,np)
     gpa=f(7,np)/xmat
     bcog=sqrt(1.D0-1.D0/(gpa*gpa))+bcog
   enddo
   tcog=tcog/DBLE(ngood)
   bcog=bcog/DBLE(ngood)
   gcog=1.D0/sqrt(1.D0-bcog*bcog)
   encog=xmat*gcog-xmat
! adjustement of the phase of RF w.r.t. the T.O.F.
   xkpi=0.D0
   if(imamin) then
     ttvpi=harm*ttvols*fcpi
     xkpi=ttvpi/360.D0
     ixkpi=int(xkpi)
     xkpi=(xkpi-DBLE(ixkpi))*360.D0
     write(16,*) ' *** TOF correction:',-xkpi,' deg'
     dp=dp-xkpi*pi/180.D0
     write(16,*)' ***phase of RF adjusted : ',dp*180.D0/pi,' deg'
   endif
! 20/08/2009    delay of phase of the reference at input w.r.t. the synchronous phase
! 20/08/2009       ttvpi=harm*ttvols*fcpi
! 20/08/2009       xkpi=ttvpi/180.D0
! 20/08/2009       ixkpi=xkpi+0.5
! 20/08/2009       ixkpi=ixkpi*180
! 20/08/2009       xkpc=cos(ixkpi*pi/180.D0)
! 20/08/2009       xkpi=ttvpi-DBLE(ixkpi)
! 20/08/2009       if(itvol.and.imamin)
! 20/08/2009     *  write(16,8975) dp*180.D0/pi,xkpi
! 20/08/2009 8975   format('***previous phase offset: ',e12.5,' deg',/,
! 20/08/2009     * '***new phase offset: ',e12.5,' deg')
!  start of write to file '.short' for buncher
   idav=idav+1
   iitem(idav)=8
   dav1(idav,1)=v
   dav1(idav,2)=dp*180.D0/pi
   dav1(idav,3)=prlim
   dav1(idav,4)=davtot*10.D0
   if(itvol) dav1(idav,5)=-xkpi
!  end
   WRITE(16,'(/,A,/,A)')' Dynamics at the input', &
   '        BETA     GAMMA      ENERGY(MeV)        TOF(deg)     TOF(sec)'
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' COG ', & 
         bcog,gcog,encog,tcog*fcpi,tcog
   e0t=harm*v/(bcog*wavel)
   pveff=v
!    random or systematic error on  RF level
   if(ierpf.eq.1) then
!  systematic error on RF level
     e0t=e0t*(1.D0+vfield)
     pveff=v*(1.D0+vfield)
!  random error on RF level
   elseif(ierpf.ge.2) then
     len=1
     call rlux(vecx,len)
     r1=(2.D0*vecx(1)-1.D0)*vfield
     e0t=e0t*(1.D0+r1)
     pveff=v*(1.D0+r1)
   endif
   cay=harm*twopi/(bcog*gcog*wavel)
   caysq=cay**2
   con=twopi*e0t*qmoy/xmat
   rad=pi/180.D0
!  systematic error on  phase
   if(ierpf.eq.1) dp=dp+vphase*rad
!  random error on phase
   if(ierpf.ge.2) then
     len=1
     call rlux(vecx,len)
     r1=(2.D0*vecx(1)-1.D0)*vphase*rad
     dp=dp+r1
   endif
! shift=true => reference and COG seperated, otherwise reference=COG
! --- save the reference
   ovref=vref
   otref=tref
! --- shift = false: the reference particle is the cog
   if(shift) then
     ovref=vref
     beref=vref/vl
     gamref=1.D0/sqrt(1.D0-beref*beref)
     older=xmat*gamref
   else
     tref=tcog
     vref=bcog*vl
     ovref=vref
     beref=bcog
     gamref=1.D0/sqrt(1.D0-beref*beref)
     older=xmat*gamref
   endif
! ---  if imamin = false: phase setting has been forced equal to dp, otherwise phase setting has been adjusted
   dgr=v*cos(harm*ttvols*fh+dp)*qmoy
   ewer=older+dgr
   gor=ewer/xmat
   vref=vl*sqrt(1.D0-1.D0/(gor*gor))
   ENRPRIN=older-xmat
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' REF ', & 
         beref,gamref,ENRPRIN,tref*fh*180.D0/pi,tref
   wsync=0.D0
   bcour=0.D0
   tcog=0.D0
   do np=1,ngood
     rs=f(2,np)**2+f(4,np)**2
     a=harm*(f(6,np)-tref+ttvols)*fh+dp
     rs=rs*1.D-04
! 20/08/2009         s=sin(a)*xkpc
     s=sin(a)
     w=f(7,np)-xmat
     bg=sqrt(w/xmat*(2.D0+w/xmat))
!    conversion cm-->m and mrd--->rd
     f2=f(2,np)
     f4=f(4,np)
     f3=f(3,np)*1.D-03
     f5=f(5,np)*1.D-03
     bgx=f3*bg
     bgy=f5*bg
     cayrsq=caysq*rs
     arg=cayrsq/4.D0
     xi0=1.D0+arg*(1.D0+arg*(.25D0+arg/36.D0))
!       dw=v*cos(a)*xi0*qmoy
     dw=v*cos(a)*xi0*f(9,np)
! 20/08/2009         dw=dw*xkpc
     wb=w+.5D0*dw
     bgav=sqrt(wb/xmat*(2.D0+wb/xmat))
     gav=1.D0+wb/xmat
     bav=bgav/gav
     bcour=bcour+bav
     wf=w+dw
     bgf=sqrt(wf/xmat*(2.D0+wf/xmat))
     xi1okr=0.5D0+.25D0*arg+arg**2/24.D0
     del=-con*s*(1.D0-bav*bcog)*xi1okr/bav
     tcog=tcog+f(6,np)
     f3=(bgx+del*f2)/bgf
     f(3,np)=f3*1.D3
     f5=(bgy+del*f4)/bgf
     f(5,np)=f5*1.D3
     f(7,np)=wf+xmat
     wsync=wsync+wf
   enddo
   wsync=wsync/DBLE(ngood)
   bcour=bcour/DBLE(ngood)
   tcog=tcog/DBLE(ngood)
! Test window
   call reject(ilost,PRTLAB)
! new output
! shift=true => reference and COG seperated, otherwise reference=COG
   engain=wsync-encog
   if(shift) then
     beref=vref/vl
     gamref=1.D0/sqrt(1.D0-beref*beref)
     enref=ewer-xmat
   else
     tref=tcog
     vref=bcour*vl
     beref=bcour
     enref=wsync
     dgr=engain
   endif
   if(itvol) ttvols=tref
   WRITE(16,'(/,A,/,A)')' Dynamics at the output', &
   '        BETA     dW(MeV)    ENERGY(MeV)    TOF(deg)     TOF(sec)'
   WRITE(16,'(A,f7.5,3x,f10.6,3x,f8.3,3x,e12.5,3x,e12.5)') ' REF ', & 
         beref,dgr,enref,fh*TREF*180.D0/pi,TREF
   WRITE(16,'(A,f7.5,3x,f10.6,3x,f8.3,3x,e12.5,3x,e12.5)') ' COG ', & 
         bcour,engain,wsync,tcog*fh*180.D0/pi,tcog
! save number of good particles for .short file
   dav1(idav,36)=DBLE(ngood)
! as beam passed through buncher, assume bunched beam
   ifcont=.false.
   WRITE(16,*) 'After buncher, bunched beam assumed'
   call emiprt(0)
   emns=(1.D12)*dav1(idav,12)/(4.D0*fh)
   trnsms=100.D0*DBLE(ngood)/DBLE(imax)
   if(nrbunc.eq.1) write(50,'(A)') '# buncher.dmp'
   if(nrbunc.eq.1) write(50,'(A,A,A,A,A)') &
     '#  cav     Z       trans   ', &
     'PHIs     TOF(COG)      COG      Wcog          TOF(REF)   ', &
     '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ', &
     'El,RMS        dWref        EffVolt      ElementName      ', &
     '          amplitude'         
   if(nrbunc.eq.1) write(50,'(A,A,A,A,A)') &
    '#   #     (m)       (%)    ', &
    '(deg)     (deg)        beta     (MeV)          (deg)      ', &
    '   beta        (MeV)      (mm.mrad)    (mm.mrad)    ', &
    '(ns.keV)      (MeV)          (MV)                         ',&
    '         see EffVolt'         
   write(50,'(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A)') &
    nrbunc,0.001D0*dav1(idav-1,4),trnsms, &
    dav1(idav-1,2),tcog*fh*180.D0/pi,bcour,wsync,fh*TREF*180.D0/pi, &
    beref,enref,0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),emns, &
    dgr,pveff,trim(uden)
!
!    write(50,7023) nrbunc,0.001D0*dav1(idav-1,4),trnsms, &
!    dav1(idav-1,2),tcog*fh*180.D0/pi,bcour,wsync,fh*TREF*180.D0/pi, &
!    beref,enref,0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),emns, &
!    dgr,pveff,trim(uden)
! 7023    format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x, &
!         2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A)
END SUBROUTINE bunparm
!> *******************************************************************
!! SUBROUTINE dwref_bunc(gam5,t5)
!! compute the energy gain and the time of flight of the reference
!! over the cavity(gap) at the exit of the cavity(gap):
!! gam5 = relativistic gamma,  t5 = tof (cavity)
!< *******************************************************************
SUBROUTINE dwref_bunc(gam5,t5)
   USE DynacConstants
   USE m4trace3d
   USE m4beam
   USE m4cavs
   USE m4numcavs
   USE fun4mhb, ONLY: xf1
   USE m4SPLfun
   USE m4RESTAY, ONLY: xlim,ncell
   USE mCOMkcell
   USE mCOMstep
   USE mCOMxitrd3
   USE mCOMsphi
   IMPLICIT NONE
   REAL(8) gam5,t5
   REAL(8) d2gdz2,dgam,dgdz,e0,estop,eww,gam0,gam1,gam2,gam3,gam4,rphas,t0,ttphi,ttvol
   REAL(8) wdgam,wdgams,xlcel,xlcum,xlpos,xnhc,xpas2,xpat,xpcel
   INTEGER ico,inc,isce,istop
!*******************************************************************
!  save previous xpas
   xpcel=xpas
   xlpos=0.D0
   isce=20
   xlcum=0.D0
   b0=vref/vl
   b1=b0
   b2=b0
   b3=b0
   b4=b0
   b5=b0
   t0=0.D0
!   xlcel (cm): length of current cell
!   xlim(inc) cm: limits of current cell
!   isce: step number in cell (forced isce = 20)
!   wdgam: energy gain over the cell
! **************************************
   do inc=1,ncell
     bcour1(inc)=b0
     tcour1(inc)=t0
     wdgams=0.D0
     xnh=0.D0
     xlcel=xlim(inc+1)-xlim(inc)
     xlpos=xlpos+xlcel
     xpas=xlcel/DBLE(isce)
     e0=xmat
     xnhc=0
     gam0=1.D0/sqrt(1.D0-b0*b0)
     estop=xpas/10.D0
     istop=0
     DO
       xpat=xnhc*xpas
       if(xpat.ge.(xlcel-estop)) EXIT
       call fposbb(xlcum)
! ---  energy gain over the step
       b1=b0
       b2=b0
       b3=b0
       b4=b0
       b5=b0
       rphas=0.D0
       ico=0
! predictor
       dgam=xf1(ico,rphas,t0,t5)*qst/e0
       gam5=gam0+dgam
! corrector
       xpas2=xpas*xpas
       dgdz=qst/e0 * tspl0
       d2gdz2=dgam/xpas2-dgdz/xpas
       d2gdz2=2.D0*d2gdz2
       gam1=gam0+dgdz*xpas/5.D0+d2gdz2*xpas2/50.D0
       gam2=gam0+dgdz*xpas*2.D0/5.D0+d2gdz2*xpas2*4.D0/50.D0
       gam3=gam0+dgdz*xpas*3.D0/5.D0+d2gdz2*xpas2*9.D0/50.D0
       gam4=gam0+dgdz*xpas*4.D0/5.D0+d2gdz2*xpas2*16.D0/50.D0
       b1=sqrt(gam1*gam1-1.D0)/gam1
       b2=sqrt(gam2*gam2-1.D0)/gam2
       b3=sqrt(gam3*gam3-1.D0)/gam3
       b4=sqrt(gam4*gam4-1.D0)/gam4
       b5=sqrt(gam5*gam5-1.D0)/gam5
       dgam=xf1(ico,rphas,t0,t5)*qst/e0
       gam5=gam0+dgam
       eww=xmat*(gam5-1.D0)
       wdgam=xmat*dgam
       wdgams=wdgams+wdgam
       b5=sqrt(gam5*gam5-1.D0)/gam5
       b0=b5
       t0=t5
       gam0=gam5
       xnh=xnh+1.D0
       xnhc=xnhc+1.D0
     ENDDO
     tcour2(inc)=t5
     xlcum=xlcum+xlcel
     ttvol=t5*fh*180.D0/pi
     ttphi=ttvol+tref*fh*180/pi
     bcour2(inc)=b5
     tr3dw(inc)=wdgams
! ************************************************
!     write(13,101) NRRES,inc,xlim(inc),xlim(inc+1), &
!         xlcel,eww,wdgams,ttvol,ttphi,avrg(inc)
!  101    format(2(2x,i4),8(2x,e12.5))
     write(13,'(2(2x,i4),8(2x,e12.5))') NRRES,inc,xlim(inc),xlim(inc+1), &
           xlcel,eww,wdgams,ttvol,ttphi,avrg(inc)
     fldctr(inc)=avrg(inc)-xlim(inc)
     zend(inc)=xlcel-fldctr(inc)
   enddo
! restore  xpas
   xpas=xpcel
END SUBROUTINE dwref_bunc
!> *******************************************************************
!! SUBROUTINE bcnum_bunc(ylg,ncell)
!! dynamics in the thick buncher
!< *******************************************************************
SUBROUTINE bcnum_bunc(ylg,ncell)
   USE DynacConstants
   USE m4beam
   USE m4cavs
   USE m4numcavs
   USE m4input
   USE m4output
   USE m4plots, ONLY: uden   
   USE m4spacecharge
   USE m4numcavs
   USE fun4mhb, ONLY: xf1,xf2,xjf1,xjf2
   USE mCOMstep
   USE mCOMelec
   USE mCOMtestref
   IMPLICIT NONE
   REAL(8) ylg
   REAL(8) d2gdz2,dgam,dgdz,e0,gam0,gam1,gam2,gam3,gam4,t0
   REAL(8) xpas2
   REAL(8) a1,beref,gamref,enref,ddt,ddt1,dgdzr,dred,dxpe1,dype1,eglsc,f6i,qc,red,red2
   REAL(8) gam00,gam11,gam22,gam33,gam44,gam55,gamm0,gamm1,gamm2,gam5,rk1,rk2
   REAL(8) t5,tmoy,tof,ttt1,ttt2,x0,xe0,xi,xk1,xpe0,xpi,xt0,y0,ye0,yi,yp0,ype0,ypi
   INTEGER ncell
   INTEGER i,i1,ico,ilost,j,npas,npas1
   REAL(8) gam(500),xe(500),xpe(500),ye(500),ype(500)
   REAL(8), allocatable ::  tcour(:),phi(:)  
   logical flgsc
   INTEGER lossreason
   character(len=8) :: PRTLAB
!*******************************************************************
   allocate(tcour(iptsz))
   allocate(phi(iptsz))
!   ylg(cm) length of cavity, xpas(cm): step length
!   8 steps over a cell
   PRTLAB='MHB'
   BEREF=VREF/VL
   GAMREF=1.D0/SQRT(1.D0-(BEREF*BEREF))
   ENREF=XMAT*GAMREF
   e0=xmat
   npas=ncell*istep
   xpas=ylg/DBLE(npas)
   npas1=npas+1
   xnh=0.D0
!   flgsc = true ---> s.c. computation
!   eglsc = 2*xpas : acting length of s.c. computation
   eglsc=2.D0*xpas
   flgsc=.false.
   do i=2,npas1
     i1=i-1
! --- seek the field E(z) values in the 6 positions in the step length xh
     call fposb
     tmoy=0.D0
     do j=1,ngood
       tmoy=tmoy+f(6,j)
     enddo
     tmoy=tmoy/DBLE(ngood)
     do j=1,ngood
       qc=f(9,j)
       gam0=f(7,j)/e0
       gam(i1)=gam0
       if(i1.eq.1) then
         tcour(j)=0.D0
         tof=f(6,j)
! ---  phase delay between the actual particle  and the reference (entrance of the cavity)
         phi(j)=(tof-tref)
       endif
       t0=tcour(j)
       ddt=t0
!  predictor (energy gain)
       if(gam0.le.1.D0) then
         f(8,j)=0.D0
         cycle
       endif
       b0=sqrt(gam0*gam0-1.D0)/gam0
       b1=b0
       b2=b0
       b3=b0
       b4=b0
       b5=b0
       ico=0
       dgam=xf1(ico,phi(j),t0,t5)*qc/e0
       gam5=gam(i1)+dgam
!   corrector (energy gain)
!   tspl0 = dE/dz  (MV/(cm*cm)
       xpas2=xpas*xpas
       dgdz=qst/e0 * tspl0
       d2gdz2=dgam/xpas2-dgdz/xpas
       d2gdz2=2.D0*d2gdz2
       gam1=gam0+dgdz*xpas/5.D0+d2gdz2*xpas2/50.D0
       gam2=gam0+dgdz*xpas*2.D0/5.D0+d2gdz2*xpas2*4.D0/50.D0
       gam3=gam0+dgdz*xpas*3.D0/5.D0+d2gdz2*xpas2*9.D0/50.D0
       gam4=gam0+dgdz*xpas*4.D0/5.D0+d2gdz2*xpas2*16.D0/50.D0
       b1=sqrt(gam1*gam1-1.D0)/gam1
       b2=sqrt(gam2*gam2-1.D0)/gam2
       b3=sqrt(gam3*gam3-1.D0)/gam3
       b4=sqrt(gam4*gam4-1.D0)/gam4
       b5=sqrt(gam5*gam5-1.D0)/gam5
       dgam=xf1(ico,phi(j),t0,t5)*qc/e0
       gam5=gam(i1)+dgam
       b5=sqrt(gam5*gam5-1.D0)/gam5
!  tranverse coordinates in (cm,rad)
       x0=f(2,j)
       y0=f(4,j)
       xt0=f(3,j)*1.D-03
       yp0=f(5,j)*1.D-03
!    Picht transformation: xe0 and ye0 (cm) xpe0 and ype0 (rad)
       gamm0=(gam0*gam0-1.D0)**0.25D0
       xe0=x0*gamm0
       xpe0=xt0*gamm0
       ye0=y0*gamm0
       ype0=yp0*gamm0
       xpe0=xpe0+0.5D0*xe0*gam0*dgdz/(gam0*gam0-1.D0)
       ype0=ype0+0.5D0*ye0*gam0*dgdz/(gam0*gam0-1.D0)
       xe(i1)=xe0
       xpe(i1)=xpe0
       ye(i1)=ye0
       ype(i1)=ype0
!   transverse coupling terms
       gam00=gam0*gam0
       gam11=gam1*gam1
       gam22=gam2*gam2
       gam33=gam3*gam3
       gam44=gam4*gam4
       bgt0=(gam00-1.D0)**1.5D0
       xk1=fh*fh/(4.D0*vl*vl*bgt0)
       red=sqrt(xe(i1)*xe(i1)+ye(i1)*ye(i1))
       red2=red*red
       dred=0.D0
       ico=1
       if(red.gt.1.D-08) then
         dred=xe(i1)*xpe(i1)+ye(i1)*ype(i1)
         dred=dred/red
       endif
       rk1=xk1*red2*xf1(ico,phi(j),t0,t5)*qc/e0
       rk2=red*dred*xk1*xf2(phi(j),t0)*qc/e0
       gam(i)=gam5+rk1+rk2
       if(gam(i).le.1.D0) then
         f(8,j)=0.D0
         ilost=ilost+1
! needs to be on energy
         lossreason=-2
! Relative to cog
         f6i=f(6,j)-tmoy
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f9.5,3x,i2,1x,a25)') & 
          PRTLAB,NRRES,davtot/100.D0,j,int(f(1,j)), &
          f(2,j),f(3,j),f(4,j),f(5,j),f6i*fh*180.D0/pi,f(7,j)-xmat, &
          f(9,j),lossreason,uden
!         write(49,3928) PRTLAB,NRRES,davtot/100.D0,j,int(f(1,j)), &
!         f(2,j),f(3,j),f(4,j),f(5,j),f6i*fh*180.D0/pi,f(7,j)-xmat, &
!         f(9,j),lossreason
! 3928    FORMAT(1x,A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x), &
!              1x,f9.5,3x,i2)
         cycle
       endif
       gam55=gam(i)*gam(i)
       bgt1=(gam11-1.D0)**1.5D0
       bgt2=(gam22-1.D0)**1.5D0
       bgt3=(gam33-1.D0)**1.5D0
       bgt4=(gam44-1.D0)**1.5D0
       bgt5=(gam55-1.D0)**1.5D0
       bge0=(gam00+2.D0)/((gam00-1.D0)*(gam00-1.D0))
       bge1=(gam11+2.D0)/((gam11-1.D0)*(gam11-1.D0))
       bge2=(gam22+2.D0)/((gam22-1.D0)*(gam22-1.D0))
       bge3=(gam33+2.D0)/((gam33-1.D0)*(gam33-1.D0))
       bge4=(gam44+2.D0)/((gam44-1.D0)*(gam44-1.D0))
       bge5=(gam55+2.D0)/((gam55-1.D0)*(gam55-1.D0))
! ******************************************************
!   compute the phase jump over the step
! ******************************************************
       f(7,j)=gam(i)*e0
       tcour(j)=t5
       ddt1=t5-ddt
       f(6,j)=ddt1+f(6,j)
! -- angular deviation
!    1) terms in dE/dt
       a1=qc/(2.D0*e0*vl)
       ttt1=xjf1(phi(j),t0)
       ttt2=xjf2(phi(j),t0)
       dxpe1=xe(i1)*ttt1+xpe(i1)*ttt2
       dype1=ye(i1)*ttt1+ype(i1)*ttt2
       xpe(i)=xpe(i1)+a1*dxpe1
       ype(i)=ype(i1)+a1*dype1
       xe(i)=xe(i1)+xpas*(xpe(i1)+xpe(i))/2.D0
       ye(i)=ye(i1)+xpas*(ype(i1)+ype(i))/2.D0
!   back to the real variables and convert to (cm,mrad)
       dgdzr=qc/e0 * tspl5
       gamm1=(gam(i)*gam(i)-1.D0)**0.25D0
       gamm2=(gam(i)*gam(i)-1.D0)**1.25D0
       xi=xe(i)/gamm1
       xpi=xpe(i)/gamm1-xe(i)*gam(i)*dgdzr/(gamm2*2.D0)
       yi=ye(i)/gamm1
       ypi=ype(i)/gamm1-ye(i)*gam(i)*dgdzr/(gamm2*2.D0)
!  convert in cm and mrd
       f(2,j)=xi
       f(4,j)=yi
       f(3,j)=xpi*1.D3
       f(5,j)=ypi*1.D3
     enddo
!  space charge computation (only odd step numbers)
     if(.not.flgsc) then
       flgsc=.true.
       call disp
     else
       if(ichaes) then
!   space charge (only SCHEFF is available)
         iesp=.true.
         call cesp(eglsc)
         iesp=.false.
         flgsc=.false.
! Change the dispersion dE/E with respect to the C.O.G of the bunch
       endif
       call disp
     endif
     xnh=xnh+1.D0
   enddo
   deallocate(tcour)
   deallocate(phi)   
END SUBROUTINE bcnum_bunc
!> *******************************************************************
!! SUBROUTINE buncnum
!! "Thick lens" BUNCHER with multi-harmonic capabilities
!< *******************************************************************
SUBROUTINE buncnum
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4cavs2
   USE m4numcavs
   USE m4gap2, ONLY: ilost
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE m4numcavs, ONLY: fmult,npt
   USE fun4mhb, ONLY: sptta0,sptsb0
   USE m4RESTAYfun
   USE m4SPLfun
   USE m4RESTAY, ONLY: flength,fhc,att,ncell
   USE m4MHBfun
   USE m4restayMIDGAP
   USE m4FENE
   USE m4ITVOLE
   USE m4ble, ONLY: cr
   USE mCOMkcell
   USE mCOMstep
   USE mCOMxitrd3
   USE mCOMelec
   USE mCOMxposi
   IMPLICIT NONE
   REAL(8) bcog,bcg,bets,bpai,cor12,dphete,dwtest,emns,encog,engain,enold,enrprin
   REAL(8) epsil,enrs,ffield,fh0,gams,ts,gcg,gcog,gpai,gref,oldfh,PENT12,PENT21
   REAL(8) QDIANP,QDIANT,QDISP,QDITAX,QDITAY,QDP,QDPDE,QMD,SQMDV,SURM,SURXTH,SURYPH
   REAL(8) TRQPY,TRQTX,ttvol,wcg,xkitr,xmor
   REAL(8) tcgprt,tcog,TESTCA,TREDG,TREFDG,trfprt,trnsms
   REAL(8) aqst
   REAL(8) trefs,ddw,dwmx
   REAL(8) beref,gamref,enref
   REAL(8) ye0
   INTEGER iarg,iprint
   INTEGER i
   REAL(8) phzt(5),dphse(5),pfield
   LOGICAL fromrfq
   character(len=256) :: wfile
   character(len=8) :: PRTLAB
!*******************************************************************
!    XESLN : NEGATIVE LENGHT OF THE DRIFT FOLLOWING THE GAP
!    IF XESLN N.E.0 THEN THE CHARGE SPACE EFFECT IMPLIES THE
!    LENGTH (YLG-XESLN)
   NRRES=NRRES+1
   ncavnm=ncavnm+1
! allow for print out on terminal of gap# on one and the same line
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      MHB                 :',NRRES,cr
   flush(6)
   WRITE(16,*)' CAVITY N :',NRRES,' CAVITY NAME : ',UDEN
! check if a .dst file is requested at the input
   if (nodflocs.gt.0) then
     do i=1,nodflocs
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then         
         if(idflio(i).eq.1 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_in.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at input of the element: ',&
                       trim(wfile)
           fromrfq=.false.                           
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif         
!  statistics
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
   ilost=0
   aqst=abs(qst)
   qmoy=aqst
! --- the frequency fh may be changed with delfh
       oldfh=fh
! --- ifreq: number of harmonic (max 5)
! --- ampl(i),  i = 1 to ifreq: amplitude of the voltage
! --- dphse(i), i = 1 to ifreq: phase offset (deg)
! --- FFIELD : in percent;
!      (electric field)=(initial electric field)*(1.D0+FFIELD/100)
   read (in,*) ifreq
   read (in,*) (ampl(i),i=1,ifreq)
   read (in,*) (dphse(i),i=1,ifreq)
   read (in,*) ffield,istep
!  *****************************************************************
   if(ncavnm.eq.1) then
     write(13,'(3x,A,2x,A,2x,A,4x,A,6x,A,5x,A,7x,A,6x,A,7x,A,5x,A)') &
       'ncav','ncell','pos I(cm)','pos S(cm)','L cell(cm)','W(MeV)', &
       'dW(MeV)','Ph RF(dg)','TOF(dg)','avrg pos(cm)'
       write(13,'(3x,A,3x,A,4x,A,4x,A,5x,A,6x,A,5x,A)') &
       'ncell','E0TL(MeV)','T(k) MeV/q','S(k) MeV/q','dW(MeV)','PHASE(dg)', &
       'Ph crest(dg)'
!       write(13,990)
!  990  format(3x,'ncav',2x,'ncell',2x,'pos I(cm)',4x,'pos S(cm)',6x, &
!       'L cell(cm)',5x,'W(MeV)',7x,'dw(MeV)',6x,'TOF(dg)',7x, &
!       'Ph RF(dg)',5x,'avrg pos(cm)')
!       write(13,995)
!  995  format(3x,'ncell',3x,'E0TL(MeV)',4x,'T(k) MeV/q',4x, &
!       'S(k) MeV/q',5x,'dW(MeV)',6x,'PHASE(dg)',5x, &
!       'Ph crest(dg)')
   endif
   write(13,*)
! ***************************************************************
   pfield=ffield
   ffield=1.D0+ffield/100.D0
   if(abs(ffield).le.fprec) ffield=1.D-12
   fmult=ffield
   if(ifield) then
! --- The field is read from the disk in the form:
!          z   (cm)   E(z) MV/cm
!     fhc: frequency of the cavity (Hertz) (read from the file 'field.txt' )
     fh=fhc*2.D0*pi
     ncel=ncell
     atte=att
     ye0=atte
!    flength : length of the field (cm)
     flength=xspl(npt)-xspl(1)
     ylg=flength
   else
! --- The field is read from the input list in the form of a Fourier series
     ncell=ncel
     oldfh=fh
!     atte: factor acting on the amplitude of the field (read from the input list)
     ye0=atte
   endif
! ********************************************************
! the following lignes are not used for the MHB (sv 22/8/2016)
!       if(itvol.and.imamin) then
! ---  adjustment of the phase offset w.r.t. the t.o.f.  (deg)
!        ottvol=fh*ttvols*180.D0/pi
!        attvol=ottvol
!        xkpi=ottvol/360.D0
!        ixkpi=int(xkpi)
!        xkpi=(xkpi-DBLE(ixkpi))*360.D0
!        dphase=dphase-xkpi
!       endif
! *******************************************************
   WRITE(16,'(2(4x,A,e12.5,A,/),4x,A,e12.5,/,4x,A,e12.5)') &
          'FREQUENCY :',FH/(2.D0*pi),' Hertz', &
          'FIELD LENGTH :',YLG,' cm', &
          'FIELD FACTOR (UNITS CONVERSION) :',ATTE, &
          'FIELD FACTOR (ATTENUATION)      :',ffield
   WRITE(16,'(4x,A,i4,A,i5,/,4x,A,i1)') & 
          'FIELD DIVIDED IN: ',NCEL,' CELLS, STEPS PER CELL ',istep, &
          'Number of frequencies: ',ifreq
   WRITE(16,*)'   Amplitude(s)   : ',(ampl(i),i=1,ifreq)
   WRITE(16,*)'   Phase(s) in deg: ',(dphse(i),i=1,ifreq)
!       if(.not.imamin) write(16,*) '   PHASE OFFSET: ',dphete,' DEG'
!       if(imamin) write(16,1501)dphete,DPHASE,xkpi
!1501   format(4x,
!     x        'PHASE OFFSET (before adjustment): ',e12.5,' deg',/,4x,
!     x        'PHASE OFFSET (after adjustment): ',e12.5,' deg',/,4x,
!     *        'ADJUSTMENT ON THE PHASE OFFSET: ',e12.5,' deg')
   fh0=fh/vl
   BEREF=VREF/VL
! --- ttvol: time of flight at entrance (sec)
   ttvol=0.D0
   if(itvol)ttvol=ttvols*fh
!  start file 'short.data'
! --- dav1(idav,3)=0: the particle reference and the cog coincide at the input
! --- dav1(idav,3)=1: the particle reference and the cog are independent
   dav1(idav,3)=0.D0
   idav=idav+1
   iitem(idav)=1
   dav1(idav,1)=ylg*10.D0
   dav1(idav,2)=ye0*100.D0
   davtot=davtot+ylg
   dav1(idav,24)=davtot*10.D0
   dav1(idav,40)=fh
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(dav1(idav,24))
   endif
   iarg=1
   call cdg(iarg)
   enold=cog(1)
   encog=enold
   gcog=enold/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   IF(SHIFT) THEN
! --- the reference particle and the cog are independent
     BEREF=VREF/VL
     GAMREF=1.D0/SQRT(1.D0-(BEREF*BEREF))
     ENREF=XMAT*GAMREF
     TREFDG=TREF*fh*180.D0/pi
     dav1(idav,3)=1.D0
   ELSE
! --- the reference particle and the cog are coinciding
     beref=bcog
     vref=bcog*vl
     tref=tcog
     gamref=gcog
     enref=cog(1)
     dav1(idav,3)=0.D0
   ENDIF
   if(int(dav1(idav,3)).eq.1) write(16,*) ' **** reference and cog evolve independently'
   if(int(dav1(idav,3)).eq.0) write(16,*) ' **** the reference is the cog '
   WRITE(16,'(/,A,/,5x,A)') ' Dynamics at the input', &
    '   BETA     GAMMA      ENERGY(MeV)        TOF(deg)     TOF(sec)'
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' COG ', &
         bcog,gcog,encog-xmat,tcog*fh*180.D0/pi,tcog
   ENRPRIN=ENREF-XMAT
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' REF ', &
         beref,gamref,ENRPRIN,tref*fh*180.D0/pi,tref
   iprint=0
   call statis
! --- phases at the entrance w.r.t. frequencies
   do i=1,ifreq
     dphse(i)=dphse(i)*pi/180.D0
     xkitr=DBLE(i)*fh/vref
! ---  transit time factors TK and SK based on the velocity at the entrance
     TK=SPTTA0(xkitr)
     SK=SPTSB0(xkitr)
! ---  dW(phz) = 0
     phzt(i)=atan(tk/sk)
     phz(i)=phzt(i)+dphse(i)+ttvol
     dwtest=tk*cos(phz(i))-sk*sin(phz(i))
     write(16,'(2x,i3,6(2x,e12.5))') i,xkitr,tk,sk,dwtest,180.D0/pi*phzt(i), &
           180.D0/pi*phz(i)
   enddo
! --- compute energy and TOF of reference
   call dwref_bunc(gams,ts)
   enrs=gams*xmat
   ddw=enrs-enref
   trefs=ts+tref
   bets=sqrt(gams*gams-1.D0)/gams
   TREDG=fh*TREFS *180.D0/pi
!  dynamics of the bunch
   call bcnum_bunc(ylg,ncell)
   gcg=0.D0
   do i=1,ngood
     gcg=gcg+f(7,i)/xmat
   enddo
   gcg=gcg/DBLE(ngood)
   bcg=sqrt(1.D0-1.D0/(gcg*gcg))
   wcg=(gcg-1.D0)*xmat
   call cogetc
   do i=1,ngood
     gpai=f(7,i)/xmat
     if(gpai.lt.1.D0) gpai=1.D0
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     fd(i)=bpai/bcg * gpai/gcg
   enddo
! ---- window control
   tref=trefs
   vref=bets*vl
   PRTLAB='MHB     '
   call reject(ilost,PRTLAB)
   write(16,*) ' PARAMETERS RELATING TO THE REFERENCE PARTICLE '
   write(16,*) '***********************************************'
   write(16,*) ' ENERGY GAIN(MeV) ',DDW,' TOF ',tredg,' DEG'
   write(16,*) ' PHASES OF RF AT ENTRANCE(DG): '
   write(16,*) '    BFA = BEFORE adjustment  AFA = AFTER adjustment'
   do i =1,ifreq
     write(16,'(2x,A,e12.5,A,e12.5,A,e12.5,A)') &
           'freq.(Hz) ',DBLE(i)*fhc,' phase BFA(deg) ',phzt(i)*180.D0/pi, &
          ' phase AFA(deg)  ',phz(i)*180.D0/pi
   enddo
   iarg=1
   call cdg(iarg)
   encog=cog(1)
   gcog=encog/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   CALL EXT2D(1)
! dphse(i)  dphete
   if(itvol) then
     write(16,*) '    TOF is active'
     dav1(idav,38)=dphse(1)-90.D0
! next line to be fixed
     dav1(idav,39)=0.D0
!     dav1(idav,39)=dphase*180.D0/pi
   else
     dav1(idav,38)=dphse(1)-90.D0
   endif
   WRITE(16,'(/,A,/,5x,A)') ' Dynamics at the output', &
         '   BETA     dW(MeV)     ENERGY(MeV)    TOF(deg)     TOF(sec)'
   engain=encog-enold
   WRITE(16,'(A,f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)') ' REF ', &
         bets,ddw,enrs-xmat,fh*TREFS *180.D0/pi,TREFS
   WRITE(16,'(A,f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)') ' COG ', &
         bcog,engain,encog-xmat,tcog*fh*180.D0/pi,tcog
   TESTCA=exten(1)*exten(2)*exten(3)
   epsil=1.D-40
   IF(abs(TESTCA).gt.epsil) THEN
     QDISP=2.D0*sqrt(exten(1))
     QMD=exten(1)*exten(3)-exten(2)**2
     SQMDV=4.D0*pi*SQRT(QMD)
     SURM=4.D0*pi*SQRT(QMD)*180.D0/pi
     QDP=2.D0*sqrt(exten(3))
     COR12=exten(2)/sqrt(exten(1)*exten(3))
     QDPDE=QDP*180.D0/pi
   ELSE
     QDISP=0.D0
     QMD=0.D0
     SQMDV=0.D0
     SURM=0.D0
     QDP=0.D0
     COR12=0.D0
     PENT12=0.D0
     PENT21=0.D0
     QDPDE=0.D0
   ENDIF
   TRQTX=exten(4)*exten(5)-exten(8)**2
   TRQPY=exten(6)*exten(7)-exten(9)**2
   QDITAX=2.D0*sqrt(exten(4))
   QDIANT=2.D0*sqrt(exten(5))
   QDITAY=2.D0*sqrt(exten(6))
   QDIANP=2.D0*sqrt(exten(7))
   SURXTH=4.D0*pi*SQRT(TRQTX)
   SURYPH=4.D0*pi*SQRT(TRQPY)
   IF(SHIFT) THEN
     vref=bets*vl
     tref=trefs
   ELSE
     vref=bcog*vl
     tref=tcog
   ENDIF
   if(itvol) ttvols=tref
   call statis
!  ENVEL
   PRLAB(IPRF)=PRTLAB
   CALL STAPL(dav1(idav,24))
   dav1(idav,16)=bcog*surxth*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   dav1(idav,21)=bcog*suryph*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   dav1(idav,25)=DBLE(nrres)
   dav1(idav,30)=DBLE(ngood)
!
!   print to 'dynac.dmp':
!   gap number, phase offset(deg), relativistic beta, energy(MeV), horz. emit.(mm*mrd,norm), vert. emit.(mm*mrd,norm),long. emit(keV*sec)
!
! --- dav1(idav,16): Emittance(norm)  x-xp (mm*mrad)
! --- dav1(idav,21): Emittance(norm)  y-yp (mm*mrad)
   emns=1.D12*sqmdv/(pi*fh)
   trfprt=fh*tref*180.D0/pi
   tcgprt=fh*tcog*180.D0/pi
! cavity number, z (m), transmission (%), synchronous phase (deg), time of flight (deg) (within -180 deg and 180 deg),
! COG relativistic beta (@ output), COG output energy (MeV), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
   trnsms=100.D0*DBLE(ngood)/DBLE(imax)
   if(ncavnm.eq.1) write(50,'(A)') '# buncnum.dmp'
   if(ncavnm.eq.1) write(50,'(A,A,A,A,A)') &
     '#  cav     Z       trans   ', &
     'PHIs     TOF(COG)    COG        Wcog          TOF(REF)   ', &
     '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ', &
     'El,RMS        dWref        EffVolt      ElementName      ', &
     '        amplitude'
   if(ncavnm.eq.1) write(50,'(A,A,A,A,A)') &
    '#   #     (m)       (%)    ', &
    '(deg)     (deg)      beta       (MeV)          (deg)      ', &
    '   beta       (MeV)       (mm.mrad)    (mm.mrad)    ', &
    '(ns.keV)      (MeV)          (MV)                         ', &
    '       FFIELD'
   write(50,'(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)') & 
    nrres,0.001D0*dav1(idav,24),trnsms,dphete, &
    tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat, &
    0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),0.25D0*emns, &
    ddw,dwmx,trim(uden),pfield
!    write(50,7023) nrres,0.001D0*dav1(idav,24),trnsms,dphete, &
!    tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat, &
!    0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),0.25D0*emns, &
!    ddw,dwmx,trim(uden),pfield
! 7023    format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x, &
!         2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)
   fh=oldfh
!       new magnetic rigidity of the reference
   gref=1.D0/sqrt(1.D0-bets*bets)
   xmor=xmat*bets*gref
   BORO=33.356D0*XMOR*1.D-01/AQST
   WRITE(16,*) ilost,' particles lost in cavity ',nrres
   call emiprt(0)
! check if a .dst file is requested at the output
   if (nodflocs.gt.0) then
     do i=1,nodflocs
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then       
         if(idflio(i).eq.2 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_out.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at output of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif                
END SUBROUTINE buncnum
!> *******************************************************************
!! SUBROUTINE cpardyn(pib)
!! --- make up a list of cell by cell RFQ data based on a file
!!     generated by an external code
!!
!!     nc: cell number
!!     ityp = 0: Standard accelerating cell
!!     ityp = 1: Transition cell of type T
!!     ityp = 2: Transition cell of type E
!!     ityp = 3: Transition cell of type M
!!     ityp = 4: Fringe-field region from the potential function
!!               (after type T, M or accelerating cell)
!!     ityp = 5: Radial matching section based on coefficients
!!     ityp = 6: Radial matching section based on RMS shape defined in
!!               an external file
!!     ityp = 7: Fringe-field region; the profile is defined in an
!!               external file (after type T, M or accelerating cell)
!!     a(1): cell length (cm)
!!     a(2): coefficient A10 (no dimension)
!!     a(3): smallest aperture  a  of vanes (cm)
!!     a(4): modulation factor  m  (no dimension)
!!     a(5): mean aperture ( r0 ) of vanes (middle of cells)   (cm)
!!     a(6): transverse radius of curvature (rh0) of the surface of
!!           electrodes at the vane tip (cm)
!!     a(7): phase (deg) (at the entrance of cells)
!!     a(8): factor FVOLT to be applied at the intervane potential
!!           (only for particles)
!!              VOLT =  (1 + FVOLT )* (intervane voltage)
!!     a(9): intervane-voltage (KV)
!!
!!     ipar: cell parity (like for PARMTEQ cells)
!! --- Note: the last line in file must be:
!!           0  0  0. 0. 0. 0. 0. 0. 0. 0. 0. 0
!< *******************************************************************
SUBROUTINE cpardyn(pib)
   USE DynacConstants
   USE m4rfq
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE fun4rfq
   USE m4rfqFBINT
   USE m4SPLfun
   USE m4SPFFfun
   USE mCOMpaths
   USE mCOMbonda
   USE mCOMrms_prfl   
   IMPLICIT NONE
   REAL(8) pib,apfac,a01,a03,a10,a12,a30,alpha,alpk,aq,bi0,bi3,bi4,bim,bim3,bim4
   REAL(8) bir0,bir3,cl,den1,dtk,erest,fact,phim,r0,reca,rh0,t10k,t30k,xa,xam,xk,xk1,xm
   REAL(8) xq0,yk2,za0,zam,zr0,zr3
   INTEGER i,j,ipar,ityp,nc,ncf,netc,no,ios
   REAL(8) a(16),vptq(16)
   character(len=256) :: vprof,fprof
   character(len=256) :: myfile
   logical even
   REAL(8) ui(16)
!  GAUSS n=16 de -1. a 1
   DATA (UI(J),J=1,16)/-.9894009D0,-.9445750D0,-.8656312D0,-.7554044D0, &
         -.6178762D0,-.4580168D0,-.2816036D0,-.0950125D0, &
          .0950125D0,.2816036D0,.4580168D0,.6178762D0,.7554044D0,.8656312D0, &
          .9445750D0,.9894009D0/
!*******************************************************************
! prepare theta values for use by function bint	   
   do i=1,16
     thet(i)=pi/2.D0*(1.D0+ui(i))
     cthet(i) =cos(thet(i))
     c3thet(i)=cos(3.D0*thet(i))
     c4thet(i)=cos(4.D0*thet(i))
     c5thet(i)=cos(5.D0*thet(i))
   enddo
   myfile=''
! 2020-03 apfac is a factor with which the RFQ aperture can be multiplied
! This has been used in other codes to make it less sensitive to beamloss, in
! particular in the case where the beamsize is close to the availaile
! aperture. The rationale is that particles between the electrodes would not
! be lost.
   apfac=1.D0
!  Do so by shifting particles belonging to the same bunch outside the (+/-) pib (rad) window
!  w.r.t.the REF to inside the (+/-) pib window w.r.t.the COG
   if(pib .gt. 0.D0) then
     pib=pi
     call accep_rfq(pib)
   elseif(pib .lt. 0.D0) then
! 2020-03 apfac is a factor with which the RFQ aperture can be multiplied
! This has been used in other codes to make it less sensitive to beamloss, in
! particular in the case where the beamsize is close to the availaile
! aperture. The rationale is that particles between the electrodes would not
! be lost.
     apfac=abs(pib)         
     pib=pi
     call accep_rfq(pib)
   endif
   write(16,*) 'The radius of the WINDOW in the RFQ used for ', &
    'rejecting particles is multiplied by a factor ',apfac
   erest=xmat
! --- for simulating PARMTEQ cells, odd cells have A01 positive and even cells have A01 negative
! --- even: logical flag, even = true ==> A01 is positive, otherwise A01 is negative
   even=.true.
   netc=0
! do loop on reading and prepping cell data
   DO
! --- read the data of the RFQ from the input file
! ****************************************************************
! ---   read 11 parameters from unit 27, file 'myfile', in the form:
!      nc  ityp intervane-voltage (kV) cl(cm)  A10  a(cm)  m  r0(cm) rho(cm) phase(deg) fvolt ipar
     netc=netc+1
     read(27,*) nc,ityp,(vptq(j),j=1,9),ipar
     if(ityp.eq.6) then
! if the RMS is of type 6, get the filename of the RMS description
       read(27,'(A)') vprof
       write(16,*) 'Read RMS from file ',trim(vprof)
     endif
     if(ityp.eq.7) then
! if the Fringe Field is of type 7, get the filename of the FF description
       read(27,'(A)') fprof
       write(16,*) 'Read Fringe Field from file ',trim(fprof)
     endif
     a(1)=vptq(2)
     a(2)=vptq(3)
     a(3)=vptq(4)
     a(4)=vptq(5)
     a(5)=vptq(6)
     a(6)=vptq(7)
     a(7)=vptq(8)
     a(8)=vptq(9)
     a(9)=vptq(1)
     rfq12(nc)=a(6)
     rfq21(nc)=a(3)         
     rfq22(nc)=a(4)       
! **************************************************
! convert intervane voltage in MV
     a(9)=a(9)*1.D-03
     if(nc.eq.1) tdvolt=a(9)
! ----  stop at the last line with nc = 0
     if(nc.eq.0) exit
     if(nc.gt.nceltot) exit
     itype(nc)=ityp
     ipari(nc)=ipar
! store polarity of the cell	   
     ncf=(ipari(nc)/2)*2-ipari(nc)
     ipol(nc)=ncf                 
     if(itype(nc).eq.5) then
! ------------
! ITYPE 5 : Radial matching section from potential function
! ------------
! ---------------------------------------------------------------------------------------------
! Note: The total length L(rms) of the RMS must be the sum of the RMS-cell lengths in the
!       Parmteq file. rho is equal to the distance between the axis and the vane, r0, at the
!       exit of the RMS
!       we have used the approximation of the modified Bessel functions for small arguments
!       and we have negleted the terms of higher order in r greater than 2
! ----------------------------------------------------------------------------------------------
       write(16,*) 'RFQ RMS from potential function'
       cl=a(1)
       r0=a(5)
       rh0=a(6)
       phim=a(7)
       fact=1.D0+a(8)
       xk=pi/(2.D0*cl)
       xq0=1.D0/6.D0*xk*xk*rh0*rh0
       aq=1.D0/xq0
! ---  convert all parameters in units (MeV, m)
!   rfq1(nc): Aq (no dimension)
!   rfq2(nc): not used
!   rfq3(nc): RMS length (m)
!   rfq4(nc): phase RF (deg)
!   rfq7(nc): mean aperture of the vane r0 (m)
!   rfq9(nc): factor to be applied at the inter-vane potentiel (only for particles)
!   rfq10(nc):intervane voltage applied to the synchronous particle (kV)
!   rfq11(nc):intervane voltage applied to the particles (kV)
!
       rfq1(nc)=aq
       rfq2(nc)=0.D0
       rfq3(nc)=cl*1.D-02
       rfq4(nc)=phim
       rfq7(nc)=r0*1.D-02
       rfq9(nc)=fact
       rfq10(nc)=(1.D0+tvolt)*a(9)
       rfq11(nc)=(1.D0+avolt)*a(9)
     elseif(itype(nc).eq.6) then
! ------------
! ITYPE 6 : RMS profile read from disk in the form (z,R(z)), with z,R in meter
! ------------
!  npt is the number of (z,R(z)) coordinates
       open(67,file=trim(vprof),status='unknown',action='read')
       npt=0
       do
!         read(67,*,END=777) xspl(npt+1),yspl(npt+1)
         read(67,*,iostat=ios) xspl(npt+1),yspl(npt+1)
         if( ios < 0 ) exit ! end of file is reached		 
         npt=npt+1
       enddo
!  777  write(16,*) 'RFQ RMS from file with ',npt,' data points'
       write(16,*) 'RFQ RMS from file with ',npt,' data points'
       call deriv2(npt)
! cl; length of the RMS (in M)
       cl=xspl(npt)
       r0=yspl(npt)
       phim=a(7)
       fact=1.D0+a(8)
!     rfq1(nc) : not used
!     rfq2(nc): not used
!     rfq3(nc): RMS length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): distance axe-vanes at the end of the RMS (m)
!     rfq9(nc): factor to be applied at the inter-vane potentiel (only for particles)
!     rfq10(nc):intervane voltage applied to the synchronous particle (kV)
!     rfq11(nc):intervane voltage applied to the particles (kV)
!       rfq1(nc)=0.D0
       rfq2(nc)=0.D0
       rfq3(nc)=cl
       rfq4(nc)=phim
       rfq7(nc)=r0
       rfq9(nc)=fact
       rfq10(nc)=(1.D0+tvolt)*a(9)
       rfq11(nc)=(1.D0+avolt)*a(9)
       close(67)
!  End Radial matching section
     elseif(itype(nc).eq.0) then
! ------------
! ITYPE 0 : Standard accelerating cell
! ------------
       cl=a(1)
       a10=a(2)
       xa=a(3)
       xm=a(4)
       r0=a(5)
       rh0=a(6)
! fph : factor affecting the phase at entrance of cells (only available for type = 0)
       a(7)=fph*a(7)
       phim=a(7)
       fact=1.D0+a(8)
!    coefficient A01 (1/(cm*cm))
       alpha=rh0/r0
       a01=3.D0*(1.D0+5.D0*alpha)/(2.D0*r0*r0*(1.D0+7.D0*alpha))
!    coefficient A03: (1/(cm**6) )
       a03=-(1.D0+alpha)/(2.D0*r0**6*(1.D0+7.D0*alpha))
!  coefficient A12: no dimensions
       xam=xa*xm
       a12=0.D0
       xk1=1.D0-a01*xa*xa-a03*(xa**6)
       yk2=-1.D0+a01*xam*xam+a03*(xam**6)
!   Bessel functions: I0(ka) I0(mka) I4(ka) I4(mka)
       xk=pi/cl
       za0=xk*xa
       zam=za0*xm
       no=0
       bi0=bint(no,za0)
!old       bi0=1.D0+za0*za0/4.D0+za0**4/64.D0+za0**6/2304.D0+za0**8/1.47456e05
!old       bi0=bi0+za0**10/1.47456e07
       bim=bint(no,zam)
!old       bim=1.D0+zam*zam/4.D0+zam**4/64.D0+zam**6/2304.D0+zam**8/1.47456e05
!old       bim=bim+zam**10/1.47456e07
       no=4
       bi4=bint(no,za0)
!old       bi4=(za0/2.D0)**4/24.
!old       zaa0=za0*za0/4.D0
!old       bi4=bi4+(za0/2.D0)**4*zaa0/120.
!old       bi4=bi4+(za0/2.D0)**4*zaa0*zaa0/1440.
       bim4=bint(no,zam)
!old       zamm=zam*zam/4.D0
!old       bim4=(zam/2.D0)**4/24.
!old       bim4=bim4+(zam/2.D0)**4*zamm/120.
!old       bim4=bim4+(zam/2.D0)**4*zamm*zamm/1440.
       den1=bim4*bi0-bim*bi4
       if(abs(den1).gt.1.D-9) a12=(yk2*bi0-xk1*bim)/den1
! rfq25 is A10 corresponding to Biscari (1.4.2)       
!        bi0=1.D0+za0*za0/4.D0+za0**4/64.D0+za0**6/2304.D0+za0**8/147456.D0
!        bim=1.D0+zam*zam/4.D0+zam**4/64.D0+zam**6/2304.D0+zam**8/147456.D0         
       rfq25(nc)=(xm*xm-1.D0)/(xm*xm*bi0+bim)                   
! ********************************************************************************************
! NOTE: the coefficient A10 is read in the file 'myfile' but it also can be computed in Dynac
!        from multipolar expansions (see the two following fortran lines):
!cc        a10=0.D0
!cc        if(abs(den1).gt.1.D-9) a10=(xk1*bim4-yk2*bi4)/den1
! ************************************
!        or from first order computations (see the two following lines):
!cc        dencc=xm*xm*bi0+bim
!cc        a10=(xm*xm-1.D0)/dencc
! ********************************************************************************************
! ---  convert all parameters in units (MeV, m)
!     rfq1(nc): A01 ( 1/(m*m) )
!     rfq2(nc): A10 (no dimension)
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq6(nc): A12 (no dimension)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq8(nc): A03 (1/(m**6)
!     rfq9(nc): error factor F = 1 + a(8)
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
! ---  odd cells have a01 positive, even cells have a01 negative
!
       rfq1(nc)=a01*1.D4
       rfq2(nc)=a10
       rfq3(nc)=cl*1.D-02
       rfq4(nc)=phim
       rfq6(nc)=a12
       rfq7(nc)=r0*1.D-02
       rfq8(nc)=a03*1.D12
       rfq9(nc)=fact
       rfq10(nc)=(1.D0+tvolt)*a(9)
       rfq11(nc)=(1.D0+avolt)*a(9)
!  endif of itype(nc) = 0 (accelerating cell)
     elseif(itype(nc).eq.1) then
! ------------
! ITYPE 1 : T-cell; must follow a standard cell and be followed by an M-cell or by fringe-field region
! ------------
       cl=a(1)
       xa=a(3)
       xm=a(4)
       r0=a(5)
       phim=a(7)
       fact=1.D0+a(8)
       xk=pi/(2.D0*cl)
       za0=xk*xa
       zam=za0*xm
!   Bessel functions
       no=0
       bi0=bint(no,za0)
       bim=bint(no,zam)
       bi3=bint(no,3.D0*za0)
       bim3=bint(no,3.D0*zam)
!   coefficients A10 and A30 (no dimensions)
       t10k=xm*xm*bi0+bim
       t30k=xm*xm*bi3+bim3
       zr0=xk*r0
       zr3=3.D0*zr0
       bir0=bint(no,zr0)
       bir3=bint(no,zr3)
       alpk=0.D0
       if(abs(bir3).gt.fprec) alpk=bir0/bir3
       dtk=t10k+alpk*t30k/3.D0
       a10=0.D0
       if(abs(dtk).gt.fprec) a10=(xm*xm-1.D0)/dtk
       a30=alpk*a10/3.D0
! ---  convert all parameters in units (MeV, m)
!     rfq1(nc): A30 (no dimension)
!     rfq2(nc): A10 (no dimension)
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq9(nc): factor to be applied at the inter-vane potentiel (only for particles)
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
!
       rfq1(nc)=a30
       rfq2(nc)=a10
       rfq3(nc)=cl*1.D-02
       rfq4(nc)=phim
       rfq7(nc)=r0*1.D-02
       rfq9(nc)=fact
       rfq10(nc)=(1.D0+tvolt)*a(9)
       rfq11(nc)=(1.D0+avolt)*a(9)
!  endif for T-cell
     elseif(itype(nc).eq.2) then
! ------------
! ITYPE 2 : E-cell; must follow an RMS and be folllowed by an even standard cell
! ------------
       cl=a(1)
       xa=a(3)
       xm=a(4)
       r0=a(5)
       a(7)=fph*a(7)
       phim=a(7)
       fact=1.D0+a(8)
       xk=pi/(2.D0*cl)
       za0=xk*xa
       zam=za0*xm
       xam=xa*xm
!   Bessel functions
       no=0
       bi0=bint(no,za0)
       bim=bint(no,zam)
       bi3=bint(no,3.D0*za0)
       bim3=bint(no,3.D0*zam)
!   coefficients A10 and A30 (no dimensions)
       t10k=xm*xm*bi0+bim
       t30k=xm*xm*bi3+bim3
       zr0=xk*r0
       zr3=3.D0*zr0
       bir0=bint(no,zr0)
       bir3=bint(no,zr3)
       alpk=0.D0
       if(abs(bir3).gt.fprec) alpk=bir0/bir3
       dtk=t10k+alpk*t30k/3.D0
       a10=0.D0
       if(abs(dtk).gt.fprec) a10=(xm*xm-1.D0)/dtk
       a30=-alpk*a10/3.D0
! ---  convert the parameters in units (MeV, m)
!     rfq1(nc): A30 (no dimensions)
!     rfq2(nc): A10 (no dimensions)
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq9(nc): factor applied at the inter-vane potentiel
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
       rfq1(nc)=a30
       rfq2(nc)=a10
       rfq3(nc)=cl*1.D-02
       rfq4(nc)=phim
       rfq7(nc)=r0*1.D-02
       rfq9(nc)=fact
       rfq10(nc)=(1.D0+tvolt)*a(9)
       rfq11(nc)=(1.D0+avolt)*a(9)
     elseif(itype(nc).eq.3) then
! ------------
! ITYPE 3 : M-cell
! ------------
       cl=a(1)
       xa=a(3)
       xm=a(4)
       r0=a(5)
       phim=a(7)
       fact=1.D0+a(8)
! ---  convert the parameters in units (MeV, m)
!     rfq1(nc): A30 = 0
!     rfq2(nc): A10 = 0
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq9(nc): factor applied at the inter-vane potentiel(F = 1 + a(15))
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)c
       rfq1(nc)=0.D0
       rfq2(nc)=0.D0
       rfq3(nc)=cl*1.D-02
       rfq4(nc)=phim
       rfq7(nc)=r0*1.D-02
       rfq9(nc)=fact
       rfq10(nc)=(1.D0+tvolt)*a(9)
       rfq11(nc)=(1.D0+avolt)*a(9)
     elseif(itype(nc).eq.4) then
! ------------
! ITYPE 4 : Fringe-field region after T-cell or M-cell
! ------------
       cl=a(1)
       a10=a(2)
       xa=a(3)
       xm=a(4)
       r0=a(5)
       rh0=a(6)
       phim=a(7)
       fact=1.D0+a(8)
! ---  convert the parameters in units (MeV, m)
!     rfq1(nc): A01 ( 1/(m*m) )
!     rfq2(nc): A10 (no dimensions)
!     rfq3(nc): cell length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): mean aperture of the vane r0 (m)
!     rfq9(nc): factor applied at the inter-vane potential (F = 1 + a(15))
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
!old        rfq1(nc)=a01*1.D4
       rfq2(nc)=a10
       rfq3(nc)=cl*1.D-02
       rfq4(nc)=phim
       rfq7(nc)=r0*1.D-02
       rfq9(nc)=fact
       rfq10(nc)=(1.D0+tvolt)*a(9)
       rfq11(nc)=(1.D0+avolt)*a(9)
     elseif(itype(nc).eq.7) then
! ------------
! ITYPE 7 : fringe field region; read the ff profil from disk in the form (z,R(z)) in M
! ------------
!    npt is the number of coordinates (z,R(z))
       open(67,file=trim(fprof),status='unknown',action='read')
       npf=0
       do
!         read(67,*,END=888) xspf(npf+1),yspf(npf+1)
         read(67,*,iostat=ios) xspf(npf+1),yspf(npf+1)
         if( ios < 0 ) exit ! end of file is reached		 
         npf=npf+1
       enddo
!  888  write(16,*) 'RFQ FF file has ',npf,' data points'
       write(16,*) 'RFQ FF file has ',npf,' data points'
       reca=xspf(1)
       do i=1,npf
         xspf(i)=xspf(i)-reca
       enddo
! length of the fringe field  m
       cl=xspf(npf)
       call derif2(npf)
       phim=a(7)
       fact=1.D0+a(8)
       write(16,*) 'Fringe Field length=',cl,' m'
       write(16,*) 'Fringe Field Phase=',phim
       write(16,*) 'Fringe Field Field Factor=',fact
!     rfq1(nc) : not used
!     rfq2(nc): not used
!     rfq3(nc): Fringe field length (m)
!     rfq4(nc): phase RF (deg)
!     rfq7(nc): distance axe-vanes at the start of the FF (m)
!     rfq9(nc): factor to be applied at the inter-vane potentiel (only for particles)
!     rfq10(nc):intervane voltage applied to the synchronous particle (KV)
!     rfq11(nc):intervane voltage applied to the particles (KV)
       rfq1(nc)=0.D0
       rfq2(nc)=0.D0
       rfq3(nc)=cl
       rfq4(nc)=phim
       rfq7(nc)=r0
       rfq9(nc)=fact
       rfq10(nc)=(1.D0+tvolt)*a(9)
       rfq11(nc)=(1.D0+avolt)*a(9)
       close(67)
     endif
! end do on cell data loop
   enddo
!********************************************
   if(netc.lt.nceltot) then
     write(ierr,*) 'Error: Parameter NCELTOT after RFQPTQ entry', &
     ' in DYNAC input file is ',NCELTOT
     write(ierr,*) 'This is larger than the', &
     ' number of cells in the RFQ datafile, which is ',netc
     write(16,*) 'Error: Parameter NCELTOT after RFQPTQ entry in', &
     ' DYNAC input file is ',NCELTOT
     write(16,*) 'This is larger than the', &
     ' number of cells in the RFQ datafile, which is ',netc
     stop
   endif
   call rfq_parm(apfac)
END SUBROUTINE cpardyn
!> *******************************************************************
!! SUBROUTINE accep_rfq(pib)
!! Do so by shifting particles belonging to the same bunch from
!! outside to inside (+/-) pi w.r.t.the synchronous particle
!< *******************************************************************
SUBROUTINE accep_rfq(pib)
   USE DynacConstants
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4input
   USE m4spacecharge
   USE m4plots
   USE fun4rfq
   USE mCOMrec   
   IMPLICIT NONE
   REAL(8) pib,drad,tcog
   INTEGER ite,i
!*******************************************************************
   do i=1,ngood
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   write(16,'(A,e14.7,A)') ' Phase of COG before reinjecting particles into the bunch: ', & 
    tcog*fh*180.D0/pi,' deg'
!   write(16,49) tcog*fh*180.D0/pi
!   49  format(' Phase of COG before reinjecting particles into the ', &
!          'bunch: ',e14.7,' deg')
   do ite=1,3
     do i=1,ngood
       drad=(f(6,i)-tref)*fh
       if(drad.gt.pib) then
         f(6,i)=(f(6,i)-2.D0*pi/fh)
       endif
       if(drad.lt.-pib) then
         f(6,i)=(f(6,i)+2.D0*pi/fh)
       endif
     enddo
   enddo
   tcog=0.D0
! --- cog in time of bunch after reinjecting particles into the bunch
   do i=1,ngood
     tcog=tcog+f(6,i)
   enddo
   tcog=tcog/DBLE(ngood)
   write(16,'(A,A,e14.7,A)') ' Phase of COG after reinjecting particles into the ', &
          'bunch: ',tcog*fh*180.D0/pi,' deg'
END SUBROUTINE accep_rfq
!> *******************************************************************
!! SUBROUTINE DERIV2(N)
!! second derivative of spline functions at position (x,y)
!< *******************************************************************
SUBROUTINE DERIV2(N)
   USE DynacConstants, ONLY: fprec
   USE m4SPLfun
   IMPLICIT NONE
   INTEGER N,I,J,NM1
   REAL(8) AVX,AVVX,AVY,AVVY,AVXN,AVVXN,AVYN,AVVYN,F,D,G1,G2,AVX1,AVVX1
!*******************************************************************
   AVXN=XSPL(N)-XSPL(N-1)
   AVVXN=XSPL(N-1)-XSPL(N-2)
   AVYN=YSPL(N)-YSPL(N-1)
   AVVYN=YSPL(N-1)-YSPL(N-2)
   F=AVXN-(AVVXN**2)/AVXN       
   P(N-1)=1.D0
   Q(N-1)=0.D0
   if(abs(f).gt.fprec) then
     P(N-1)=(-2.D0*AVXN-3.D0*AVVXN-AVVXN**2/AVXN)/F
     Q(N-1)=6.D0*(AVYN/AVXN-AVVYN/AVVXN)/F
   endif
   NM1=N-1
   DO J=2,NM1
     I=N-J
     AVX=XSPL(I+1)-XSPL(I)
     AVVX=XSPL(I+2)-XSPL(I+1)
     AVY=YSPL(I+1)-YSPL(I)
     AVVY=YSPL(I+2)-YSPL(I+1)
     D=2.D0*(AVX+AVVX)+AVVX*P(I+1)
     P(I)=-AVX/D
     Q(I)=(6.D0*(AVVY/AVVX-AVY/AVX)-AVVX*Q(I+1))/D
   ENDDO
   AVX1=XSPL(2)-XSPL(1)
   AVVX1=XSPL(3)-XSPL(2)
   G1=(AVVX1/AVX1)+1.D0-P(2)-(Q(2)/Q(1))
   G2=(AVVX1/(AVX1*P(1)))-(AVVX1/AVX1)-1.D0+P(2)
   S(1)=(Q(1)*G1)/(P(1)*G2)
   DO I=1,NM1
     S(I+1)=P(I)*S(I)+Q(I)
   ENDDO
END SUBROUTINE DERIV2
!> *******************************************************************
!! SUBROUTINE DERIF2(N)
!! second derivative of spline functions at position (x,y)
!< *******************************************************************
SUBROUTINE DERIF2(N)
   USE DynacConstants, ONLY: fprec
   USE m4SPFFfun
   IMPLICIT NONE
   INTEGER N,I,J,NM1
   REAL(8) AVX,AVVX,AVY,AVVY,AVXN,AVVXN,AVYN,AVVYN,F,D,G1,G2,AVX1,AVVX1
!*******************************************************************
   AVXN=XSPF(N)-XSPF(N-1)
   AVVXN=XSPF(N-1)-XSPF(N-2)
   AVYN=YSPF(N)-YSPF(N-1)
   AVVYN=YSPF(N-1)-YSPF(N-2)
   F=AVXN-(AVVXN**2)/AVXN
   PF(N-1)=1.D0
   QF(N-1)=0.D0
!   if(f.ne.0.) then
   if(abs(f).gt.fprec) then
     PF(N-1)=(-2.D0*AVXN-3.D0*AVVXN-AVVXN**2/AVXN)/F
     QF(N-1)=6.D0*(AVYN/AVXN-AVVYN/AVVXN)/F
   endif
   NM1=N-1
   DO J=2,NM1
     I=N-J
     AVX=XSPF(I+1)-XSPF(I)
     AVVX=XSPF(I+2)-XSPF(I+1)
     AVY=YSPF(I+1)-YSPF(I)
     AVVY=YSPF(I+2)-YSPF(I+1)
     D=2.D0*(AVX+AVVX)+AVVX*PF(I+1)
     PF(I)=-AVX/D
     QF(I)=(6.D0*(AVVY/AVVX-AVY/AVX)-AVVX*QF(I+1))/D
   ENDDO
   AVX1=XSPF(2)-XSPF(1)
   AVVX1=XSPF(3)-XSPF(2)
   G1=(AVVX1/AVX1)+1.D0-PF(2)-(QF(2)/QF(1))
   G2=(AVVX1/(AVX1*PF(1)))-(AVVX1/AVX1)-1.D0+PF(2)
   SF(1)=(QF(1)*G1)/(PF(1)*G2)
   DO I=1,NM1
     SF(I+1)=PF(I)*SF(I)+QF(I)
   ENDDO
END SUBROUTINE DERIF2
!> *******************************************************************
!! SUBROUTINE rfq_parm(apfac)
!!  NOTE:
!!      The reference particle and particles may evolve separately or
!!      may be connected
!!      Only the SCHEFF space charge method is available
!!      Space charge computations are automaticaly made at the middle
!!      of each cell
!!
!! -------------------------------------------------------------------
!!  Radial matching section
!!     rfq1(nc): Aq (no dimension)
!!     rfq2(nc): not used
!!     rfq3(nc): RMS length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq9(nc): factor to be applied at the inter-vane potentiel
!!               (only for particles)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!! -------------------------------------------------------------------
!!  Standard accelerating cells (ityp = 0)
!!     rfq1(nc): A01 ( 1/(m*m) )
!!     rfq2(nc): A10 (no dimensions)
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq6(nc): A12 (no dimension)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq8(nc): A03 (1/(m**6)
!!     rfq9(nc): factor F = 1 + a() (only for inter-vane potentiel
!!               of particles)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!!  odds cells have a01 positive, even cells have a01 negative
!!
!! -------------------------------------------------------------------
!!  Transition T-cell and E-cell
!!     rfq1(nc): A30 (no dimensions)
!!     rfq2(nc): A10 (no dimensions)
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq9(nc): factor F = 1 + a(8)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!! -------------------------------------------------------------------
!!  M-cell
!!     rfq1(nc): A30 = 0
!!     rfq2(nc): A10 = 0
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq9(nc): factor F = 1 + a(8)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!! -------------------------------------------------------------------
!!  Fringe-field region from the potential function (F-cell)
!!     rfq1(nc): A01 ( 1/(m*m) )
!!     rfq2(nc): A10 (no dimensions)
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m)
!!     rfq9(nc): factor F = 1 + a(8)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!! -------------------------------------------------------------------
!!  Fringe-field region the profil is read from disk (F-cell)
!!     rfq1(nc): not used
!!     rfq2(nc): not used
!!     rfq3(nc): cell length (m)
!!     rfq4(nc): phase RF (deg)
!!     rfq7(nc): mean aperture of the vane r0 (m) (not used)
!!     rfq9(nc): factor F = 1 + a(8)
!!     rfq10(nc):intervane voltage applied to the synchronous
!!               particle (KV)
!!     rfq11(nc):intervane voltage applied to the particles (KV)
!!
!< *******************************************************************
SUBROUTINE rfq_parm(apfac)
   USE DynacConstants
   USE m4rfq
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4cavs2
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4scheff2, ONLY: irfqp
   USE m4chase, ONLY: chasit
   USE m4plots
   USE fun4rfq
   USE m4SPLfun
   USE m4SPFFfun
   USE m4FENE
   USE m4ITVOLE
   USE m4ble, ONLY: cr
   USE mCOMfiles
   USE mCOMrec   
   USE mCOMbonda   
   USE mCOMrms_prfl
   USE mCOMrfqwdst
   USE mCOMtrfq   
   IMPLICIT NONE
   REAL(8) apfac
   REAL(8) a03vb,a10v,a10vb,a12vb,amort,av,avb,av10b,a31v,a31vb
   REAL(8) b2kr,b2kr3,bav,bcog,beta,bff,bg,bgav,bgfac,bi,bgi,bi03,bi1,bi13,bi1p,bi4r,bi5,br0
   REAL(8) bref,brefm,c1,c2,c1t,c2t,c3kz,cay,cc,ckz,ckz3,cp,delt,dese,dez,dispr,dphete,dr0
   REAL(8) dref,dw,dwref,ecog,eddav,eddavb,emns,encog,er,erf,etf,ex,exns,ey,eyns,ez,f6i,fns
   REAL(8) GA,GAM,gav,gcog,gi,gref,grefm,hl
   REAL(8) bi0,bi3,bi4
   REAL(8) cl,r0,xm,rh0
   REAL(8) pavolt,phdep,phfin,phi,phini,phmil,phref,qq,qzrm,r1,r2,radian,rf1,rf2,rfqphas,rm
   REAL(8) rprof,rproff,rpv,rr1,rr2,rtvolt,s1t,s2t,scl,signx,signy,skpz,skz,skz3,sp
   REAL(8) sqmdv,surxth,suryph,tcgprt,tcog,theta,tim,tlgth,trfprt,trnsms,twopi,vanx,vany
   REAL(8) vlm,vorb,WAV,wavel,wcog,wref,wrefin,wrefm,ww,xi,xf,xl,xlrfq,xml,xmor
   REAL(8) xpi,xpm,yi,yf,ym,yml,ypi,ypm,z,zl,zrm,zrm3
   INTEGER I,n,ilost,ip,ISTAT,len,ncf,nn
   INTEGER nrwcc,ns,nsm,nsp1
   logical iflag
   logical fromrfq
   REAL(8) vecx(1)
   INTEGER lossreason   
   REAL(8) rfqdmp(500,10)
   REAL(8) da01,da10,da10mp,da10x,den,denx,deny,dsa,dsm       
! 2025 for now a, b, c, bigrm, bigrp not used   
!   REAL(8) a,b,c,bigrm,bigrp,csign,r,r0i,rr0,rx,ry,sa,sm,tlgths,za0       
   REAL(8) csign,r,r0i,rr0,rx,ry,sa,sm,tlgths,za0       
   REAL(8) pckz,pckz2,pckz3,pskz,pskz2,pskz3,skzr,zprt,zrms       
   REAL(8) a01,a10,a10ckz,a10mp,a10n,a10x,a12
   REAL(8) a10tp,a30tp,a10vp,a31vp   
   REAL(8) cay2       
   character(len=8) :: PRTLAB
   integer no
!*******************************************************************
   PRTLAB='RFQPTQ  '
! allow for print out on terminal of cell# on one and the same line
   irfqp=.true.
   iflag=.false.
   radian=pi/180.D0
   ilost=0
   twopi=2.D0*pi
!  convert vl in m
   vlm=vl/100.D0
   wavel=2.D0*pi*vlm/fh
   er=xmat
! --- check if systematic or random errors on the RF phase or field level are requested
   if(ierpf.eq.1) then
! --- systematic error on the phase offset and or on the field level
! --- set tref in sec based on vphase (deg)
     tref=tref+vphase*pi/(fh*180.D0)
     write(16,*) 'Systematic error on RF phase    : ',vphase,' deg'
     write(16,*) 'Systematic error on RF amplitude: ',vfield*100.D0,' %'
   elseif(ierpf.eq.2) then
! --- random error on the phase offsetand and or on the field level
     len=1
     call rlux(vecx,len)
     r1=(2.D0*vecx(1)-1.D0)*abs(vphase)
     tref=tref+r1*pi/(fh*180.D0)
     len=1
     call rlux(vecx,len)
     r2=(2.D0*vecx(1)-1.D0)*100.D0*abs(vfield)
     write(16,*) 'Random error on RF phase    : ',r1,' deg'
     write(16,*) 'Random error on RF amplitude: ',r2,' %'
     vfield=r2/100.D0
   endif
! set flag that optional RFQ .dst file is not open
   ISTAT=0
!  STATISTICS FOR PLOTS
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
!  start prints in file 'short.data'
   tlgth=0.D0
   tlgths=0.D0       
   idav=idav+1
   iitem(idav)=15
   dav1(idav,9)=tdvolt*1000.D0
   dav1(idav,7)=DBLE(nceltot)
   dav1(idav,8)=tdvolt*1000.D0*(1.D0+avolt)*(1.D0+vfield)
! --- end daves
   xlrfq=0.D0
!  the integer nn is only used if the RMS profile is required
   nn=0
!  nrwcc is a counter used for the optional WRBEAM behind cells listed
   nrwcc=1
   do ncell=1,nceltot
     WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      RFQ cell            :',ncell,cr
     flush(6)
!  ns = 18: number of steps in cells (except for the fringe field region and RMS)
     ns=18
! rh0 is rho of cell in m         
     rh0=rfq12(ncell)*1.D-02
     if(itype(ncell).gt.3) ns=126
     nsm=ns/2
     r0=rfq7(ncell)
     cl=rfq3(ncell)
     davtot=davtot+cl*100.D0
     xlrfq=xlrfq+cl*100.D0
     pavolt=(1.D0+vfield)*rfq11(ncell)
!********************************************
     if(itype(ncell).eq.0) then
!********************************************
! ------------- accelerating cells(ityp = 0)
!********************************************
       cay=pi/cl
! --- synchronous particle
       rtvolt=rfq10(ncell)
!  vorsq not needed
!       vorsq=rfq1(ncell)*rtvolt
       av=rfq2(ncell)*rtvolt
!  a12v not needed
!      a12v=rfq6(ncell)*rtvolt
! --- particles
!       pavolt=rfq11(ncell)
       vorb=rfq1(ncell)*pavolt*rfq9(ncell)
       avb=rfq2(ncell)*pavolt*rfq9(ncell)
       a12vb=rfq6(ncell)*pavolt*rfq9(ncell)
! a03vb not needed (?)
       a03vb=rfq8(ncell)*pavolt*rfq9(ncell)
     elseif(itype(ncell).eq.1) then
!********************************************
! ---------------- T-cell(Type = 1)
!********************************************
       cay=pi/(2.D0*cl)
! ---- synchronous particle
       rtvolt=rfq10(ncell)
       a31v=rfq1(ncell)*rtvolt
       a10v=rfq2(ncell)*rtvolt
! ---- particles (field)
!           pavolt=rfq11(ncell)
       a31vb=rfq1(ncell)*pavolt*rfq9(ncell)
       a10vb=rfq2(ncell)*pavolt*rfq9(ncell)
     elseif(itype(ncell).eq.2) then
!********************************************
! --------   E-cell(Type = 2)
!********************************************
       cay=pi/(2.D0*cl)
! ---- synchronous particle
       rtvolt=rfq10(ncell)
       a31v=rfq1(ncell)*rtvolt
       a10v=rfq2(ncell)*rtvolt
! ---- particles
!           pavolt=rfq11(ncell)
       a31vb=rfq1(ncell)*pavolt*rfq9(ncell)
       a10vb=rfq2(ncell)*pavolt*rfq9(ncell)
     elseif(itype(ncell).eq.4) then
!********************************************
! ------- F-cell (ityp = 4)
!********************************************
! --- synchronous particle
       rtvolt=rfq10(ncell)
       av=rfq2(ncell)*rtvolt
! --- particles
!           pavolt=rfq11(ncell)
       avb=rfq2(ncell)*pavolt*rfq9(ncell)
     elseif(itype(ncell).eq.7) then
!********************************************
!  fringe field type 7
! ------- F-cell (ityp = 7)
!********************************************
! --- synchronous particle
       rtvolt=rfq10(ncell)
! --- particles
!           pavolt=rfq11(ncell)
       a31vb=pavolt*rfq9(ncell)
     elseif(itype(ncell).eq.5) then
!********************************************
! -----Radial matching section from potential function (Type = 5)
!********************************************
       cay=pi/(2.D0*cl)
! ---- synchronous particle
       rtvolt=rfq10(ncell)
       a31v=rfq1(ncell)*rtvolt
       a10v=rfq2(ncell)*rtvolt
! ---- particles (field)
!           pavolt=rfq11(ncell)
       a31vb=rfq1(ncell)*pavolt*rfq9(ncell)
       av10b=rfq2(ncell)*pavolt*rfq9(ncell)
     elseif(itype(ncell).eq.6) then
!********************************************
! -----Radial matching section with vanes profile read from disk (Type = 6)
!********************************************
       cay=pi/(2.D0*cl)
! ---- potential applied to the synchronous particle
       rtvolt=rfq10(ncell)
! ---- potential applied to particles
!           pavolt=rfq11(ncell)
       a31vb=pavolt*rfq9(ncell)
     endif
!********************************************
!   c.o.g of the bunch
     tcog=0.D0
     ecog=0.D0
     do i =1,ngood
       tcog=tcog+f(6,i)
       ecog=ecog+f(7,i)
     enddo
     tcog=tcog/DBLE(ngood)
     ecog=ecog/DBLE(ngood)
     gcog=ecog/er
     bcog=sqrt(1.D0-1.D0/(gcog*gcog))
     wcog=ecog-er
     if(ncell.eq.1) then
! ---- shift = .false. ==> the synchronous particle is the center of gravity
       if(.not.shift) then
         tref=tcog
         bref=bcog
         vref=bref*vl
         gref=gcog
         wref=wcog
         wrefin=wref
       else
! ---- shift = .true. ==> the synchronous particle and the c.o.g are separated
         bref=vref/vl
         gref=1.D0/sqrt(1.D0-bref*bref)
         wref=er*(gref-1.D0)
         wrefin=wref
       endif
     endif
!********************************************
! --- fringe field region type 4
     if(itype(ncell).eq.4) then
       cay=pi/(2.D0*cl)
       !NS=int(36.D0*CL/(BREF*WAVEL))
       !if(ns.le.5) ns=6
       nsm=ns/2
     endif
!********************************************
!   Fringe field region type 7
     if(itype(ncell).eq.7) then
       cay=pi/(2.D0*cl)
       !NS=int(36.D0*CL/(BREF*WAVEL))
       !ns=3*ns
       nsm=ns/2
     endif
!********************************************
! ---  M-cell (itype = 3)
!old sv         if(itype(ncell).eq.3) cay=pi/cl
!********************************************
     xl=cl/DBLE(ns)
     hl=0.5D0*xl
!----  scl: space charge length in SCHEFF unit (cm)
     scl=cl*100.D0
!----  phini: phase of the synchronous at input of the cell
     phini=-tref*fh+rfq4(ncell)*radian
     if(ncell.eq.1) then
       write(16,'(/,A,/,5x,A)') ' Dynamics at the input', &
         '   BETA     GAMMA      ENERGY(MeV)        TOF(deg)     TOF(sec)'
       write(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' COG ', &
        bcog,gcog,wcog,tcog*fh*180.D0/pi,tcog
       write(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' REF ', &
        bref,gref,wref,tref*fh*180.D0/pi,tref
       write(16,*)
       write(75,'(5x,A,4x,A,8x,A,12x,A,11x,A,11x,A)') &
         'ncell','A01(m-2)','A10','A12','r0(m)','A03(m-6)'
       write(70,'(A,3x,A,4x,A,7x,A,8x,A,7x,A,7x,A,7x,A,6x,A,5x,A,6x,A)') &
         '#','ncell','Lcell(m)','Ztot(m)','Phi(deg)','Phm(deg)','Pho(deg)','Wsyn,out', &
         'Wcog,out','ngood','Zacc(m)'
     endif
     z=0.D0
     dr0=0.D0
     if(ncell.eq.1) dr0=rfq7(2)-rfq7(1)
     if(ncell.gt.1) dr0=rfq7(ncell)-rfq7(ncell-1)
     eddav=0.D0
     eddavb=0.D0
     if(ncell.gt.1 .and. itype(ncell).eq.0) then
       eddav=(rfq2(ncell)-rfq2(ncell-1))*rtvolt
       eddavb=(rfq2(ncell)-rfq2(ncell-1))*pavolt*rfq9(ncell)
     endif
     eddav=eddav/DBLE(ns)
     eddavb=eddavb/DBLE(ns)
! 2024NEW         
! set up to get physical limits of electrodes        
     if(ncell.gt.2) then
       dA01=(rfq1(ncell)-rfq1(ncell-1))/10000.
       dA10=rfq2(ncell)-rfq2(ncell-1)
       dA10mp=rfq23(ncell)-rfq23(ncell-1)
       dA10x=rfq25(ncell)-rfq25(ncell-1)
       dsa=rfq21(ncell)-rfq21(ncell-1)        
     else
       dA01=0.
       dA10=0.
       dA10mp=0.
       dA10x=0.
       dsa=0.        
       dsm=0.
     endif  
     if(ncell.eq.3 .and. itype(ncell-1).eq.2) then
       dA10x=rfq25(ncell)-rfq2(ncell-1)         
     endif         
     dsa=dsa/dble(ns)        
     dr0=dr0/dble(ns)
     dA01=dA01/dble(ns)
     dA10=dA10/dble(ns)         
     dA10x=dA10x/dble(ns)         
     dA10mp=abs(dA10mp/dble(ns))
     csign=1.
     if(ipari(ncell).eq.0) csign=-1.         
!********************************         
! ---- iterations over steps xl *
!********************************
     nsp1=ns+1
     do n=1,nsp1
       z=z+hl
       fns=DBLE(n-1)
       if(z.gt.cl) then
         if((z-cl).gt.0.00001D0) then                      
           zl=z-hl
           tlgth=tlgth+zl
           phfin=tref*fh+phini
           phfin=phfin*180.D0/pi
!cc          phfin=phref*180.D0/pi
           if(ncell.eq.1) then
             rfqdmp(ncell,1)=davtot/100.0D0
             rfqdmp(ncell,3)=wref-wrefin
           else
             rfqdmp(ncell,1)=zl+rfqdmp(ncell-1,1)
             rfqdmp(ncell,3)=wref-wrefin
           endif
           wrefin=wref
           rfqdmp(ncell,2)=phdep
! the maximum energy gain is pi/4 * A * V
           rfqdmp(ncell,4)=0.25D0*pi*rfq2(ncell)*rfq10(ncell)
           !write(70,'(2x,i5,7(3x,e12.5),3x,i8,2x,e12.5)') ncell,zl,tlgth,phdep,phmil, &
           !  phfin,wref,wcog,ngood,davtot/100.0D0
           exit
         else
           z=cl
         endif    
       endif
! --- change of reference over the half step hl
       tref=tref+hl/(bref*vlm)
       if(itvol) ttvols=tref
       phref=tref*fh+phini
       skz=sin(cay*z)
       ckz=cos(cay*z)
! ---  synchronous particle
!        change of energy over the step xl
       sp=sin(phref)
       if(itype(ncell).eq.0) then
!****************************
! standard accelerating cell
!****************************
         if(ncell.gt.1) then
           av=rfq2(ncell-1)*rtvolt+eddav*fns
           avb=rfq2(ncell-1)*pavolt*rfq9(ncell)+eddavb*fns
         else
           av=rfq2(ncell)*rtvolt
           avb=rfq2(ncell)*pavolt*rfq9(ncell)
         endif
         dwref=0.5D0*qst*cay*av*skz*sp*xl
! print in file rfq_list1.data
         if(n.eq.1) phdep=rfq4(ncell)
         pckz=csign*cos(cay*(z+hl))                         
         rr0=rfq7(ncell-1)+dr0*dble(n)
         if(ncell.gt.2) then
           sa=rfq21(ncell-1)+dsa*dble(n)
           a10=rfq2(ncell-1)+dA10*dble(n)
           a10x=rfq25(ncell-1)+dA10x*dble(n)
           a10mp=abs(rfq23(ncell-1))+dA10mp*dble(n)              
         else            
           sa=rfq21(ncell)
           sm=rfq22(ncell)
           a10=rfq2(ncell)
           a10x=rfq25(ncell)
           a10mp=abs(rfq23(ncell))
         endif
         if(ncell.eq.3 .and. itype(ncell-1).eq.2) then
           a10x=rfq2(ncell-1)+dA10x*dble(n-1)
         endif             
         za0=cay*sa
         cay2=cay*cay
         no=0
         bi0=bint(no,za0)
         a01=1.D0/(rr0*rr0)
         a10n=(1.D0-sa*sa*a01)/bi0
         a10ckz=a10x*pckz
         denx=0.D25*cay2*a10ckz+a01
         deny=-0.D25*cay2*a10ckz+a01
         tlgths=tlgths+2.D0*hl
         rx=sqrt((1.D0-a10ckz)/denx)
         ry=sqrt((1.D0+a10ckz)/deny)
! 4th power             
!             a=cay2*cay2*a10ckz/64.D0   
!             b=a01+cay2*a10ckz/4.D0  
!             c=a10ckz-1.D0 
!             bigrp=(-b+sqrt(b*b-4.D0*a*c))/(2.D0*a)
!             bigrm=(-b-sqrt(b*b-4.D0*a*c))/(2.D0*a)
!             bigrp=sqrt(abs(bigrp))
!             bigrm=sqrt(abs(bigrm))
! 4th power including A12
         a12=rfq6(ncell)             
!         a=cay2*cay2*a10ckz/64.D0
!         a=a+cay2*cay2*a12*ckz/384.D0
!         b=a01+cay2*a10ckz/4.D0 
!         c=a10ckz-1.D0
! 2025 not used for the moment...also..check for (b*b-4.D0*a*c) > 0.    
!         bigrp=(-b+sqrt(b*b-4.D0*a*c))/(2.D0*a)
!         bigrm=(-b-sqrt(b*b-4.D0*a*c))/(2.D0*a)
!         bigrp=sqrt(abs(bigrp))
!         bigrm=sqrt(abs(bigrm))
         zprt=tlgths
         xm=rfq22(ncell)
         if(ipol(ncell).eq.0) then
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,rx,rr0,ry
           vanx=rx
           vany=ry                 
         else
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,ry,rr0,rx
           vanx=rx
           vany=ry                 
         endif                          
       elseif(itype(ncell).eq.1) then
!****************************
! T-cell (type = 1)
!****************************
         cay2=cay*cay
         skz3=sin(3.D0*cay*z)
         ckz3=cos(3.D0*cay*z)
         dwref=0.5D0*qst*cay*(a10v*skz+3.D0*a31v*skz3)*sp*xl
! print in file rfq_list1.data
         if(n.eq.1) phdep=rfq4(ncell)
         rr0=rfq7(ncell-1)-dr0*fns
         pckz3=-csign*cos(3.D0*cay*(z+hl))
         pckz=-csign*cos(cay*(z+hl))             
         a10tp=rfq2(ncell)
         a30tp=rfq1(ncell)             
         denx=4./(rr0*rr0)-cay2*a10tp*pckz-9.*cay2*a30tp*pckz3
         deny=4./(rr0*rr0)+cay2*a10tp*pckz+9.*cay2*a30tp*pckz3
         rx=4.+4.*a10tp*pckz+4.*a30tp*pckz3
         ry=4.-4.*a10tp*pckz-4.*a30tp*pckz3            
         rx=sqrt(rx/abs(denx))
         ry=sqrt(ry/abs(deny))
         tlgths=tlgths+2.D0*hl
         zprt=tlgths
         if(ipol(ncell).eq.0) then
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,rx,r0,ry
           vanx=rx
           vany=ry                 
         else
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,ry,r0,rx
           vanx=ry
           vany=rx                 
         endif 
       elseif(itype(ncell).eq.2) then
!****************************
! E-cell (type = 2)
!****************************
         skz3=sin(3.D0*cay*z)
         ckz3=cos(3.D0*cay*z)
         dwref=0.5D0*qst*cay*(a10v*ckz+3.D0*a31v*ckz3)*sp*xl
! print in file rfq_list1.data
         if(n.eq.1) phdep=rfq4(ncell)
         rr0=rfq7(ncell-1)+dr0*dble(n)             
         a31vp=rfq1(ncell)
         a10vp=rfq2(ncell)
         pskz=csign*sin(cay*(z+hl))
         pskz3=csign*sin(3.D0*cay*(z+hl))             
         denx=4./(rr0*rr0)-cay*cay*a10vp*pskz-9.*cay*cay*a31vp*pskz3
         deny=4./(rr0*rr0)+cay*cay*a10vp*pskz+9.*cay*cay*a31vp*pskz3
         rx=4.+4.*a10vp*pskz+4.*a31vp*pskz3
         ry=4.-4.*a10vp*pskz-4.*a31vp*pskz3
         rx=sqrt(rx/abs(denx))
         ry=sqrt(ry/abs(deny))
         tlgths=tlgths+2.D0*hl
         zprt=tlgths
         if(ipol(ncell).eq.0) then
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,rx,r0,ry
           vanx=rx
           vany=ry                 
         else
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,ry,r0,rx
           vanx=ry
           vany=rx                 
         endif                                                   
       elseif(itype(ncell).eq.3) then
!****************************
! M-cell (type = 3)
!****************************
         dwref=0.D0
! print in file rfq_list1.data
         if(n.eq.1) phdep=rfq4(ncell)
         r0=rfq7(ncell)             
         rx=r0
         ry=rx
         tlgths=tlgths+2.D0*hl
         zprt=tlgths
         if(ipol(ncell).eq.0) then
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,rx,r0,ry
           vanx=rx
           vany=ry                 
         else
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,ry,r0,rx
           vanx=ry
           vany=rx                 
         endif             
       elseif(itype(ncell).eq.4) then
!****************************
! Fringe-field region (itype = 4)
!****************************
         rtvolt=rfq10(ncell)
         av=rfq2(ncell-1)*rtvolt+eddav*fns
         avb=rfq2(ncell-1)*pavolt*rfq9(ncell)+eddavb*fns
!2024     r0=rfq7(ncell)
         r0=rfq7(ncell-1)+dr0*dble(n) 
         c3kz=cos(3.D0*cay*z)
         skpz=0.75D0*(skz+sin(3.D0*cay*z))
         dwref=0.5D0*qst*cay*av*skpz*sp*xl
! print in file rfq_list1.data
         if(n.eq.1) phdep=rfq4(ncell)
         pskz=csign*sin(cay*(z+hl))
         pckz=csign*cos(cay*(z+hl))
         pskz2=2.*pskz*pckz
         pckz2=pckz*pckz-pskz*pskz
         pckz3=pckz2*pckz-pskz2*pskz
         den=abs(3.*pckz+pckz3)
         if(den.lt.fprec) then
           rx=2.D0*vanx              
         else               
           rx=2.D0*r0/sqrt(den)
         endif  
         ry=rx             
!         if(z.le.ffelec) then
         if(z.le.cl) then
           tlgths=tlgths+2.D0*hl
           zprt=tlgths
           if(ipol(ncell).eq.0) then
             if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,rx,r0,ry
             vanx=rx
             vany=ry                   
           else
             if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,ry,r0,rx
             vanx=ry
             vany=rx                   
           endif
         endif                            
       elseif(itype(ncell).eq.7) then
!****************************
! Fringe-field region (itype = 7)
!****************************
         rtvolt=rfq10(ncell)
         av=rfq2(ncell-1)*rtvolt+eddav*fns
         avb=rfq2(ncell-1)*pavolt*rfq9(ncell)+eddavb*fns
         skpz=0.75D0*(skz+sin(3.D0*cay*z))
         dwref=0.5D0*qst*cay*av*skpz*sp*xl
!   rprof: current fringe field profile at the azimutal position z
!             r0=rfq7(ncell-1)+dr0*fns
!2019             
         r0=rfq7(ncell)
         c3kz=cos(3.D0*cay*z)
         rproff=splinf(npf,z)
         vanx=rproff
         vany=rproff  
         tlgths=tlgths+2.D0*hl
         zprt=tlgths 
! print in file rfq_list1.data
         if(n.eq.1) phdep=rfq4(ncell)
         if(ipol(ncell).eq.0) then
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,rproff,r0,rproff     
         else
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zprt,rproff,r0,rproff      
         endif                                       
       elseif(itype(ncell).eq.5) then
!****************************
! --- RMS (type = 5)
!****************************
         dwref=0.D0
! print in file rfq_list1.data
         if(n.eq.1) phdep=rfq4(ncell)
         zrms=z+hl
         skzr=csign*sin(cay*zrms)
         r=abs(skzr*skzr*skzr)
         r0i=r0
         rx=sqrt(r0i*r0i/r)
         ry=rx
         tlgths=zrms
         if(ipol(ncell).eq.0) then
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zrms,rx,r0,ry
           vanx=rx
           vany=ry               
         else
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zrms,ry,r0,rx
           vanx=ry
           vany=rx              
         endif             
       elseif(itype(ncell).eq.6) then
!****************************
! --- RMS (type = 6)
!****************************
         dwref=0.D0
!   rprof: current RMS profile given at z
         rprof=spline(npt,z)
         vanx=rprof
         vany=rprof             
! print in file rfq_list1.data
         if(n.eq.1) phdep=rfq4(ncell)
         zrms=z+hl
         tlgths=zrms            
         if(ipol(ncell).eq.0) then
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zrms,rprof,r0,rprof     
         else
           if(.not. mcselect) write(98,'(2x,i4,5x,i1,3x,i3,2x,e13.6,3(1x,f10.6))') ncell,itype(ncell),n,zrms,rprof,r0,rprof      
         endif                          
       endif
! --- gain of energy (synchronous particle)
       wrefm=wref+0.5D0*dwref
       grefm=wrefm/er+1.D0
       brefm=sqrt(1.D0-1.D0/(grefm*grefm))
       wref=wref+dwref
       gref=wref/er+1.D0
       bref=sqrt(1.D0-1.D0/(gref*gref))
       dez=0.D0
       dref=0.D0
! ****************
! ---- Beam ---- *
! ****************
!      coordinates x, xp,y, yp convert to m and rad
       do ip=1,ngood
         xi=f(2,ip)*1.D-02
         xpi=f(3,ip)*1.D-03
         yi=f(4,ip)*1.D-02
         ypi=f(5,ip)*1.D-03
         ww=f(7,ip)-er
! remove from the bunch particles that have energy < 0
         if(ww.lt. 0.D0)then
           f(8,ip)=0.D0
           ilost=ilost+1
           lossreason=-2
           f6i=f(6,ip)-tref
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
           PRTLAB,ncell,davtot/100.D0,ip, &
           int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip), &
           f6i*fh*180.D0/pi,f(7,ip)-er,f(9,ip),lossreason,uden
           iflag=.true.
           cycle
         endif
         gi=ww/er+1.D0
         if(gi .lt. 1.D0) then
           f(8,ip)=0.D0
           ilost=ilost+1
! needs to be on energy
           lossreason=-2
           f6i=f(6,ip)-tref
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
           PRTLAB,ncell,davtot/100.D0,ip, &
           int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip), &
           f6i*fh*180.D0/pi,f(7,ip)-er,f(9,ip),lossreason,uden
           iflag=.true.
           cycle
         endif
         bi=sqrt(1.D0-1.D0/(GI*GI))
         bgi=bi*gi
! move particles back in the bunch if they have abs(phi) > pi
         tim=f(6,ip)+hl/(bi*vlm)
         phi=fh*(tim-tref)
         if(abs(phi).ge.pi) then
!           f(6,ip)=f(6,ip)-2.D0*pi/fh
           f(6,ip)=f(6,ip)-sign(2.D0,phi)*pi/fh
           tim=f(6,ip)+hl/(bi*vlm)
           phi=fh*(tim-tref)
           if(abs(phi).gt.pi) then
             f(8,ip)=0.D0
             ilost=ilost+1
             lossreason=-1
             f6i=tim-tref
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
             PRTLAB,ncell,davtot/100.D0,ip, &
             int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip), &
             f6i*fh*180.D0/pi,f(7,ip)-er,f(9,ip),lossreason,uden
             iflag=.true.
             cycle
           endif
         endif
         tim=f(6,ip)+hl/(bi*vlm)
         phi=phini+fh*tim
         qq=abs(f(9,ip))
         sp=sin(phi)
         cp=cos(phi)
         bav=bi
         gav=gi
         bgav=bgi
         bg=bgi
         beta=bi
         delt=0.D0
         amort=1.D0
         xm=xi+xpi*hl
         ym=yi+ypi*hl
         rm=sqrt(xm*xm+ym*ym)
! ---- particle is lost if abs(xm) > vanx or abs(ym) > vany
         if(n.ne.ns/2) then
           if(abs(ym).lt.rh0 .and. abs(xm).gt.vanx*apfac) then
! within height of H electrode               
               f(8,ip)=0.D0
               lossreason=2
           elseif(abs(xm).gt.vanx*apfac) then
               f(8,ip)=0.D0
               lossreason=2
           endif
           if(abs(xm).lt.rh0 .and. abs(ym).gt.vany*apfac) then
! within height of V electrode               
             f(8,ip)=0.D0
             lossreason=3
           elseif(abs(ym).ge.vany*apfac) then
             f(8,ip)=0.D0
             lossreason=3
           endif
           if(int(f(8,ip)).eq.0) then
             ilost=ilost+1
             f6i=tim-tref
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
             PRTLAB,ncell,davtot/100.D0,ip, &
             int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip), &
             f6i*fh*180.D0/pi,f(7,ip)-er,f(9,ip),lossreason,uden
             iflag=.true.
             cycle
           endif
         else
           if(rm.gt.r0*apfac) then
             f(8,ip)=0.D0
             ilost=ilost+1
             lossreason=1
             f6i=tim-tref
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
             PRTLAB,ncell,davtot/100.D0,ip, &
             int(f(1,ip)),f(2,ip),f(3,ip),f(4,ip),f(5,ip), &
             f6i*fh*180.D0/pi,f(7,ip)-er,f(9,ip),lossreason,uden
             iflag=.true.
             cycle
           endif
         endif
         theta=0.D0
         signx=0.D0
         signy=0.D0
         xml=xm
         yml=ym
         if(abs(xm).gt.1.D-10) then
           theta=atan(ym/xm)
           signx=1.D0
           signy=1.D0
           if(theta.gt. 0.D0) then
             if(xm.lt. 0.D0) signx=-1.D0
             if(ym.lt. 0.D0) signy=-1.D0
           endif
           if(theta.lt. 0.D0) then
             if(xm.lt. 0.D0) signx=-1.D0
             if(ym.gt. 0.D0) signy=-1.D0
           endif
         else
           if(abs(ym).gt.1.D-10) then
             if(xm.ge.0.D0 .and.ym.gt. 0.D0) theta=pi/2
             if(xm.ge.0.D0 .and.ym.lt. 0.D0) theta=-pi/2
             if(xm.lt.0.D0 .and.ym.lt. 0.D0) theta=pi/2
             if(xm.lt.0.D0 .and.ym.gt. 0.D0) theta=-pi/2
           endif
         endif
         if(abs(theta).le.fprec) then
           signx=0.D0
           signy=0.D0
         endif
         if(itype(ncell).eq.0) then
!****************************
! ----  standard accelerating cell
!****************************
           zrm=cay*rm
!   Bessel functions
           no=0
           bi0=bint(no,zrm)
           no=1
           bi1=bint(no,zrm)
           no=3
           bi3=bint(no,zrm)
           no=4
           bi4=bint(no,zrm)
           no=5
           bi5=bint(no,zrm)
! ----- Bessel functions: I0 to I4
           bi1p=0.D0
           if(rm.gt.fprec) bi1p=bi1/rm
           bi4r=0.D0
           if(rm.gt.1.D-06) bi4r=bi4/rm
           c2t=cos(2.D0*theta)
           s2t=sin(2.D0*theta)
           c1t=cos(theta)
           s1t=sin(theta)
! ---   transverse fields (cylindrical coordinates)
           erf=vorb*c2t*2.D0*rm+ &
           cay*(avb*bi1+a12vb*(bi3+bi5)*cos(4.D0*theta)/2.D0)*ckz
!          cay*(avb*bi1+a12vb*bi3*cos(4.D0*theta)/2.D0)*ckz
           erf=-erf/2.D0
           etf=vorb*s2t*2.D0*rm+ &
           4.D0*a12vb*bi4r*sin(4.D0*theta)*ckz
           etf=etf/2.D0
           ncf=(ipari(ncell)/2)*2-ipari(ncell)
           if(ncf.eq.0) then
             erf=-erf
             etf=-etf
           endif
!  cartesian fields Ex and Ey
           ex=erf*c1t-etf*s1t
           ey=erf*s1t+etf*c1t
           ex=signx*ex
           ey=signy*ey
         elseif(itype(ncell).eq.1) then
!****************************
! ---- T-cell (Type = 1) (end of RFQ)
!****************************
!   transverse fields (cylindrical coordinates)
           zrm=cay*rm
           zrm3=zrm*3.D0
           no=0
           bi0=bint(no,zrm)
           bi03=bint(no,zrm3)
           no=1
           bi1=bint(no,zrm)
           bi13=bint(no,zrm3)
           c2t=cos(2.D0*theta)
           s2t=sin(2.D0*theta)
           c1t=cos(theta)
           s1t=sin(theta)
           pavolt=(1.D0+vfield)*rfq11(ncell)
           rpv=pavolt*rfq9(ncell)
           ncf=(ipari(ncell)/2)*2-ipari(ncell)
           if(ncf.eq.0) then
             rpv=-rpv
             erf=-rpv/(r0*r0)*c2t*rm
             erf=erf+cay/2.D0*(a10vb*bi1*ckz+3.D0*a31vb*bi13*ckz3)
             etf=rpv/(r0*r0)*s2t*rm
           else
             erf=-rpv/(r0*r0)*c2t*rm
             erf=erf-cay/2.D0*(a10vb*bi1*ckz+3.D0*a31vb*bi13*ckz3)
             etf=rpv/(r0*r0)*s2t*rm
           endif
           ex=erf*c1t-etf*s1t
           ey=erf*s1t+etf*c1t
           ex=signx*ex
           ey=signy*ey
         elseif(itype(ncell).eq.2) then
!****************************
! ---- E-cell (Type = 2) (beginning of RFQ)
!****************************
! ---   transverse fields (cylindrical coordinates)
           zrm=cay*rm
           zrm3=zrm*3.D0
           no=0
           bi0=bint(no,zrm)
           bi03=bint(no,zrm3)
           no=1
           bi1=bint(no,zrm)
           bi13=bint(no,zrm3)
           c2t=cos(2.D0*theta)
           s2t=sin(2.D0*theta)
           c1t=cos(theta)
           s1t=sin(theta)
           pavolt=(1.D0+vfield)*rfq11(ncell)
           rpv=pavolt*rfq9(ncell)
           erf=-rpv/(r0*r0)*c2t*rm
           erf=erf+0.5D0*cay*(a10vb*bi1*skz+3.D0*a31vb*bi13*skz3)
           etf=rpv/(r0*r0)*s2t*rm
!   control polarity of the cell
           ncf=(ipari(ncell)/2)*2-ipari(ncell)
           if(ncf.eq.0) then
             erf=-erf
             etf=-etf
           endif
           ex=erf*c1t-etf*s1t
           ey=erf*s1t+etf*c1t
           ex=signx*ex
           ey=signy*ey
         elseif(itype(ncell).eq.3) then
!****************************
! ---- M-cell (Type = 3)
!****************************
           c2t=cos(2.D0*theta)
           s2t=sin(2.D0*theta)
           c1t=cos(theta)
           s1t=sin(theta)
           pavolt=(1.D0+vfield)*rfq11(ncell)
           rpv=pavolt*rfq9(ncell)
           erf=-rpv/(r0*r0)*c2t*rm
           etf=rpv/(r0*r0)*s2t*rm
! ---- M-cell (Type = 3)
! *************************************************
!  control polarity of the cell
           ncf=(ipari(ncell)/2)*2-ipari(ncell)
           if(ncf.eq.0) then
             erf=-erf
             etf=-etf
           endif
           ex=erf*c1t-etf*s1t
           ey=erf*s1t+etf*c1t
           ex=signx*ex
           ey=signy*ey
         elseif(itype(ncell).eq.5) then
!****************************
! ---- Radial matching section (type = 5)
!****************************
           c2t=cos(2.D0*theta)
           s2t=sin(2.D0*theta)
           c1t=cos(theta)
           s1t=sin(theta)
           skz3=sin(3.D0*cay*z)
           ckz3=cos(3.D0*cay*z)
           zrm=cay*rm
           b2kr=zrm*zrm/8.D0
           b2kr3=(9.D0/8.D0)*zrm*zrm
           qzrm=0.D0
           erf=0.D0
           etf=0.D0
           if(rm .gt. 0.D0) then
             qzrm=(b2kr*skz-(1.D0/27.D0)*b2kr3*skz3)
             erf=-a31vb*cay*cay*(skz-1.D0/3.D0*skz3)*c2t/8.D0
             erf=erf*rm
             etf=a31vb*qzrm*s2t/rm
           endif
           ex=erf*c1t-etf*s1t
           ey=erf*s1t+etf*c1t
           ex=signx*ex
           ey=signy*ey
         elseif(itype(ncell).eq.6) then
!****************************
! ---- RMS based on profile  (type = 6)
!****************************
           BGFAC=GAV*BAV**2
           cc=a31vb*qq*xl*sp/(bgfac*er)
           rr1=-cc/(rprof*rprof)
           rr2=cc/(rprof*rprof)
           rr1=rr1*xm
           rr2=rr2*ym
         elseif(itype(ncell).eq.7) then
!****************************
! Fringe field profile from the disk (type 7)
!****************************
           BGFAC=GAV*BAV**2
           c1=0.75D0*(ckz+c3kz/3.D0)
           cc=a31vb*qq*xl*sp/(bgfac*er)
           rr1=-cc/(rproff*rproff)
           rr2=cc/(rproff*rproff)
!  test the cell parity
           ncf=(ipari(ncell)/2)*2-ipari(ncell)
           if(ncf.eq.0) then
             rr1=-rr1
             rr2=-rr2
           endif
           rr1=rr1*xm
           rr2=rr2*ym
         endif
!********************************************
!----  CHANGE ENERGY OVER the STEP XL
         if(itype(ncell).eq.0) then
! ------ standard accelerating cell (Type = 0)
           ez=0.5D0*(avb*bi0+a12vb*bi4*cos(4.D0*theta))*skz*cay
           dw=qq*ez*sp*xl
         elseif(itype(ncell).eq.1) then
! ------ T-cell (Type = 1)
           ez=0.5D0*cay*(a10vb*skz*bi0+3.D0*a31vb*skz3*bi03)
           dw=qq*ez*sp*xl
         elseif(itype(ncell).eq.2) then
! ------ E-cell (Type = 2)
           ez=0.5D0*cay*(a10vb*ckz*bi0+3.D0*a31vb*ckz3*bi03)
           dw=qq*ez*sp*xl
         elseif(itype(ncell).eq.3) then
! ------ M-cell (itype = 3)
           dw=0.D0
         elseif(itype(ncell).eq.4) then
! ------ fringe field region (itype = 4)
!           dw=0.5D0*qq*cay*avb*skz*sp*xl
           dw=0.5D0*qq*cay*avb*skpz*sp*xl
         elseif(itype(ncell).eq.7) then 
! ------ (itype = 7)
           dw=0.5D0*qq*cay*avb*skz*sp*xl
         elseif(itype(ncell).eq.5) then
! ------ RMS (itype = 5)
           ez=-1.D0/16.D0*a31vb*cay**3*rm*rm*(ckz-ckz3)*c2t
           dw=qq*ez*sp*xl
         elseif(itype(ncell).eq.6) then
! ------ RMS (itype = 6)
           dw=0.D0
         endif
! -----  WAV: energy at the middle of the element
         WAV=WW+0.5D0*DW
         GA=WAV/ER
         if(ga .LE. 0.D0) then
           f(8,ip)=0.D0
           ilost=ilost+1
! needs to be on energy
           lossreason=-2
           f6i=f(6,ip)-tref
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
           PRTLAB,ncell,davtot/100.D0,ip,int(f(1,ip)), &
           f(2,ip),f(3,ip),f(4,ip),f(5,ip),f6i*fh*180.D0/pi, &
           WAV,f(9,ip),lossreason,uden
           iflag=.true.
           cycle
         endif
         BGAV=SQRT(GA*(2.D0+GA))
         GAV=1.D0+GA
         BAV=BGAV/GAV
! ---- energy over step xl
         WW=WW+DW
         GA=WW/ER
         GAM=1.D0+GA
         if(gam.le.1.D0) then
           f(8,ip)=0.D0
           ilost=ilost+1
! needs to be on energy
           lossreason=-2
           f6i=f(6,ip)-tref
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
           PRTLAB,ncell,davtot/100.D0,ip,int(f(1,ip)), &
           f(2,ip),f(3,ip),f(4,ip),f(5,ip),f6i*fh*180.D0/pi, &
           WAV,f(9,ip),lossreason,uden
           iflag=.true.
           cycle
         endif
         BG=SQRT(GA*(2.D0+GA))
         beta=sqrt(1.D0-1.D0/(gam*gam))
!old jump of phase (sec) of particles (only for standard accelerating cells)
         delt=0.D0
!old           if(itype(ncell).eq.0) then
!old             dez=0.5D0*qq*cay*avb*skz*sp
!old             delt=0.5D0*(dez/er) * xl*xl/(bav**3*gav**3*vlm)
!old           endif
         amort=bgi/bg
         BGFAC=GAV*BAV**2
         cc=qq*xl*sp/(bgfac*er)
!********************************************
         if(itype(ncell).lt.4) then
! cell type 0,1,2,3           
           rr1=cc*ex
           rr2=cc*ey
           xpm=xpi*amort+rr1
           ypm=ypi*amort+rr2
           xf=xm+xpm*hl
           yf=ym+ypm*hl
         elseif(itype(ncell).eq.5) then
! cell type 5           
           rr1=cc*ex
           rr2=cc*ey
           xpm=xpi*amort+rr1
           ypm=ypi*amort+rr2
           xf=xm+xpm*hl
           yf=ym+ypm*hl
         elseif(itype(ncell).eq.6) then
! cell type 6           
           xpm=xpi*amort+rr1
           ypm=ypi*amort+rr2
           xf=xm+xpm*hl
           yf=ym+ypm*hl
         elseif(itype(ncell).eq.7) then
! cell type 7           
           xpm=xpi*amort+rr1
           ypm=ypi*amort+rr2
           xf=xm+xpm*hl
           yf=ym+ypm*hl
         elseif(itype(ncell).eq.4) then
!********************************************
! ------- Fringe-field region (itype = 4)
!           if(itype(ncell).eq.4) then
!*********************************************************
!         C1 = (1/m**2) * (m) = (1/m)
!         C2 = (1/m**2) * (m) = (1/m)
!         RF1 = (MeV/(MeV*m**2)) = (1/m**2)
!         RF2 =  (MeV/MeV) * (1/m**2) = (1/m**2)
!*******************************************************
!old              RF1=QQ*VORB/ER
!old              RF2=.25*QQ*CAY*CAY*AVB/ER
!old              C1=RF1*SP*XL/BGFAC
!old              C2=RF2*CKZ*SP*XL/BGFAC
!old              C1=C1*.75*(CKZ+C3KZ/3.D0)
!old              C2=C2*.75*(CKZ+3.D0*C3KZ)
!old              RR1=-(C1+C2)
!old              RR2=(C1-C2)
! rfq11(ncell) is (1.D0+avolt)*VV , where VV is intervane voltage seen by particles
           pavolt=(1.D0+vfield)*rfq11(ncell)
! rfq9(ncell) is 1.+fvolt
           rpv=pavolt*rfq9(ncell)
!            rf1=qq*rpv/(r0*r0*er)
           rf1=rpv/(r0*r0)
! avb is a10*rpv
!            rf2=0.25D0*qq*cay*cay*avb/er
           rf2=0.25D0*cay*cay*avb
!  test cell parity
           ncf=(ipari(ncell)/2)*2-ipari(ncell)
           if(ncf.eq.0) then
             rf1=-rf1
             rf2=-rf2
           endif
!        c1=rf1*sp*xl/bgfac
!        c2=rf2*sp*xl/bgfac
           c1=rf1*cc
           c2=rf2*cc
!         c2=rf2*ckz*sp*xl/bgfac
           c1=c1*0.75D0*(ckz+c3kz/3.D0)
           c2=c2*0.75D0*(ckz+3.D0*c3kz)
           rr1=-(c1+c2)
           rr2=(c1-c2)
           xpm=xpi*amort+rr1*xm
           ypm=ypi*amort+rr2*ym
           xf=xm+xpm*hl
           yf=ym+ypm*hl
         endif
!  restore coordinates x, xp, y, yp in cm and mrad
         f(2,ip)=xf*100.D0
         f(4,ip)=yf*100.D0
         f(3,ip)=xpm*1000.D0
         f(5,ip)=ypm*1000.D0
!   tof over the length xl
!       if(beta.eq.0.) then
         if(abs(beta).le.fprec) then
           f(6,ip)=f(6,ip)+hl/(bi*vlm)
         else
           f(6,ip)=f(6,ip)+hl/(bi*vlm)+hl/(beta*vlm)
         endif
         f(7,ip)=ww+er
! ********************************             
! --- end do ip (particle loop)  *
! ********************************
       enddo
! ----- reshuffle the good particles at the end of each element
       if(iflag) then
         call shuffle
         iflag=.false.
       endif
!    Check if at the middle of the cell
       if(n.eq.nsm) then
         if(ichaes) then
!    Space charge at the middle of the cell
!         iesp=.true.
           call cesp(scl)
!         iesp=.false.
         endif
         if(rfqiflg.gt.0  .and. (rfqmidcell .or. rfqmaecell)) then
!    Write particle distribution to file if selected with WRBEAM for the cell middle 
           fromrfq=.true.
! check if file already open
           if(ISTAT.eq.0) then
             istat=1
             open(57,file=rfqwfil,status='unknown')
           endif
           if(rfqiflg.gt.nceltot) then
! print for every cell
!
!title line
             if(iflgr.eq.100) then
               write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)'
             elseif(iflgr.eq.101) then
               write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  particle#'
             elseif(iflgr.eq.102) then
               write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  charge'
             elseif(iflgr.eq.103) then
               write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  charge    ', &
                     'particle#'
             else
               write(57,*) 'mid cell ',ncell
             endif
             irec=rfqirec
             call prbeam(iflgr,rfqwfil,fromrfq)
             write(57,*) 
             write(57,*)                  
           elseif(rfqiflg.eq.ncell) then
! print for the single cell indicated
             if(iflgr.eq.100) then
               write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)'
             elseif(iflgr.eq.101) then
               write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)  particle#'
             elseif(iflgr.eq.102) then
               write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  charge'
             elseif(iflgr.eq.103) then
               write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)  charge    ', &
                         'particle#'
             else
               write(57,*) 'mid cell ',ncell
             endif
             irec=rfqirec
             call prbeam(iflgr,rfqwfil,fromrfq)
             close(57)
           endif
         elseif(rfqiflg.lt.0  .and. (rfqmidcell .or. rfqmaecell)) then
! print for the cells in the list
           fromrfq=.true.
! check if file already open
           if(ISTAT.eq.0) then
             istat=1
             open(57,file=rfqwfil,status='unknown')
           endif
           if(nrwcc.le.nrwc) then
             if(iwcl(nrwcc).eq.ncell) then
! plot for the cell indicated
               if(iflgr.eq.100) then
                 write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)'
               elseif(iflgr.eq.101) then
                 write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)  particle#'
               elseif(iflgr.eq.102) then
                 write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)  charge'
               elseif(iflgr.eq.103) then
                 write(57,*) 'mid cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)  charge    ', &
                         'particle#'
               else
                 write(57,*) 'mid cell ',ncell
               endif
               irec=rfqirec
               call prbeam(iflgr,rfqwfil,fromrfq)
               write(57,*) 
               write(57,*)                  
               nrwcc=nrwcc+1
             endif                 
           endif
         endif
       endif
! --- change the reference over the half step hl
       tref=tref+hl/(bref*vlm)
       if(itvol) ttvols=tref
       vref=bref*vl
       z=z+hl
! save RF phase in the middle of the cell
       if(n.eq.ns/2) then
         phmil=(tref*fh+phini)*180.D0/pi
       endif
!     Change  dp/p over the cell
       call disp
!****************************************           
!        end of do n=1,nsp1 (steps in cell)
     enddo
!****************************************           
!----  c.o.g of the bunch at the output of the cell
     tcog=0.D0
     ecog=0.D0
     do i =1,ngood
       tcog=tcog+f(6,i)
       ecog=ecog+f(7,i)
     enddo
     tcog=tcog/DBLE(ngood)
     ecog=ecog/DBLE(ngood)
     gcog=ecog/er
     bcog=sqrt(1.D0-1.D0/(gcog*gcog))
     wcog=ecog-er
!---  window control relative to the energy of the c.o.g of the bunch
! ---- ifw = 0 ===> wdisp = dW/W
! ---- ifw = 1 ===> wdisp = dW (MeV)
! ----- convert wdisp in dp/p
     if(ifw.eq.0 .or. ifw.eq.10) then
       dispr=gcog*gcog*wdisp/(gcog*(gcog+1.D0))
     endif
     if(ifw.eq.1 .or. ifw.eq.11) then
       dispr=gcog*gcog*wdisp/(gcog*(gcog+1.D0)*wcog)
     endif
     iflag=.false.
     do i=1,ngood
       dese=abs(fd(i)-1.D0)
       if(dese.gt.dispr) then
         ilost=ilost+1
         f(8,i)=0.D0
         lossreason=-2
         f6i=f(6,i)-tref
         write(49,'(A8,1x,I4,1x,E12.5,1x,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
         PRTLAB,ncell,davtot/100.D0,i,int(f(1,i)), &
         f(2,i),f(3,i),f(4,i),f(5,i),f6i*fh*180.D0/pi,WAV,f(9,i), &
         lossreason,uden
         iflag=.true.
       endif
     enddo
     if(iflag) then
       call shuffle
!----  c.o.g of the bunch after shuffle
       tcog=0.D0
       ecog=0.D0
       do i =1,ngood
         tcog=tcog+f(6,i)
         ecog=ecog+f(7,i)
       enddo
       tcog=tcog/DBLE(ngood)
       ecog=ecog/DBLE(ngood)
       gcog=ecog/er
       bcog=sqrt(1.D0-1.D0/(gcog*gcog))
       wcog=ecog-er
     endif
     write(70,'(2x,i5,7(3x,e12.5),3x,i8,2x,e12.5)') &
      ncell,zl,tlgth,phdep,phmil,phfin,wref,wcog,ngood,davtot/100.0D0
!     write(70,9999)ncell,zl,tlgth,phdep,phmil,phfin, &
!                   wref,wcog,ngood,davtot/100.0D0
! 9999    format(2x,i5,7(3x,e12.5),3x,i8,2x,e12.5)                  
     br0=rfq7(ncell)*rfq7(ncell)
     bff=(1.D0/er)*wavel*wavel*tdvolt/br0
     write(75,'(3x,i5,5(3x,e12.5))')ncell,rfq1(ncell),rfq2(ncell), &
     rfq6(ncell),rfq7(ncell),rfq8(ncell)
!et2010s
! dphete,dav1(idav,16),dav1(idav,21) and dav1(idav,12) still to be assigned correct value
     dphete=0.D0
     trfprt=fh*tref*180.D0/pi
     tcgprt=fh*tcog*180.D0/pi
!         n2kp=int(tofprt/360.)
!         tofprt=tofprt-DBLE(n2kp)*360.D0
!         if(tofprt.gt.180.) tofprt=tofprt-360.
! cavity number, transmission (%), synchronous phase (deg), time of flight (deg) (reference),
! COG relativistic beta (@ output), COG output energy (MeV), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
     trnsms=100.D0*DBLE(ngood)/DBLE(imax)
     call cdg(1)
     encog=cog(1)
     gcog=encog/xmat
     bcog=sqrt(1.D0-1.D0/(gcog*gcog))
     tcog=cog(3)
     CALL EXT2D(1)
     SURXTH=SQRT(exten(4)*exten(5)-exten(8)**2)
     SURYPH=SQRT(exten(6)*exten(7)-exten(9)**2)
     sqmdv=sqrt(exten(1)*exten(3)-exten(2)*exten(2))
     exns=bcog*surxth*10.D0/sqrt(1.D0-bcog*bcog)
     eyns=bcog*suryph*10.D0/sqrt(1.D0-bcog*bcog)
     emns=sqmdv*1.D12/fh
     if(ncell.eq.1) then
       write(50,'(A)') '# rfqparm.dmp'
       write(50,'(A,A,A,A,A)') &
       '#  cell    Z       trans   ', &
       'PHIs     TOF(COG)      COG      Wcog          TOF(REF)   ', &
       '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ', &
       'El,RMS        dWref        EffVolt      ElementName      ', &
       '          amplitude'    
       write(50,'(A,A,A,A,A)') &
       '#   #     (m)       (%)    ', &
       '(deg)     (deg)        beta     (MeV)          (deg)      ', &
       '   beta        (MeV)      (mm.mrad)    (mm.mrad)    ', &
       '(ns.keV)      (MeV)          (MV)                         ',&
       '         cell FVOLT'            
     endif
     rfqphas=rfqdmp(ncell,2)
     if(itype(ncell).eq.4 .or. itype(ncell).eq.7) rfqphas=rfqdmp(ncell,2)-180.0D0
     write(50,'(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)') &
      ncell,rfqdmp(ncell,1),trnsms,rfqphas,tcgprt,bcog,wcog,trfprt,bref,wref, &
      exns,eyns,emns,rfqdmp(ncell,3),rfqdmp(ncell,4),trim(uden),rfq9(ncell)
!      write(50,7023) ncell,rfqdmp(ncell,1),trnsms, &
!      rfqphas,tcgprt,bcog,wcog,trfprt,bref,wref, &
!      exns,eyns,emns,rfqdmp(ncell,3),rfqdmp(ncell,4),trim(uden),rfq9(ncell)
! 7023    format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x, &
!         2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)
     if(ncell.eq.nceltot) then
       write(16,'(/,A,/,5x,A)') ' Dynamics at the output', &
        '   BETA     GAMMA      ENERGY(MeV)        TOF(deg)     TOF(sec)'
       write(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' COG ', &
        bcog,gcog,wcog,tcog*fh*180.D0/pi,tcog
       write(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' REF ', &
        bref,gref,wref,tref*fh*180.D0/pi,tref
       if(itvol) write(16,*) '  time of flight: ', &
                 ttvols*fh*180.D0/pi,' deg'
!----  new magnetic rigidity of the reference
       xmor=xmat*bref*gref
       boro=33.356D0*xmor*1.D-01/qst
       dav1(idav,4)=davtot*10.D0
       dav1(idav,5)=xlrfq*10.D0
       dav1(idav,6)=(gref-1.D0)*er
       dav1(idav,36)=DBLE(ngood)
       irfqp=.false.
     endif
!   plots
     PRLAB(IPRF)='RFQPTQ  '
     ELNAM(IPRF)=trim(uden)
     CALL STAPL(davtot*10.D0)
!
! write particle distribution to file if selected with WRBEAM for end of cell
!
     if(rfqiflg.gt.0  .and. (.not.rfqmidcell .or. rfqmaecell)) then
       fromrfq=.true.
! check if file already open
       if(ISTAT.eq.0) then
         istat=1
         open(57,file=rfqwfil,status='unknown')
       endif
       if(rfqiflg.gt.nceltot) then
! print behind every cell
!
!title line
         if(iflgr.eq.100) then
           write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)'
         elseif(iflgr.eq.101) then
           write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  particle#'
         elseif(iflgr.eq.102) then
           write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  charge'
         elseif(iflgr.eq.103) then
           write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  charge    ', &
                     'particle#'
         else
           write(57,*) 'end cell ',ncell
         endif
         irec=rfqirec
         call prbeam(iflgr,rfqwfil,fromrfq)
         write(57,*) 
         write(57,*)                  
       elseif(rfqiflg.eq.ncell) then
! print behind the single cell indicated
         if(iflgr.eq.100) then
           write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)'
         elseif(iflgr.eq.101) then
           write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  particle#'
         elseif(iflgr.eq.102) then
           write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  charge'
         elseif(iflgr.eq.103) then
           write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                     'yp(rad) phi(rad) W(MeV)  charge    ', &
                     'particle#'
         else
           write(57,*) 'end cell ',ncell
         endif
         irec=rfqirec
         call prbeam(iflgr,rfqwfil,fromrfq)
         close(57)
       endif
     elseif(rfqiflg.lt.0  .and. (.not.rfqmidcell .or. rfqmaecell)) then
!  print behind the cells in the list
       fromrfq=.true.
! check if file already open
       if(ISTAT.eq.0) then
         istat=1
         open(57,file=rfqwfil,status='unknown')
       endif
       if(nrwcc.le.nrwc) then
         if(iwcl(nrwcc).eq.ncell) then
! print behind the cell indicated
           if(iflgr.eq.100) then
             write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)'
           elseif(iflgr.eq.101) then
             write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)  particle#'
           elseif(iflgr.eq.102) then
             write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)  charge'
           elseif(iflgr.eq.103) then
             write(57,*) 'end cell ',ncell,' x(cm) xp(rad) y(cm) ', &
                         'yp(rad) phi(rad) W(MeV)  charge    ', &
                         'particle#'
           else
             write(57,*) 'end cell ',ncell
           endif
           irec=rfqirec
           call prbeam(iflgr,rfqwfil,fromrfq)
           write(57,*) 
           write(57,*)                  
           nrwcc=nrwcc+1
         endif
       else
         close(57)
       endif
     endif
     if(chasit) call emiprt(0)
! --- end do ncell
   enddo
   if(rfqiflg.gt.nceltot) close(57)
   call emiprt(0)
   ifcont=.false.
   WRITE(16,*) 'After RFQ, bunched beam assumed'
!      close the file that contains the rfq profile that was written
   if(.not. mcselect) close(98)       
END SUBROUTINE rfq_parm
!> *******************************************************************
!! SUBROUTINE etgap
!! single cell of a DTL (CAVSC)
!!
!!   etcell(1)=cell#, etcell(2)=energy (MeV), etcell(3)=beta
!!   etcell(4)=cell length (cm), etcell(5)=T, etcell(6)=TP,
!!   etcell (7)=S, etcell(8)=SP
!!   etcell(9)=quad length (cm), etcell (10)=quad. strength (kG/cm),
!!   etcell(11)=Eo (MV/m), etcell(12)= phase of RF at middle(deg),
!!   etcell(13)= actual length(cm), etcell(14)=TPP,
!!   etcell(15)=frequency (MHz), etcell(16)=field factor
!< *******************************************************************
SUBROUTINE etgap 
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4cavs2
   USE m4cavsc
   USE m4gapiter, ONLY: XKM
   USE m4gap2
   USE m4gap3
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE fun4cavscmc
   USE m4gaprestay
   USE m4RESTAYfun, ONLY: YLG
   USE m4restayMIDGAP
   USE m4FENE
   USE m4ITVOLE
   USE m4ble, ONLY: cr
   IMPLICIT NONE
   REAL(8) FAKT
   REAL(8) aqst,bcog,BEMY,BEREF,BETS,CFH,CKH,coeph,cor12,ddw,DELPHR,DELWRM,DHX,DKG
   REAL(8) dphase,dphete,DTS,ecog,emns,encog,dltaw,enold
   REAL(8) ENREF,ENREFS,ENRS,epsil,F0,F2,FACT,FH0,FPK,FPK0,FPK1,HX,PENT12,PENT21
   REAL(8) gamref,gams,gcog,gref,PHARED,PHARES,QDIANP,QDIANT,QDITAX,QDITAY,QDPDE
   REAL(8) qdisp,qdp,qmd,saphi,tcgprt,tcog,tcogdg,tofprt,tre0tl,trefs,trfprt,trnsms
   REAL(8) trphase,ttvol
   REAL(8) SAPHO,SCLEN,SQMDV,SURM,SURXTH,SURYPH,T0,TP0,TPP0,TRQPY,TRQTX,XK1,XK2,XKG
   REAL(8) XMOR,YE0,FK1,GX
   REAL(8) SK0,SPK0,SP3K0,SP4K0,SPPK0
   REAL(8) TK0,TPK0,TP3K0,TP4K0,TPPK0
   REAL(8) TREDG,TREFDG
   REAL(8) TESTCA,TIL2
   REAL(8) GPX,GPPX
   REAL(8) T3K,T4K,S3K,S4K
   INTEGER IIII,IT,iarg,iet,iprint
!  TRANSIT TIME COEFFICIENTS
!   COMMON/TTFC1/T3K,T4K,S3K,S4K
!   COMMON/RANEC1/DUMMY(6)
!   COMMON/fct/FAKT
!     SHIFT =TRUE: cog and synchronous particle are independent
!     SHIFT =FALSE: cog and synchronous particle are coinciding
   REAL(8) etcell(maxcell)
!*******************************************************************
! --- iesp, irstay, ispcel logical flags used in the routines of space charge computations
!       iesp=false: accelerating element
!       ispcel = .true.: space charge computation
   iesp=.false.
   irstay=.false.
   ispcel=.true.
   ilost=0
   FACT=1.D0
   NDTL=NDTL+1
   nrres=nrres+1
! allow for print out on terminal of gap# on one and the same line
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating gap    :',NDTL,cr
   flush(6)                            
   WRITE(16,*)'ACCELERATING GAP N :',NDTL
   read(IN,*) (etcell(iet),iet=1,16)
   FH=etcell(15)
   FAKT=etcell(16)
   if (abs(FAKT).le.fprec) FAKT=1.D-12
   FH=FH*2.D0*PI*1000000.D0
! --- YLG : CELL LENGTH (cm)
! --- YE0 : ELECTRIC FIELD (MV/cm)
   YLG=etcell(4)
   scdist=ylg
   YE0=etcell(11)/100.D0
!  TRANSIT TIME COEFFICIENTS (at the middle OF THE CELL)
   T0=etcell(5)*YLG*YE0
   TP0=-etcell(6)*YLG*YLG*YE0
   TPP0=-etcell(14)*YLG*YLG*YLG*YE0
!  TRANSIT TIME factors at the ENTRANCE OF THE CELL
!   with kg=2*PI/ylg:
!     TK0=T0*COS(kg*ylg/2) = -T0
!     SK0=T0*SIN(kg*ylg/2) = 0
!     TPK0=d(TK0)/dk
!     SPK0=d(SK0)/dk
!     TPPK0=d(TPK0)/dk
!     SPPK0=d(SPK0)/dk
   TK0=-T0
   SK0=0.D0
   TPK0=-TP0
   SPK0=-YLG*T0/2.D0
   TPPK0=YLG*YLG*T0/4.D0-TPP0
   SPPK0=-YLG*TP0/2.D0
   TK=TK0
   T1K=TPK0
   T2K=TPPK0
   SK=SK0
   S1K=SPK0
   S2K=SPPK0
   TP3K0=0.D0
   TP4K0=0.D0
   SP3K0=0.D0
   SP4K0=0.D0
!  MULTIPLY TRANSIT TIME factors WITH FAKT
   T0=T0*FAKT
   TP0=TP0*FAKT
   TPP0=TPP0*FAKT
   TK0=-T0
   TPK0=-TP0
   SPK0=-YLG*T0/2.D0
   TPPK0=YLG*YLG*T0/4.D0-TPP0
   SPPK0=-YLG*TP0/2.D0
   TK=TK0
   T1K=TPK0
   T2K=TPPK0
   SK=SK0
   S1K=SPK0
   S2K=SPPK0
!       IPOINR=IPOINR+1
!   print in file: 'short.data'
! --- ylg : CELL LENGTH (cm) ==> (mm)
! --- ye0 : ELECTRIC FIELD (MV/cm) ==> (Kv/mm)
! --- davtot (mm)
   idav=idav+1
   iitem(idav)=17
   dav1(idav,1)=ylg*10.D0
   dav1(idav,2)=ye0*100.D0
   tstp=(davtot+ylg*xpsc)*10.D0
   davtot=davtot+ylg
   dav1(idav,24)=davtot*10.D0
! 21.11.09       dav1(idav,40)=fh
   FH0=FH/VL
!  STATISTICS FOR PLOT
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(dav1(idav,24))
   endif
!  reference particle
   iarg=1
   call cdg(iarg)
   ecog=cog(1)
   enold=ecog
   gcog=ecog/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   IF(SHIFT) THEN
!    reference particle and cog are independent
     BEREF=VREF/VL
     GAMREF=1.D0/SQRT(1.D0-(BEREF*BEREF))
     ENREF=XMAT*GAMREF
     TREFDG=TREF*fh*180.D0/pi
     tcogdg=tcog*fh*180.D0/pi
     dav1(idav,3)=1.D0
   ELSE
!    reference and c.o.g. are coinciding
     vref=bcog*vl
     tref=tcog
     gamref=gcog
     beref=bcog
     enref=cog(1)
     TREFDG=TREF*fh*180.D0/pi
     tcogdg=tcog*fh*180.D0/pi
     dav1(idav,3)=0.D0
   ENDIF
! --- ttvol: time of flight at entrance (sec)
   ttvol=0.D0
   if(itvol)ttvol=ttvols*fh
! ***** reference is placed in the position ngdrf=ngood+1 in array f(10,i)
! *****         ngdrf=ngood+1
! *****         BEREF=VREF/VL
! *****         GAMREF=1.D0/SQRT(1.D0-(BEREF*BEREF))
! *****         ENREF=XMAT*GAMREF
! ****         f(1,ngdrf)=ngdrf
! ****         f(2,ngdrf)=0.
! ****         f(3,ngdrf)=0.
! ****         f(4,ngdrf)=0.
! ****         f(5,ngdrf)=0.
! ****         f(6,ngdrf)=tref
! ****         f(7,ngdrf)=enref
! ****         f(8,ngdrf)=1.D0
! ****         f(9,ngdrf)=qst
! ****         f(10,ngdrf)=0.
   if(int(dav1(idav,3)).eq.1) write(16,*) ' **** reference and cog are different'
   if(int(dav1(idav,3)).eq.0) write(16,*) ' **** reference and cog coincide '
   WRITE(16,'(/,A,/,5x,A)') ' DYNAMICS AT THE INPUT ', &
    '   BETA     GAMMA      ENERGY(MeV)        TOF(deg)     TOF(sec)'
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' COG ', &
     bcog,gcog,ecog-xmat,tcogdg,tcog
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' REF ', &
     beref,gamref,enref-xmat,TREFDG,TREF
   tofprt=tref
!  iprint=1: full print ( in case of pbmes)
   iprint=0
   call statis
   XK1=FH/VREF
! ---  predictor of the average beta:BEMY.
   BEREF=VREF/VL
   GAMREF = 1.D0/SQRT(1.D0-(BEREF*BEREF))
!  DPHASE : PHASE  AT THE MIDDLE OF THE CELL (rad)
   dphete=etcell(12)
   dphase=etcell(12)*pi/180.D0
! 15/12/09       dpherd=dphase
! 15/12/09       ttvol=0.
! --- The option TOF is passive in the DTL
!   t.o.f. at the middle of the cell
! 15/12/09       if(itvol) then
! 15/12/09        tvolm=ylg/(2.D0*vref)
! 15/12/09        ttvol=(ttvols+tvolm)
! 15/12/09       endif
! 15/12/09 adjust the phase of RF w.r.t. TOF
! 15/12/09       if(itvol.and.imamin) then
! 15/12/09        odphase=dphase
! 15/12/09        ottvol=fh*ttvol*180.D0/pi
! 15/12/09        attvol=ottvol
! 15/12/09        xkpi=ottvol/360.D0
! 15/12/09        ixkpi=int(xkpi)
! 15/12/09        xkpi=(xkpi-DBLE(ixkpi))*360.D0
! 15/12/09        dphase=dphase-xkpi*pi/180.D0
! 15/12/09       endif
   aqst=abs(qst)
   ddw=aqst*t0*cos(dphase)
   ENREFS=ENREF+DDW
   GAMS= ENREFS/XMAT
   BETS=SQRT(1.D0-1.D0/(GAMS*GAMS))
   XK2=FH/(BETS*VL)
   BEMY=(GAMS*BETS+GAMREF*BEREF)/(GAMS+GAMREF)
   XKM=FH/(BEMY*VL)
   XKG=2.D0*PI/YLG
! --- average phase of RF at entrance
   saphi=dphase
   SAPHO=SAPHI
   EQVL=YLG
   DKG=(XKM-XKG)
   DTS=TP0/T0
   FK1=2.D0*DTS
   FPK0=(TP0*TP0+T0*TPP0)/(T0*T0)
   FPK1=2.D0*TP0**2/(T0*T0)
   FPK=2.D0*(FPK0-FPK1)
   PCREST=ATAN(-SK/TK)
   DDW=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))/2.D0
   IF(DDW.lt. 0.D0) PCREST=PCREST+PI
   PEQVL=YLG/2.D0
   SCLEN=YLG
! 15/12/09       if(.not.imamin) then
   WRITE(16,'(4x,A,e12.5,A,/,4x,A,e12.5,A,/,4x,A,e12.5,A,/)') 'FREQUENCY :', &
     FH/(2.D0*pi),' Hertz','GAP LENGTH :',YLG,' cm', &
     'PHASE of RF (middle of the gap)  :',DPHASE*180.D0/pi,'deg'
! 15/12/09       else
! 15/12/09        WRITE(16,1556)FH/(2.D0*pi),YLG,DPHASE*180.D0/pi,odphase
! 15/12/09 1556    FORMAT(4X,'FREQENCY :',E12.5,' Hertz',/,4x,
! 15/12/09     x        'GAP LENGTH :',e12.5,' cm',/,4x,
! 15/12/09     x        'phase of RF after adjustement:',e12.5,'deg',/,4x,
! 15/12/09     *        'phase of RF before adjustment',e12.5,'deg')
! 15/12/09       endif
! ---  Follow ITERATIONS giving:
!            The equivalent field length   (cm)
!            The asociated drift length    (cm)
!            The slip of phase             (rd)
!            The energy gain               (MeV)
!            The phase jump                (rd)
!            The average k                 (cm-1)
!            The transit time coefficients (MeV,cm)
!            The phase crest               (rad)
!            The phase offset at entrance  (rad)
   EQVL=YLG
   DKG=(XKM-XKG)
   FPK=2.D0*(FPK0-FPK1)
   TIL2=0.D0
   DO IT=1,3
!    slip of phase and equivalent field length
     IF(IT.EQ.1) PHSLIP=-4.D0*ATAN(3.2D0*DTS/EQVL)
     IF(abs(PHSLIP).GT.fprec) THEN
       TIL2=PHSLIP/2.D0
       DO IIII=1,4
         GX=1.D0/TAN(TIL2)-1.D0/TIL2
         GPX=-1.D0/(SIN(TIL2)*SIN(TIL2)) + 1.D0/(TIL2*TIL2)
         GPPX=2.D0*COS(TIL2)/(SIN(TIL2)**3) - 2.D0/(TIL2*TIL2*TIL2)
         HX=GPX/(GX*GX) -2.D0*FPK/(FK1**2)
         DHX=-(2.D0*GX*GPX*GPX-GX*GX*GPPX)/(GX**4)
         TIL2=TIL2-HX/DHX
         EQVL=SQRT(ABS(2.D0*FPK/GPX))
         IF(ABS(HX).LE.1.D-5) EXIT
       ENDDO
       PHSLIP=TIL2*2.D0
     ENDIF
     PEQVL=YLG/2.D0
     ASDL=PEQVL-EQVL/2.D0
!  ENERGY GAIN AND PHASE JUMP (i.e. DELPHR)
     saphi=sapho-pcrest+ttvol
     F0=XITL0(GAMREF,GAMS,BEMY,SAPHI,AQST)
     DELWRM=(F0-GAMREF)*XMAT
     ENRS=ENREF+DELWRM
     GAMS= ENRS/XMAT
     bets=sqrt(1.D0-1.D0/(GAMS*GAMS))
     xk2=fh0/bets
     coeph=fh*aqst/(vl*xmat)
!     F2=XITL2(GAMREF,GAMS,BEMY,SAPHI,AQST)
     F2=XITL2(GAMREF,GAMS,SAPHI,AQST)
     DELPHR= COEPH * F2
     XKM=DELPHR/EQVL + XK2*(1.D0+ASDL/EQVL) - XK1*ASDL/EQVL
     BEMY=FH0/XKM
!TRANSIT TIME FACTORS
     DKG=(XKM-XKG)
     TK=TK0+DKG*TPK0+DKG*DKG*TPPK0/2.D0+DKG**3*TP3K0/6.D0+ &
       DKG**4*TP4K0/24.D0
     T1K=TPK0+DKG*TPPK0+DKG*DKG*TP3K0/2.D0+DKG**3*TP4K0/6.D0
     T2K=TPPK0+DKG*TP3K0+DKG*DKG*TP4K0/2.D0
     T3K=TP3K0+DKG*TP4K0
     T4K=TP4K0
     SK=SK0+DKG*SPK0+DKG*DKG*SPPK0/2.D0+DKG**3*SP3K0/6.D0+ &
       DKG**4*SP4K0/24.D0
     S1K=SPK0+DKG*SPPK0+DKG*DKG*SP3K0/2.D0+DKG**3*SP4K0/6.D0
     S2K=SPPK0+DKG*SP3K0+DKG*DKG*SP4K0/2.D0
     S3K=SP3K0+DKG*SP4K0
     S4K=SP4K0
!  PHASE CREST
     PCREST=ATAN(-SK/TK)
     DDW=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))/2.D0
     IF(DDW.lt. 0.D0) PCREST=PCREST+PI
   ENDDO
!  CREST VALUE = SQCTTF*(PHSLIP/2)/SIN(PHSLIP/2)
   SQCTTF=TIL2*SQRT(TK*TK+SK*SK)/SIN(TIL2) *2.D0
!  THE synchronous particle IS BASED ON CHARGE STATE : QMOY =AQST
   CFH=FH/(VL*2.D0*XMAT)
   CKH=QMOY*QMOY/(4.D0*XMAT*XMAT)
   call gap(gamref,saphi,gams,delphr)
!  output of the element
! new PHARES,TREFS to be in accordance with GENAC
   PHARES=SAPHI+FH*YLG/VREF+DELPHR
   trefs=tref+ylg/(bets*vl)+delphr/fh
   PHARED=(PHARES-SAPHI)*180.D0/pi
   TREDG=fh*TREFS *180.D0/pi
   write(16,*) ' PARAMETERS RELATING TO THE REFERENCE PARTICLE '
   write(16,*) '************************************************'
   write(16,*) ' ENERGY GAIN(MeV): ',delwrm,' TOF(DEG) ',tredg
!   write(16,*) ' PHASE JUMP(DEG): ',sphrfs*180.D0/pi
   write(16,*) ' CREST PHASE OF RF (DG): ', &
                 PCREST*180.D0/pi
   write(16,*) ' PHASE OF RF AT THE MIDDLE (DG): ',sapho*180.D0/pi
   write(16,*) ' PHASE OF RF AT THE ENTRANCE (DG): ',saphi*180.D0/pi
   write(16,*) ' AVERAGE k (cm-1) (freq./velocity): ',XKM
   write(16,*) ' TRANSIT TIME FACTORS (MeV-cm):'
   write(16,*) ' T dT/dk d2T/dk2 ',TK,T1K,T2K
   WRITE(16,*) ' S dS/dk d2S/dk2 ',SK,S1K,S2K
   write(16,*) ' PHASE SLIP(DEG) ',PHSLIP*180.D0/pi
   write(16,*)
   write(16,*) ' PARAMETERS RELATING TO THE EQUIVALENT FIELD '
   write(16,*) '************************************************'
   WRITE(16,'(A,e12.5,A)') ' length :',EQVL,' cm '
   write(16,*) ' Associated drift length: ',asdl,' cm'
   WRITE(16,*)' magnitude: ',SQCTTF,' MV/cm'
   iarg=1
   call cdg(iarg)
   encog=cog(1)
   gcog=encog/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   CALL EXT2D(1)
! sup        phnew=-(int(tcog*fh/pi+0.5D0)-tcog*fh/pi)*180.
! sup        dav1(idav,7)=phnew
        dav1(idav,37)=saphi*180.D0/pi
! 15/12/09        if(itvol) then
! 15/12/09        dav1(idav,38)=dphete
! 15/12/09        dav1(idav,39)=dphase*180.D0/pi
! 15/12/09        else
        dav1(idav,38)=dphete
! 15/12/09        endif
!  end print in the file: 'short.data'
   write(16,'(/,3x,A,/,5x,A)') '*** DYNAMICS AT THE OUTPUT: ', &
    '   BETA     dW(MeV)    ENERGY(MeV)    TOF(deg)     TOF(sec)'
   write(16,'(A,f7.5,3x,f10.6,3x,f8.3,3x,e12.5,3x,e12.5)') ' REF ', &
     bets,delwrm,enrs-xmat,fh*trefs*180.D0/pi,trefs
   write(16,'(A,f7.5,3x,f10.6,3x,f8.3,3x,e12.5,3x,e12.5)') ' COG ', &
     bcog,encog-enold,encog-xmat,tcog*fh*180.D0/pi,tcog
! trace3d
! split cell into drif-gap-drift
   kt3t=kt3t+1
   write(tif,'(A,i4,A,i4,A,f12.6)') &
     '  nt(',kt3t,')= 1, a(1,',kt3t,')=',10.D0*etcell(4)/2.D0
   trace3t(kt3t)=tif
!
   trphase=etcell(12)
!   tre0tl=etcell(11)*etcell(5)*etcell(4)/100.D0
   tre0tl=delwrm/cos(pi*trphase/180.D0)
   kt3t=kt3t+1
   write(tif,'(A,i4,A,i4,A,f9.5,A,f9.2,A,f5.3,A)') &
     '  nt(',kt3t,')=10, a(1,',kt3t,')=',tre0tl,' , ',trphase, &
          ', 1., 1.,',fid,','
   trace3t(kt3t)=tif
!
   kt3t=kt3t+1
   write(tif,'(A,i4,A,i4,A,f12.6)') &
     '  nt(',kt3t,')= 1, a(1,',kt3t,')=',10.D0*etcell(4)/2.D0
   trace3t(kt3t)=tif
! end trace3d drift-gap-drift
   TESTCA=exten(1)*exten(2)*exten(3)
   epsil=1.D-40
   IF(abs(TESTCA).gt.epsil) THEN
     qdisp=2.D0*sqrt(exten(1))
     qmd=exten(1)*exten(3)-exten(2)**2
     SQMDV=4.D0*pi*SQRT(QMD)
     SURM=4.D0*pi*SQRT(QMD)*180.D0/pi
     qdp=2.D0*sqrt(exten(3))
     cor12=exten(2)/sqrt(exten(1)*exten(3))
     QDPDE=QDP*180.D0/pi
   ELSE
     QDISP=0.D0
     QMD=0.D0
     SQMDV=0.D0
     SURM=0.D0
     QDP=0.D0
     COR12=0.D0
     PENT12=0.D0
     PENT21=0.D0
     QDPDE=0.D0
   ENDIF
   TRQTX=exten(4)*exten(5)-exten(8)**2
   TRQPY=exten(6)*exten(7)-exten(9)**2
   QDITAX=2.D0*sqrt(exten(4))
   QDIANT=2.D0*sqrt(exten(5))
   QDITAY=2.D0*sqrt(exten(6))
   QDIANP=2.D0*sqrt(exten(7))
   SURXTH=4.D0*pi*SQRT(TRQTX)
   SURYPH=4.D0*pi*SQRT(TRQPY)
   IF(SHIFT) THEN
     vref=bets*vl
     tref=trefs
   ELSE
     vref=bcog*vl
     tref=tcog
   ENDIF
   if(itvol) then
    ttvols=tref
   endif
   call statis
!  PROFIL (plot)
   PRLAB(IPRF)='CAVSC   '
   CALL STAPL(dav1(idav,24))
   dltaw=qdisp*xmat*bcog*bcog/sqrt(1.D0-bcog*bcog)
!   print in the file: 'dynac.dmp':
!   gap number, phase offset(deg), relativistic beta, energy(MeV), horz. emit.(mm*mrd,norm), vert. emit.(mm*mrd,norm),long. emit(keV*sec)
!  dav1(idav,16): Emittance(norm)  x-xp (mm*mrad)
   dav1(idav,16)=bcog*surxth*10.D0/(pi*sqrt(1.D0-bcog*bcog))
!  dav1(idav,21): Emittance(norm)  y-yp (mm*mrad)
   dav1(idav,21)=bcog*suryph*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   dav1(idav,25)=DBLE(ndtl)
   emns=1.D12*sqmdv/(pi*fh)
   trfprt=fh*tref*180.D0/pi
   tcgprt=fh*tcog*180.D0/pi
!       n2kp=int(tofprt/360.)
!       tofprt=tofprt-DBLE(n2kp)*360.D0
!       if(tofprt.gt.180.) tofprt=tofprt-360.
! cavity number, z(m), transmission (%), synchronous phase (deg), time of flight (deg) (cog), COG relativistic beta (@ output)
! COG output energy (MeV), time of flight (deg) (REF), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
   trnsms=100.D0*DBLE(ngood)/DBLE(imax)
   if(ndtl.eq.1) write(50,'(A)') '# gap.dmp'
   if(ndtl.eq.1) write(50,'(A,A,A,A,A)') &
     '#  gap     Z       trans   ', &
     'PHIs     TOF(COG)      COG      Wcog          TOF(REF)   ', &
     '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ', &
     'El,RMS        dWref        EffVolt      ElementName      ', &
     '          amplitude'           
   if(ndtl.eq.1) write(50,'(A,A,A,A,A)') &
    '#   #     (m)       (%)    ', &
    '(deg)     (deg)        beta     (MeV)          (deg)      ', &
    '   beta        (MeV)      (mm.mrad)    (mm.mrad)    ', &
    '(ns.keV)      (MeV)          (MV)                         ',&
    '         ETCELL(16)'        
   write(50,'(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)') &
    ndtl,0.01D0*davtot,trnsms,dphete,tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat, &
    0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),0.25D0*emns,delwrm,tre0tl,trim(uden),ETCELL(16)
!    write(50,7023) ndtl,0.01D0*davtot,trnsms,dphete,tcgprt, &
!    bcog,encog-xmat,trfprt,bets,enrs-xmat, &
!    0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),0.25D0*emns, &
!    delwrm,tre0tl,trim(uden),ETCELL(16)
! 7023    format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x, &
!     2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)
!  RIGIDITY of the ref. prtcle
   gref=1.D0/sqrt(1.D0-bets*bets)
   XMOR=XMAT*bets*gref
   BORO=33.356D0*XMOR*1.D-01/QST
   WRITE(16,*) ilost,' particles are lost in element ',ndtl
   write(16,*)
   call emiprt(0)
END SUBROUTINE etgap
!> *******************************************************************
!! SUBROUTINE gap(GAMREF,SAPHI,GAMS,DELPHR)
!! ETGAP or RESTAY ==> GAP
!! dynamics in the accelerating element
!< *******************************************************************
SUBROUTINE gap(GAMREF,SAPHI,GAMS,DELPHR)
   USE DynacConstants
   USE m_h_t_h1_t1  
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4cavs
   USE m4cavsc
   USE m4gap
   USE m4gap2
   USE m4gap3
   USE m4gapiter
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE m4gaprestay
   USE m4RESTAYfun, ONLY: YLG
   USE m4restayMIDGAP
   USE m4FENE
   USE m4prtcls, ONLY: FS
   USE m4ble, ONLY: ialin   
   USE mCOMtranrs
   IMPLICIT NONE
   REAL(8) GAMREF,SAPHI,GAMS,DELPHR
   REAL(8) aqmoy,CXLG,DCUM,DKM1,DKMP,DKMS,dphsph1,FH0,gakst,gapst
   REAL(8) GAMI,VARPHA
   INTEGER ini,ipas,is,istm,js
! ***************************************************************
!     functions in COS(DXDPT)
!   common/iterco/YH11T,YH1K1T,YH1K01T,YH10PKT,YH11PKT,YH1P1T, &
!     functions in SIN(DXDPT)
!   common/itersi/YH21T,YH2K1T,YH2K01T,YH2P1T,YH20PKT,YH21PKT, &
!   common/tranrs/SA11,SA12,SA21,SA22,SACT11,SACT12,SACT21,SACT22
! --- routine XTYPL1
!   COMMON/TYPL1/YH1K0,YH1K1,YP1K1,YP1K2,YH1K00,YH1K01,YP1K01, &
!   COMMON/TYPL2/YH2K0,YH2K1,YP2K1,YP2K2,YH2K00,YH2K01,YP2K01, &
!   COMMON/TYPI1/YE1K0,YE1K1,YE1K2,YE1KC0,YE1KC1,YE1KC2, &
!   COMMON/TYPI2/YE2K0,YE2K1,YE2K2,YE2KC0,YE2KC1,YE2KC2, &
!   COMMON/THAD2/H0AKI,H0AKIM,H0AKM,H0BKI,H0BKIM,H0BKM, &
! --- routine XTYPLP1
!   COMMON/TYPLP1/YH1P1,YH2P1,HAPI,HBPI
! --- routine XTYPL2
!   COMMON/TYPLP2/HAPPI,HBPPI
! --- routine XTYLPK
!   COMMON/TYPLPK/YH10PK,YH11PK,YH20PK,YH21PK
!     Integrals of E(z)**2
! --- routine XTYPJ
!   COMMON/TYPJ/YFSK0,YFSK1,YFSK2,YFSP0,YFSP1,YFSP2, &
! --- routine XTYPM
!   COMMON/TYPM/YNSK0,YNSK1,YNSK2,YNSP0,YNSP1,YNSP2, &
! ********************************************************************
   character(len=8) :: PRTLAB
!*******************************************************************
   if (.not. allocated(FS)) allocate(FS(7,iptsz))
   FH0=FH/VL
!   iesp is used in s.c. routines : iesp=.false. == > accel. element
   iesp=.false.
   iavp=.true.
   ipas=2
   DCUM=YLG
   PRTLAB='GAP     '
!   random errors in alignment
   if(ialin) call randali
!   Random variation on the phase for each particle
   VARPHA=0.D0
!   INTEGRALS REQUIRED BY THE EXPANSIONS IN LONGITUDINAL MOTION (ALL THE ELEMENT)
!   ( computations of the average k and slip of phase from which are computed deltk delphi,..)
!    *   valero 08/08/07
   aqmoy=abs(qst)
!omment       aqmoy=qst
!    *
   CALL XTYPL1(GAMREF,SAPHI,AQMOY,DCUM)
!  see here equations 88 and 106 of Part. Acc. 1994 vol44 pp215-255
   CXLG=aqmoy/(4.D0*XMAT*EQVL)
   GAMI=GAMREF
   DKMP= (GAMI*GAMI-1.D0)**(1.5D0)*(GAMS*GAMS-1.D0)**(-1.5D0)
   DKMS= DKMP*(1.D0+ASDL/EQVL) &
         +YH1K01*FH0*CXLG/EQVL -ASDL/EQVL
   DKM1= -GAKS*(GAMS*GAMS-1.D0)**(-1.5D0)*FH0*(1.D0+ASDL/EQVL)
!    DKMSKE :(eq.106, see article of Part.Acc.)
   DKMSKE=DKMS/(1.D0-YH1K1*CXLG*FH0/EQVL-DKM1)
   CALL XTYPL2(GAMREF,SAPHI,AQMOY,DCUM)
   CALL XTYPLP1(GAMREF,SAPHI,AQMOY,DCUM)
   CALL XTYLPK(GAMREF,SAPHI,AQMOY,DCUM)
   dphsph1=(yh1p1-yh21)*cxlg*fh0
   DKMSPHI=-FH0*(GAMS*GAMS-1.D0)**(-1.5D0)*GAPS*(1.D0+ASDL/EQVL)+ &
            DPHSPH1/EQVL
!   These integrals are saved
   gakst=gaks
   gapst=gaps
!     functions in COS(DXDPT)
   YH11T=YH11
   YH1K1T=YH1K1
   YH1K01T=YH1K01
   YH10PKT=YH10PK
   YH11PKT=YH11PK
   YH1P1T=YH1P1
   H1AKIT=H1AKI
   H1AKIMT=H1AKIM
   H1AKMT=H1AKM
   HAPIT=HAPI
   HAPPIT=HAPPI
!     functions in SIN(DXDPT)
   YH21T=YH21
   YH2K1T=YH2K1
   YH2K01T=YH2K01
   YH2P1T=YH2P1
   YH20PKT=YH20PK
   YH21PKT=YH21PK
   H1BKIT=H1BKI
   H1BKIMT=H1BKIM
   H1BKMT=H1BKM
   HBPIT=HBPI
   HBPPIT=HBPPI
   if(ichaes.and.ispcel) then
     ipas=1
     write(16,*)'  SPACE CHARGE ACTING ON LENGTH: ',scdist,' CM'
     dcum=ylg*xpsc
     write(16,*)'  POSITION OF S.C. COMPUTATION:  ',dcum,' CM'
!     computation of the integrals in the middle of the cavity
! INTEGRALS  E(z)*(BG)**-3 *z**n   n=0,1
! INTEGRALS  dE(z)/dt*(BG)**-3 *z**n   n=0,1,2
     call xtypl1(gamref,saphi,aqmoy,dcum)
     istm=ist-1
! INTEGRALS ON SECOND DERIVATIVES k HA0(Z) & HB0(Z)
     call xtypl2(gamref,saphi,aqmoy,dcum)
!  1st,2nd,3rd DERIVATIVES ON PHASE,HA0(Z) & HB0(Z)
     call xtyplp1(gamref,saphi,aqmoy,dcum)
!DERIVATIVES  COUPLED ON PHASE, K FUNCTIONS HA0(Z) & HB0(Z)
     call xtylpk(gamref,saphi,aqmoy,dcum)
! TRANSVERSE INTEGRALS  TYPE J & M
     call xtypj(gamref,saphi,aqmoy,dcum)
     call xtypm(gamref,saphi,aqmoy,dcum)
   endif
   DO
     if(ipas.eq.2) then
       dcum=ylg
       gaks=gakst
       gaps=gapst
! --- COS(DXDPT)
       yh11=yh11t
       yh1k1=yh1k1t
       yh1k01=yh1k01t
       yh10pk=yh10pkt
       yh11pk=yh11pkt
       yh1p1=yh1p1t
       h1aki=h1akit
       h1akim=h1akimt
       h1akm=h1akmt
       hapi=hapit
       happi=happit
! ---  SIN(DXDPT)
       yh21=yh21t
       yh2k1=yh2k1t
       yh2k01=yh2k01t
       yh2p1=yh2p1t
       yh20pk=yh20pkt
       yh21pk=yh21pkt
       h1bki=h1bkit
       h1bkim=h1bkimt
       h1bkm=h1bkmt
       hbpi=hbpit
       hbppi=hbppit
       call xtypl1(gamref,saphi,aqmoy,dcum)
! INTEGRALS ON SECOND DERIVATIVES k HA0(Z) & HB0(Z)
       call xtypl2(gamref,saphi,aqmoy,dcum)
!  1st,2nd,3rd DERIVATIVES ON PHASE,HA0(Z) & HB0(Z)
       call xtyplp1(gamref,saphi,aqmoy,dcum)
!DERIVATIVES  COUPLED ON PHASE, K FUNCTIONS HA0(Z) & HB0(Z)
       call xtylpk(gamref,saphi,aqmoy,dcum)
!   TRANSVERSE INTEGRALS  TYPE J & M
       call xtypj(gamref,saphi,aqmoy,dcum)
       call xtypm(gamref,saphi,aqmoy,dcum)
     endif
     SA11=1.D0
     SA12=0.D0
     SA21=0.D0
     SA22=1.D0
     SACT11=1.D0
     SACT12=0.D0
     SACT21=0.D0
     SACT22=1.D0
!SAVE BEAM
     do is=1,ngood
       do js=1,7
         fs(js,is)=f(js,is)
       enddo
     enddo
     call boucle(ipas,gamref,saphi,dcum,delphr)
!  Reshuffles f(i,j) array after boucle
     call shuffle
     IF(IPAS.EQ.1) THEN
!   compute the space charge on the beam (except the reference)
!  call stapl at the position of space charge computation
       if(iscsp.eq.1) then
         ini=1
         call hersc(ini)
         ini=2
         call hersc(ini)
       endif
       if(iscsp.eq.2) CALL SCHERMI
       if(iscsp.eq.3) CALL SCHEFF1(1)
! -----  window control
       write(16,*) 'Checking for lost particles'
       call reject(ilost,PRTLAB)
!    second step of the gap
       ipas=2
       iavp=.false.
     ELSE
!  end of space charge computation
       exit
     ENDIF
   ENDDO
!       charateristics of the beam
! 18/03/2009       if (dave) then
! 18/03/2009         gimax=f(7,ngood)/xmat
! 18/03/2009         bimax=sqrt(1.D0-1./(gimax*gimax))
! 18/03/2009         dav1(idav,3)=bimax
! 18/03/2009         dav1(idav,4)=f(7,ngood)-xmat
! 18/03/2009         dav1(idav,5)=-(INT(f(6,ngood)*FH/PI+0.5D0)-
! 18/03/2009     *                f(6,ngood)*FH/PI)*180.
! 18/03/2009         dav1(idav,38)=dphase*180.D0/pi
! 18/03/2009       endif
! ----       WINDOW CONTROL
   call reject(ilost,PRTLAB)
END SUBROUTINE gap
!> *******************************************************************
!! SUBROUTINE restay
!! motion of particles in a cavity
!! the field can be read from disk in the form (z,E(z)) or it can be
!! listed in the form of a Fourier series expansion
!< *******************************************************************
SUBROUTINE restay
   USE DynacConstants
   USE m4cavsc
   USE m4beam
   USE m4cavs
   USE m4cavs2
   USE m4gapiter, ONLY: DPHII,XKM
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE fun4restay
   USE fun4cavscmc
   USE m4gaprestay
   USE m4gap2
   USE m4gap3
   USE m4RESTAYfun
   USE m4RESTAY, ONLY: flength,fhc,att,ncell
   USE m4restayMIDGAP
   USE m4FENE
   USE m4ITVOLE
   USE m4wforsc, ONLY: DWP
   USE m4ble, ONLY: cr
   USE mCOMttfcb
   IMPLICIT NONE
   REAL(8) aqst,attvol,bcog,bets,bemy,CFH,CKH,COEPH,COR12
   REAL(8) DCEMD,DDW,DDWC,DELPHR,DELWRM,dphase,dphete
   REAL(8) DTS,BEREF,emns,encog,engain,ENREF
   REAL(8) enold,ENREFS,ENRPRIN,enrs,epsil,EQVLP,F0,F2,F3,ffield,fh0,FK1
   REAL(8) GAMREF,gams,gcog,gref,GX,HX,GPX,oldfh,ottvol,PENT12,PENT21
   REAL(8) PHARED,PHARES,QDIANP,QDIANT,QDISP,QDITAX,QDITAY,QDP,QDPDE,QMD,SQMDV,SURM
   REAL(8) SURXTH,SURYPH,SAPHI,SAPHO,savph,SK0,SPK0,SP3K0,SP4K0,SPPK0,t0s,tcgprt,tcog
   REAL(8) TESTCA,TIL2,TK0,TP3K0,TP4K0,TPK0,TPPK0,TREDG,TREFDG,TREFS,trfprt,trnsms
   REAL(8) TRQPY,TRQTX,ttvol,xesln,tofprt,XK1,XK2,xkpi,xmor,xpos,ye0
   REAL(8) pfield,davtotin,mydum
   INTEGER i,iarg,idum,iiii
   INTEGER IMEDI,iprint,isec,IT,ixkpi
   LOGICAL fromrfq
   character(len=256) :: wfile,cvprt
!*******************************************************************
   if (.not. allocated(DWP)) allocate(DWP(iptsz))
!    XESLN : NEGATIVE LENGTH OF THE DRIFT FOLLOWING THE GAP
!    IF XESLN N.E.0 THEN THE CHARGE SPACE EFFECT IMPLIES THE
!    LENGTH (YLG-XESLN)
   NRRES=NRRES+1
   ncavmc=ncavmc+1
! allow for print out on terminal of gap# on one and the same line
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
   WRITE(16,*)' CAVITY N :',NRRES
   write(16,*)' CAVITY NAME : ',UDEN
! set up stuff for cavdat.out   
   if(ncavmc.eq.1) then
     write(13,'(A,2x,A,2x,A,1x,A,4x,A,7x,A,6x,A,6x,A,6x,A,2x,A,3x,A,4x,A,4x,A,5x,A,5x,A,5x,A,5x,A,4x,A)') &
      '#','ncav','ncell','Zin,acc(cm)','Zin(cm)','Zmid(cm)','Zavg(cm)','Zout(cm)','L cell(cm)',&
      'Wref,out(MeV)','dWref(MeV)','Ph RF(dg)','TOFref(dg)','E0TL(MeV)',' Tk(MeV) ',' Sk(MeV) ', &
      'PHASE(dg)','Ph crest(dg)'
   endif
   davtotin=davtot   
! check if a .dst file is requested at the input
   if (nodflocs.gt.0) then
     do i=1,nodflocs  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then          
         if(idflio(i).eq.1 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_in.dst'
! check if intended to run on multiple cores             
!               if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at input of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif       
   ilost=0
   aqst=abs(qst)
   qmoy=aqst
! --- the frequency fh may be changed with delfh
   oldfh=fh
!        IDUM : dummy variable (indicate in input file the number of the cavity)
   READ (IN,*) IDUM
!
! --- XESLN (cm): difference between the length of the field YLG and the physical length of the cavity
!      (The space charge is acting on the length (YLG-XESLN) )
!      dphase (deg): phase offset from the phase crest (giving the maximum of energy gain)
!      FFIELD : in percent;
!                    (electric field)=(initial electric field)*(1.D0+FFIELD/100)
!         isec: flag
!           isec = 0 : The crest phase (or the valley) is adjusted at the entrance of the accelerating element
!           isec = 1 : The crest phase (or the valley)is adjusted at the middle of the accelerating element
!
!           idum is for compatability with CAVNUM
   read (in,*) xesln,dphase,ffield,isec,idum
   pfield=ffield       
   ffield=1.D0+ffield/100.D0
   if(abs(ffield).le.fprec) ffield=1.D-12
   if(ifield) then
! --- The field is read from the disk in file 'field.txt' in the form:
!          z   (cm)   E(z) MV/cm
!     fhc: frequency of the cavity (Hertz) (read in the file 'field.txt')
     fh=fhc*2.D0*pi
     ncel=ncell
     atte=att
     ye0=atte
!    flength : length of the field (cm)
     ylg=flength
     SCDIST=YLG-ABS(XESLN)
   else
! --- The field is read in the input list in the form of a Fourier series
     oldfh=fh
!     atte: factor acting on the amplitude of the field (read in the input list)
     ye0=atte
     SCDIST=YLG-ABS(XESLN)
   endif
   dphete=dphase
   if(itvol.and.imamin) then
! ---  adjustment of the phase offset w.r.t. the t.o.f.  (deg)
     ottvol=fh*ttvols*180.D0/pi
     attvol=ottvol
     xkpi=ottvol/360.D0
     ixkpi=int(xkpi)
     xkpi=(xkpi-DBLE(ixkpi))*360.D0
     dphase=dphase-xkpi
   endif
! --- iesp, irstay and ispcel: logical flags for space charge computations
   iesp=.false.
   irstay=.true.
   ispcel=.true.
! ---  dwp(*): array reserved to space charge computations
   do i=1,iptsz
     dwp(i)=0.D0
   enddo
   WRITE(16,'(4x,A,e12.5,A,/,4x,A,e12.5,A,/,4x,A,e12.5,/,4x,A,f12.6)') &
     'FREQUENCY :',FH/(2.D0*pi),' Hertz','FIELD LENGTH :',YLG,' cm', &
     'FIELD FACTOR (UNITS CONVERSION) :',ATTE, &
     'FIELD FACTOR (ATTENUATION)      :',ffield
   WRITE(16,'(4x,A,i4,A)') 'FIELD DIVIDED IN: ',NCEL,' SECTIONS '
   if(imamin) then
     write(16,'(4x,A,e12.5,A,/,4x,A,e12.5,A,/,4x,A,e12.5,A)') &
       'PHASE OFFSET (before adjustment): ',dphete,' deg', &
       'PHASE OFFSET (after  adjustment): ',DPHASE,' deg', &
       'ADJUSTMENT ON THE PHASE OFFSET: ',xkpi,' deg'
   else       
     write(16,*) '   PHASE OFFSET: ',dphete,' DEG'
   endif  
   BEREF=VREF/VL
   fh0=fh/vl
! --- prediction of transit time factors TK and SK based on the velocity at the entrance
   TK=TTA0(BEREF)/2.D0 * FFIELD
   SK=TSB0(BEREF)/2.D0 * FFIELD
! --- prediction of PCREST (phase of RF giving the maximum of energy gain in the cavity)
   PCREST=ATAN(-SK/TK)
   DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
   IF(DDWC.lt. 0.D0) PCREST=PCREST+PI
! --- ttvol: time of flight at entrance (sec)
   ttvol=0.D0
   if(itvol)ttvol=ttvols*fh
!  start file 'short.data'
! --- dav1(idav,3)=0: the particle reference and the cog coincide at the input
! --- dav1(idav,3)=1: the particle reference and the cog are independent
   dav1(idav,3)=beref
   idav=idav+1
   iitem(idav)=1
   dav1(idav,1)=ylg*10.D0
   dav1(idav,2)=ye0*100.D0
   tstp=(davtot+ylg*xpsc)*10.D0
   davtot=davtot+ylg
   dav1(idav,24)=davtot*10.D0
   dav1(idav,40)=fh
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(dav1(idav,24))
   endif
   iarg=1
   call cdg(iarg)
   enold=cog(1)
   encog=enold
   gcog=enold/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   IF(SHIFT) THEN
! --- the reference particle and the cog are independent
     BEREF=VREF/VL
     GAMREF=1.D0/SQRT(1.D0-(BEREF*BEREF))
     ENREF=XMAT*GAMREF
     TREFDG=TREF*fh*180.D0/pi
     dav1(idav,3)=1.D0
   ELSE
! --- the reference particle and the cog are coinciding
     beref=bcog
     vref=bcog*vl
     tref=tcog
     gamref=gcog
     enref=cog(1)
     dav1(idav,3)=0.D0
   ENDIF
! ---   the reference particle is put in the array f(10,iptsz) at the position ngdrf = ngood + 1
! ****         ngdrf=ngood+1
! ****         BEREF=VREF/VL
! ****         GAMREF=1.D0/SQRT(1.D0-(BEREF*BEREF))
! ****         ENREF=XMAT*GAMREF
! ****         f(1,ngdrf)=ngdrf
! ****         f(2,ngdrf)=0.
! ****         f(3,ngdrf)=0.
! ****         f(4,ngdrf)=0.
! ****         f(5,ngdrf)=0.
! ****         f(6,ngdrf)=tref
! ****         f(7,ngdrf)=enref
! ****         f(8,ngdrf)=1.
! ****         f(9,ngdrf)=qst
! ****         f(10,ngdrf)=0.
   if(int(dav1(idav,3)).eq.1)write(16,*)' ****reference and cog evolve independently'
   if(int(dav1(idav,3)).eq.0)write(16,*)' **** the reference is the cog '
   WRITE(16,'(/,A,/,5x,A)') ' Dynamics at the input', &
     '   BETA     GAMMA      ENERGY(MeV)        TOF(deg)     TOF(sec)'
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' COG ', &
     bcog,gcog,encog-xmat,tcog*fh*180.D0/pi,tcog
   ENRPRIN=ENREF-XMAT
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') ' REF ', &
     beref,gamref,ENRPRIN,tref*fh*180.D0/pi,tref
   tofprt=tref
   iprint=0
   call statis
   XK1=FH/VREF
! --- prediction of transit time factors based on an average value of velocity
   DDW=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
   ENREFS=ENREF+DDW
   GAMS= ENREFS/XMAT
   BETS=SQRT(1.D0-1.D0/(GAMS*GAMS))
   BEMY=(GAMS+GAMREF)/(GAMS*BETS+GAMREF*BEREF)
   BEMY=1.D0/BEMY
   TK0=TTA0(BEMY)/2.D0  * FFIELD
   TPK0=TTA1(BEMY)/2.D0 * FFIELD
   TPPK0=TTA2(BEMY)/2.D0* FFIELD
   TP3K0=TTA3(BEMY)/2.D0* FFIELD
   TP4K0=TTA4(BEMY)/2.D0* FFIELD
   SK0=TSB0(BEMY)/2.D0  * FFIELD
   SPK0=TSB1(BEMY)/2.D0 * FFIELD
   SPPK0=TSB2(BEMY)/2.D0* FFIELD
   SP3K0=TSB3(BEMY)/2.D0* FFIELD
   SP4K0=TSB4(BEMY)/2.D0* FFIELD
   TK=TK0
   T1K=TPK0
   T2K=TPPK0
   T3K=TP3K0
   T4K=TP4K0
   SK=SK0
   S1K=SPK0
   S2K=SPPK0
   S3K=SP3K0
   S4K=SP4K0
! ----  prediction of PCREST (crest phase) based on the actual coefficients factors T and S
   PCREST=ATAN(-SK0/TK0)
   DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
   IF(DDWC.lt. 0.D0) PCREST=PCREST+PI
! --- the routine crest is computing the equivalent field lenght: EQVL
   call crest(bemy,eqvl,xpos,sqcttf,ffield)
! ---  follow computations of the parameters:
!            equivalent field length   (cm)
!            asociated drift length    (cm)
!            slip of phase             (rad)
!            energy gain               (MeV)
!            phase jump                (rad)
!            average k (=frequency/velocity) (cm-1)
!            transit time coefficients (MeV,cm)
!            crest phase               (rd)
!            phase of RF at entrance   (rd)
   SAPHI=PCREST
! --- start iterations: improve the average velocity and the transit time factors
   DO IT=1,3
     DTS=(TK*T1K+SK*S1K)/(TK*TK+SK*SK)
     FK1=2.D0*DTS
     EQVLP=EQVL
! --- computation of the phase slip: PHSLIP
     PHSLIP=-4.D0*ATAN(3.2D0*DTS/EQVL)
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       TIL2=PHSLIP/2.D0
       do iiii=1,4
         GX=1.D0/TAN(TIL2)-1.D0/TIL2-FK1/EQVLP
         GPX=-1.D0/(SIN(TIL2)*SIN(TIL2)) + 1.D0/(TIL2*TIL2)
         TIL2=TIL2-GX/GPX
         HX=1.D0/TAN(TIL2)-1.D0/TIL2
         EQVLP=FK1/HX
       enddo
       PHSLIP=TIL2*2.D0
     ENDIF
     PEQVL=XPOS
     ASDL=PEQVL-EQVL/2.D0
     F0=XITL0(GAMREF,GAMS,BEMY,SAPHI,AQST)
     DELWRM=(F0-GAMREF)*XMAT
     enrs=enref+delwrm
     gams=enrs/xmat
     bets=sqrt(1.D0-1.D0/(GAMS*GAMS))
! ---  computation of the jump of phase:DELPHR
     COEPH =FH*AQST/(VL*XMAT)
     F3=XITL3(GAMREF,GAMS,BEMY,IT,SAPHI,AQST)
     DELPHR= COEPH * F3
     XK2=FH0/BETS
     XKM=DELPHR/EQVL + XK2*(1.D0+ASDL/EQVL) - XK1*ASDL/EQVL
     BEMY=FH0/XKM
! --- computations of transit time factors
     TK=TTA0(BEMY)/2.D0  * FFIELD
     T1K=TTA1(BEMY)/2.D0 * FFIELD
     SK=TSB0(BEMY)/2.D0  * FFIELD
     S1K=TSB1(BEMY)/2.D0 * FFIELD
   ENDDO
! --- crest phase PCREST (after iterations)
   PCREST=ATAN(-SK/TK)
   DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
   IF(DDWC.lt. 0.D0) PCREST=PCREST+PI
   DCEMD=0.D0
! --- isec = 0: the phase offset is given relative to the entrance of the cavity
! --- isec = 1: the phase offset is given relative to the middle of the cavity
! --- (vapmi has been computed in the function XITL3 (in deg) )
   if(isec.ne.0) then
     IMEDI=INT(VAPMI/360.D0+.4D0)
     DCEMD=VAPMI-360.D0*DBLE(IMEDI)
     WRITE(16,'(2X,A,i4,/,2x,A,E12.5,A,E12.5,A,2X,A,e12.5,A,/)') &
      ' AT THE MIDDLE OF THE CAVITY:',NRRES,' *ENERGY :',ENMIL,&
      ' MEV  *PHASE :',VAPMI,' DEG',' *SLIP OF PHASE  :',DCEMD,' deg'
!     WRITE(16,773) NRRES,ENMIL,VAPMI,DCEMD
!  773    FORMAT(2X,' AT THE MIDDLE OF THE CAVITY:',i4,/,2x, &
!  ' *ENERGY :',E12.5,' MEV  *PHASE :',E12.5,' DEG',2X, &
!  ' *SLIP OF PHASE  :',e12.5,' deg',/)
     DCEMD=DCEMD*PI/180.D0
   endif
!  SAPHI: phase of RF w.r.t. the phase offset
   DPHASE=DPHASE*pi/180.D0
   SAPHI=PCREST+DPHASE+TTVOL-DCEMD
   DDW=AQST*(TK0*COS(SAPHI)-SK0*SIN(SAPHI))
   enrs=enref+ddw
   gams=enrs/xmat
! --- start new iterations to improve:
!         transit time factors
!         phase slip
!         jump of phase
!         crest phase
!         phase of RF
!
   SAPHO=SAPHI
   DO IT=1,3
     DTS=(TK*T1K+SK*S1K)/(TK*TK+SK*SK)
     FK1=2.D0*DTS
     EQVLP=EQVL
     PHSLIP=-4.D0*ATAN(3.2D0*DTS/EQVL)
!     IF(PHSLIP.NE.0.) THEN
     IF(abs(PHSLIP).GT.fprec) THEN
       TIL2=PHSLIP/2.D0
       do iiii=1,3
         GX=1.D0/TAN(TIL2)-1.D0/TIL2-FK1/EQVLP
         GPX=-1.D0/(SIN(TIL2)*SIN(TIL2)) + 1.D0/(TIL2*TIL2)
         TIL2=TIL2-GX/GPX
         HX=1.D0/TAN(TIL2)-1.D0/TIL2
         EQVLP=FK1/HX
       enddo
       PHSLIP=TIL2*2.D0
     ENDIF
     PEQVL=XPOS
     ASDL=PEQVL-EQVL/2.D0
! --- ENERGY GAIN AND PHASE JUMP
     F0=XITL0(GAMREF,GAMS,BEMY,SAPHI,AQST)
     DELWRM=(F0-GAMREF)*XMAT
     ENRS=ENREF+DELWRM
     gams=enrs/xmat
     bets=sqrt(1.D0-1.D0/(GAMS*GAMS))
     xk2=fh0/bets
! ---DELPHR: jump of phase
     COEPH =FH*AQST/(VL*XMAT)
     F2=XITL3(GAMREF,GAMS,BEMY,IT,SAPHI,AQST)
     DELPHR= COEPH * F2
! ---XKM:  average k =  frequency/velocity)
     XKM=DELPHR/EQVL + XK2*(1.D0+ASDL/EQVL) - XK1*ASDL/EQVL
     BEMY=FH0/XKM
! ---  TRANSIT TIME FACTORS (based on the velocity BEMY)
     TK=TTA0(BEMY)/2.D0  * FFIELD
     T1K=TTA1(BEMY)/2.D0 * FFIELD
     T2K=TTA2(BEMY)/2.D0 * FFIELD
     T3K=TTA3(BEMY)/2.D0 * FFIELD
     T4K=TTA4(BEMY)/2.D0 * FFIELD
     SK=TSB0(BEMY)/2.D0  * FFIELD
     S1K=TSB1(BEMY)/2.D0 * FFIELD
     S2K=TSB2(BEMY)/2.D0 * FFIELD
     S3K=TSB3(BEMY)/2.D0 * FFIELD
     S4K=TSB4(BEMY)/2.D0 * FFIELD
     PCREST=ATAN(-SK/TK)
     DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
     IF(DDWC.lt. 0.D0) PCREST=PCREST+PI
     DPHII=(XK1-XK2)*EQVL/10.D0+(XKP1+XKP2)/120.D0*EQVL*EQVL &
           + (XK1-XKM)*ASDL
! --- phase of RF
     SAPHI=PCREST+DPHASE+TTVOL-DCEMD+DPHII
   ENDDO
   savph=saphi*180.D0/pi
!  REFERENCE PARTICLE BASED ON CHARGE STATE: QMOY = ABS(QST)
   CFH=FH/(VL*2.D0*XMAT)
   CKH=QMOY*QMOY/(4.D0*XMAT*XMAT)
   DPHII=(XK1-XK2)*EQVL/10.D0+(XKP1+XKP2)/120.D0*EQVL*EQVL &
           + (XK1-XKM)*ASDL
   PHARES=SAPHI+XK2*YLG+DELPHR
   TREFS=TREF+(XK2*YLG+DELPHR)/FH
! ****************************
   PHARED=(PHARES-SAPHI)*180.D0/pi
   TREDG=fh*TREFS *180.D0/pi
! *****  REFERENCE BASED ON THE AVERAGE CHARGE STATE QMOY (if several charges state)
! *****       CFH=FH/(VL*2.D0*XMAT)
! *****       CKH=QMOY*QMOY/(4.D0*XMAT*XMAT)
! *****  save the energy and the T.O.F of the particle reference at the input of the cavity
! *****       enri=f(7,ngdrf)
! *****       trefi=f(6,ngdrf)
! *****       call gap(gamref,saphi,gams,delphr)
! *****  trefs and enrs: time of flight and energy of the reference and the output of the cavity
! *****       trefs=f(6,ngdrf)
! *****       enrs=f(7,ngdrf)
! *****       grefs=f(7,ngdrf)/xmat
! *****       bets=sqrt(grefs*grefs-1.D0)/grefs
! *****       PHARES=SAPHI+XK2*YLG+DELPHR
! *****       TREFS=TREF+(XK2*YLG+DELPHR)/FH
! *****       TREDG=fh*TREFS *180.D0/pi
   write(16,*) ' PARAMETERS RELATING TO THE REFERENCE PARTICLE '
   write(16,*) '***********************************************'
   write(16,*) ' ENERGY GAIN(MeV) ',DELWRM,' TOF ',tredg,' DEG'
   write(16,*) ' PHASE JUMP(DG) ',DELPHR*180.D0/pi
   write(16,*) ' SLIP OF PHASE AT THE INPUT(DG) ',SAPHO*180.D0/pi
   write(16,*) ' PHASE OF RF AT ENTRANCE(DG) ',savph
   write(16,*) ' AVERAGE k (cm-1) (freq./velocity): ',XKM
   write(16,*) ' Associated drift length ',asdl,' (cm)'
   write(16,*) ' Equivalent field length ',eqvl,' cm center at ',xpos,' cm'
   write(16,*) ' TRANSIT TIME FACTORS AND DERIVATIVES (MeV,cm):'
   write(16,*) ' T ',TK,T1K,T2K,T3K,T4K
   WRITE(16,*) ' S ',SK,S1K,S2K,S3K,S4K
   write(16,*) ' PHASE SLIP(DEG) ',PHSLIP*180.D0/pi
   write(16,*) ' CREST PHASE OF RF (DEG) ',PCREST*180.D0/pi
   WRITE(16,*) ' MAGNITUDE ',SQCTTF,' MV/cm'
   t0s=sqrt(tk*tk+sk*sk)
   WRITE(16,*) ' T0 ',T0S
! **********************************************************************
   call gap(gamref,saphi,gams,delphr)
   iarg=1
   call cdg(iarg)
   encog=cog(1)
   gcog=encog/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   CALL EXT2D(1)
   if(itvol) then
    dav1(idav,38)=dphete
    dav1(idav,39)=dphase*180.D0/pi
   else
    dav1(idav,38)=dphete
   endif
   WRITE(16,'(/,A,/,5x,A)') ' Dynamics at the output', &
     '   BETA     dW(MeV)     ENERGY(MeV)    TOF(deg)     TOF(sec)'
   engain=encog-enold
   WRITE(16,'(A,f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)') ' REF ', &
     bets,DELWRM,enrs-xmat,fh*TREFS *180.D0/pi,TREFS
   WRITE(16,'(A,f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)') ' COG ', &
     bcog,engain,encog-xmat,tcog*fh*180.D0/pi,tcog
   TESTCA=exten(1)*exten(2)*exten(3)
!   epsil=1.E-20
   epsil=1.D-40
   IF(abs(TESTCA).gt.epsil) THEN
     QDISP=2.D0*sqrt(exten(1))
     QMD=exten(1)*exten(3)-exten(2)**2
     SQMDV=4.D0*pi*SQRT(QMD)
     SURM=4.D0*pi*SQRT(QMD)*180.D0/pi
     QDP=2.D0*sqrt(exten(3))
     COR12=exten(2)/sqrt(exten(1)*exten(3))
     QDPDE=QDP*180.D0/pi
   ELSE
     QDISP=0.D0
     QMD=0.D0
     SQMDV=0.D0
     SURM=0.D0
     QDP=0.D0
     COR12=0.D0
     PENT12=0.D0
     PENT21=0.D0
     QDPDE=0.D0
   ENDIF
   TRQTX=exten(4)*exten(5)-exten(8)**2
   TRQPY=exten(6)*exten(7)-exten(9)**2
   QDITAX=2.D0*sqrt(exten(4))
   QDIANT=2.D0*sqrt(exten(5))
   QDITAY=2.D0*sqrt(exten(6))
   QDIANP=2.D0*sqrt(exten(7))
   SURXTH=4.D0*pi*SQRT(TRQTX)
   SURYPH=4.D0*pi*SQRT(TRQPY)
   IF(SHIFT) THEN
     vref=bets*vl
     tref=trefs
   ELSE
     vref=bcog*vl
     tref=tcog
   ENDIF
   if(itvol) then
     ttvols=tref
   endif
   call statis
!  ENVEL
   PRLAB(IPRF)='CAVMC   '
   CALL STAPL(dav1(idav,24))
   dav1(idav,16)=bcog*surxth*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   dav1(idav,21)=bcog*suryph*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   dav1(idav,25)=DBLE(nrres)
   dav1(idav,30)=DBLE(ngood)
!
!   print to the file: 'dynac.dmp':
!   gap number, phase offset(deg), relativistic beta, energy(MeV), horz. emit.(mm*mrd,norm), vert. emit.(mm*mrd,norm),long. emit(keV*sec)
!
! --- dav1(idav,16): Emittance(norm)  x-xp (mm*mrad)
! --- dav1(idav,21): Emittance(norm)  y-yp (mm*mrad)
   emns=1.D12*sqmdv/(pi*fh)
   tcgprt=fh*tcog*180.D0/pi
   trfprt=fh*tref*180.D0/pi
! cavity number, z (m), transmission (%), synchronous phase (deg), time of flight (deg) (reference),
! COG relativistic beta (@ output), COG output energy (MeV), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV)
   trnsms=100.D0*DBLE(ngood)/DBLE(imax)
   if(ncavmc.eq.1) write(50,'(A)') '# cavmc.dmp'
   if(ncavmc.eq.1) write(50,'(A,A,A,A,A)') &
     '#  cav     Z       trans   ', &
     'PHIs     TOF(COG)      COG      Wcog          TOF(REF) ', &
     '      REF         Wref       Ex,RMS,n     Ey,RMS,n     ', &
     'El,RMS        dWref        EffVolt      ElementName      ', &
     '        amplitude'           
   if(ncavmc.eq.1) write(50,'(A,A,A,A,A)') &
    '#   #     (m)       (%)    ', &
    '(deg)     (deg)        beta     (MeV)          (deg)    ', &
    '     beta        (MeV)      (mm.mrad)    (mm.mrad)    ', &
    '(ns.keV)      (MeV)          (MV)                         ', &
    '       FFIELD'
   write(50,'(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)') &
    nrres,0.001D0*dav1(idav,24),trnsms,dphete, &
    tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat, &
    0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),0.25D0*emns,delwrm, &
    abs(ddwc)/AQST,trim(uden),pfield
!    write(50,7023) nrres,0.001D0*dav1(idav,24),trnsms,dphete, &
!    tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat, &
!    0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),0.25D0*emns,delwrm, &
!    abs(ddwc)/AQST,trim(uden),pfield
! 7023    format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x, &
!     2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)
   fh=oldfh
!   new magnetic rigidity of the reference
   gref=1.D0/sqrt(1.D0-bets*bets)
   xmor=xmat*bets*gref
   BORO=33.356D0*XMOR*1.D-01/AQST
   WRITE(16,*) ilost,' particles lost in cavity ',nrres

   mydum=0.D0
   iiii=1   
   write(cvprt,'(2(2x,i4),6(2x,e12.5))') NRRES,iiii,davtotin,mydum,YLG/2.D0,YLG/2.D0,YLG,YLG
   write(13,'(A,9(2x,e12.5))') trim(cvprt),enrs-xmat,DELWRM,savph,trfprt,abs(ddwc),TK,SK,dphete,PCREST*180.D0/pi
   
   
   call emiprt(0)
! check if a .dst file is requested at the output
   if (nodflocs.gt.0) then
     do i=1,nodflocs  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then          
         if(idflio(i).eq.2 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_out.dst'
! check if intended to run on multiple cores             
!               if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at output of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif              
END SUBROUTINE restay
!> *******************************************************************
!! SUBROUTINE cavnum
!! numerical computations of the dynamic in cavities or gap
!! the field can be read from the disk on the form: (z,E(z)
!! or it can be read in the command list on the form of a Fourier
!! series expansion
!< *******************************************************************
SUBROUTINE cavnum
   USE DynacConstants
   USE m4cavsc
   USE m4beam
   USE m4trace3d
   USE m4mcs
   USE m4cavs
   USE m4cavs2
   USE m4numcavs, ONLY: fmult,npt
   USE m4gap2, ONLY: ilost
   USE m4input
   USE m4output
   USE m4spacecharge
   USE m4plots
   USE fun4restay
   USE m4RESTAYfun
   USE m4SPLfun
   USE m4RESTAY, ONLY: flength,fhc,att,ncell
   USE m4restayMIDGAP
   USE m4FENE
   USE m4ITVOLE
   USE m4ble, ONLY: cr
   USE mCOMkcell
   USE mCOMstep
   USE mCOMxitrd3
   USE mCOMelec
   USE mCOMxposi
   IMPLICIT NONE
   REAL(8) avbet,bcg,bpai,davtotin,dielec,dwmx,gcg,gpai,phi0
   REAL(8) ffield,tre0tl,trphase,ts,wcg,zcrest
   CHARACTER frmt*128
   INTEGER ielec,i,iarg,klm
   REAL(8) PCREST
   REAL(8) aqst,attvol,bcog,bets,COR12
   REAL(8) DDW,DDWC,dphase,dphete
   REAL(8) BEREF,emns,encog,engain,ENREF
   REAL(8) enold,ENRPRIN,enrs,epsil,fh0
   REAL(8) GAMREF,gams,gcog,gref,oldfh,ottvol,PENT12,PENT21
   REAL(8) QDIANP,QDIANT,QDISP,QDITAX,QDITAY,QDP,QDPDE,QMD,SQMDV,SURM
   REAL(8) SURXTH,SURYPH,tcgprt,tcog
   REAL(8) TESTCA,TREDG,TREFDG,TREFS,trfprt,trnsms
   REAL(8) TRQPY,TRQTX,ttvol,XK1,xkpi,xmor,ye0
   REAL(8) pfield
   INTEGER idum
   INTEGER iprint,ixkpi
   logical fromrfq
   character(len=8) :: PRTLAB
   character(len=256) :: wfile
!*******************************************************************
!    XESLN : NEGATIVE LENGTH OF THE DRIFT FOLLOWING THE GAP
!    IF XESLN N.E.0 THEN THE CHARGE SPACE EFFECT AFFECTS THE
!    LENGTH (YLG-XESLN)
   NRRES=NRRES+1
   ncavnm=ncavnm+1
! allow for print out on terminal of gap# on one and the same line
   frmt="('Transport element:',i5," // &
        "'      Accelerating element:',i5,a1)"
   WRITE(6,frmt,advance='no') NRTRE,NRRES,cr
   flush(6)
   WRITE(16,*)' CAVITY N :',NRRES,' CAVITY NAME : ',UDEN
! check if a .dst file is requested at the input
   if (nodflocs.gt.0) then
     do i=1,nodflocs
!       write(16,*) ' DBX1: ',trim(dflnames(i)),' DBX2: ',trim(adjustl(UDEN))  
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then         
         if(idflio(i).eq.1 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_in.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at input of the element: ',&
                       trim(wfile)
           fromrfq=.false.                           
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif  
   davtotin=davtot
!  statistics
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
   ilost=0
   aqst=abs(qst)
   qmoy=aqst
! --- the frequency fh may be changed with delfh
   oldfh=fh
!        IDUM : dummy variable (indicate in input file the number of the cavity)
   READ (IN,*) IDUM
!
!      ielec = 0 acceleration for non relativistic particles with erest < 1 MeV (e.g. non-relativistic electrons)
!                otherwise acceleration for hadrons
!      dphase (deg): phase offset from the phase crest (giving the maximum of energy gain)
!      FFIELD : in percent;
!                    (electric field)=(initial electric field)*(1.D0+FFIELD/100)
   jelec=.false.
   read (in,*) dielec,dphase,ffield,istep,ielec
   pfield=ffield
! *********************************************************
!  SV  28/10/2015
   if(ncavnm.eq.1) then
     write(13,'(A,2x,A,2x,A,1x,A,4x,A,7x,A,6x,A,6x,A,6x,A,2x,A,3x,A,4x,A,4x,A,5x,A,5x,A,5x,A,5x,A,4x,A)') &
      '#','ncav','ncell','Zin,acc(cm)','Zin(cm)','Zmid(cm)','Zavg(cm)','Zout(cm)','L cell(cm)',&
      'Wref,out(MeV)','dWref(MeV)','Ph RF(dg)','TOFref(dg)','E0TL(MeV)','Tk(MeV/q)','Sk(MeV/q)', &
      'PHASE(dg)','Ph crest(dg)'
!     write(13,990)
!  990     format('#',2x,'ncav',2x,'ncell',1x,'Zin,acc(cm)',4x,'Zin(cm)',7x,'Zmid(cm)',6x, &
!          'Zavg(cm)',6x,'Zout(cm)',6x,'L cell(cm)',2x,'Wref,out(MeV)',3x, &
!          'dWref(MeV)',4x,'TOFref(dg)',4x,'Ph RF(dg)',5x,'E0TL(MeV)',5x, &
!          'Tk(MeV/q)',5x,'Sk(MeV/q)',5x,'PHASE(dg)',4x,'Ph crest(dg)')
   endif
! ***************************************************************
   if(ielec.eq.0) jelec=.true.
   ffield=1.D0+ffield/100.D0
!    if(ffield.eq.0.) ffield=1.D-12
   if(abs(ffield).le.fprec) ffield=1.D-12
   fmult=ffield
   if(ifield) then
! --- The field is read from the disk in the form:
!          z   (cm)   E(z) MV/m
!     fhc: frequency of the cavity (Hertz) (read in the file 'field.txt' )
     fh=fhc*2.D0*pi
     ncel=ncell
     atte=att
     ye0=atte
!    flength : length of the field (cm)
     flength=xspl(npt)-xspl(1)
     ylg=flength
   else
! --- The field is read from the input list in the form of a Fourier series
     ncell=ncel
     oldfh=fh
!     atte: factor acting on the amplitude of the field (read in the input list)
     ye0=atte
   endif
   dphete=dphase
   if(itvol.and.imamin) then
! ---  adjustment of the phase offset w.r.t. the t.o.f.  (deg)
     ottvol=fh*ttvols*180.D0/pi
     attvol=ottvol
     xkpi=ottvol/360.D0
     ixkpi=int(xkpi)
     xkpi=(xkpi-DBLE(ixkpi))*360.D0
     dphase=dphase-xkpi
   endif
   WRITE(16,'(4x,A,E12.5,A,/,4x,A,E12.5,A,/,4x,A,E12.5,/,4x,A,E12.5,A)') &
            'FREQUENCY :',FH/(2.D0*pi),' Hertz', &
            'FIELD LENGTH :',YLG,' cm', &
            'FIELD FACTOR (UNITS CONVERSION) :',ATTE, &
            'FIELD FACTOR (ATTENUATION)      :',ffield
   WRITE(16,'(4x,A,i4,A,i5)') &
            'FIELD DIVIDED IN: ',NCEL,' CELLS,  STEPS PER CELL ',istep
   if(imamin) then
     write(16,'(4x,A,e12.5,A,/,4x,A,e12.5,A,/,4x,A,e12.5,A)') &
       'PHASE OFFSET (before adjustment): ',dphete,' deg', &
       'PHASE OFFSET (after  adjustment): ',DPHASE,' deg', &
       'ADJUSTMENT ON THE PHASE OFFSET: ',xkpi,' deg'
   else
     write(16,*) '   PHASE OFFSET: ',dphete,' DEG'
   endif       
   fh0=fh/vl
   BEREF=VREF/VL
! --- ttvol: time of flight at entrance (sec)
   ttvol=0.D0
   if(itvol)ttvol=ttvols*fh
!  start file 'short.data'
! --- dav1(idav,3)=0: the particle reference and the cog coincide at the input
! --- dav1(idav,3)=1: the particle reference and the cog are independent
   idav=idav+1
   iitem(idav)=1
   dav1(idav,1)=ylg*10.D0
   dav1(idav,2)=ye0*100.D0
   davtot=davtot+ylg
   dav1(idav,24)=davtot*10.D0
   dav1(idav,40)=fh
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(dav1(idav,24))
   endif
   iarg=1
   call cdg(iarg)
   enold=cog(1)
   encog=enold
   gcog=enold/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   IF(SHIFT) THEN
! --- the reference particle and the cog are independent
     BEREF=VREF/VL
     GAMREF=1.D0/SQRT(1.D0-(BEREF*BEREF))
     ENREF=XMAT*GAMREF
     TREFDG=TREF*fh*180.D0/pi
     dav1(idav,3)=1.D0
   ELSE
! --- the reference particle and the cog are coinciding
     beref=bcog
     vref=bcog*vl
     tref=tcog
     gamref=gcog
     enref=cog(1)
     dav1(idav,3)=0.D0
   ENDIF
   if(int(dav1(idav,3)).eq.1) write(16,*) &
     ' ****reference and cog evolve independently'
   if(int(dav1(idav,3)).eq.0) write(16,*) &
     ' **** the reference is the cog '
   WRITE(16,'(/,A,/,5x,A)') ' Dynamics at the input', &
            '   BETA     GAMMA      ENERGY(MeV)        TOF(deg)     TOF(sec)'
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') & 
            ' COG ',bcog,gcog,encog-xmat,tcog*fh*180.D0/pi,tcog
   ENRPRIN=ENREF-XMAT
   WRITE(16,'(A,F7.5,3X,E12.5,1X,E12.5,3X,E12.5,3x,E12.5)') & 
            ' REF ',beref,gamref,ENRPRIN,tref*fh*180.D0/pi,tref
   iprint=0
   call statis
   XK1=FH/VREF
! ---  transit time factors TK and SK  based on the velocity at the entrance
   TK=TTA0(BEREF)/2.D0 * FFIELD
   SK=TSB0(BEREF)/2.D0 * FFIELD
! --- prediction of PCREST (phase of RF giving the maximum of energy gain in the cavity)
   PCREST=ATAN(-SK/TK)
   DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
   IF(DDWC.lt. 0.D0) PCREST=PCREST+PI
! --- first correction of pcrest based on an average beta
   call phcrest(pcrest,ylg,ncell,zcrest)
!    avbet: average value of beta
   avbet=fh/(zcrest*vl)
   tk=tta0(avbet)/2.D0 * ffield
   sk=tsb0(avbet)/2.D0 * ffield
   PCREST=ATAN(-SK/TK)
   DDWC=AQST*(TK*COS(PCREST)-SK*SIN(PCREST))
   IF(DDWC.lt. 0.D0) PCREST=PCREST+PI
!  final correction of the phase crest PCREST
   call phcrest1(pcrest,ylg,ncell,dwmx)
!   phase at the entrance of the cavity
   DPHASE=DPHASE*pi/180.D0
   phi0=pcrest+dphase+ttvol
! --- compute energy and TOF of reference
! ******************************************
   call dwref(phi0,gams,ts,davtotin)
! ********************************************
   enrs=gams*xmat
   ddw=enrs-enref
   if(t3d) then
     do klm=1,ncel
       trphase=tr3ph(klm)
       tre0tl=t0tr3d(klm)/aqst
!c split cell into drif-gap-drift
!c debugging to be done: include q/m !! !! protons assumed for now
       kt3t=kt3t+1
! drift
       write(tif,'(A,i4,A,i4,A,f12.6)') &
                 '  nt(',kt3t,')= 1, a(1,',kt3t,')=',10.D0*fldctr(klm)
       trace3t(kt3t)=tif
!
       kt3t=kt3t+1
! gap
       write(tif,'(A,i4,A,i4,A,f9.5,A,f9.2,A,f5.3,A)') &
        '  nt(',kt3t,')= 1, a(1,',kt3t,')=',tre0tl,' , ',trphase, &
          ', 0., 1.,',fid,','
       trace3t(kt3t)=tif
!
       kt3t=kt3t+1
! drift
       write(tif,'(A,i4,A,i4,A,f12.6)') &
                 '  nt(',kt3t,')= 1, a(1,',kt3t,')=',10.D0*zend(klm)
       trace3t(kt3t)=tif
     enddo
   endif
! end trace3d drift-gap-drift
!
   trefs=ts+tref
   bets=sqrt(gams*gams-1.D0)/gams
!old       bets=b5
   TREDG=fh*TREFS *180.D0/pi
!  dynamic of the bunch
   call bcnum(phi0,ylg,ncell)
! -----  window control
   gcg=0.D0
   do i=1,ngood
     gcg=gcg+f(7,i)/xmat
   enddo
   gcg=gcg/DBLE(ngood)
   bcg=sqrt(1.D0-1.D0/(gcg*gcg))
   wcg=(gcg-1.D0)*xmat
   call cogetc
!omment  twind=0.D0
   do i=1,ngood
     gpai=f(7,i)/xmat
     if(gpai.lt.1.D0) gpai=1.D0
     bpai=sqrt(1.D0-1.D0/(gpai*gpai))
     fd(i)=bpai/bcg * gpai/gcg
!omment    twind=twind+f(6,i)
   enddo
!omment  twind=twind/DBLE(ngood)
! ---- window control
   tref=trefs
   vref=bets*vl
   PRTLAB='CAVNUM  '
   call reject(ilost,PRTLAB)
!  Reshuffles f(i,j) array after window (now done in 'reject')
!         call shuffle
   write(16,*) ' PARAMETERS RELATING TO THE REFERENCE PARTICLE '
   write(16,*) '***********************************************'
   write(16,*) ' ENERGY GAIN(MeV) ',DDW,' TOF ',tredg,' DEG'
   write(16,*) ' PHASE OF RF AT ENTRANCE(DG) ',phi0*180.D0/pi
   write(16,*) ' CREST PHASE OF RF (DEG) ',PCREST*180.D0/pi
   iarg=1
   call cdg(iarg)
   encog=cog(1)
   gcog=encog/xmat
   bcog=sqrt(1.D0-1.D0/(gcog*gcog))
   tcog=cog(3)
   CALL EXT2D(1)
   if(itvol) then
    dav1(idav,38)=dphete
    dav1(idav,39)=dphase*180.D0/pi
   else
    dav1(idav,38)=dphete
   endif
   WRITE(16,'(/,A,/,5x,A)') ' Dynamics at the output', &
     '   BETA     dW(MeV)     ENERGY(MeV)    TOF(deg)     TOF(sec)'
   engain=encog-enold
   WRITE(16,'(A,f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)') &
            ' REF ',bets,ddw,enrs-xmat,fh*TREFS *180.D0/pi,TREFS
   WRITE(16,'(A,f7.5,3x,f10.6,3x,e12.5,3x,e12.5,3x,e12.5)') &
            ' COG ',bcog,engain,encog-xmat,tcog*fh*180.D0/pi,tcog
   TESTCA=exten(1)*exten(2)*exten(3)
!   epsil=1.E-20
   epsil=1.D-40
   IF(abs(TESTCA).gt.epsil) THEN
     QDISP=2.D0*sqrt(exten(1))
     QMD=exten(1)*exten(3)-exten(2)**2
     SQMDV=4.D0*pi*SQRT(QMD)
     SURM=4.D0*pi*SQRT(QMD)*180.D0/pi
     QDP=2.D0*sqrt(exten(3))
     COR12=exten(2)/sqrt(exten(1)*exten(3))
     QDPDE=QDP*180.D0/pi
   ELSE
     QDISP=0.D0
     QMD=0.D0
     SQMDV=0.D0
     SURM=0.D0
     QDP=0.D0
     COR12=0.D0
     PENT12=0.D0
     PENT21=0.D0
     QDPDE=0.D0
   ENDIF
   TRQTX=exten(4)*exten(5)-exten(8)**2
   TRQPY=exten(6)*exten(7)-exten(9)**2
   QDITAX=2.D0*sqrt(exten(4))
   QDIANT=2.D0*sqrt(exten(5))
   QDITAY=2.D0*sqrt(exten(6))
   QDIANP=2.D0*sqrt(exten(7))
   SURXTH=4.D0*pi*SQRT(TRQTX)
   SURYPH=4.D0*pi*SQRT(TRQPY)
   IF(SHIFT) THEN
     vref=bets*vl
     tref=trefs
   ELSE
     vref=bcog*vl
     tref=tcog
   ENDIF
   if(itvol) ttvols=tref
   call statis
!  ENVEL
   PRLAB(IPRF)='CAVNUM  '
   CALL STAPL(dav1(idav,24))
   dav1(idav,16)=bcog*surxth*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   dav1(idav,21)=bcog*suryph*10.D0/(pi*sqrt(1.D0-bcog*bcog))
   dav1(idav,25)=DBLE(nrres)
   dav1(idav,30)=DBLE(ngood)
!
!   print to the file: 'dynac.dmp':
!   gap number, phase offset(deg), relativistic beta, energy(MeV), horz. emit.(mm*mrd,norm), vert. emit.(mm*mrd,norm),long. emit(keV*sec)
!
! --- dav1(idav,16): Emittance(norm)  x-xp (mm*mrad)
! --- dav1(idav,21): Emittance(norm)  y-yp (mm*mrad)
   emns=1.D12*sqmdv/(pi*fh)
   trfprt=fh*tref*180.D0/pi
   tcgprt=fh*tcog*180.D0/pi
! cavity number, z (m), transmission (%), synchronous phase (deg), time of flight (deg) (within -180 deg and 180 deg),
! COG relativistic beta (@ output), COG output energy (MeV), REF relativistic beta (@ output), REF output energy (MeV),
! horizontal emittance (mm.mrad, RMS normalized), vertical emittance (mm.mrad, RMS normalized),
! longitudinal emittance (RMS, ns.keV), energy gain of the reference (MeV), effective voltage (MV), user defined element 
! name, cavity amplitude
   trnsms=100.D0*DBLE(ngood)/DBLE(imax)
   if(ncavnm.eq.1) write(50,'(A)') '# cavnum.dmp'
   if(ncavnm.eq.1) write(50,'(A,A,A,A,A)') &
     '#  cav     Z       trans   ', &
     'PHIs     TOF(COG)    COG        Wcog          TOF(REF)   ', &
     '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ', &
     'El,RMS        dWref        EffVolt      ElementName      ', &
     '        amplitude'         
   if(ncavnm.eq.1) write(50,'(A,A,A,A,A)') &
    '#   #     (m)       (%)    ', &
    '(deg)     (deg)      beta       (MeV)          (deg)      ', &
    '   beta       (MeV)       (mm.mrad)    (mm.mrad)    ', &
    '(ns.keV)      (MeV)          (MV)                         ', &
    '       FFIELD'        
   write(50,'(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)') & 
    nrres,0.001D0*dav1(idav,24),trnsms,dphete, &
    tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat, &
    0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),0.25D0*emns, &
    ddw,dwmx,trim(uden),pfield
!    write(50,7023) nrres,0.001D0*dav1(idav,24),trnsms,dphete, &
!    tcgprt,bcog,encog-xmat,trfprt,bets,enrs-xmat, &
!    0.25D0*dav1(idav,16),0.25D0*dav1(idav,21),0.25D0*emns, &
!    ddw,dwmx,trim(uden),pfield
! 7023    format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x, &
!     2(e14.7,1x,f7.5,1x,e14.7,1x),5(e12.5,1x),A,1x,f9.4)
   fh=oldfh
!   new magnetic rigidity of the reference
   gref=1.D0/sqrt(1.D0-bets*bets)
   xmor=xmat*bets*gref
   BORO=33.356D0*XMOR*1.D-01/AQST
   WRITE(16,*) ilost,' particles lost in cavity ',nrres
   call emiprt(0)
! check if a .dst file is requested at the output
   if (nodflocs.gt.0) then
     do i=1,nodflocs
       if(trim(dflnames(i)).eq.trim(adjustl(UDEN))) then       
         if(idflio(i).eq.2 .or. idflio(i).eq.3) then
           wfile=trim(dflnames(i))//'_out.dst'
! check if intended to run on multiple cores             
!           if(mcselect) wfile='mc'//mc//trim(wfile)                                     
           write(16,*)'Name of .dst file at output of the element: ',&
                       trim(wfile)
           fromrfq=.false.                             
           call prbeam(idflg,wfile,fromrfq)
           exit
         endif
       endif  
     enddo
   endif         
END SUBROUTINE cavnum
!> *******************************************************************
!! SUBROUTINE bcnum(phref,ylg,ncell)
!! dynamics of the bunch
!< *******************************************************************
SUBROUTINE bcnum(phref,ylg,ncell)
   USE DynacConstants  
   USE m4beam
   USE m4cavs
   USE m4cavs2
   USE m4numcavs
   USE m4output
   USE m4plots, ONLY: uden
   USE m4spacecharge
   USE fun4cavnum
   USE mCOMstep
   USE mCOMelec
   USE mCOMtestref
   IMPLICIT NONE
   REAL(8) phref,ylg,a1,ae2,aqst,beref,d2gdz2,ddt,dgam,dgdz,dgdzr,dred,dxpe1,dxpe2
   REAL(8) dype1,dype2,e0,eglsc,enref,etfac,etmul1,etmul2,f6i
   REAL(8) gam0,gam00,gam00m1,gam1,gam11,gam11m1,gam2,gam22,gam22m1,gam2im1
   REAL(8) gam3,gam33,gam33m1,gam4,gam44,gam44m1,gam5,gam55,gam55m1
   REAL(8) gamm0,gamm1,gamm2,yi,yp0,ype0,ypi,t5
   REAL(8) gamref,qc,qcoe0,r1,red,red2,rk1,rk2,rphas,stt1,stt2,t0,tmoy,tof
   REAL(8) ttt1,ttt2,vphasi,x0,xe0,xi,xk1,xkp,xpas2,xpe0,xpi,xt0,y0,ye0
   INTEGER ilost,i,ncell,i1,j,len,npas,npas1
   REAL(8) vecx(1)
   REAL(8) gam(500),xe(500),xpe(500),ye(500),ype(500)
   REAL(8), allocatable ::  tcour(:),phi(:)  
   logical flgsc
   INTEGER lossreason   
   character(len=8) :: PRTLAB
!*******************************************************************
   allocate(tcour(iptsz))
   allocate(phi(iptsz))
!   ylg(cm) length of cavity, xpas(cm): step length
!   8 steps over a cell (a voir!! !)
   PRTLAB='CAVNUM'
   BEREF=VREF/VL
   GAMREF=1.D0/SQRT(1.D0-(BEREF*BEREF))
   ENREF=XMAT*GAMREF
   e0=xmat
   xkp=fh*fh/(4.D0*vl*vl)
   npas=ncell*istep
   xpas=ylg/DBLE(npas)
   npas1=npas+1
   xnh=0.D0
!   flgsc = true ---> s.c. computation
!   eglsc = 2*xpas : acting length of s.c. computation
   eglsc=2.D0*xpas
   flgsc=.false.
   aqst=abs(qst)
   do i=2,npas1
     i1=i-1
! --- seek the field E(z) values in the 6 positions in the step length xh
     call fposb
     tmoy=0.D0
     do j=1,ngood
       tmoy=tmoy+f(6,j)
     enddo
     tmoy=tmoy/DBLE(ngood)
! --- systematic or random defaults on the phase amplitude (not for the reference)
     if(ierpf.ne.0) then
! --- systematic default on the amplitude
       if(ierpf.eq.1) then
         tspl0=tspl0*(1.D0+vfield)
         tspl1=tspl1*(1.D0+vfield)
         tspl2=tspl2*(1.D0+vfield)
         tspl3=tspl3*(1.D0+vfield)
         tspl4=tspl4*(1.D0+vfield)
         tspl5=tspl5*(1.D0+vfield)
       endif
! --- random error on the amplitude
       if(ierpf.gt.1) then
         len=1
         call rlux(vecx,len)
         r1=(2.D0*vecx(1)-1.D0)*vfield
         tspl0=tspl0*(1.D0+r1)
         tspl1=tspl1*(1.D0+r1)
         tspl2=tspl2*(1.D0+r1)
         tspl3=tspl3*(1.D0+r1)
         tspl4=tspl4*(1.D0+r1)
         tspl5=tspl5*(1.D0+r1)
       endif
     endif
     do j=1,ngood
       qc=abs(f(9,j))
       qcoe0=qc/e0
       gam0=f(7,j)/e0
       gam(i1)=gam0
       if(i1.eq.1) then
         tcour(j)=0.D0
         tof=f(6,j)
! --- rphas: phase delay between the actual particle and the reference (entrance of the cavity)
         rphas=fh*(tof-tref)
! --- systematic or random defaults on the phase RF (not for the reference)
         if(ierpf.ne.0) then
           vphasi=vphase*pi/180.D0
! --- systematic default on the phase offset
           if(ierpf.eq.1) rphas=rphas+vphasi
! --- random error on  phase offset
           if(ierpf.gt.1) then
             len=1
             call rlux(vecx,len)
             r1=(2.D0*vecx(1)-1.D0)*vphasi
             rphas=rphas+r1
           endif
         endif
         phi(j)=phref+rphas
       endif
       t0=tcour(j)
       ddt=t0
!  predictor (energy gain)
       if(gam0.le.1.D0) then
         f(8,j)=0.D0
         ilost=ilost+1
! needs to be on energy
         lossreason=-2
! Relative to cog
         f6i=f(6,j)-tmoy
         write(49,'(A8,1x,I4,1x,E12.5,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') & 
          PRTLAB,NRRES,davtot/100.D0,i,int(f(1,j)), &
          f(2,j),f(3,j),f(4,j),f(5,j),f6i*fh*180.D0/pi,f(7,j)-xmat, &
          f(9,j),lossreason,uden
!         write(49,3928) PRTLAB,NRRES,davtot/100.D0,i,int(f(1,j)), &
!             f(2,j),f(3,j),f(4,j),f(5,j),f6i*fh*180.D0/pi,f(7,j)-xmat, &
!             f(9,j),lossreason
! 3928    FORMAT(1x,A8,1x,I4,1x,E12.5,i8,1x,i8,1x,6(f12.3,1x),1x, &
!                  f5.2,3x,i2)
         cycle
       endif
       b0=sqrt(gam0*gam0-1.D0)/gam0
       b1=b0
       b2=b0
       b3=b0
       b4=b0
       b5=b0
       dgam=xi1(phi(j),t0,t5)*qc/e0
       gam5=gam(i1)+dgam
!   corrector (energy gain)
!   tspl0 = dE/dz  (MV/(cm*cm)
       xpas2=xpas*xpas
       dgdz=qst/e0 * tspl0
       d2gdz2=dgam/xpas2-dgdz/xpas
!       d2gdz2=2.D0*d2gdz2
!       gam1=gam0+dgdz*xpas/5.D0+d2gdz2*xpas2/50.D0
!       gam2=gam0+dgdz*xpas*2.D0/5.D0+d2gdz2*xpas2*4.D0/50.D0
!       gam3=gam0+dgdz*xpas*3.D0/5.D0+d2gdz2*xpas2*9.D0/50.D0
!       gam4=gam0+dgdz*xpas*4.D0/5.D0+d2gdz2*xpas2*16.D0/50.D0
       etmul1=dgdz*xpas
       etmul2=d2gdz2*xpas2
       gam1=gam0+etmul1*0.2D0+etmul2*0.04D0
       gam2=gam0+etmul1*0.4D0+etmul2*0.16D0
       gam3=gam0+etmul1*0.6D0+etmul2*0.36D0
       gam4=gam0+etmul1*0.8D0+etmul2*0.64D0
       if(gam1.le.1.D0 .or. gam2.le.1D0 .or. gam3.le.1D0 .or. gam4.le.1D0 .or. gam5.le.1D0) then
         f(8,j)=0.D0
         ilost=ilost+1
! needs to be on energy
         lossreason=-2
! Relative to cog
         f6i=f(6,j)-tmoy
         write(49,'(A8,1x,I4,1x,E12.5,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
          PRTLAB,NRRES,davtot/100.D0,i,int(f(1,j)), &
          f(2,j),f(3,j),f(4,j),f(5,j),f6i*fh*180.D0/pi,f(7,j)-xmat, &
          f(9,j),lossreason,uden
         cycle
       endif
       b1=sqrt(gam1*gam1-1.D0)/gam1
       b2=sqrt(gam2*gam2-1.D0)/gam2
       b3=sqrt(gam3*gam3-1.D0)/gam3
       b4=sqrt(gam4*gam4-1.D0)/gam4
       b5=sqrt(gam5*gam5-1.D0)/gam5
!       dgam=xi1(phi(j),t0,t5)*qc/e0
       dgam=xi1(phi(j),t0,t5)*qcoe0
       gam5=gam(i1)+dgam
       b5=sqrt(gam5*gam5-1.D0)/gam5
!      tranverse coordinates in (cm,rad)
       x0=f(2,j)
       y0=f(4,j)
       xt0=f(3,j)*1.D-03
       yp0=f(5,j)*1.D-03
!      Picht transformation: xe0 and ye0 (cm) xpe0 and ype0 (rad)
!      gamm0=(gam0*gam0-1.D0)**0.25D0
       gam00=gam0*gam0
       gam00m1=gam00-1.D0
       gamm0=sqrt(sqrt(gam00m1))
!      gam00=gam0*gam0
       xe0=x0*gamm0
       xpe0=xt0*gamm0
       ye0=y0*gamm0
       ype0=yp0*gamm0
       etfac=0.5D0*gam0*dgdz/gam00m1
!       xpe0=xpe0+0.5D0*xe0*gam0*dgdz/(gam0*gam0-1.D0)
!       ype0=ype0+0.5D0*ye0*gam0*dgdz/(gam0*gam0-1.D0)
       xpe0=xpe0+xe0*etfac
       ype0=ype0+ye0*etfac
       xe(i1)=xe0
       xpe(i1)=xpe0
       ye(i1)=ye0
       ype(i1)=ype0
!      transverse coupling terms
!       gam00=gam0*gam0
       gam11=gam1*gam1
       gam22=gam2*gam2
       gam33=gam3*gam3
       gam44=gam4*gam4
!       bgt0=(gam00-1.D0)**1.5D0
       bgt0=gam00m1*sqrt(gam00m1)
!       xk1=fh*fh/(4.D0*vl*vl*bgt0)
       xk1=xkp/bgt0
!       red=sqrt(xe(i1)*xe(i1)+ye(i1)*ye(i1))
!       red2=red*red
       red2=xe(i1)*xe(i1)+ye(i1)*ye(i1)
       red=sqrt(red)
       dred=0.D0
       if(red.gt.1.D-08) then
         dred=xe(i1)*xpe(i1)+ye(i1)*ype(i1)
         dred=dred/red
       endif
!       rk1=xk1*red2*xi1(phi(j),t0,t5)*qc/e0
!       rk2=red*dred*xk1*xi2(phi(j),t0)*qc/e0
       rk1=xk1*red2*xi1(phi(j),t0,t5)*qcoe0
       rk2=red*dred*xk1*xi2(phi(j),t0)*qcoe0
       gam(i)=gam5+rk1+rk2
       if(gam(i).le.1.D0) then
         f(8,j)=0.D0
         ilost=ilost+1
! needs to be on energy
         lossreason=-2
! Relative to cog
         f6i=f(6,j)-tmoy
         write(49,'(A8,1x,I4,1x,E12.5,i8,1x,i8,1x,6(f12.3,1x),1x,f5.2,3x,i2,1x,a25)') &
          PRTLAB,NRRES,davtot/100.D0,i,int(f(1,j)), &
          f(2,j),f(3,j),f(4,j),f(5,j),f6i*fh*180.D0/pi,f(7,j)-xmat, &
          f(9,j),lossreason,uden
         cycle
       endif
       gam55=gam(i)*gam(i)
       gam11m1=gam11-1.D0
       gam22m1=gam22-1.D0
       gam33m1=gam33-1.D0
       gam44m1=gam44-1.D0
       gam55m1=gam55-1.D0
!       bgt1=(gam11-1.D0)**1.5D0
!       bgt2=(gam22-1.D0)**1.5D0
!       bgt3=(gam33-1.D0)**1.5D0
!       bgt4=(gam44-1.D0)**1.5D0
!       bgt5=(gam55-1.D0)**1.5D0
       bgt1=gam11m1*sqrt(gam11m1)
       bgt2=gam22m1*sqrt(gam22m1)
       bgt3=gam33m1*sqrt(gam33m1)
       bgt4=gam44m1*sqrt(gam44m1)
       bgt5=gam55m1*sqrt(gam55m1)
       bge0=(gam00+2.D0)/((gam00-1.D0)*(gam00-1.D0))
!       bge1=(gam11+2.D0)/((gam11-1.D0)*(gam11-1.D0))
!       bge2=(gam22+2.D0)/((gam22-1.D0)*(gam22-1.D0))
!       bge3=(gam33+2.D0)/((gam33-1.D0)*(gam33-1.D0))
!       bge4=(gam44+2.D0)/((gam44-1.D0)*(gam44-1.D0))
!       bge5=(gam55+2.D0)/((gam55-1.D0)*(gam55-1.D0))
       bge1=(gam11+2.D0)/(gam11m1*gam11m1)
       bge2=(gam22+2.D0)/(gam22m1*gam22m1)
       bge3=(gam33+2.D0)/(gam33m1*gam33m1)
       bge4=(gam44+2.D0)/(gam44m1*gam44m1)
       bge5=(gam55+2.D0)/(gam55m1*gam55m1)
! ******************************************************
!   compute the jump of phase over the step
!old         dlt=(1.D0+red2*xk1)*xi3(phi(j),t0)
!old         dlt=dlt+red*dred*xk1*xi4(phi(j),t0)
!old         dlt=dlt*qc/(e0*vl)
!old         tof=tof+xpas/(vl*b0)+dlt
! *******************************************************
       f(7,j)=gam(i)*e0
       tcour(j)=t5
!       ddt1=t5-ddt
!       f(6,j)=ddt1+f(6,j)
       f(6,j)=t5-ddt+f(6,j)
! -- angular deviation
!    1) terms in dE/dt
       a1=qc/(2.D0*e0*vl)
       ttt1=xj1(phi(j),t0)
       ttt2=xj2(phi(j),t0)
!old     dxpe=xe(i1)*xj1(phi(j),t0)+xpe(i1)*xj2(phi(j),t0)
!old     dype=ye(i1)*xj1(phi(j),t0)+ype(i1)*xj2(phi(j),t0)
       dxpe1=xe(i1)*ttt1+xpe(i1)*ttt2
       dype1=ye(i1)*ttt1+ype(i1)*ttt2
       xpe(i)=xpe(i1)+a1*dxpe1
       ype(i)=ype(i1)+a1*dype1
! --- 2) terms in E*E (only for no-relativistic electrons)
       if(jelec) then
         ae2=qc/(2.D0*e0)
         ae2=ae2*ae2
         stt1=xe21(phi(j),t0)
         stt2=xe22(phi(j),t0)
         dxpe2=xe(i1)*stt1+xpe(i1)*stt2
         dype2=ye(i1)*stt1+ype(i1)*stt2
         xpe(i)=xpe(i1)+a1*dxpe1-ae2*dxpe2
         ype(i)=ype(i1)+a1*dype1-ae2*dype2
       endif
!  extension
!old         dxe=xe(i1)*xj2(phi,t0)+xpe(i1)*xj3(phi,t0)
!old         dye=ye(i1)*xj2(phi,t0)+ype(i1)*xj3(phi,t0)
!old         xe(i)=xe(i1)+a1*dxe+xpas*xpe(i1)
!old         ye(i)=ye(i1)+a1*dye+xpas*ype(i1)
       xe(i)=xe(i1)+xpas*(xpe(i1)+xpe(i))/2.D0
       ye(i)=ye(i1)+xpas*(ype(i1)+ype(i))/2.D0
!       back to the real variables and convert to (cm,mrad)
       dgdzr=qc/e0 * tspl5
       gam2im1=gam(i)*gam(i)-1.D0
!       gamm1=(gam(i)*gam(i)-1.D0)**0.25D0
       gamm1=sqrt(sqrt(gam2im1))
!       gamm2=(gam(i)*gam(i)-1.D0)**1.25D0
       gamm2=gamm1*gam2im1
       etfac=gam(i)*dgdzr/(gamm2*2.D0)
       xi=xe(i)/gamm1
!       xpi=xpe(i)/gamm1-xe(i)*gam(i)*dgdzr/(gamm2*2.D0)
       xpi=xpe(i)/gamm1-xe(i)*etfac
       yi=ye(i)/gamm1
!       ypi=ype(i)/gamm1-ye(i)*gam(i)*dgdzr/(gamm2*2.D0)
       ypi=ype(i)/gamm1-ye(i)*etfac
!      convert in cm and mrd
       f(2,j)=xi
       f(4,j)=yi
       f(3,j)=xpi*1.D3
       f(5,j)=ypi*1.D3
     enddo
!  space charge computation (only odd step numbers)
     if(.not.flgsc) then
       flgsc=.true.
       call disp
     else
       if(ichaes) then
!      Charge space (only SCHEFF is available)
         iesp=.true.
         call cesp(eglsc)
         iesp=.false.
         flgsc=.false.
!     Change the dispersion dE/E with respect to the C.O.G of the bunch
       endif
       call disp
     endif
     xnh=xnh+1.D0
   enddo
   deallocate(tcour)
   deallocate(phi)
END SUBROUTINE bcnum
!> *******************************************************************
!! SUBROUTINE phcrest(phi0,ylg,ncell,zcrest)
!! REFERENCE:
!! average k (cm-1)
!< *******************************************************************
SUBROUTINE phcrest(phi0,ylg,ncell,zcrest)
   USE DynacConstants 
   USE m4beam, ONLY: VREF,XMAT,QST
   USE m4cavs
   USE m4numcavs
   USE fun4cavnum, ONLY: xi1
   USE m4SPLfun
   IMPLICIT NONE
   REAL(8) ylg,d2gdz2,dgam,dgdz
   REAL(8) e0,phi0,zcrest,estop,xpat
   REAL(8) gam0,gam1,gam2,gam3,gam4,gam5
   REAL(8) t0,xpas2,t5
   INTEGER ncell,npas
!*******************************************************************
!   ylg(cm) length of cavity, xpas(cm): step length
!   8 steps over a cell
   npas=ncell*10
   xpas=ylg/DBLE(npas)
   e0=xmat
   b0=vref/vl
   b1=b0
   b2=b0
   b3=b0
   b4=b0
   b5=b0
   t0=0.D0
   gam0=1.D0/sqrt(1.D0-b0*b0)
   xnh=0.D0
   estop=xpas/10.D0
   DO
     xpat=xnh*xpas
     if(xpat.lt.(ylg-estop)) then
       call fposb
! ---  enegy gain over the step
!   predictor of energy gain
       b1=b0
       b2=b0
       b3=b0
       b4=b0
       b5=b0
       dgam=xi1(phi0,t0,t5)*qst/e0
       gam5=gam0+dgam
!   corrector of energy gain
       xpas2=xpas*xpas
       dgdz=qst/e0 * tspl0
       d2gdz2=dgam/xpas2-dgdz/xpas
       d2gdz2=2.D0*d2gdz2
       gam1=gam0+dgdz*xpas/5.D0+d2gdz2*xpas2/50.D0
       gam2=gam0+dgdz*xpas*2.D0/5.D0+d2gdz2*xpas2*4.D0/50.D0
       gam3=gam0+dgdz*xpas*3.D0/5.D0+d2gdz2*xpas2*9.D0/50.D0
       gam4=gam0+dgdz*xpas*4.D0/5.D0+d2gdz2*xpas2*16.D0/50.D0
       b1=sqrt(gam1*gam1-1.D0)/gam1
       b2=sqrt(gam2*gam2-1.D0)/gam2
       b3=sqrt(gam3*gam3-1.D0)/gam3
       b4=sqrt(gam4*gam4-1.D0)/gam4
       b5=sqrt(gam5*gam5-1.D0)/gam5
       dgam=xi1(phi0,t0,t5)*qst/e0
       gam5=gam0+dgam
       b5=sqrt(gam5*gam5-1.D0)/gam5
       b0=b5
       t0=t5
       gam0=gam5
       xnh=xnh+1.D0
     else
       exit
     endif
   ENDDO
!   compute an average k: zcrest
   zcrest=fh*t5/ylg
END SUBROUTINE phcrest
!> *******************************************************************
!! SUBROUTINE phcrest1(phi0,ylg,ncell)
!! REFERENCE:
!! computation of the phase giving the maximum energy gain)
!< *******************************************************************
SUBROUTINE phcrest1(phi0,ylg,ncell,dwmx)
   USE DynacConstants 
   USE m4beam, ONLY: VREF,XMAT,QST
   USE m4cavs
   USE m4numcavs
   USE fun4cavnum, ONLY: xi1
   USE fun4rfq, ONLY: slope
   USE m4SPLfun
   IMPLICIT NONE
   REAL(8) ylg,d2gdz2,dgam,dgdz
   REAL(8) e0,phi0,dph,dph1,dwmx
   REAL(8) gam0,gam1,gam2,gam3,gam4,gam5
   REAL(8) t0,t5,xpas2
   REAL(8) dplim,dwcpr,phi,pmin,pmax,rad,wwpcr,wwref,yf,yfb
   INTEGER i,ncell,npas,ibcl
   REAL(8) stx(400),sty(400),sts(400),stp(400),stq(400)
   REAL(8) phc(100),wph(100)
!*******************************************************************
!   ylg(cm) length of cavity, xpas(cm): step length
   npas=ncell*10
   xpas=ylg/DBLE(npas)
   e0=xmat
   rad=pi/180.D0
   dph=rad
   dph1=rad
   dplim=rad*0.01D0
   pmax=phi0+10.D0*rad
   pmin=phi0-10.D0*rad
   ibcl=1
   phi=pmin
   DO
     if(phi.ge.pmax) EXIT
     phc(ibcl)=phi
     b0=vref/vl
     b1=b0
     b2=b0
     b3=b0
     b4=b0
     b5=b0
     t0=0.D0
     gam0=1.D0/sqrt(1.D0-b0*b0)
     wwref=(gam0-1.D0)*e0
     xnh=0.D0
     DO
       if(xnh*xpas.ge.ylg) EXIT
       call fposb
! ---  energy gain over the step
!   predictor of energy gain
       b1=b0
       b2=b0
       b3=b0
       b4=b0
       b5=b0
       dgam=xi1(phi,t0,t5)*qst/e0
       gam5=gam0+dgam
!   corrector
       xpas2=xpas*xpas
       dgdz=qst/e0 * tspl0
       d2gdz2=dgam/(xpas2)-dgdz/xpas
       d2gdz2=2.D0*d2gdz2
       gam1=gam0+dgdz*xpas/5.D0+d2gdz2*xpas2/50.D0
       gam2=gam0+dgdz*xpas*2.D0/5.D0+d2gdz2*xpas2*4.D0/50.D0
       gam3=gam0+dgdz*xpas*3.D0/5.D0+d2gdz2*xpas2*9.D0/50.D0
       gam4=gam0+dgdz*xpas*4.D0/5.D0+d2gdz2*xpas2*16.D0/50.D0
       b1=sqrt(gam1*gam1-1.D0)/gam1
       b2=sqrt(gam2*gam2-1.D0)/gam2
       b3=sqrt(gam3*gam3-1.D0)/gam3
       b4=sqrt(gam4*gam4-1.D0)/gam4
       b5=sqrt(gam5*gam5-1.D0)/gam5
       dgam=xi1(phi,t0,t5)*qst/e0
       gam5=gam0+dgam
       b5=sqrt(gam5*gam5-1.D0)/gam5
       b0=b5
       t0=t5
       gam0=gam5
       xnh=xnh+1.D0
     ENDDO
     wwpcr=(gam0-1.D0)*e0
     dwcpr=wwpcr-wwref
     wph(ibcl)=dwcpr
     phi=phi+dph
     ibcl=ibcl+1
   ENDDO
   ibcl=ibcl-1
! save spline areas (partial save)
   do i=1,400
     stx(i)=xspl(i)
     sty(i)=yspl(i)
     sts(i)=s(i)
     stp(i)=p(i)
     stq(i)=q(i)
   enddo
! padding spline areas
   dwmx=wph(1)
   do i=1,ibcl
     xspl(i)=phc(i)
     yspl(i)=wph(i)
     if(wph(i).gt.dwmx)dwmx=wph(i)
   enddo
   call deriv2(ibcl)
   i=1
   phi=xspl(1)
   yfb=slope(ibcl,phi)/100.D0
   DO
     if(phi.ge.xspl(ibcl)) EXIT
     if(dph1.le.dplim) EXIT
     yf=slope(ibcl,phi)
     if(yf.gt. 0.D0) then
       phi=phi+dph1
     else
       phi=phi-dph1
       dph1=dph1/2.D0
       phi=phi+dph1
     endif
   ENDDO
   phi0=phi
! restore spline areas (partial save)
   do i=1,400
     xspl(i)=stx(i)
     yspl(i)=sty(i)
     s(i)=sts(i)
     p(i)=stp(i)
     q(i)=stq(i)
   enddo
END SUBROUTINE phcrest1
!> *******************************************************************
!! SUBROUTINE dwref(phi0,gam5,t5,davtotin)
!! compute the energy gain and the time of flight of the reference
!! over the cavity(gap) at the exit of the cavity(gap):
!! gam4 = relativistic gamma,  t4 = tof (cavity)
!! davtotin is the absolute position at the beginning of the cavity
!< *******************************************************************
SUBROUTINE dwref(phi0,gam5,t5,davtotin)
   USE DynacConstants
   USE m4cavs
   USE m4numcavs
   USE m4beam, ONLY: TREF,VREF,XMAT,QST
   USE fun4cavnum, ONLY: xi1
   USE m4trace3d, ONLY: fldctr,zend
   USE m4SPLfun
   USE m4RESTAY, ONLY: xlim,ncell
   USE mCOMkcell
   USE mCOMstep
   USE mCOMxitrd3
   USE mCOMsphi
   USE mCOMcavdata
   IMPLICIT NONE
   REAL(8) phi0,t0,t5,gam5,davtotin,aqst,d2gdz2
   REAL(8) dgam,dgdz,e0,estop,eww,gam0,gam1,gam2,gam3,gam4
   REAL(8) ttphi,ttvol,wdgam,wdgams,xlcel,xlcum,xlpos,xnhc,xpas2,xpat,xpcel,zmid
   INTEGER inc,isce,istop
!*******************************************************************
!  save previous xpas
   aqst=abs(qst)
   xpcel=xpas
   xlpos=0.D0
   isce=20
   xlcum=0.D0
   b0=vref/vl
   b1=b0
   b2=b0
   b3=b0
   b4=b0
   b5=b0
   t0=0.D0
!   xlcel (cm): length of current cell
!   xlim(inc) cm: limits of current cell
!   isce: step number in cell (forced isce = 20)
!   wdgam: energy gain over the cell
! **************************************
   do inc=1,ncell
     bcour1(inc)=b0
     tcour1(inc)=t0
     wdgams=0.D0
     xnh=0.D0
     xlcel=xlim(inc+1)-xlim(inc)
     xlpos=xlpos+xlcel
     xpas=xlcel/DBLE(isce)
     e0=xmat
     xnhc=0.D0
     gam0=1.D0/sqrt(1.D0-b0*b0)
     estop=xpas/10.D0
     istop=0
     DO
       xpat=xnhc*xpas
       if(xpat.ge.(xlcel-estop)) EXIT
       call fposbb(xlcum)
! ---  energy gain over the step
       b1=b0
       b2=b0
       b3=b0
       b4=b0
       b5=b0
! predictor
       dgam=xi1(phi0,t0,t5)*aqst/e0
       gam5=gam0+dgam
!   corrector
       xpas2=xpas*xpas
       dgdz=aqst/e0 * tspl0
       d2gdz2=dgam/xpas2-dgdz/xpas
       d2gdz2=2.D0*d2gdz2
       gam1=gam0+dgdz*xpas/5.D0+d2gdz2*xpas2/50.D0
       gam2=gam0+dgdz*xpas*2.D0/5.D0+d2gdz2*xpas2*4.D0/50.D0
       gam3=gam0+dgdz*xpas*3.D0/5.D0+d2gdz2*xpas2*9.D0/50.D0
       gam4=gam0+dgdz*xpas*4.D0/5.D0+d2gdz2*xpas2*16.D0/50.D0
       b1=sqrt(gam1*gam1-1.D0)/gam1
       b2=sqrt(gam2*gam2-1.D0)/gam2
       b3=sqrt(gam3*gam3-1.D0)/gam3
       b4=sqrt(gam4*gam4-1.D0)/gam4
       b5=sqrt(gam5*gam5-1.D0)/gam5
       dgam=xi1(phi0,t0,t5)*aqst/e0
       gam5=gam0+dgam
       eww=xmat*(gam5-1.D0)
       wdgam=xmat*dgam
       wdgams=wdgams+wdgam
       b5=sqrt(gam5*gam5-1.D0)/gam5
       b0=b5
       t0=t5
       gam0=gam5
       xnh=xnh+1.D0
       xnhc=xnhc+1.D0
     ENDDO
     tcour2(inc)=t5
     xlcum=xlcum+xlcel
     ttvol=t5*fh*180.D0/pi
     ttphi=ttvol+tref*fh*180.D0/pi
     bcour2(inc)=b5
     tr3dw(inc)=wdgams
     zmid=(xlim(inc+1)+xlim(inc))/2.D0
! ************************************************
!         write(13,101) NRRES,inc,xlim(inc),zmid,avrg(inc),xlim(inc+1), &
!              xlcel,eww,wdgams,ttvol,ttphi
     write(cavprt(inc),'(2(2x,i4),10(2x,e12.5))') &
      NRRES,inc,davtotin+xlim(inc),xlim(inc),zmid, &
      avrg(inc),xlim(inc+1),xlcel,eww,wdgams,ttvol,ttphi
!     write(cavprt(inc),101) NRRES,inc,davtotin+xlim(inc),xlim(inc),zmid, &
!          avrg(inc),xlim(inc+1),xlcel,eww,wdgams,ttvol,ttphi
!  101    format(2(2x,i4),10(2x,e12.5))
     fldctr(inc)=avrg(inc)-xlim(inc)
     zend(inc)=xlcel-fldctr(inc)
   enddo
   call itrd3
! restore  xpas
   xpas=xpcel
END SUBROUTINE dwref
!> *******************************************************************
!! SUBROUTINE itrd3
!< *******************************************************************
SUBROUTINE itrd3
   USE DynacConstants
   USE m4cavs
   USE m4numcavs, ONLY: fmult
   USE m4beam, ONLY: QST
   USE fun4restay, ONLY: ta0,sb0
   USE m4RESTAY, ONLY: xlim,ncell
   USE mCOMkcell
   USE mCOMxitrd3
   USE mCOMsphi
   USE mCOMcavdata
   IMPLICIT NONE
   REAL(8) atr3d,bcour,ddw,drift1,drift2,tph,tt,xsign1,xsing
   INTEGER nrc
   REAL(8) ttr3d(15),str3d(15)
!*******************************************************************
   do nrc=1,ncell
     bcour=(bcour1(nrc)+bcour2(nrc))/2.D0
     ttr3d(nrc)=ta0(bcour,nrc)
   enddo
   do nrc=1,ncell
     bcour=(bcour1(nrc)+bcour2(nrc))/2.D0
     str3d(nrc)=sb0(bcour,nrc)
   enddo
   do nrc=1,ncell
     t0tr3d(nrc)=qst*sqrt(ttr3d(nrc)**2+str3d(nrc)**2)*fmult/2.D0
     atr3d=0.D0
     tt=tr3dw(nrc)/t0tr3d(nrc)
     tph=atan(-str3d(nrc)/ttr3d(nrc))
     if(tt .lt. 1.D0) atr3d=acos(tt)
     ddw=ttr3d(nrc)*cos(tph)-str3d(nrc)*sin(tph)
     if(ddw.lt. 0.D0) then
       tph=tph+pi
     endif
!     if(tph.ge.pcrest) atr3d=-atr3d
     drift1=avrg(nrc)-xlim(nrc)
     drift2=xlim(nrc+1)-avrg(nrc)
     xsign1=tcour2(nrc)-tcour1(nrc)
     xsing=xsign1-(drift1/bcour1(nrc)+drift2/bcour2(nrc))/vl
     if(xsing.gt. 0.D0) atr3d=-atr3d
     tr3ph(nrc)=atr3d*180.D0/pi
!         write(13,100)nrc,t0tr3d(nrc),ttr3d(nrc),str3d(nrc),tr3dw(nrc) &
!                    ,atr3d*180.D0/pi,tph*180.D0/pi
!  100    format(2x,i4,6(2x,e12.5))
     write(13,'(A,5(2x,e12.5))') trim(cavprt(nrc)),t0tr3d(nrc),ttr3d(nrc), &
      str3d(nrc),atr3d*180.D0/pi,tph*180.D0/pi
!     write(13,100) trim(cavprt(nrc)),t0tr3d(nrc),ttr3d(nrc),str3d(nrc), &
!                atr3d*180.D0/pi,tph*180.D0/pi
!  100    format(A,5(2x,e12.5))
   enddo
END SUBROUTINE itrd3
!> *******************************************************************
!! SUBROUTINE fposbbb(xlcum,fposs,jx)
!! electric field at the 6 Bode's positions in the step (see routine
!! dwref)
!< *******************************************************************
SUBROUTINE fposbbb(xlcum,fposs,jx)
   USE DynacConstants, ONLY: fprec
   USE m4input
   USE m4numcavs, ONLY: xnh,xpas,fmult,npt,tspl0,tspl1,tspl2,tspl3,tspl4,tspl5, &
       fpos0,fpos1,fpos2,fpos3,fpos4,fpos5 
   USE fun4rfq, ONLY: spline
   USE fun4restay, ONLY: fone
   USE m4RESTAYfun, ONLY: ifield
   USE m4SPLfun
   USE mCOMxposi
   IMPLICIT NONE
   REAL(8) xlcum,fposs,xnh1
   INTEGER jx
!*******************************************************************
   if(abs(fposs).le.fprec) then
     fpos0=xnh*xpas+xlcum+fposs
     fpos1=(xnh+0.2D0)*xpas+xlcum+fposs
     fpos2=(xnh+0.4D0)*xpas+xlcum+fposs
     fpos3=(xnh+0.6D0)*xpas+xlcum+fposs
     fpos4=(xnh+0.8D0)*xpas+xlcum+fposs
     fpos5=(xnh+1.D0)*xpas+xlcum+fposs
   else
     fpos0=xnh*xpas+fposs
     fpos1=(xnh+0.2D0)*xpas+fposs
     fpos2=(xnh+0.4D0)*xpas+fposs
     fpos3=(xnh+0.6D0)*xpas+fposs
     fpos4=(xnh+0.8D0)*xpas+fposs
     fpos5=(xnh+1.D0)*xpas+fposs
   endif
   if(jx.eq.1)then
     xnh1=xnh+1
!     if(xnh1.eq.DBLE(iscx(jx))) fposs=fpos5
     if(abs(xnh1-DBLE(iscx(jx))).le.fprec) fposs=fpos5
   endif
   if(ifield) then
! --- the field was read from disk in MV/cm
     tspl0=spline(npt,fpos0)*fmult
     tspl1=spline(npt,fpos1)*fmult
     tspl2=spline(npt,fpos2)*fmult
     tspl3=spline(npt,fpos3)*fmult
     tspl4=spline(npt,fpos4)*fmult
     tspl5=spline(npt,fpos5)*fmult
! ****TEST
!cc         write(13,*) 'xnh fpos tspl '
!          write(13,700) xnh,fpos0,tspl0,xpas,fposs
!         write(13,700) xnh,fpos1,tspl1
!         write(13,700) xnh,fpos2,tspl2
!         write(13,700) xnh,fpos3,tspl3
!         write(13,700) xnh,fpos4,tspl4
!         write(13,700) xnh,fpos5,tspl5,xpas,fposs
!700      format(5(2x,e12.5))
! ***********************************
   else
! ++++ THIS OPTION IS NOT AVAILABLE IN THE CODE +++++++++++++
! the field (MV/cm) was given in the form of a Fourier series
     write(6,*)
     write(ierr,*) 'CAVNUM requires field data defined with FIELD'
     write(ierr,*) 'Replace HARM card with FIELD card'
     write(16,*) 'CAVNUM requires field data defined with FIELD'
     write(16,*) 'Replace HARM card with FIELD card'
     STOP
     tspl0=fone(fpos0)*fmult
     tspl1=fone(fpos1)*fmult
     tspl2=fone(fpos2)*fmult
     tspl3=fone(fpos3)*fmult
     tspl4=fone(fpos4)*fmult
     tspl5=fone(fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(70,700) fpos0,tspl0
!c         write(70,700) fpos1,tspl1
!c         write(70,700) fpos2,tspl2
!c         write(70,700) fpos3,tspl3
!c         write(70,700) fpos4,tspl4
!old         write(70,700) fpos5,tspl5
! ***********************************
   endif
END SUBROUTINE fposbbb
!> *******************************************************************
!! SUBROUTINE fposbb(xlcum)
!! electric field at the 6 Bode's positions in the step  (see routine
!! dwref1)
!< *******************************************************************
SUBROUTINE fposbb(xlcum)
!   USE DynacConstants
   USE m4input
   USE m4numcavs, ONLY: xnh,xpas,fmult,npt,tspl0,tspl1,tspl2,tspl3,tspl4,tspl5, &
       fpos0,fpos1,fpos2,fpos3,fpos4,fpos5 
   USE fun4rfq, ONLY: spline
   USE fun4restay, ONLY: fone
   USE m4RESTAYfun, ONLY: ifield
   USE m4SPLfun
   IMPLICIT NONE
   REAL(8) xlcum
!*******************************************************************
   fpos0=xnh*xpas+xlcum
   fpos1=(xnh+0.2D0)*xpas+xlcum
   fpos2=(xnh+0.4D0)*xpas+xlcum
   fpos3=(xnh+0.6D0)*xpas+xlcum
   fpos4=(xnh+0.8D0)*xpas+xlcum
   fpos5=(xnh+1.D0)*xpas+xlcum
   if(ifield) then
! --- the field was read from disk in MV/cm
     tspl0=spline(npt,fpos0)*fmult
     tspl1=spline(npt,fpos1)*fmult
     tspl2=spline(npt,fpos2)*fmult
     tspl3=spline(npt,fpos3)*fmult
     tspl4=spline(npt,fpos4)*fmult
     tspl5=spline(npt,fpos5)*fmult
! ****TEST
!cc         write(13,*) 'xnh fpos tspl '
!c         write(13,700) xnh,fpos0,tspl0,xpas
!         write(13,700) xnh,fpos1,tspl1
!         write(13,700) xnh,fpos2,tspl2
!         write(13,700) xnh,fpos3,tspl3
!         write(13,700) xnh,fpos4,tspl4
!         write(13,700) xnh,fpos5,tspl5,xpas
!700      format(4(2x,e12.5))
! ***********************************
   else
! the field (MV/cm) was given in the form of a Fourier series
     write(6,*)
     write(ierr,*) 'CAVNUM requires field data defined with FIELD'
     write(ierr,*) 'Replace HARM card with FIELD card'
     write(16,*) 'CAVNUM requires field data defined with FIELD'
     write(16,*) 'Replace HARM card with FIELD card'
     STOP
     tspl0=fone(fpos0)*fmult
     tspl1=fone(fpos1)*fmult
     tspl2=fone(fpos2)*fmult
     tspl3=fone(fpos3)*fmult
     tspl4=fone(fpos4)*fmult
     tspl5=fone(fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(70,700) fpos0,tspl0
!c         write(70,700) fpos1,tspl1
!c         write(70,700) fpos2,tspl2
!c         write(70,700) fpos3,tspl3
!c         write(70,700) fpos4,tspl4
!old         write(70,700) fpos5,tspl5
! ***********************************
   endif
END SUBROUTINE fposbb
!> *******************************************************************
!! SUBROUTINE fposb
!! electric field at the 6 Bode's positions in the step
!< *******************************************************************
SUBROUTINE fposb
!   USE DynacConstants
   USE m4input
   USE m4numcavs, ONLY: xnh,xpas,fmult,npt,tspl0,tspl1,tspl2,tspl3,tspl4,tspl5, &
       fpos0,fpos1,fpos2,fpos3,fpos4,fpos5 
   USE fun4rfq, ONLY: spline  
   USE fun4restay, ONLY: fone    
   USE m4RESTAYfun, ONLY: ifield
   USE m4SPLfun
   IMPLICIT NONE
!*******************************************************************
   fpos0=xnh*xpas
   fpos1=(xnh+0.2D0)*xpas
   fpos2=(xnh+0.4D0)*xpas
   fpos3=(xnh+0.6D0)*xpas
   fpos4=(xnh+0.8D0)*xpas
   fpos5=(xnh+1.D0)*xpas
   if(ifield) then
! --- the field was read from disk in MV/cm
     tspl0=spline(npt,fpos0)*fmult
     tspl1=spline(npt,fpos1)*fmult
     tspl2=spline(npt,fpos2)*fmult
     tspl3=spline(npt,fpos3)*fmult
     tspl4=spline(npt,fpos4)*fmult
     tspl5=spline(npt,fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(13,700) xnh,fpos0,tspl0
!c         write(13,700) xnh,fpos1,tspl1
!c         write(13,700) xnh,fpos2,tspl2
!c         write(13,700) xnh,fpos3,tspl3
!c         write(13,700) xnh,fpos4,tspl4
!c         write(13,700) xnh,fpos5,tspl5
!c700      format(3(2x,e12.5))
! ***********************************
   else
! the field (MV/cm) was given in the form of a Fourier series
     write(6,*)
     write(ierr,*) 'CAVNUM requires field data defined with FIELD'
     write(ierr,*) 'Replace HARM card with FIELD card'
     write(16,*) 'CAVNUM requires field data defined with FIELD'
     write(16,*) 'Replace HARM card with FIELD card'
     STOP
     tspl0=fone(fpos0)*fmult
     tspl1=fone(fpos1)*fmult
     tspl2=fone(fpos2)*fmult
     tspl3=fone(fpos3)*fmult
     tspl4=fone(fpos4)*fmult
     tspl5=fone(fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(70,700) fpos0,tspl0
!c         write(70,700) fpos1,tspl1
!c         write(70,700) fpos2,tspl2
!c         write(70,700) fpos3,tspl3
!c         write(70,700) fpos4,tspl4
!old         write(70,700) fpos5,tspl5
! ***********************************
   endif
END SUBROUTINE fposb
!> *******************************************************************
!! SUBROUTINE sposb
!! derivative of electric field at the 6 Bode's positions in the step
!! not used in the code
!< *******************************************************************
SUBROUTINE sposb
!   USE DynacConstants
   USE m4input
   USE m4numcavs 
   USE fun4rfq, ONLY: slope
   USE fun4restay, ONLY: fone
   USE m4RESTAYfun, ONLY: ifield
   USE m4SPLfun
   IMPLICIT NONE
!*******************************************************************
   fpos0=xnh*xpas
   fpos1=(xnh+0.2D0)*xpas
   fpos2=(xnh+0.4D0)*xpas
   fpos3=(xnh+0.6D0)*xpas
   fpos4=(xnh+0.8D0)*xpas
   fpos5=(xnh+1.D0)*xpas
   if(ifield) then
! --- the field is read from disk in MV/cm
     sspl0=slope(npt,fpos0)*fmult
     sspl1=slope(npt,fpos1)*fmult
     sspl2=slope(npt,fpos2)*fmult
     sspl3=slope(npt,fpos3)*fmult
     sspl4=slope(npt,fpos4)*fmult
     sspl5=slope(npt,fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!cc         write(13,700) xnh,fpos0,sspl0
!cc         write(13,700) xnh,fpos1,sspl1
!cc         write(13,700) xnh,fpos2,sspl2
!cc         write(13,700) xnh,fpos3,sspl3
!cc         write(13,700) xnh,fpos4,sspl4
!cc         write(13,700) xnh,fpos5,sspl5
!cc700      format(3(2x,e12.5))
! ***********************************
   else
! the field (MV/cm) is given in the form of a Fourier series
     write(6,*)
     write(ierr,*) 'CAVNUM requires field data defined with FIELD'
     write(ierr,*) 'Replace HARM card with FIELD card'
     write(16,*) 'CAVNUM requires field data defined with FIELD'
     write(16,*) 'Replace HARM card with FIELD card'
     STOP
     tspl0=fone(fpos0)*fmult
     tspl1=fone(fpos1)*fmult
     tspl2=fone(fpos2)*fmult
     tspl3=fone(fpos3)*fmult
     tspl4=fone(fpos4)*fmult
     tspl5=fone(fpos5)*fmult
! ****TEST
!old         write(6,*) 'xnh fmult ',xnh,fmult
!c         write(70,700) fpos0,tspl0
!c         write(70,700) fpos1,tspl1
!c         write(70,700) fpos2,tspl2
!c         write(70,700) fpos3,tspl3
!c         write(70,700) fpos4,tspl4
!old         write(70,700) fpos5,tspl5
! ***********************************
   endif
END SUBROUTINE sposb
!> *******************************************************************
!! SUBROUTINE crest(betr,eqvl,xpos,bkcr,ffield)
!! called by RESTAY
!! Look for the beta giving the maximun energy gain
!! iterative method
!< *******************************************************************
SUBROUTINE crest(betr,eqvl,xpos,bkcr,ffield)
   USE DynacConstants
   USE m4cavs
   USE fun4restay
   USE m4RESTAYfun, ONLY: YLG
   IMPLICIT NONE
   REAL(8) betr,eqvl,xpos,bkcr,ffield
   REAL(8) BE1,BE2,XLEQ,XLHE,A1K12,A2K12,AK12,BK12,BECRT,DELTK,DESY,DFTIL,DTS,EPSRD,FTIL
   REAL(8) S1,S2,SP1,SP2,T1,T2,TP1,TP2,TIL2,XK1,XK2,XKCRT
   INTEGER ITR,III
!*******************************************************************
   XLHE=YLG
   ITR=0
   BE1=BETR
   BE2=BETR-8.333D-3*BETR
   XLEQ=XLHE
   DO
     ITR=ITR+1
     XK1=FH/(VL*BE1)
     XK2=FH/(VL*BE2)
     T1=TTA0(BE1)*ffield
     S1=TSB0(BE1)*ffield
     TP1=TTA1(BE1)*ffield
     SP1=TSB1(BE1)*ffield
     T2=TTA0(BE2)*ffield
     S2=TSB0(BE2)*ffield
     TP2=TTA1(BE2)*ffield
     SP2=TSB1(BE2)*ffield
     DTS=(T1*TP1+S1*SP1)/(T1*T1+S1*S1)
     A1K12=(T1*TP1+S1*SP1)/(T2*TP2+S2*SP2)
     A2K12=(T2*T2+S2*S2)/(T1*T1+S1*S1)
     AK12=A1K12*A2K12
     AK12=1.D0/AK12
     BK12=(XK2-XK1)/(AK12-1.D0)
     BK12=BK12*DTS
     DESY=-4.D0*ATAN(DTS*3.2D0/XLEQ)
!     improve  DESYNCHRONISATION
     EPSRD=1.D-04
     IF(ABS(DESY).GE.EPSRD) THEN
       TIL2=DESY/2.D0
       DO III=1,3
         FTIL=TIL2/TAN(TIL2)-1.D0-BK12
         DFTIL=-TIL2/(SIN(TIL2)*SIN(TIL2))+1.D0/TAN(TIL2)
         TIL2=TIL2-FTIL/DFTIL
       ENDDO
       DESY=TIL2*2.D0
     ENDIF
     IF(ABS(DESY).LT.EPSRD) EXIT
!       XPOS=(T1*SP1-S1*TP1)/(T1*T1+S1*S1)
!       BKCR=SQRT(T1*T1+S1*S1)
!       EQVL=XLEQ
!       RETURN
!     ENDIF
!calculates the equivalent length
     XLEQ=DESY*(AK12-1.D0)/(XK2-XK1)
     DELTK=DESY/XLEQ
     XKCRT=XK1-DELTK
     BECRT=FH/(VL*XKCRT)
     BE1=BECRT
     BE2=BECRT-BECRT/120.D0
   ENDDO
   XPOS=(T1*SP1-S1*TP1)/(T1*T1+S1*S1)
   BKCR=SQRT(T1*T1+S1*S1)
   EQVL=XLEQ
END SUBROUTINE crest
!> *******************************************************************
!! SUBROUTINE rharm
!! the field is in the form of a Fourier series expansion
!< *******************************************************************
SUBROUTINE rharm
   USE DynacConstants, ONLY: VL,PI,RPEL,FPREC
   USE m4input 
   USE m4numcavs, ONLY: xpas,npt
   USE fun4rfq, ONLY : spline
   USE fun4restay, ONLY: fone
   USE m4RESTAYfun
   USE m4SPLfun
   USE m4RESTAY, ONLY: yf,xf,xlim,flength,fhc,att,npoint,ncell
   USE mCOMpaths   
   USE mCOMfiles
   USE mCOMkcell
   IMPLICIT NONE
   REAL(8) part,xcour,xlimf
   REAL(8) xp,zx,cmin,cmax,fmin,fmax,ff,frac
   INTEGER i,j,nfpt,ilast,inh,lfile,lpath,nsteps
   character(len=256) :: myfile
   logical remove
!*******************************************************************
   myfile=''
!   ifield=.false.
   ifield=.true.
!  g: length of the field (cm)
!    fh: frequency (hertz)
!    atte: field factor
!    ncel: number of cells in the cavity
   read(in,*) ylg,fhc,atte,ncel
   read(in,*) nharm
   read(in,*) (a(i),i=1,nharm)
   write(16,'(A,i3,/,A,e12.5,A,/,A,e12.5,A,e12.5)') &
     ' number of cells in the cavity: ',ncel,' field length: ',ylg, ' cm', &
     ' freq. ',fhc,' Hertz field factor ',atte
   write(16,*) ' number of harmonics: ',nharm
   write(16,'(3(2x,e12.5))') (a(i),i=1,nharm)
   do i=1,nharm
     a(i)=a(i)*atte
   enddo
!   fhc=fhc*2.D0*pi
   nsteps=400
   xp=ylg/DBLE(nsteps)
   part=1.D0
   myfile='chemtr.txt'
   if(mcselect) myfile='mc'//mc//'chemtr.txt'
   lpath=LEN_TRIM(dpath)
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(18,file=myfile,status='unknown')
   zx=0.D0
   i=0
! reconstitute the field from the Fourier coefficients
   DO j=1,nsteps+1
     do inh=1,nharm
      ff=fone(zx)
     enddo
     i=i+1
     write(18,'(2(2x,e12.5))') zx/100.D0,ff
     xspl(i)=zx
     yspl(i)=ff
     zx=zx+xp
   ENDDO
   close(18)
   npt=i
   call deriv2(npt)
   xpas=(xspl(3)-xspl(2))/part
   xcour=xspl(1)
   nfpt=1
   do i=1,10000
     if(xcour.gt.xspl(npt) ) exit
     yf(i)=spline(npt,xcour)
     xf(i)=xcour
     xcour=xcour+xpas
     nfpt=nfpt+1
   enddo
   nfpt=nfpt-1
   fmax=yf(1)
   fmin=yf(1)
   do i=2,nfpt
     if(yf(i).gt.fmax) fmax=yf(i)
     if(yf(i).lt.fmin) fmin=yf(i)
   enddo
   xlimf=xspl(npt)
   xf(nfpt)=0.D0
   if(abs(fmax).gt.abs(fmin)) then
     fmin=sign(fmax,fmin)
   elseif(abs(fmin).gt.abs(fmax)) then
     fmax=sign(fmin,fmax)
   endif      
!omment       yf(nfpt)=0.D0
! look for the number of cells,the limits of the cells, the number of coordinates in each cell
   do i=1,15
     npoint(i)=0
   enddo
   npoint(1)=1
   ncell=1
   xlim(ncell)=xf(1)
   cmin=yf(1)
   cmax=yf(1)
! frac is relative noise floor in the field distribution
   frac=0.02D0
   ilast=1
   do i=2,nfpt
     if(yf(i).gt.cmax) cmax=yf(i)
     if(yf(i).lt.cmin) cmin=yf(i)
     if (abs(xf(i)).le.fprec) then
       ncell=ncell+1
       xlim(ncell)=xlimf
!       write(16,*) 'debug end ',nfpt,i,xf(i)
       exit
     endif
     if(yf(i)*yf(i-1).lt. 0.D0) then
       if(abs(cmax/fmax).gt.frac .or. abs(cmin/fmin).gt.frac)then
!         write(16,*)' debug ',i,xf(i),cmax,fmax,cmin,fmin,cmax/fmax,cmin/fmin
         ncell=ncell+1
         npoint(ncell)=npoint(ncell)+1
         xlim(ncell)=xf(i)
         ilast=i
         cmin=yf(1)
         cmax=yf(1)
       else
         npoint(ncell)=npoint(ncell)+1
       endif
     else
       npoint(ncell)=npoint(ncell)+1
     endif
   enddo
   cmin=yf(1)
   cmax=yf(1)
   remove=.true.
   do i=ilast,nfpt
     if(abs(yf(i)/fmax).gt.frac .or. abs(yf(i)/fmin).gt.frac)then
       remove=.false.
     endif
   enddo
   if(remove) then
     xlim(ncell-1)=xlim(ncell)
     npoint(ncell-2)=npoint(ncell-2)+npoint(ncell-1)+1
     ncell=ncell-1
   endif
   flength=xlim(ncell)
   ncell=ncell-1
   att=atte
   write(16,'(A,i3,A,e12.5,A,A,e12.5,A,e12.5,A)') &
     ' Number of cells: ',ncell,' field length: ',flength,' cm', &
     ' field factor: ',att,' frequency: ',fhc,' Hz'
! ******************************************
!  sv 28/10/2015
   call celint
! *****************************************
   do i=1,ncell
     write(16,'(A,i3,A,e12.5,A,A,e12.5,A,A,e12.5,A)') &
          ' Cell number ',i,' lower limit ',xlim(i),' cm ', &
          ' upper limit ',xlim(i+1),' cm ','average ',avrg(i),' cm'
   enddo
END SUBROUTINE rharm
!> *******************************************************************
!! SUBROUTINE fieldcav(atte)
!! read from disk the electromagnetic field in the form (z,E(z))
!! SUPERFISH units: z(m) E(z) (Volt/m)
!! converted to: z(cm)  E(z) (MVolt/cm)
!< *******************************************************************
SUBROUTINE fieldcav(atte)
   USE DynacConstants
   USE m4input 
   USE m4numcavs, ONLY: xpas,npt
   USE fun4rfq, ONLY : spline
   USE m4RESTAYfun, ONLY: ifield
   USE mCOMkcell
   USE m4SPLfun
   USE m4RESTAY, ONLY: yf,xf,xlim,flength,fhc,att,npoint,ncell
   IMPLICIT NONE
   REAL(8) atte
   REAL(8) part,tdep,xcour,xlimf
   INTEGER i,it,nfpt
!*******************************************************************
   part=1.D0
   ifield=.true.
   read(20,*)fhc
   att=atte
   read(20,*) xspl(1),yspl(1)
   yspl(1)=yspl(1)*att
   xspl(1)=xspl(1)*100.D0
   npt=2
   do
     read(20,*) xspl(npt),yspl(npt)
!     if (xspl(npt).eq.0.) exit
     if (abs(xspl(npt)).le.fprec) exit
     if (npt.gt.4000) then
       write(6,*)
       write(ierr,*) 'Error reading FIELD file:'
       write(ierr,*) 'FIELD file contains more than 4000 points'
       write(16,*) 'Error reading FIELD file:'
       write(16,*) 'FIELD file contains more than 4000 points'
       STOP
     endif
     xspl(npt)=xspl(npt)*100.D0
     yspl(npt)=yspl(npt)*att
     npt=npt+1
   enddo
   npt=npt-1
! **************************************
   tdep=xspl(1)
   do it=1,npt
    xspl(it)=xspl(it)-tdep
   enddo
! **************************************
   call deriv2(npt)
   xpas=(xspl(3)-xspl(2))/part
   xcour=xspl(1)
   nfpt=1
   do i=1,10000
     if(xcour.gt.xspl(npt) ) exit
     yf(i)=spline(npt,xcour)
     xf(i)=xcour
     xcour=xcour+xpas
     nfpt=nfpt+1
   enddo
!   *  valero  mars 2006
   xlimf=xspl(npt)
   xf(nfpt)=0.D0
!omment       yf(nfpt)=0.
! look for the number of cells,the limits of the cells, the number of coordinates in each cell
   do i=1,15
     npoint(i)=0
   enddo
   ncell=1
   xlim(ncell)=xf(1)
   do i=2,nfpt
!     if (xf(i).eq.0.) then
     if (abs(xf(i)).le.fprec) then
       ncell=ncell+1
       xlim(ncell)=xlimf
       exit
     endif
     if(yf(i)*yf(i-1).lt. 0.D0) then
       ncell=ncell+1
       xlim(ncell)=xf(i)
     else
       npoint(ncell)=npoint(ncell)+1
     endif
   enddo
   flength=xlim(ncell)
   ncell=ncell-1
!   write(16,*) ' ******Read the field of the cavity************'
   write(16,'(A,i3,A,e12.5,A,e12.5,A,e12.5,A)') ' Number of cells: ',ncell, &
     ' field length: ',flength,'cm field factor: ',att,' frequency: ',fhc,' Hz'
! ******************************************
!  sv 28/10/2015
   call celint
! *****************************************
   do i=1,ncell
     write(16,'(A,i3,A,e12.5,A,e12.5,A,e12.5,A)') ' Cell number ',i, &
      ' lower limit ',xlim(i),' cm  upper limit ',xlim(i+1),' cm average ', &
      avrg(i),' cm'
   enddo
END SUBROUTINE fieldcav
!> *******************************************************************
!! SUBROUTINE celint
!! average position in the cell
!< *******************************************************************
SUBROUTINE celint
   USE DynacConstants
   USE m4input 
   USE m4numcavs, ONLY: xnh,xpas,npt
   USE fun4rfq, ONLY : spline
   USE m4SPLfun
   USE m4RESTAY, ONLY: xlim,ncell
   USE mCOMkcell
   IMPLICIT NONE
   REAL(8) estop,fpos0,fpos1,fpos2,fpos3,fpos4,fpos5,tspl0,tspl1,tspl2,tspl3,tspl4,tspl5
   REAL(8) tspl11,xi1,xi2,xint1,xint2,xlcel,xlcum,xlpos,xnhc,xpat,xspl0,xspl1,xspl2,xspl3
   REAL(8) xspl4,xspl5,z0,z1,z2,z3,z4,z5
   INTEGER inc,isce,istop
!*******************************************************************
   xlpos=0.D0
   isce=20
   xlcum=0.D0
   do inc=1,ncell
     xint1=0.D0
     xint2=0.D0
     xnh=0.D0
     xlcel=xlim(inc+1)-xlim(inc)
     xlpos=xlpos+xlcel
     xpas=xlcel/DBLE(isce)
     xnhc=0
     estop=xpas/10.D0
     istop=0
     DO
       xpat=xnhc*xpas
       if(xpat.ge.(xlcel-estop)) EXIT
       z0=xnh*xpas
       z1=(xnh+0.2D0)*xpas
       z2=(xnh+0.4D0)*xpas
       z3=(xnh+0.6D0)*xpas
       z4=(xnh+0.8D0)*xpas
       z5=(xnh+1.D0)*xpas
       fpos0=xnh*xpas+xlcum
       fpos1=(xnh+0.2D0)*xpas+xlcum
       fpos2=(xnh+0.4D0)*xpas+xlcum
       fpos3=(xnh+0.6D0)*xpas+xlcum
       fpos4=(xnh+0.8D0)*xpas+xlcum
       fpos5=(xnh+1.D0)*xpas+xlcum
       tspl0=spline(npt,fpos0)
       tspl1=spline(npt,fpos1)
       tspl2=spline(npt,fpos2)
       tspl3=spline(npt,fpos3)
       tspl4=spline(npt,fpos4)
       tspl5=spline(npt,fpos5)
       xspl0=z0*tspl0
       xspl1=z1*tspl1
       xspl2=z2*tspl2
       xspl3=z3*tspl3
       xspl4=z4*tspl4
       xspl5=z5*tspl5
!  integral E(z)*z over the cell
       tspl11=19.D0*xspl0+75.D0*xspl1+50.D0*xspl2+50.D0*xspl3+75.D0*xspl4 &
       +19.D0*xspl5
       xi1=xpas/288.D0 * tspl11
       xint1=xint1+xi1
       xspl0=tspl0
       xspl1=tspl1
       xspl2=tspl2
       xspl3=tspl3
       xspl4=tspl4
       xspl5=tspl5
!  integral E(z) over the cell
       tspl2=19.D0*xspl0+75.D0*xspl1+50.D0*xspl2+50.D0*xspl3+75.D0*xspl4 &
       +19.D0*xspl5
       xi2=xpas/288.D0 * tspl2
       xint2=xint2+xi2
       xnh=xnh+1.D0
       xnhc=xnhc+1.D0
     ENDDO
     avrg(inc)=xint1/xint2+xlcum
     xlcum=xlcum+xlcel
   enddo
END SUBROUTINE celint
!> *******************************************************************
!! SUBROUTINE stripp
!!  solid stripper foils for low velocity hadron particles
!! ---- characteristics of the stripper:
!!
!! ---- qs : atomic number
!! ---- atms   : Atomic mass (amu)
!! ---- ths:thickness (g/cm**2)
!!
!< *******************************************************************
SUBROUTINE stripp
   USE DynacConstants
   USE fun4cstrip
   USE fun4rfq, ONLY: spline
   USE m4output
   USE m4mcs
   USE m4beam
   USE m4plots
   USE m4SPLfun
   USE m4ITVOLE, ONLY: SHIFT
   USE m4ble, ONLY: cr
   IMPLICIT NONE
   REAL(8) qp,qsp,alpha,aps,ax,ay,bcog,bref,con,dene,denes,des,diff,dthet,fact
   REAL(8) gcg,gcog,fksi,pcent,pcsum,qavg,qbar,qcg,sm,rthet,stdv,thck,thresh,tmp,vx,vy
   REAL(8) wapc,wcg,wicg,wp,wpatm,xa,xarpha,xb,xmor,xn,yy,zps
   INTEGER i,ip,len,ncount,np,nrtre,nstrp,ntot,numchs
   INTEGER npcent(20)
   REAL(8)  pc(20),xeast(21),yeast(21),vecx(1)
! --- Eastham curve (reduced half angle over reduced thickness)
! ---- xeast: reduced thickness
! ---- yeast: reduced half angle
   data xeast/ 0.D0, 2.D0, 4.D0, 6.D0, 8.D0,10.D0,12.D0,14.D0,16.D0,18.D0,20.D0, &
              22.D0,24.D0,26.D0,28.D0,30.D0,32.D0,34.D0,36.D0,38.D0,40.D0/
   data yeast/0.D0,0.6D0,1.04D0,1.56D0,1.8D0,2.08D0,2.32D0,2.72D0,2.96D0,3.2D0,3.44D0, &
              3.624D0,3.808D0,3.992D0,4.176D0,4.36D0,4.544D0,4.728D0,4.912D0, &
              5.096D0,5.28D0/
!*******************************************************************
! allow for print out on terminal of stripper number on one and the same line
   nstrp=1
   imcs=1
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Charge Stripper     :',nstrp,cr
   flush(6)
   write(16,'(A,/,1x,A,f4.0,A,f4.0)') '***** Projectile ', &
    'atomic number: ',anp,' atomic mass : ',atm
   write(16,'(A,/,1x,A,f4.0,A,f4.0,A,e12.5,A)') '***** Charge Stripper ', &
    'atomic number: ',qs,' atomic mass : ',atms,' thickness: ',ths,' g/cm**2'
! ---- characteristics of particles
! --------- qp=f(9,i)
! --------- uem: atomic mass (amu)
! --------- wp=f(7,i)-xmat
! ----------------------------
! ----      ENVELOPE
   IF(IPRF.EQ.1) then
     PRLAB(IPRF)='START   '
     CALL STAPL(davtot*10.D0)
   endif
! ---- start prints in file 'short.data'
   idav=idav+1
   iitem(idav)=16
   dav1(idav,1)=qs
   dav1(idav,2)=atms
   dav1(idav,3)=ths
   dav1(idav,4)=davtot*10.D0
! ---- kinetic energy at the input
   wicg=0.D0
   do i=1,ngood
     wicg=f(7,i)+wicg
   enddo
   wicg=wicg/DBLE(ngood)
   gcog=wicg/xmat
   bcog=sqrt(gcog*gcog-1.D0)/gcog
   wicg=wicg-xmat
   np=21
   denes=0.D0
   do i=1,np
     xspl(i)=xeast(i)
     yspl(i)=yeast(i)
   enddo
! ----  deriv2: develop the matrix for the b-splines functions
   call deriv2(np)
   len=1
   do ip=1,ngood
     wp=f(7,ip)-xmat
! --- wpatm: MeV/atm
     wpatm=wp/atm
     qp=f(9,ip)
! ---- xa: screening distance (cm)
     qsp=qs**(2.D0/3.D0)+qp**(2.D0/3.D0)
     xa=4.68165D-9/sqrt(qsp)
! ---- reduced thickness: thck
     xn=6.022D23/atms
     thck=xn*pi*xa*xa*ths
! --- reduce half angle: rtheta(rad) from Eastham curve
! ----  b-splines interpollation if thck<40, otherwise: rthet = 9.2e-02*thck + 1.6 (linear interpolation)
     if (thck.lt.40.D0) then
       rthet=spline(np,thck)
     else
       rthet=9.2D-2*thck+1.6D0
     endif
! ---- half angle of diffusion: dthet (mrad)
     zps=qs*qp/(xa*wp)
     dthet=2.88D-10*zps*rthet
! ---  angle of diffusion (mrad) scattered from M.C. separatly in xp and yp directions from a uniform law
!unif         call rlux(vec,len)
!unif         rx=(2.D0*vec-1.D0)*dthet*2.
!unif         f(3,ip)=f(3,ip)+rx
!unif         call rlux(vec,len)
!unif         ry=(2.D0*vec-1.D0)*dthet*2.
!unif         f(5,ip)=f(5,ip)+ry
! ---  angle of diffusion (mrad) scattered from M.C. separatly in xp and yp directions from a Gaussian law
     ax=f(3,ip)
     sm=dthet*2.D0
     call randga(len,sm,ax,vx)
     f(3,ip)=vx
     ay=f(5,ip)
     call randga(len,sm,ay,vy)
     f(5,ip)=vy
! ---  closest distance of approach: xb(cm)
     aps=(atms+atm)/(atms*atm)
     xb=1.44D-13*aps*qs*qp/sqrt(wpatm)
     if(ip.eq.1) then
       alpha=1.576D-02*qp*qs/sqrt(wpatm)
       write(16,'(1x,A,e12.5,A,/,1x,A,e12.5,A,e12.5,A)') &
        'screening distance: ',xa,' cm', &
        'reduced thickness: ',thck,' reduced half angle: ',rthet,' rad '
       write(16,'(1x,A,e12.5,A,/,1x,A,e12.5,A,/,1x,A,e12.5)') &
        'closest distance of approach: ',xb,' cm', &
        'half angle of diffusion: ',dthet,' mrad', &
        'Bohr parameter: ',alpha
     endif
     wapc=4.D0*atm*atms/((atm+atms)**2)
     if(int(qs).eq.6) then
! energy loss in the case of carbon ions
! dke_Bethe routine supplied by Ji-Ho Jang, RAON/IBS
       dene=dkeBethe(wp)
     else
! ----  loss of energy per scatter in the stripper (eq.16)
       dene=wapc*xb*xb*rthet*rthet/(xa*xa)*wp
     endif
     denes=denes+dene
     f(7,ip)=f(7,ip)-dene
! ---- change the electric charge state of the particle over the foil
     f(9,ip)=qop
   enddo
   denes=denes/DBLE(ngood)
   if(int(qs).eq.6) then
     write(16,*)'dE (Bethe-Bloch): ',denes,' MeV or ',denes/atm,' MeV/u'
   else
     write(16,*)'dE (Eastham): ',denes,' MeV or ',denes/atm,' MeV/u'
   endif
   if(int(qs).eq.6 .or. int(qs).eq.3) then
! ---- change the electric charge state of the particles (carbon foil case)
! ---- Based on E.Baron et al, NIM A328 (1993) p.177-182
! calculate dX', dY', dZ'
     fksi=0.1535375D0*(qs/atms)*anp*ths/(bcog*bcog)
     des=0.5D0*0.001D0*(1.866D0+1.57D0*log(wicg/atm))*(anp/atm)
     des=des*sqrt(1000000.D0*ths*qs/atms)
     write(16,*)'dE(MeV) stripping: ',des,des*atm,wicg,wicg/atm
     write(16,*)'dE(MeV) ksi: ',fksi
! calculate the charge state distribution
     qbar=anp*(1.D0-exp(-83.275D0*bcog/(anp**0.447D0)))
     qavg=qbar*(1.D0-exp(-12.905D0+0.2124D0*anp-0.00122D0*anp*anp))
     yy=qbar/anp
     stdv=sqrt(qbar*(0.07535D0+0.19D0*yy-0.2654D0*yy*yy))
     con=1.D0/(stdv*sqrt(2.D0*pi))
     fact=-1.D0/(2.D0*stdv*stdv)
     pcsum=0.D0
     numchs=0
     qst=DBLE(int(qavg))
! ---- only take charge states that have more than thresh % of the particles
     thresh=100.D0/DBLE(ngood)
     write(16,'(1x,A,A/,1x,A,f12.7,A)') 'Carbon foil stripper. ', &
      'Charge state distribution based on E.Baron et al, NIM A328 (1993) p.177-182', &
      'Threshold for cutoff of the distribution: ',thresh,' %'
     do i=1,100
       tmp=fact*(DBLE(i)-qavg)*(DBLE(i)-qavg)
! next line to avoid underflow condition
       if(tmp .lt. -700.D0) tmp=-700.D0
!        pcent=100.D0*con*exp(fact*(DBLE(i)-qavg)*(DBLE(i)-qavg))
!       write(6,*) '******************** DBX TMP ***************',in,tmp,exp(tmp)
       pcent=100.D0*con*exp(tmp)
       if(pcent.gt.thresh) then
         numchs=numchs+1
         sqst(numchs)=DBLE(i)
         pc(numchs)=pcent
         pcsum=pcsum+pcent
       endif
     enddo
     nqst=numchs
     f(9,1)=DBLE(int(qavg))
     qavg=f(9,1)
     write(16,'(1x,A,i2,/,1x,A,i3)') &
      'Number of charge states after the foil ',nqst, &
      'Average charge state: ',int(qavg)
     netac=nqst
! FIRST TRAJECTORY HAS AVERAGE CHARGE STATE
     NTOT=0
     DO I=1,numchs
       NPCENT(I)=int(pc(i)*DBLE(ngood)/100.D0)
       ntot=ntot+NPCENT(I)
     enddo
! add missing number of particles to central charge state
     ncstat=numchs
!     write(16,*) ' ntot,ngood=',ntot,ngood,' particles',int(sqst(i)),int(f(9,1))
     DO I=1,numchs
!       if(int(sqst(i)) .eq. int(f(9,1))) then
       if(abs(sqst(i)-f(9,1)).le.fprec) then
          NPCENT(I)=NPCENT(I)+ngood-ntot
       endif
       cstat(i)=DBLE(int(sqst(i)))
       charm(i)=cstat(i)
       write(16,'(1x,A,f3.0,A,i8,A,f12.7,A)') &
        'Charge=',sqst(i),' with ',npcent(i),' particles or ',pc(i),' %'
     enddo
     write(16,*) 'Total number of particles: ',ngood
     len=1
     i=2
     DO
       if(i.gt.ngood) exit
       DO
         call rlux(vecx,len)
         XARPHA=VECX(1)
         NCOUNT=int(XARPHA*(DBLE(numchs)+0.5D0))
         IF(NCOUNT.gt.0) exit
       ENDDO
!       write(16,*) "DBX ",i,NCOUNT
       IF(NPCENT(NCOUNT).gt.0) then
         NPCENT(NCOUNT)=NPCENT(NCOUNT)-1
         f(9,i)=DBLE(int(sqst(NCOUNT)))
         i=i+1
       ENDIF
     ENDDO
   endif
   call cogetc
! ----  Change  dp/p over the stripper
   call disp
!
! ----  update the cog energy
  qcg=0.D0
  wcg=0.D0
  do i=1,ngood
    wcg=f(7,i)+wcg
    qcg=f(9,i)+qcg
  enddo
  wcg=wcg/DBLE(ngood)
  gcg=wcg/xmat
  qcg=qcg/DBLE(ngood)
  qmoy=qcg
  if(shift) then
    write(16,*) '******************************************************'
    write(16,*) 'Although REFCOG not equal to 0, in charge stripper set'
    write(16,*) 'reference energy to that of COG'
    write(16,*) '******************************************************'
  endif  
  bref=sqrt(gcg*gcg-1.D0)/gcg
  vref=bref*vl
!----  new magnetic rigidity
  xmor=xmat*bref*gcg
  boro=33.356D0*xmor*1.D-01/qcg
  diff=(wcg-xmat)-wicg
  if(int(qs).eq.6 .or. int(qs).eq.3) then
    dav1(idav,5)=qavg
  else
    dav1(idav,5)=qmoy
  endif
  dav1(idav,6)=diff
  dav1(idav,36)=DBLE(ngood)
  write(16,'(1x,A,e12.5,A,/,1x,A,e12.5,A)') 'Energy of cog: at entrance: ', &
    wicg,' MeV','Energy loss of cog: ',-diff,' MeV'
!   plots
  PRLAB(IPRF)='STRIPPER'
  CALL STAPL(davtot*10.D0)
  call emiprt(0)
END SUBROUTINE stripp
!> *******************************************************************
!! SUBROUTINE randga(len,s,am,v)
!! generateur aleatoire selon une loi normale
!!         s : ecart-type de la distribution
!!         am: moyenne de la distribution
!!         v : nombre aleatoire selon la loi normale
!< *******************************************************************
SUBROUTINE randga(len,s,am,v)
   IMPLICIT NONE
   REAL(8) vecx(1),s,am,v,a,y
   INTEGER len,i
!*******************************************************************
   a=0.D0
   do i=1,24
     call rlux(vecx,len)
     y=vecx(1)
     a=a+y
   enddo
   v=(a-12.D0)*s+am
END SUBROUTINE randga
! ********************************************
!   SUBROUTINE separa(iwfia,wfxl,wfef,wfbf)
! WIENFILTER (analytical)
! This routine is a modified version of the SEPARA subroutine that is
! included in ZGOUBI, a program for computing the trajectories of charged 
! particles in electric and magnetic fields. SEPARA was authored by 
! Francois Meot, previously at Brookhaven National Laboratory 
! ********************************************
SUBROUTINE separa(iwfia,wfxl,wfef,wfbf)
! ********************************************
   USE DynacConstants, ONLY: VL, PI, RPEL, FPREC
   USE m4beam
   USE m4output
   USE m4plots   
   USE m4cavs, ONLY: FH,NRRES,NRTRE
   USE m4input
   USE m4ITVOLE
   USE m4short, ONLY: shortl
   USE m4wiena1
   USE m4ble, ONLY: cr
   IMPLICIT NONE
   REAL(8) tcog
   REAL(8) BTA,fcpi,XL
   REAL(8) ALP,AM,ARG,B,C1,C2,DL,E,EPS,G1,OME,P0,PHI,PO,Q,R,RCA,RSA,THET
   REAL(8) TO,V,XO,XP,YP,ZO,ZP
   REAL(8) wfxl,wfef,wfbf
   REAL(8) Y,T,Z,P,X
   INTEGER iwfia
   INTEGER i,ilost,IJ
   INTEGER IPR, NDL, I1
   character(len=8) :: PRTLAB
   character(len=10) :: TYP(2)
   PARAMETER (IPR=0, NDL=1, I1=1)
   DATA TYP / 'HORIZONTAL','VERTICAL' /
!*******************************************************************
!...........................................................
!   IJ = 0 ( DRIFT SPACE) , 1 (H SEPARATION) OR 2 ( V SEP.)
!   DL = LENGTH ( M )
!   E  ( V/M ) = E-FIELD  (USUALLY > 0)
!   B  ( T )   = B-FIELD  (USUALLY < 0)
!...........................................................
! ELEMENTARY CHARGE
   QE=1.602176487D-19
   fcpi=fh*180.D0/pi
!  cast input arguments and DYNAC parameters to ZGOUBI defined parameters  
   IJ = iwfia
   DL = wfxl/100.D0
   E =  wfef
   B =  wfbf
   CL=VL/100.D0
   CL9=CL*1.D-9
   Q=QST
   AM=XMAT
   XL = DL*1.D2
!    
   NRTRE=NRTRE+1   
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
!         
   write(16,'(A)') ' ********** Wien Filter (analytical model) *********'
   if(int(abs(qst)).gt.1) then
     write(16,'(A)') ' The analytical model does not work for beams with charge state larger'
     write(16,'(A)') ' than 1 or less than -1. Use the numerical model (WIENNUM) instead'
     write(6,'(A)') ' The analytical model does not work for beams with charge state larger'
     write(6,'(A)') ' than 1 or less than -1. Use the numerical model (WIENNUM) instead'
     STOP
   endif  
   ilost=0
   IF(IJ .NE. 0) THEN
!    STATISTICS
     IF(IPRF.EQ.1) then
       PRLAB(IPRF)='START   '
       CALL STAPL(davtot*10.D0)
     endif
     davtot=davtot+wfxl
!C   P0 = BORO*CL*1.D-9 *Q/QE
!C   P0 = BORO*CL*1.D-9 *Q
     P0 = BORO*CL9*abs(Q)
     WRITE(16,'(A,A,A,A)') ' ',trim(TYP(IJ)),' ELECTROSTATIC MASS SEPARATOR'
     write(16,'(A,e14.7,A)') ' Reference momentum   = ',boro,' kG.cm'
  
     WRITE(16,'(A,1P,G12.5,A,/,3(A,G12.5,A,/),A,G12.5,/,A,G12.5)') &
      ' Length               = ',DL,'    m', &
      ' E                    = ',E,'   V/m', &
      ' B                    = ',B,'   T', &
      ' Mass   of particles  = ',AM,'   MeV/c2', &
      ' Charge of particles  = ',Q, &
      ' Reference beta       = ',P0/SQRT(P0*P0+AM*AM)
     IF(abs(B) .GT. fprec) WRITE(16,'(A,1P,G12.5,/)') ' Beta wanted = -E/c.B = ',E/(-B*CL)

     IF(abs(Q*AM) .LE. fprec) THEN
       write(6,'(A,/,A)') ' ERROR in Wien Filter (WIEN): ', &
                  'Partcicle mass and/or charge are zero '
       write(16,'(A,/,A)')' ERROR in Wien Filter (WIEN): ', &
                  'Partcicle mass and/or charge are zero '
       STOP
     ENDIF
 
     IF(ABS(Q) .GE. 2.D0) THEN
       write(6,'(A,/,A)') ' ERROR in Wien Filter (WIEN): ', &
                  'WIEN only works for single-charge particles'
       write(16,'(A,/,A)')' ERROR in Wien Filter (WIEN): ', &
                  'WIEN only works for single-charge particles'
       STOP
     ENDIF
   ELSE
     WRITE(16,'(A,/,A,f12.5,A,/)') ' ++++++++++ SEPARATOR OFF +++++++', &
       ' Will therefore be treated as a drift with length ',DL,' m'
   ENDIF
 
   IF(IJ .NE. 0) THEN 
     DO I=1,ngood
       IF    (IJ .EQ. 1) THEN
!        ** HORIZONTAL SEPARATION, convert from cm to m, mrad to rad
         XO = F(2,I)*.01D0
         TO = F(3,I)*.001D0
         ZO = F(4,I)*.01D0
         PO = F(5,I)*.001D0
       ELSEIF(IJ .EQ. 2) THEN
!        **  VERTICAL  SEPARATION, convert from cm to m, mrad to rad
         ZO = F(2,I)*.01D0
         PO = F(3,I)*.001D0
         XO = F(4,I)*.01D0
         TO = F(5,I)*.001D0
       ENDIF
!       write(6,*) 'ANA ytzp in ',I,XO,TO,ZO,PO
!2020    P = P0*F(1,I)
       P = P0*fd(I)
       BTA = P/SQRT(P*P+AM*AM)
       G1 = SQRT(1-BTA*BTA)
       V = BTA*CL
         
       C1 = V*SIN(TO)*COS(PO)
       C2 = V*COS(TO)*COS(PO)
       ZP= V*SIN(PO)
       IF(abs(E*B) .GT. fprec) THEN
         if(I.eq.1) write(16,'(A)')' Using B and E fields '
         ALP = -E*CL*CL/(AM*1.D6)*G1
         OME = -B*CL*CL/(AM*1.D6)*G1
         R = SQRT( C1*C1 + (C2+ALP/OME)**2 ) / OME
         IF(abs(C1) .LE. fprec) C1=1.D-10
         EPS = ATAN2( C2+ALP/OME , C1 )              
         CALL ZEROF(I,DL,BTA,ALP,OME,C1,R,EPS,T)
         ARG = OME*T+EPS
         RCA = R*COS(ARG)
         RSA = R*SIN(ARG)
         X =  RSA - (ALP/OME+C2)/OME + XO
         Y = -RCA - (ALP*T  -C1)/OME
         Z = ZP*T + ZO
         XP = OME*RCA
         YP = OME*RSA - ALP/OME
         THET = ATAN2(XP,YP)
         PHI  = ATAN2(ZP,SQRT(XP*XP+YP*YP))
       ELSEIF(abs(B) .LE. fprec) THEN
         if(I.eq.1) write(16,'(A)')' Using E field only '
         ALP = -E*CL*CL/(AM*1.D6)*G1
         T = DL/V
         X =  (-ALP*T*.5D0 + C1)*T + XO
         XP=  -ALP*T + C1
         YP = C2
         Z = ZP*T + ZO
         THET = ATAN2(XP,YP)
         PHI  = ATAN2(ZP,SQRT(XP*XP+YP*YP))
       ELSEIF(abs(E) .LE. fprec) THEN
         if(I.eq.1) write(16,'(A)')' Using B field only '
         OME = -B*CL*CL/(AM*1.D6)*G1
         R = SQRT( C1*C1 + C2*C2 ) / OME
         IF(C1 .EQ. 0.D0) C1=1.D-10
         EPS = ATAN2( C2 , C1 )
         T = ( ACOS( (C1/OME - DL)/R ) - EPS )/OME
         ARG = OME*T+EPS
         RCA = R*COS(ARG)
         RSA = R*SIN(ARG)
         X =  RSA - C2/OME + XO
         Y = -RCA + C1/OME
         Z = ZP*T + ZO
         XP = OME*RCA
         YP = OME*RSA
         THET = ATAN2(XP,YP)
         PHI  = ATAN2(ZP,SQRT(XP*XP+YP*YP))
       ENDIF
 
       IF    (IJ .EQ. 1) THEN
!      ** HORIZONTAL  SEPARATION
         F(2,I) = X*1.D2
         F(3,I) = THET*1.D3
         F(4,I) = Z*1.D2
         F(5,I) = PHI*1.D3
       ELSEIF(IJ .EQ. 2) THEN
!        ** VERTICAL  SEPARATION
         F(2,I) = Z*1.D2
         F(3,I) = PHI*1.D3
         F(4,I) = X*1.D2
         F(5,I) = THET*1.D3
       ENDIF
!2020    F(6,I) = F(6,I) + V*T*1.D2    <-- F(6,I) in ZGOUBI is the total path length; handled by davtot at start of routine
!        F(7,I) = F(7,I) + T*1.D+6     <-- F(7,I) in ZGOUBI is the total time, is F(6,I) in DYNAC
       F(6,I) = F(6,I) + T            
     ENDDO
     tref=tref+wfxl/vref
! Test for beam loss after the Wien filter
     PRTLAB='WIENANA '
     call reject(ilost,PRTLAB)
     write(16,*) 'Particles lost in Wien filter: ',ilost
! prepare and print statitistics related to the output beam          
     tcog=0.D0
     do i=1,ngood
       tcog=tcog+f(6,i)
     enddo
     tcog=tcog/DBLE(ngood)
     if(itvol) then
       write(16,'(A,e12.5,A,e12.5,A,/,3x,A,e12.5,A,e12.5,A)') ' *** tof for adjustments : ', &
         ttvols*fcpi,' deg at position: ',davtot,' cm in the lattice', &
         'tof of the reference: ',tref*fcpi,' deg, tof of the cog: ',tcog*fcpi,' deg'
     else
       write(16,'(A,e12.5,A,e12.5,A)') ' *** Output tof of the reference: ',tref*fcpi, &
         ' deg, output tof of the cog: ',tcog*fcpi,' deg'
       write(16,'(A,e12.5,A,e12.5,A)') ' *** Output tof of the reference: ',tref, &
         ' sec, output tof of the cog: ',tcog,' sec'              
     endif
     shortl='WIENANA'
     call emiprt(1)
!  envelope
     PRLAB(IPRF)='WIENANA '
     call stapl(davtot*10.D0)
   ELSEIF(IJ .EQ. 0) THEN
!-------- SEPARATOR OFF, treat as a drift 
     call drift(wfxl)
     shortl='WIENANA as a drift'
     call emiprt(1)
   ENDIF
END SUBROUTINE separa
! ********************************************
SUBROUTINE ZEROF(IT,XL,BTA,ALP,OME,C1,R,EPS,T)
! ********************************************
   USE m4wiena1
   IMPLICIT NONE
   REAL(8) XL,BTA,ALP,OME,C1,R,EPS,T,Y
   INTEGER IT,N
!*******************************************************************
!     ** VALEUR DE T QUI EST LE ZERO DE Y(T)=XL
   T = XL/(BTA*CL)
   Y = -R*COS(OME*T+EPS) - (ALP*T  -C1)/OME
   IF( (Y-XL)*(Y-XL) .GE. 1.D-6 ) THEN
     N=0
     DO
       N = N+1
       T = ( C1 - ( R*COS(OME*T+EPS) + XL ) *OME ) / ALP
       Y = -R*COS(OME*T+EPS) - (ALP*T  -C1)/OME
       IF( (Y-XL)*(Y-XL) .LT. 1.D-6 ) EXIT
       IF(N .GT. 200) THEN
         WRITE(16,*) ' Particle ',IT,', Convergence problem in sbr ZEROF :',N,'  iterations'
         EXIT 
       ENDIF  
     ENDDO
   ENDIF
END SUBROUTINE ZEROF
!************************************************
! SUBROUTINE WIENFILTER (numerical)
! This routine is a modified version of the WIENFI subroutine that is
! included in ZGOUBI, a program for computing the trajectories of charged 
! particles in electric and magnetic fields. WIENFI was authored by 
! Francois Meot, previously at Brookhaven National Laboratory  
!************************************************
SUBROUTINE WIENFIN
   USE DynacConstants
   USE m4beam
   USE m4cavs, ONLY: FH,NRRES,NRTRE
   USE m4plots
   USE m4input
   USE m4output
   USE m4ITVOLE, ONLY: ITVOL,ttvols
   USE m4short, ONLY: shortl
   USE m4wiena1
   USE m4wienn, ONLY: KFLD,MG,LC,ML
!  B (KFLD=MG) or E (KFLD=LC) or EB (KFLD=ML)
   USE m4wienn1
   USE m4wienn2
   USE m4wienn4
   USE mCOMchafui
   USE m4ble, ONLY: cr
   IMPLICIT NONE
   REAL(8) tcog
   REAL(8) BTA,DSREF,DT,dum,fcpi,pref,SCUM,TCUM,XL
   INTEGER KALC,KHV,klm,KPOS,ND
   INTEGER i,ilost
   INTEGER MSR,MCOEF
   character(len=8) :: PRTLAB
! to be checked
   PARAMETER(MCOEF=6)
   PARAMETER (MSR=8)
   CHARACTER(2) QSHROE(MSR),QSHROS(MSR)
   REAL(8) VSHROE(MSR), VSHROS(MSR)
!*******************************************************************
!  B (KFLD=MG) or E (KFLD=LC) or EB (KFLD=ML)
   MG=1
   LC=2
   ML=3
! ELEMENTARY CHARGE
   QE=1.602176487D-19
   CL=VL/100.D0
   CL9=CL*1.D-9
   fcpi=fh*180.D0/pi
! HDPRF initialized to 1 in zgoubi OBJETS and zgoubi MCOBJET, DPREF to 0
   HDPRF=1.D0
   DPREF=0.D0
   NRTRE=NRTRE+1   
   WRITE(6,"(A,i5,A,i5,A1)",advance='no') 'Transport element:',NRTRE,'      Accelerating element:',NRRES,cr
   flush(6)
!        
! the remainder is from the original routine        
!     note that wiendat(I) corresponds to A(NOEL,I) in ZGOUBI, with NOEL being the element number in ZGOUBI
!----- IL = 0 (default, does nothing; or 1 log to zgoubi.res; or 2 log to zgoubi.plt; or 7 log to zgoubi.impdev.out
!     note that LST=int(A(NOEL,1)) in CHXC
! for now, default to IL=2 ; will utlimately most likey not be used in dynac
!        READ(in,*) wiendat(1)
   wiendat(1) = 2.
!----- XL(cm), E(V/m), B(T), H-V
   READ(in,*) wiendat(13),(wiendat(I),I=10,12)
   wiendat(10)=wiendat(10)/100.D0
   XL=wiendat(10)
!----- XE,LMBD-E, LMBD-B (entrance)
   READ(in,*) (wiendat(I),I=20,22)
!      COEFS E
   READ(in,*) (wiendat(I),I=30,35)
!      COEFS B
   READ(in,*) (wiendat(I),I=40,45)
!----- XE,LMBD-E, LMBD-B (exit)
   READ(in,*) (wiendat(I),I=50,52)
!      COEFS E
   READ(in,*) (wiendat(I),I=60,65)
!      COEFS B
   READ(in,*) (wiendat(I),I=70,75)
!----- XPAS
   ND = 80
   READ(in,*) wiendat(ND)
   PAS=wiendat(ND)
!2020 wiendat(90) = KP = KPOS, if KPOS=KP=1 means element aligned. Always assume aligned, as misalignment is dealt with differently in dynac
!----- KP,XCE,YCE,ALE
!        READ(in,*) wiendat(90),(wiendat(I),I=91,93)
!        IDUM = int(wiendat(90))
   wiendat(90)=1.
   KPOS=1
   wiendat(91)=XCE
   wiendat(92)=YCE
   wiendat(93)=ALE
   XCE  = wiendat(91)
   YCE  = wiendat(92)
   ALE  = wiendat(93)
! KFLD DEFINES THE FIELD COMBINATION:
!----- Mag pure (KFLD=1)
!----- Elc pure (KFLD=2)
!----- Mag+Elc  (KFLD=3)
!        B (KFLD=MG) or E (KFLD=LC) or EB (KFLD=ML)
!2020 for now set KFLD=3, fix this for the other 2 cases
   KFLD=3
! KALC DEFINES THE FIELD:
!         KALC = 1: DEFINES A MAGNETIC FIELD IN THE MEDIAN
!                     PLANE + ASSUMES MID PLANE SYM (ANALYTICAL)
!         KALC = 2: READS A FIELD MAP
!         KALC = 3: DEFINES QUAD , SEXTU , ... , MULTPL... (ANALYTICAL 3D)
   KALC = 3
!-----------------------------------------------------
!     Optical elements defined in cartesian frame
!-----------------------------------------------------
!--------  FIELDS ARE DEFINED IN CARTESIAN COORDINATES, KART = 1  is what is implemented in DYNAC
!--------  Cylindrical coordinates KART = 2 not used for WIENF in ZGOUBI (KART=1 is used)
   DSREF=0.D0
   do klm =1,msr
     QSHROE(klm)=''
     QSHROS(klm)=''
     VSHROE(klm)=0.D0 
     VSHROS(klm)=0.D0 
   enddo
   CALL CHXC(XL,DSREF)
   
   KHV =NINT( wiendat(13) )
   IF(KHV.eq.0) then
! separator off, treat as drift.
     call drift(xl*100.D0)
     shortl='WIENNUM as a drift'
     call emiprt(1)
   ELSE        
! separator on
!       STATISTICS
     IF(IPRF.EQ.1) then
       PRLAB(IPRF)='START   '
       CALL STAPL(davtot*10.D0)
     endif
     davtot=davtot+wiendat(10)*100.D0
!take SCUM to be accumulated length; assume 0 for now, to be interfaced with dynac
     SCUM=0.D0
     TCUM=tref
     XL=DSREF
!     write(6,*) 'Debug 0 ',SCUM,XL,TCUM
     SCUM = SCUM + XL
!----- Compute cumulative time. 
!        write(6,*) 'Debug 1 ',XMAT
!        write(6,*) 'Debug 2 ',BORO,DPREF,HDPRF,CL9
     PREF = (BORO*(DPREF+HDPRF)) *CL9*QST
!        write(6,*) 'Debug 2a ',PREF
     BTA = PREF / SQRT(PREF*PREF+XMAT*XMAT)
!        write(6,*) 'Debug 3 ',XL,CL,BTA
!-----XL is in centimeters, TCUM is seconds
!2020  DT = XL / (CL*BTA) *UNIT(5) , unit(5)=0.01 is used in ZGOUBI
     DT = XL / (CL*BTA) * 0.01D0
     TCUM = TCUM + DT
     tref = TCUM 
     dum=XL
!    write(6,*) 'In scumw b4 exit=',dt,dum,scum,tcum
     CALL RAZDRV(3)
     DXI=PAS
     XFE=-XE
     XFS=XS-XLIM
!    write(6,*) 
!    write(6,*) 'In QSX ',PAS,MSR,XE,XFE,XFS,XLIM
!    write(6,*) 
!------- Optical elmnt undergoes new positionning. Its frame becomes the new reference frame.
!        Not used in DYNAC; overwrite the offsets by setting them to 0
     XCS = 0.D0
     YCS = 0.D0
     ALS = 0.D0

     QSHROE(1) = 'XS'
     VSHROE(1) = XCE
     QSHROE(2) = 'YS'
     VSHROE(2) = YCE
     QSHROE(3) = 'ZR'
     VSHROE(3) = ALE
     VSHROE(MSR) = 3
     QSHROS(1) = 'XS'
     VSHROS(1) = XCS
     QSHROS(2) = 'YS'
     VSHROS(2) = YCS
     QSHROS(3) = 'ZR'
     VSHROS(3) = ALS
     VSHROS(MSR) = 3
     
!    write(6,*) 'In WIENFIN pas=',pas
!    IF(PAS.LE.0.D0) THEN
!      TEMP=XI
!      XI=XF
!      XF=TEMP
!      XFE=XLIM-XS
!      XFS=XE
!    ENDIF
        
! XI,XF set in CHXC, passed by common AIM
     X=XI
     XLIM=XF
!        write(6,*) 'In wienfin XI,XF=',XI,XF
!            write(6,*) 'before call to transf: ',WEDGE,WDGE,FINTE,GAPE

     CALL TRANSF(QSHROE,VSHROE,QSHROS,VSHROS)     
     WRITE(16,'(10x,A,1P,G12.4,A,G12.4,A,G16.8,A,/)') &
                               'X =',XCE,' cm   Y =',YCE,' cm,  tilt  angle =',ALE,' rad'
                               
     WRITE(16,'(A,E14.6,A)')   ' Cumulative length of optical axis = ',SCUM*0.01D0,' m'
     WRITE(16,'(A,E14.6,A,/)') ' Reference TOF at the output       = ',TCUM,' s'
     
! Test for beam loss after the Wien filter
     PRTLAB='WIENNUM '
     call reject(ilost,PRTLAB)
     write(16,*) 'Particles lost in Wien filter: ',ilost
! prepare and print statitistics related to the output beam          
     tcog=0.D0
     do i=1,ngood
       tcog=tcog+f(6,i)
     enddo
     tcog=tcog/DBLE(ngood)
     if(itvol) then
!       write(16,11) ttvols*fcpi,davtot,tref*fcpi,tcog*fcpi
!   11  FORMAT(' *** tof for adjustments : ',E14.6, &
!         ' deg at position: ',E14.6,' cm in the lattice', &
!       /,3x,'tof of the reference: ',E14.6,' deg, tof of the cog: ', &
!       E14.6,' deg')
       write(16,'(A,e14.6,A,e14.6,A,/,3x,A,e14.6,A,e14.6,A)') ' *** tof for adjustments : ', &
         ttvols*fcpi,' deg at position: ',davtot,' cm in the lattice', &
         'tof of the reference: ',tref*fcpi,' deg, tof of the cog: ',tcog*fcpi,' deg'
     else
       write(16,'(A,e14.6,A,e14.6,A)') ' *** Output tof of the reference: ',tref*fcpi, &
         ' deg, output tof of the cog: ',tcog*fcpi,' deg'
       write(16,'(A,e14.6,A,e14.6,A)') ' *** Output tof of the reference: ',tref, &
         ' sec, output tof of the cog: ',tcog,' sec'       
     endif
     shortl='WIENNUM'
     call emiprt(1)
!  envelope
     PRLAB(IPRF)='WIENNUM '
     call stapl(davtot*10.D0)
   ENDIF
END SUBROUTINE WIENFIN
!************************************************
SUBROUTINE CHXC(XL,DSREF)
!************************************************
   USE DynacConstants
   USE m4beam
   USE m4plots
   USE m4input
   USE fun4wien
   USE m4wiena1
   USE m4wienn, ONLY: LST,KFLD,MG,LC,ZSYM,IDS,IDB,IDE,IDZ
!     B (KFLD=MG) or E (KFLD=LC) or EB (KFLD=ML)
   USE m4wienn1
   USE m4wienn2
   USE m4wienn4
   USE m4wienn5, ONLY: WDGE, WDGS, FINTE, FINTS, GAPE, GAPS, WEDGE, WEDGS, &
                       IFB, AM,BBM,CM,IDRT
   USE mCOMchafui
   USE mCOMmultpe
   USE mCOMmultpl
   IMPLICIT NONE
   REAL(8) DSREF,XL
   REAL(8) B,E,PHE,PHS,PRF,scal,TE,TEQ,TS,TSQ,TTA,XLS,ZCE,ZCS
   REAL(8) CTE,STE,CTS,STS,CTEQ,STEQ,CTSQ,STSQ
   INTEGER KHV
   INTEGER i,I1,NND
   INTEGER MCOEF,MPOL,MXC,LST2
! --------------------------------------
! to be checked
   PARAMETER(MCOEF=6)
! to be checked
   PARAMETER(MPOL=10)
   PARAMETER (MXC = 4)
!   EQUIVALENCE (RTB(1),CTE), (RTB(2),STE), (RTB(4),CTS), (RTB(5),STS)
!   EQUIVALENCE (RTQ(1),CTEQ),(RTQ(2),STEQ),(RTQ(4),CTSQ),(RTQ(5),STSQ)
!   EQUIVALENCE relaced by assignments at the bottom of this routine
   LOGICAL SHARPE, SHARPS
   CHARACTER(10) TYP(2)
   DATA TYP / 'HORIZONTAL',' VERTICAL ' /
!*******************************************************************
!----- Some initializations and resets
! ELEMENTARY CHARGE
   QE=1.602176487D-19
   ZSYM=.TRUE.
   LST =LSTSET(NINT(wiendat(1)))
   LST2 = INT(10 * (wiendat(1) - NINT(wiendat(1))))
!  ... FACTEUR D'ECHELLE DES ChampS. UTILISE PAR 'SCALING'
!  2020 ASSUME SCAL=1.
   scal=1.D0
   XE = 0.D0
   XS = 0.D0
   XLIM = 0.D0
   IDRT = 0
   IFB = 0
   NND = 10
   XCE = 0.D0
   YCE = 0.D0
   ALE = 0.D0
   ZCE = 0.D0
   PHE = 0.D0
   TTA = 0.D0
   XCS = 0.D0
   YCS = 0.D0
   ALS = 0.D0
   ZCS = 0.D0
   PHS = 0.D0
!----- Default values of upper order of field derivative
   IDE=4
   IDB=2
!----- Default values of upper order for mid-plane extrapolation
   IDZ=2
!--------- WIENFILT
!2020 for wienfilter IDS=4 is used in ZGOUBI (set via call to MORORD), is order in calculation
   IDS=4        
!        write(6,*) 'SCALE,XL ',SCAL, XL
!        CALL WIENFI(SCAL,  XL)
!************************************************
!        SUBROUTINE wienfi(SCAL,XL)
!************************************************
! called with card #65 'WIENFILT' in ZGOUBI
   XL =wiendat(10)
   E  =wiendat(11)*SCAL
   B  =wiendat(12)*SCAL
   KHV =NINT( wiendat(13) )
   XE = wiendat(20)
   QLE(1) = wiendat(21)
   DLE(1) = wiendat(22)
   XLS = wiendat(50)
   QLS(1) = wiendat(51)
   DLS(1) = wiendat(52)
   DO I=0,5
     I1=I+1
     QCE(I1) =wiendat(30+I)
     CE(I1) =wiendat(40+I)
     QCS(I1) =wiendat(60+I)
     CS(I1) =wiendat(70+I)
   ENDDO
   TE=0.D0
   TS=0.D0
   CTE=COS(TE)
   STE=SIN(TE)
   CTS=COS(TS)
   STS=SIN(TS)
   TEQ=0.D0
   TSQ=0.D0
   CTEQ=COS(TEQ)
   STEQ=SIN(TEQ)
   CTSQ=COS(TSQ)
   STSQ=SIN(TSQ)
!----------- Champ DE FUITE
   SHARPE=QLE(1)*DLE(1) .LE. 0.D0
   SHARPS=QLS(1)*DLS(1) .LE. 0.D0        
   write(16,'(A)') ' ********** Wien Filter (numerical model) **********'
   IF(SHARPE) THEN
!------- Correction for entrance wedge
     FINTE = XE
     XE=0.D0
     GAPE = -DLE(1)
     WRITE(16,'(A)') ' Entrance hard edge is to be implemented'
     WEDGE = .TRUE.
     WDGE = -TE
   ENDIF
   IF(SHARPS) THEN
!------- Correction for exit wedge
     FINTS = XLS
     XLS=0.D0
     GAPS = -DLS(1)
     WRITE(16,'(A)') ' Exit hard edge is to be implemented'
     WEDGS = .TRUE.
     WDGS = -TS
   ENDIF
!---------------------------------------------------
!          KHV = 0 (act as a DRIFT) OR 1 (H SEPARATION) OR 2 ( V SEPARATION)
!          E  ( V/M )  = E-FIELD
!          B  ( T )    = B-FIELD
!---------------------------------------------------
   IF(KHV.eq.0) then
     write(16,'(A)') ' ++++++++++ SEPARATOR OFF +++++++'
     write(16,'(A,F12.5,A,/)') ' Will therefore be treated as a drift with length ',XL,' m'
   ELSE  
     PRF = BORO*CL9*QST *(DPREF+HDPRF)
     WRITE(16,'(A,A,A,A)') ' ',trim(TYP(KHV)),' ELECTROSTATIC MASS SEPARATOR'
     write(16,'(A,e14.7,A)') ' Reference momentum   = ',boro,' kG.cm'
     WRITE(16,'(A,1P,G11.5,A,/,3(A,G12.5,A,/),A,G12.5,/,A,G12.5)') &
       ' Length               = ',XL,'    m', &
       ' E                    = ',E,'   V/m', &
       ' B                    = ',B,'   T', &
       ' Mass   of particles  = ',XMAT,'   MeV/c2', &
       ' Charge of particles  = ',QST, &
       ' Reference beta       = ',PRF/SQRT(PRF*PRF+XMAT*XMAT)
         
     IF(abs(B) .GT. fprec) WRITE(16,'(A,1P,G12.5)') ' Beta wanted = -E/c.B = ',E/(-B*CL)

     WRITE(16,'(/,5x,A)') 'ENTRANCE FACE'
     WRITE(16,'(5x,A,f7.3,A,2f7.3,A,A)') 'DX = ',XE, &
        ',  LAMBDA_E, LAMBDA_B = ',QLE(1),DLE(1),' cm', &
        '    (hard-edge if LAMBDA_E * LAMBDA_B = 0 )'
     IF(QLE(1) .NE. 0.D0) WRITE(16,'(5x,A,6F9.5,A)') &
       ' COEFFICIENTS DE E :',(QCE(I),I=1,6),'  (unused if hard-edge)'
     IF(DLE(1) .NE. 0.D0) WRITE(16,'(5x,A,6F9.5,A)') &
       ' COEFFICIENTS DE B :',(CE(I),I=1,6),'  (unused if hard-edge)'

     WRITE(16,'(/,5x,A)') 'EXIT FACE'
     WRITE(16,'(5x,A,f7.3,A,2f7.3,A,A)') 'DX = ',XLS, &
        ',  LAMBDA_E, LAMBDA_B = ',QLS(1),DLS(1),' cm', &
        '    (hard-edge if LAMBDA_E * LAMBDA_B = 0 )'
     IF(QLS(1) .NE. 0.D0) WRITE(16,'(5x,A,6F9.5,A)') &
       ' COEFFICIENTS DE E :',(QCS(I),I=1,6),'  (unused if hard-edge)'
     IF(DLS(1) .NE. 0.D0) WRITE(16,'(5x,A,6F9.5,A)') &
       ' COEFFICIENTS DE B :',(CS(I),I=1,6),'  (unused if hard-edge)'
!----- change units: XL->cm, B->kG, E->MeV/cm
     XL=XL*100.D0
     XI = 0.D0
     XLIM = XL + XE + XLS
     XF = XLIM
     XS = XL + XE
     EM(1)=E*1.D-8
     BM(1)=B*10.D0
     IF    (KHV .EQ. 1) THEN
       BM(6)=0.D0
       EM(6)=.5D0*PI
     ELSEIF(KHV .EQ. 2) THEN
       EM(6)=0.D0
       BM(6)=-.5D0*PI
     ENDIF
     IF(B .EQ. 0.D0) KFLD=LC
     IF(E .EQ. 0.D0) KFLD=MG
     IF(E*E+B*B .EQ. 0.D0) KFLD=0
!----- DEFINITION DES ANGLES DE COIN
!        (=0 DEG. DANS CETTE VERSION)
     IF(SHARPE) THEN
       IDRT = -1
       AM(1)=1.D0
       BBM(1)=0.D0
       CM(1)=-XE
     ELSE
       QI(1,1)=-EM(1)/QLE(1)
       DI(1,1)=-BM(1)/DLE(1)
       DO I=2,3
         QI(1,I)=-QI(1,I-1)/QLE(1)
         DI(1,I)=-DI(1,I-1)/DLE(1)
       ENDDO
     ENDIF
     IF(SHARPS) THEN
       IF(IDRT .EQ. -1) THEN
         IDRT = 2
       ELSE
         IDRT = 1
       ENDIF
       AM(2)=1.D0
       BBM(2)=0.D0
       CM(2)=-XS
     ELSE
       QS(1,1)=-EM(1)/QLS(1)
       DS(1,1)=-BM(1)/DLS(1)
       DO I=2,3
         QS(1,I)=-QS(1,I-1)/QLS(1)
         DS(1,I)=-DS(1,I-1)/DLS(1)
       ENDDO
     ENDIF
     IF( SHARPE .OR. SHARPS ) then
       WRITE(16,'(A,A)') "***  Warning : hard-edge fringe model entails vertical wedge" ,&
         " focusing simulated with first order kick ***"
     ENDIF
!      END SUBROUTINE WIENFI
      
!         Motion in this lmnt has no z-symm.
     ZSYM=.FALSE.
     DSREF = XL
!---------------------------------------------------------------------
!          XCE  = wiendat(ND+NND+1)
!          YCE  = wiendat(ND+NND+2)
!          ALE  = wiendat(ND+NND+3)
!          PAS = wiendat(ND)
!          write(6,*) '??????? in CHXC ',ND,NND,ND+NND+1
!          write(6,*) 'VALUES  in CHXC ',XCE,YCE,ALE
!          write(6,*) '@@@@@@@ in CHXC ',PAS
!          write(6,*) '+++++++ in CHXC ',KFLD,LC
     IF(KFLD.GE.LC) THEN
       IF(QST*XMAT .EQ. 0.D0) then
         write(16,'(A)') 'ERROR in WIENNUM:'
         write(16,'(A)') 'Mass and/or charge have not been defined prior to WIENNUM'
         write(6,'(/,A)') 'ERROR in WIENNUM:'
         write(6,'(A)') 'Mass and/or charge have not been defined prior to WIENNUM'
         STOP
       ENDIF
     ENDIF
!------ Some more actions on Magnetic Multipoles, BEND, etc.  :
!            - automatic positioning in SBR TRANSF,
!            - warning on z-foc. if sharp edge dipole field
!        IF( KPAS .GT. 0 ) THEN
!-------- KPAS=2 -> Variable step (not implemented)
!        ELSE
!-------- KPAS=0 -> Fixed step size of size PAS
     WRITE(16,'(/,5x,A,1P,G12.4,A,/)') 'Integration step :',PAS,' cm'
   ENDIF
!   EQUIVALENCE (RTB(1),CTE),(RTB(2),STE),(RTB(4),CTS),(RTB(5),STS)
!   EQUIVALENCE (RTQ(1),CTEQ),(RTQ(2),STEQ),(RTQ(4),CTSQ),(RTQ(5),STSQ)
   RTB(1)=CTE
   RTB(2)=STE
   RTB(4)=CTS
   RTB(5)=STS
   RTQ(1)=CTEQ
   RTQ(2)=STEQ
   RTQ(4)=CTSQ
   RTQ(5)=STSQ
END SUBROUTINE CHXC
!************************************************
!   SUBROUTINE RAZDRV(IOP)
!   --------------------------------------------------------
!   INITIALISATIONS DANS CHAMC.
!   INITIALISATIONS LIEES A L'ORDRE DE CALCUL ( 2, 25 OU 4 )
!   DU Champ B(X,Y,Z).
!   --------------------------------------------------------
!************************************************
SUBROUTINE RAZDRV(IOP)
!************************************************
   USE m4wienn, ONLY: B,E
   USE m4wienn3
   USE mCOMwfchamp
   IMPLICIT NONE
   INTEGER I,J,K,L,IOP
!*******************************************************************
   IF(IOP.eq.1 .or. IOP.eq.3) then
     DO I=1,3
       B(1,I)=0.D0
     ENDDO
     DO J=1,3
       DO I=1,3
         DB(I,J) = 0.D0
       ENDDO 
     ENDDO 
     DO K=1,3
       DO J=1,3
         DO I=1,3
           DDB(I,J,K) = 0.D0
           D3BX(I,J,K)=0.D0
           D3BY(I,J,K)=0.D0
           D3BZ(I,J,K)=0.D0
         ENDDO 
       ENDDO 
     ENDDO 
     DO L=1,3
       DO K=1,3
         DO J=1,3
           DO I=1,3
             D4BX(I,J,K,L)=0.D0
             D4BY(I,J,K,L)=0.D0
             D4BZ(I,J,K,L)=0.D0
           ENDDO 
         ENDDO 
       ENDDO 
     ENDDO 
     DO J=1,5
       DO I=1,5
         BZ0(I,J) = 0.D0
       ENDDO 
     ENDDO 
   ENDIF
!
   IF(IOP.eq.2 .or. IOP.eq.3) then
     DO I=1,3
       E(1,I)=0.D0
     ENDDO
     DO J=1,3
       DO I=1,3
         DE(I,J) = 0.D0
           D3EX(I,J,K)=0.D0
           D3EY(I,J,K)=0.D0
           D3EZ(I,J,K)=0.D0
       ENDDO 
     ENDDO 
     DO K=1,3
       DO J=1,3
         DO I=1,3
           DDE(I,J,K) = 0.D0
         ENDDO 
       ENDDO 
     ENDDO 
     DO L=1,3
       DO K=1,3
         DO J=1,3
           DO I=1,3
             D4EX(I,J,K,L)=0.D0
             D4EY(I,J,K,L)=0.D0
             D4EZ(I,J,K,L)=0.D0
           ENDDO 
         ENDDO 
       ENDDO 
     ENDDO 
     DO J=1,5
       DO I=1,5
         EZ0(I,J) = 0.D0
       ENDDO 
     ENDDO
   ENDIF
END SUBROUTINE RAZDRV
!************************************************
!   SUBROUTINE TRANSF(QSHROE,VSHROE,QSHROS,VSHROS)
!   ----------------------------------------------------------------
!   Called by WIENFIN in DYNAC (by AIMANT and QUASEX in ZGOUBI).
!   APPELLE INTEGR POUR LE CALCUL DES IMAX TRAJECTOIRES DU FAISCEAU.
!   ----------------------------------------------------------------
!************************************************
SUBROUTINE TRANSF(QSHROE,VSHROE,QSHROS,VSHROS)
!************************************************
   USE m4beam
   USE m4wienn, ONLY: LST,ZSYM
   USE m4wienn1
   USE m4wienn2, ONLY: X,IT
   USE m4wienn5, ONLY: IDRT
   IMPLICIT NONE
   REAL(8) XO
   INTEGER MSR
   INTEGER KEX
! to be checked
   PARAMETER (MSR=8)
   CHARACTER(2) QSHROE(MSR),QSHROS(MSR)
   REAL(8) VSHROE(MSR),    VSHROS(MSR)
   LOGICAL CHGRFE,CHGRFS,CHPFE,CHPFS,EVNT,BACKW,DRT
   LOGICAL MIRROR
   DATA MIRROR / .FALSE. /
   DATA BACKW / .FALSE. /
!*******************************************************************
!   write(6,*) 'In TRANSF ',LST     
   IF(LST .GE. 1 ) CALL CTRLB(1)

   CHGRFE= NINT(VSHROE(MSR)).NE.0
   CHGRFS= NINT(VSHROS(MSR)).NE.0

   CHPFE = ( XFE .NE. 0.D0 )
   CHPFS = ( XFS .NE. 0.D0 )
!   write(16,*)   
!   write(16,*) 'DBX In TRANSF2 ',XFE,XFS,CHGRFE,CHGRFS,CHPFE,CHPFS     
!   write(16,*)      

! 2020 KSPN seems to have to do with spin in ZGOUBI; not implemented in DYNAC, therefore set KSPN=0
!      KSPN=0
!      KCSR=0         
!----- Events, such as spin tracking, in-flight decay, etc...
!        EVNT = KSPN .EQ. 1 .OR. KCSR .EQ. 1 
!2020 Take EVNT as .false. or .true. ?
   EVNT = .false.
                  
!----- Droite de coupure entree
!        write(16,*) 'DBX In TRANSF2a ',IDRT     
   DRT = IDRT .EQ. -1 .OR. IDRT .GE. 2

!------ Some initialisations in SBR DEVTRA...
!2020 fix this (supposedly set in CHXC ??)
!        X=XI
   XO=X
!        write(16,*) 'DBX In TRANSF3 ',LST,EVNT,DRT,X     
!        write(16,*) 'DBX In TRANSF4 ',ZSYM
!        write(16,*) 'DBX In TRANSF5 ',CHGRFE,CHPFE,CHGRFS,CHPFS 
   
   DO IT=1,ngood
!2020   next line and write(16,100) below can be removed when transferring to dynac
     KEX=1
     IF(.NOT. ZSYM ) THEN
!       write(16,*) 'DBX LOOP ',IT
       CALL INITRA(IT)
       X=XO
!       write(16,*) 'DBX NUM ytzp in ',it,y,t,z,p,x,tar
!       write(16,*) 'DBX i,ytzp=',it,"y,t,z,p"
!       if(IT.eq.245) stop
!       write(6,*) 'before call to change: ',WEDGE,WDGE,FINTE,GAPE < these are not used or altered within this routine
!       write(6,*) 'are we changing: ',CHGRFE,chpfe
       
       IF( CHGRFE ) CALL CHANRF(QSHROE,VSHROE)

       IF( CHPFE  ) CALL CHAREF(XFE,0.D0,0.D0)

       IF( DRT  ) CALL DRTENT

!2020 issue with # of args in  CALL INTEGR(EVNT,BACKW,MIRROR,KFLD) in ZGOUBI, ok in DYNAC
!                        SUBROUTINE INTEGR(EVNT,BACKW,MIRROR)
!            write(6,*) 'before call to integr: ',WEDGE,WDGE,FINTE,GAPE
       CALL INTEGR(BACKW,MIRROR)
!            STOP
!            write(16,*) 'NUM ytzp after INT ',it,y,t,z,p,x,tar
!            if(it.eq.9) then
!               write(6,*) 'Done for now'
!               STOP
!            endif   
       IF( CHPFS  ) CALL CHAREF(XFS,0.D0,0.D0)
       IF( CHGRFS ) THEN
!                write(6,*) 'i,ytzp=',it,y,t,z,p
! next write useful for comparison with ZGOUBI, but not needed for DYNAC
!                WRITE(16,100)'A',KEX,X,Y,T,Z,P,IT
! 100            FORMAT(2X,A1,2X,I3,8X,F9.3,4F10.3,8X,I5)
         CALL CHANRF(QSHROS,VSHROS)
       ENDIF

       CALL MAJTRA(IT)

     ELSE
!            CALL DEJACA(IT)
     ENDIF
 !1    CONTINUE
   ENDDO
!        write(16,*) 'DBX In TRANSF7 LST ',LST     

   IF(LST .GE. 1 ) CALL CTRLB(2)

   MIRROR = .FALSE.
   BACKW = .FALSE.
END SUBROUTINE TRANSF
!************************************************
SUBROUTINE CTRLB(K)
!************************************************
   USE m4wienn5, ONLY: XSTP,DIVB,ALAPL,RTN
   IMPLICIT NONE
   INTEGER K,I
!*******************************************************************
   IF(k.eq.1) then
     XSTP = 0.D0
     DIVB = 0.D0
     DO I=1,3
       ALAPL(I) = 0.D0
       RTN(I) = 0.D0
     ENDDO
     ALAPL(4)=0.D0
   ELSEIF(K.eq.2) then
     IF(XSTP .EQ. 0.D0) RETURN
     DIVB = DIVB/XSTP
     DO I = 1,3
       ALAPL(I) = ALAPL(I)/XSTP
       RTN(I) = RTN(I)/XSTP
     ENDDO
     ALAPL(4) = ALAPL(4)/XSTP
     WRITE(16,'(5x,A,f10.0,A,/,10x,A,9x,A,8x,A)') &
       'MAXWELL CONDITIONS  (',XSTP,'  STEPS )  :', &
       'DIV(B)','LAPLACIAN(B)','ROT(B)'
     WRITE(16,'(7x,1P,G12.4,5X,G12.4,6X,G12.4,2(/,24X,G12.4,6X,G12.4))') &
       DIVB,(ALAPL(I),RTN(I),I=1,3)
     WRITE(16,'(10x,A,G12.4)') 'LAPLACIAN SCALAR =',ALAPL(4)
   ENDIF
END SUBROUTINE CTRLB       
!************************************************
!   SUBROUTINE INITRA(I)
!   ***COORDONNEES DE LA TRAJECTOIRE I ,INITIALISATION
!************************************************
SUBROUTINE INITRA(I)
!************************************************
   USE DynacConstants
   USE m4beam
   USE m4wienn2
   IMPLICIT NONE
   REAL(8) bref,gref,gpai,bpai,fdi
   INTEGER I
!*******************************************************************
   bref=vref/vl
   gref=1.d0/sqrt(1.D0-bref*bref)
   gpai=f(7,i)/xmat
   bpai=sqrt(1.D0-1.d0/(gpai*gpai))
   fdi=bpai/bref * gpai/gref
   IT = I
   Y=F(2,I)
   T=F(3,I)*0.001D0
   Z=F(4,I)
   P=F(5,I)*0.001D0
!   DP=F(1,I)
!   DP=FD(I) FD(I) is w.r.t. COG....need w.r.t. REF
   DP=FDI
!   write(6,*) 'In initra Q,Q(i)=',qst,f(9,i)
!   QT = AMQ(2,I)
!2020        QBR =    QST*BORO*DP
!            QBR = f(9,i)*BORO*DP
   QBR = QST*BORO*DP
!   write(96,*) 'In initra QBR,q=',i,qst,qbr,f(9,i),boro,dp
!   BRI = QT/QBR
   BRI = 1.D0/QBR
!   SAR= F(6,I) <---total path length in ZGOUBI, not needed in dynac 
!   AMT = AMQ(1,I) <-- using XMAT instead
!----- AMQ(2,I) = Q/QE
!        TAR = F(7,I)   *1.D5 <--- F(7,I) accumulated time in ZGOUBI in mu_second
   TAR = F(6,I)   *1.D5 *1.D6
END SUBROUTINE INITRA
!************************************************
SUBROUTINE CHANRF(QSHRO,VSHRO)
!************************************************
   USE DynacConstants
   USE m4beam
   USE m4wiena1
   USE m4wienn2
   IMPLICIT NONE
   REAL(8) CP,CX,DL,DS,DTAR,QBRO,SX,UX,UY,UZ,TEMP,XL,XR,XS
   REAL(8) YL,YO,YR,YS,ZL,ZO,ZR,ZS,PP
   INTEGER MSR,NSR,KSR
   PARAMETER (MSR=8)
! to be checked
   CHARACTER(2) QSHRO(MSR)
   REAL(8) VSHRO(MSR)
!*******************************************************************
!-----------------------------------------------
!CHANGEMENT DE REFERENCE PARTICULE PAR PARTICULE
!-----------------------------------------------
   NSR = NINT(VSHRO(MSR))
!   write(16,*) 'DBX In CHANRF MSR,VSHRO(MSR),NSR,XS=',msr,vshrO(MSR),nsr,QSHRO(1),VSHRO(1)
   KSR = 1
   DO
     IF    (QSHRO(KSR).EQ.'XS') THEN
       XS = VSHRO(KSR)
       YO=Y
       Y= Y          + XS*SIN(T)  /COS(T)
       XL=XS
       YL=-YO+Y
       DL=SQRT(XL*XL+YL*YL)
       DL=SIGN(DL,XL)
       DS = DL/COS(P)
!     SAR= SAR+DS
       Z=Z+DL*TAN(P)
       QBRO = QBR*CL9
!     DTAR = DS / (QBRO/SQRT(QBRO*QBRO+AMT*AMT)*CL9)
       DTAR = DS / (QBRO/SQRT(QBRO*QBRO+XMAT*XMAT)*CL9)
       TAR = TAR + DTAR
     ELSEIF(QSHRO(KSR).EQ.'YS') THEN
       YS = VSHRO(KSR)
       Y = Y-YS
     ELSEIF(QSHRO(KSR).EQ.'ZS') THEN
       ZS = VSHRO(KSR)
       Z = Z-ZS
     ELSEIF(QSHRO(KSR).EQ.'XR') THEN
       XR = VSHRO(KSR)
       CX = COS(XR)
       SX = SIN(XR)
! Position vector:
       TEMP = Y * CX + Z * SX
       Z   = -Y * SX + Z * CX
       Y = TEMP
! Velocity vector:
       CP = COS(P)
       UX = CP*COS(T)
       UY = CP*SIN(T)
       UZ = SIN(P)
       TEMP =  UY * CX + UZ * SX
       UZ   = -UY * SX + UZ * CX
       UY = TEMP
       T = ATAN2(UY,UX)
       P = ASIN(UZ)
     ELSEIF(QSHRO(KSR).EQ.'YR') THEN
       YR = VSHRO(KSR)
       ZO=Z
       PP = ATAN(TAN(P)/COS(T))
       Z=Z*COS(PP)/COS(PP-YR)
       PP=PP-YR
       P = ATAN2(TAN(PP),1.D0/COS(T))
       XL = -Z *SIN(YR)
       ZL = -ZO + Z*COS(YR)
       DL=SQRT(XL*XL+ZL*ZL)
       DL=SIGN(DL,XL)
       DS = DL/COS(T)/COS(P)
!     SAR= SAR+DS
       Y=Y+DS*COS(P)*SIN(T)
       QBRO = QBR*CL9
!     DTAR = DS / (QBRO/SQRT(QBRO*QBRO+AMT*AMT)*CL9)
       DTAR = DS / (QBRO/SQRT(QBRO*QBRO+XMAT*XMAT)*CL9)
       TAR = TAR + DTAR
     ELSEIF(QSHRO(KSR).EQ.'ZR') THEN
       ZR = VSHRO(KSR)
       YO=Y
       Y=Y*COS(T)/COS(T-ZR)
       T=T-ZR
       XL=-Y*SIN(ZR)
       YL=-YO+Y*COS(ZR)
       DL=SQRT(XL*XL+YL*YL)
       DL=SIGN(DL,XL)
       DS = DL/COS(P)
!     SAR= SAR+DS
       Z=Z+DL*TAN(P)
       QBRO = QBR*CL9
!     DTAR = DS / (QBRO/SQRT(QBRO*QBRO+AMT*AMT)*CL9)
       DTAR = DS / (QBRO/SQRT(QBRO*QBRO+XMAT*XMAT)*CL9)
       TAR = TAR + DTAR
     ENDIF
     KSR = KSR+1
     IF(KSR.GT.NSR) EXIT
   ENDDO
END SUBROUTINE CHANRF
!************************************************
SUBROUTINE DRTENT
!************************************************
   USE m4wienn2, ONLY: Y,T,Z,P,X
   USE m4wienn5, ONLY: AM,BBM,CM
   IMPLICIT NONE
   REAL(8) CT,ST,DEN
   REAL(8) DL,XN
!*******************************************************************
!-----------------------------
!     Droite de coupure entree
!-----------------------------
   CT=COS(T)
   ST=SIN(T)
   DEN = AM(1)*CT+BBM(1)*ST
! CARTESIEN
   XN = (-CM(1)*CT+X*BBM(1)*ST-Y*BBM(1)*CT)/DEN
   Y  = (-CM(1)*ST-X*AM(1)*ST+Y*AM(1)*CT)/DEN
   DL = (XN-X)/CT
!   SAR = SAR + DL/COS(P)
   Z = Z + DL*TAN(P)
   X = XN
END SUBROUTINE DRTENT
!************************************************
!   SUBROUTINE INTEGR(BACKW,MIRROR)
!   -------------------------------------------------------------
!   APPELE PAR TRANSF.
!   CALCULE UNE TRAJECTOIRE DE X A XLIM; DXI=PAS EN X OU EN ANGLE
!   PAS = PAS EN S : cf. DEPLA, COFIN
!   -------------------------------------------------------------
!************************************************
SUBROUTINE INTEGR(BACKW,MIRROR)
!************************************************
   USE DynacConstants, ONLY: VL, PI, RPEL
   USE m4beam, ONLY: XMAT
   USE m4wiena1
   USE m4wienn, ONLY: LST
   USE m4wienn2
   USE m4wienn4
   USE m4wienn5, ONLY: WDGE, WDGS, FINTE, FINTS, GAPE, GAPS, &
                       AFB, BFB, CFB, AM, BBM, CM, IDRT, &
                       WEDGE, WEDGS, IFB   
   IMPLICIT NONE
   REAL(8) DLIM,PI24,AL,Z2,CL1,BL,COSTA,CT,ST,D,DX,PAF,X2,Y2,XFINAL
   REAL(8) DTAR,QBRO
   INTEGER MXSTEP,ISORT,KDR,KFB,LST2,NSTEP
! to be checked
   LOGICAL BACKW,MIRROR
   PARAMETER (DLIM = 1.D-6)
!-- Max integration steps in an lmnt
   PARAMETER (MXSTEP=10000)
   PARAMETER (PI24= 2.467401101D0)
   LOGICAL BACK,skip
!*******************************************************************
   skip=.false.
!   DATA WDGE, WDGS, FINTE, FINTS, GAPE, GAPS / 6*0.D0 /
!     write(6,*) 
!     write(6,*) 'Start of integr: ',WEDGE,WDGE,FINTE,GAPE
!     write(6,*) 

   KDR = 2
   ISORT=1
   CT=COS(T)
   ST=SIN(T)

   IF(LST .EQ. 2) THEN
     LST2 =2
   ELSE
      LST2=0
   ENDIF
!   IF(KPAS .NE. 0)  THEN     <--- not implemented
!------- 3-region step &/or variable step
!        ENDIF
   NSTEP = 0
   X2 = X
   Y2 = Y
   Z2 = Z
!        write(6,*) 'In Integr FI0 ',WEDGE
!        write(6,*) 'In Integr FI1 ',X,Y,Z
!        write(6,*) 'In Integr FI2 ',IT,BRI
!        write(6,*) 'In Integr 1 CONTINUE ',pi24,T
!----- DEBUT DE BOUCLE SUR DXI
!      Start loop on DXI
   DO
!   1 CONTINUE
!---------------------  Some tests to possibly stop integration
     NSTEP = NSTEP+1
!    write(6,*)
!    write(6,*)'INTEGR step, Z pos ',NSTEP,X,DTAR
!    IF(NSTEP .EQ. 29) then
!      write(6,*) 'Forced stop'
!      stop
!    ENDIF
     IF(NSTEP .GT. MXSTEP) then
       write(6,*) 'Too many integration steps (SBR INTEG)'
       STOP
     ENDIF
     BACK = T*T .GT. PI24
     IF(.NOT.BACKW) THEN
!------- PARTICLES BENT BACKWARD THOUGH NOT ALLOWED ARE STOPPED
       IF(BACK) THEN
         write(6,*) 'Particle(s)going backward (SBR INTEG)'
         STOP
       ENDIF
     ENDIF
!    Calculate the field at each integration step
     CALL CHAMC(X2,Y2,Z2)
!     write(6,*) 'Forced stop CHAMC'
!     stop
! 7    CONTINUE
!2020 remove next line 
!        IF(NSTEP .EQ. 10) STOP
     IF(NSTEP .EQ. 1) THEN
!-------- Entrance wedge correction in BEND, in MULTIPOL(if non zero B1),
!          write(6,*) 'In integr after 7:',T,Z,P,WDGE,FINTE,GAPE
!          write(6,*) 
!          write(16,*) 'DBX In integr after 7:',WEDGE,T,Z,P,WDGE,FINTE,GAPE
!          write(6,*)   
       IF(WEDGE) CALL WEDGKI(1,T,Z,P,WDGE,FINTE,GAPE)
     ENDIF
!        write(16,*) 'DBX In Integr before DEVTRA ',Y,T,Z,P,X,TAR,IT,qbr
     CALL DEVTRA
!        write(6,*) 'Forced stop DEVTRA'
!        stop
!        write(6,*) 'In Integr after  DEVTRA ',Y,T,Z,P
!        write(6,*) 'In Integr after DEVTRA2 idrt=',IDRT

!C FM 08/99        IF(IDRT .GE. 2) THEN
     IF(IDRT .GE. 1) THEN
!------- DROITE(S) DE COUPURE EN SORTIE
!          "Droite" has to be intersected by trajectory within X<XLIM (X cannot
!          be > XLIM)

!--------- COORDONNEES CARTESIENNES
       D = ABS(AM(KDR)*X + BBM(KDR)*Y + CM(KDR))
!       write(16,*) 'DBX In Integr after IF(IDRT .GE. 1) ',kdr,d,dxi,t

       IF(D .LT. DXI) THEN
         AL = AM(KDR)
         BL = BBM(KDR)
         CL1 = -D
         ST = SIN(T)
         CT = COS(T)
         COSTA = AL*CT + BL*ST
         PAF = D/COSTA
         IF(.NOT.MIRROR) THEN
!------------- Step onto the exit 'DROITE'
           CALL DEPLA(PAF)
           COSTA=AL*CT+BL*ST
!           CALL ITER(AL,BL,CL1,PAF,COSTA,*97)
!           CALL COFIN(Y,T,Z,P,X,TAR,*97)
           CALL ITER(AL,BL,CL1,PAF,COSTA)
           CALL COFIN(Y,T,Z,P,X,TAR)
!C FM 08/99                  IF    (KDR .EQ. IDRT) THEN
           IF(KDR .GE. IDRT) THEN
!--------------- i.e., IDRT=1 or 2
             XFINAL = XLIM
             skip=.true.
!             GOTO 6
             EXIT
           ELSEIF(KDR .LT. IDRT) THEN
!---------------- Thus, IDRT > 2
!---------------- There are (IDRT-1)>2 "droites en sorties" (e.g., spectrometer detector planes)
             KDR = KDR + 1
             CT=COS(T)
             ST=SIN(T)
!             GOTO 1
             CYCLE
           ENDIF
         ELSEIF(MIRROR) THEN
           IF(BACK) THEN
             PAF = -PAF
             CALL DEPLA(PAF)
!             CALL COFIN(Y,T,Z,P,X,TAR,*97)
             CALL COFIN(Y,T,Z,P,X,TAR)
             XFINAL = -CM(IDRT)
             skip=.true.
!             GOTO 6
             EXIT
           ENDIF
         ENDIF
!------------- if .not.mirror etc.
       ENDIF
     ENDIF ! IDRT .GE. 1

!        write(6,*) 'In Integr IFB=',ifb
!-----------------------    TEST  EFB's in Multipoles etc.
!                                        IFB set to .ne.0 due to mixed sharp edge+FF
     IF(IFB .NE. 0 ) THEN
!------ Entrance or exit EFB's
!------ COORDONNEES CARTESIENNES
       KFB = 0
       IF( AFB(1)*X + BFB(1)*Y + CFB(1) .LE. 0.D0 ) THEN
         IF( IFB .EQ. -1 .OR. IFB .EQ. 2 ) KFB=1
!--------- EFB entree
       ELSEIF(AFB(2)*X + BFB(2)*Y + CFB(2) .LE. 0.D0 ) THEN
         IF( IFB .EQ. 1 .OR. IFB .EQ. 2 ) KFB=2
!--------- EFB sortie
       ENDIF

       IF( KFB .NE. 0 ) THEN
         D = ABS(AFB(KFB)*X + BFB(KFB)*Y + CFB(KFB))
         IF(D .LT. DXI) THEN
           AL = AFB(KFB)
           BL = BFB(KFB)
           CL1 = -D
           ST = SIN(T)
           CT = COS(T)
           COSTA = AL*CT + BL*ST
           PAF = D/COSTA
           CALL DEPLA(PAF)
           COSTA=AL*CT+BL*ST
!           CALL ITER(AL,BL,CL1,PAF,COSTA,*97)
!           CALL COFIN(Y,T,Z,P,X,TAR,*97)
           CALL ITER(AL,BL,CL1,PAF,COSTA)
           CALL COFIN(Y,T,Z,P,X,TAR)
           CT=COS(T)
           ST=SIN(T)
!           IF(ABS(D) .GT. DLIM) GOTO 1
           IF(ABS(D) .GT. DLIM) CYCLE
         ENDIF
       ENDIF
     ENDIF
!-------- ifb .ne. 0
     DX=XLIM-X
!        write(6,*) 'In Integr XLIM,X,DX,mirror=',XLIM,X,DX,mirror
!        write(6,*) 'In Integr DXI,DX/DXI=',DXI,DX/DXI
     IF(DX/DXI .LT. 1.D0) THEN
       IF(.NOT.MIRROR) THEN
!         GOTO 2
         EXIT
       ELSE
         IF(.NOT.BACK) then
             write(6,*) 'reached field limit in optical element in SBR INTEGR'
             STOP
         endif  
       ENDIF
     ENDIF
     PAF = PAS
!        write(6,*) 'In Integr before depla PAF=',PAF
     CALL DEPLA(PAF)
!        write(6,*) 'In Integr before cofin1=',LST2,PAF
!        write(6,*) 'In Integr before cofin2=',IT
!        write(16,*) 'DBX In Integr before cofin=',Y,T,Z,P,X,TAR
!        write(6,*) 'In Integr before cofin4=',TAR
!     CALL COFIN(Y,T,Z,P,X,TAR,*97)
     CALL COFIN(Y,T,Z,P,X,TAR)
!        write(16,*) 'DBX In Integr after  cofin=',Y,T,Z,P,X,TAR
!        write(6,*) 'In Integr after  cofin4=',TAR
     CT=COS(T)
     ST=SIN(T)
     X2 = X
     Y2 = Y
     Z2 = Z
!   GOTO 1
   ENDDO
!---------  FIN DE BOUCLE SUR DXI
!             End loop on DXI
! 2    CONTINUE
   if(.NOT. skip) then
     AL=1.D0
     BL=0.D0
     CL1=-DX
     PAF=DX/CT
     CALL DEPLA(PAF)
     COSTA=AL*CT+BL*ST
!     CALL ITER(AL,BL,CL1,PAF,COSTA,*97)
!     CALL COFIN(Y,T,Z,P,X,TAR,*97)
     CALL ITER(AL,BL,CL1,PAF,COSTA)
     CALL COFIN(Y,T,Z,P,X,TAR)
     XFINAL = XLIM
   endif
! 6    CONTINUE
   DX=XFINAL-X
   IF(ABS(DX) .GT. DLIM) THEN
     CT=COS(T)
     ST=SIN(T)
     X=XFINAL
     Y=Y+(DX*ST)/CT
     Z=Z+(DX*TAN(P))*(1.D0/CT)
     PAF = DX/(CT*COS(P))
!          SAR= SAR+PAF
     QBRO = QBR*CL9
!          DTAR = PAF / (QBRO/SQRT(QBRO*QBRO+AMT*AMT)*CL9)
     DTAR = PAF / (QBRO/SQRT(QBRO*QBRO+XMAT*XMAT)*CL9)
     TAR = TAR + DTAR
   ENDIF
!-------- Wedge correction in BEND, in MULTIPOL with non zero B1, etc.
   IF(WEDGS) CALL WEDGKI(2,T,Z,P,WDGS,FINTS,GAPS)

! 97   CONTINUE
END SUBROUTINE INTEGR
!************************************************
!   SUBROUTINE CHAMC(X,Y,Z)
!   --------------------------------------------------------------
!   Champ CALCULE. APPELE PAR INTEGR A CHAQUE PAS D'INTEGRATION.
!   CALCULE, A PARTIR D'UNE FORMULE, LE Champ ET SES DERIVEES DANS
!   LE PLAN MEDIAN, AU POINT COURANT X,Y,Z=0.
!   --------------------------------------------------------------
!************************************************
SUBROUTINE CHAMC(X,Y,Z)
!************************************************
   USE m4wiena1
   USE m4wienn, ONLY: B,E,KFLD,MG,LC,ML,IDB,IDE,IDZ
   USE m4wienn3
   USE m4wienn4
   USE mCOMchafui
   USE mCOMmultpe
   USE mCOMmultpl
   USE mCOMwfchamp
   IMPLICIT NONE
   REAL(8) Y,Z,X
   REAL(8) Y0,Z0
   INTEGER MCOEF,MPOL
   PARAMETER(MPOL=10)
   PARAMETER(MCOEF=6)
!*******************************************************************
   CALL RAZDRV(KFLD)
!     write(6,*) 'In CHAMC KFLD2 ',EM(6),BM(6)

!    ELSEIF(KUASEX .EQ. 21) THEN
!----- WIENFILTER
!----- Electric component
   Y0=Y
   Z0=Z
   IF(EM(6) .NE. 0.D0) CALL ROTX(EM(6),Y0,Z0)
   CALL BENDF(EM(1),MPOL,XE,XS,QCE,QCS,QLE,QLS,QI,QS,RTQ,X,Y0,EZ0)
   CALL SYMMED(Z0,IDZ,EZ0,E,DE,DDE,D3EX,D3EY,D3EZ,D4EX,D4EY)
   CALL XROTB(EM(6),E,DE,DDE,D3EX,D3EY,D3EZ,D4EX,D4EY,D4EZ)

!----- Magnetic component
   Y0=Y
   Z0=Z
   IF(BM(6) .NE. 0.D0) CALL ROTX(BM(6),Y0,Z0)
   CALL BENDF(BM(1),MPOL,XE,XS,CE,CS,DLE,DLS,DI,DS,RTB,X,Y0,BZ0)
   CALL SYMMED(Z0,IDZ,BZ0,B,DB,DDB,D3BX,D3BY,D3BZ,D4BX,D4BY)
   CALL XROTB(BM(6),B,DB,DDB,D3BX,D3BY,D3BZ,D4BX,D4BY,D4BZ)
!   ENDIF (KUASEX .EQ. 21)

   IF    (KFLD .EQ. MG) THEN
     CALL DBDXYZ(IDB,DB,DDB,D3BX,D3BY,D3BZ,D4BX,D4BY,D4BZ)
   ELSEIF(KFLD .EQ. LC) THEN
     CALL DBDXYZ(IDE,DE,DDE,D3EX,D3EY,D3EZ,D4EX,D4EY,D4EZ)
   ELSEIF(KFLD .EQ. ML) THEN
     CALL DBDXYZ(IDE,DE,DDE,D3EX,D3EY,D3EZ,D4EX,D4EY,D4EZ)
     CALL DBDXYZ(IDB,DB,DDB,D3BX,D3BY,D3BZ,D4BX,D4BY,D4BZ)
   ENDIF
END SUBROUTINE CHAMC
!************************************************
SUBROUTINE CHAREF(XC,YC,A)
!************************************************
   USE DynacConstants, ONLY: VL, PI, RPEL
   USE m4beam, ONLY: XMAT
   USE m4wiena1
   USE m4wienn2
   IMPLICIT NONE
   REAL(8) XC,YC,A
   REAL(8) DTAR,QBRO
   REAL(8) DL,DS,XL,YL,YO
!*******************************************************************
!     -----------------------------------------------
!     CHANGEMENT DE REFERENCE PARTICULE PAR PARTICULE
!     -----------------------------------------------
   YO=Y
   Y=((Y-YC)*COS(T)+XC*SIN(T))/COS(T-A)
   T=T-A
   XL=XC-Y*SIN(A)
   YL=YC-YO+Y*COS(A)
   DL=SQRT(XL*XL+YL*YL)
   DL=SIGN(DL,XL)
   DS = DL/COS(P)
!   SAR= SAR+DS
   Z=Z+DL*TAN(P)
   QBRO = QBR*CL9
!   DTAR = DS / (QBRO/SQRT(QBRO*QBRO+AMT*AMT)*CL9)
   DTAR = DS / (QBRO/SQRT(QBRO*QBRO+XMAT*XMAT)*CL9)
   TAR = TAR + DTAR
END SUBROUTINE CHAREF            
!************************************************
SUBROUTINE ROTX(A,Y,Z)
!************************************************
   USE DynacConstants, ONLY: PI
   IMPLICIT NONE
   REAL(8) A,Y,Z
   REAL(8) YY,C,S
!*******************************************************************
!----- Rotation sens trigo
   IF(A.EQ.PI/4.D0) THEN
     YY=(Y + Z) / SQRT(2.D0)
     Z=(-Y + Z) / SQRT(2.D0)
   ELSE
     C=COS(A)
     S=SIN(A)
     YY= Y*C + Z*S
     Z=-Y*S + Z*C
   ENDIF
   Y=YY
END SUBROUTINE ROTX
!************************************************
SUBROUTINE BENDF(BN,MPOL,XE,XS,CE,CS,DLE,DLS,DE,DS,RTB,X,Y,BZ0)
!************************************************
   USE DynacConstants, ONLY: PI
   USE m4wienn2, ONLY: BRI
   USE m4wienn4, ONLY: XLIM
   IMPLICIT NONE
   REAL(8) BN,XE,XS,X,Y
   REAL(8) G1, G2
   REAL(8) BZ,BZX,BZXX,BZXXX,BZXXY,BZXY,BZXYY,BZY,BZYY,BZYYY,CTE,CTE2,CTS,CTS2
   REAL(8) SE,SS,STE,STE2,STS,STS2,XLS
   REAL(8) GE,DGE,D2GE,D3GE,D4GE,D5GE,D6GE,GS,DGS,D2GS,D3GS,D4GS,D5GS,D6GS
   INTEGER MPOL,MCOEF,IOPIN,IOPOU
   PARAMETER(MCOEF=6)
   REAL(8) CE(MCOEF), CS(MCOEF)
   REAL(8) DLE(MPOL),DLS(MPOL),DE(MPOL,MCOEF),DS(MPOL,MCOEF),RTB(MPOL)
   REAL(8) BZ0(5,*)
   DATA G1, G2 /0.d0,0.d0/
!*******************************************************************
   CTE=RTB(1)
   STE=RTB(2)
   CTS=RTB(4)
   STS=RTB(5)
!-----  dSE/dx=-cosTE=-CTE , dSE/dy = -sinTE =-STE
!-----  dSS/dx=-cosTS=-CTS , dSS/dy = +sinTS =+STS
   SE = ( (XE-X)*CTE - Y*STE )

   IF( SE*SE .LT. 1.D-16) SE=0.d0

   IF(SE*SE .LE. XE*XE) THEN
     IF(DLE(1) .NE. 0.d0) THEN
       SE=SE/DLE(1)
       CALL DRVG(4,CE,SE,GE,DGE,D2GE,D3GE,D4GE,D5GE,D6GE)
!C     >                                             D7GE,D8GE,D9GE,D10GE)
       DGE  = DGE  * DE(1,1)*BRI
       D2GE = D2GE * DE(1,2)*BRI
       D3GE = D3GE * DE(1,3)*BRI
       D4GE = D4GE * DE(1,4)*BRI
! 2024-May-09 in ZGOUBI, IOPIN is set in bendi.f: IOPIN = NINT(A(NOEL,30))	
! In dynac, in CHXC A(NOEL,) corresponds to wiendat(). Still to check if this should be used.
! For now, initialize IOPIN here. Also see IOPOU further down
       IOPIN=0            
       IF(IOPIN.LT.0) THEN
           IF(SE.LT.0.D0) THEN
             SE = -SE*DLE(1)
             GE = 2.D0 * (GE - 0.5D0)*SE/XE
             DGE  = 2.D0 * DGE  * SE/XE !!! + 2.D0 * (GE - 0.5D0)/XE
             D2GE = 2.D0 * D2GE * SE/XE !!! + 4.D0 * DGE/XE
             D3GE = 2.D0 * D3GE * SE/XE !!! + 6.D0 * DGE/XE
             D4GE = 2.D0 * D4GE * SE/XE !!! + 8.D0 * DGE/XE
           ELSE
             GE = 0.D0
             DGE = 0.D0
             D2GE= 0.D0
             D3GE= 0.D0
             D4GE= 0.D0
           ENDIF
       ENDIF
     ELSE
!--------- DLE=0. => XE=0.
       GE = 1.D0
       DGE = 0.D0
       D2GE= 0.D0
       D3GE= 0.D0
       D4GE= 0.D0
     ENDIF
   ELSE
     IF(SE .GT. 0.D0) THEN
       GE= 0.D0
     ELSE
       GE = 1.D0
     ENDIF
     DGE = 0.D0
     D2GE= 0.D0
     D3GE= 0.D0
     D4GE= 0.D0
   ENDIF

   XLS = XLIM-XS
   SS = -( (XS-X)*CTS + Y*STS )

   IF( SS*SS .LT. 1.D-16) SS=0.D0

   IF(SS*SS .LE. XLS*XLS) THEN
     IF(DLS(1) .NE. 0.D0) THEN
       SS = SS/DLS(1)
       CALL DRVG(4,CS,SS,GS,DGS,D2GS,D3GS,D4GS,D5GS,D6GS)
!C     >                                             D7GS,D8GS,D9GS,D10GS)
       DGS  = DGS  * DS(1,1)*BRI
       D2GS = D2GS * DS(1,2)*BRI
       D3GS = D3GS * DS(1,3)*BRI
       D4GS = D4GS * DS(1,4)*BRI
! 2024-May-09 in ZGOUBI, IOPOU is set in bendi.f: IOPOU = NINT(A(NOEL,50))	
! In dynac, in CHXC A(NOEL,) corresponds to wiendat(). Still to check if this should be used.
! For now, initialize IOPOU here. Also see IOPIN higher up
       IOPOU=0            
       IF(IOPOU.LT.0) THEN
           IF(SS.LT.0.D0) THEN
             SS = -SS*DLS(1)
             GS = 2.D0 * (GS - 0.5D0)*SS/XLS
             DGS  = 2.D0 * DGS  * SS/XLS !!! + 2.D0 * (GS - 0.5D0)/XLS
             D2GS = 2.D0 * D2GS * SS/XLS !!! + 4.D0 * DGS/XLS
             D3GS = 2.D0 * D3GS * SS/XLS !!! + 6.D0 * DGS/XLS
             D4GS = 2.D0 * D4GS * SS/XLS !!! + 8.D0 * DGS/XLS
           ELSE
             GS = 0.D0
             DGS = 0.D0
             D2GS= 0.D0
             D3GS= 0.D0
             D4GS= 0.D0
           ENDIF
       ENDIF
     ELSE
!--------- DLS=0. => XS=0.
       GS = 1.D0
       DGS = 0.D0
       D2GS= 0.D0
       D3GS= 0.D0
       D4GS= 0.D0
     ENDIF
   ELSE
     IF(SS .GT. 0.D0) THEN
       GS= 0.D0
     ELSE
       GS = 1.D0
     ENDIF
     DGS = 0.D0
     D2GS= 0.D0
     D3GS= 0.D0
     D4GS= 0.D0
   ENDIF

   CTE2=CTE*CTE
   STE2=STE*STE
   CTS2=CTS*CTS
   STS2=STS*STS

!C        BZ = ( GE+GS-1.D0 )*BN*BRI
   BZ = (( GE+GS-1.D0 )*BN + G1*Y + G2*Y**2)*BRI

   BZX=  DGE*CTE - DGS*CTS
!C        BZY=  DGE*STE + DGS*STS
   BZY=  DGE*STE + DGS*STS + (G1 + 2D0*G2*Y)*BRI

   BZXX= D2GE*CTE2    + D2GS*CTS2
   BZXY= D2GE*CTE*STE - D2GS*CTS*STS
!C        BZYY= D2GE*STE2    + D2GS*STS2
   BZYY= D2GE*STE2    + D2GS*STS2 + 2D0*G2*BRI

   BZXXX=  D3GE*CTE2*CTE - D3GS*CTS2*CTS
   BZXXY=  D3GE*CTE2*STE + D3GS*CTS2*STS
   BZXYY=  D3GE*CTE*STE2 - D3GS*CTS*STS2
   BZYYY=  D3GE*STE2*STE + D3GS*STS2*STS

!C        BZX4=  D4GE*CTE2*CTE2    + D4GS*CTS2*CTS2
!C        BZX3Y= D4GE*CTE2*CTE*STE - D4GS*CTS2*CTS*STS
!C        BZX2Y2=D4GE*CTE2*STE2    + D4GS*CTS2*STS2
!C        BZXY3= D4GE*CTE*STE2*STE - D4GS*CTS*STS2*STS
!C        BZY4=  D4GE*STE2*STE2    + D4GS*STS2*STS2

!C Due to reminicences from ancient times
   BZ0(1,1)=BZ
   BZ0(2,1)=BZX
   BZ0(1,2)=BZY
   BZ0(3,1)=BZXX
   BZ0(2,2)=BZXY
   BZ0(1,3)=BZYY
   BZ0(4,1)=BZXXX
   BZ0(3,2)=BZXXY
   BZ0(2,3)=BZXYY
   BZ0(1,4)=BZYYY
!C   BZ0(5,1)=BZX4
!C   BZ0(4,2)=BZX3Y
!C   BZ0(3,3)=BZX2Y2
!C   BZ0(2,4)=BZXY3
!C   BZ0(1,5)=BZY4
END SUBROUTINE BENDF
!************************************************
SUBROUTINE SYMMED(Z,IDZ,BZ0,B,DB,DDB,D3BX,D3BY,D3BZ,D4BX,D4BY)
!************************************************
   IMPLICIT NONE
   REAL(8) Z
   REAL(8) B0,B1,B2,B11,B12,B22,B111,B112,B122,B222,B1111,B1112,B1122,B1222,B2222
   REAL(8) B33,ZB33,ZZB12,ZZB21,Z2B422,Z2B313,Z2B224,Z3B44,Z3B422,Z3B313,Z3B224
   INTEGER IDZ
   REAL(8) BZ0(5,5)
   REAL(8) B(5,3),DB(3,3),DDB(3,3,3)
   REAL(8) D3BX(3,3,3), D3BY(3,3,3), D3BZ(3,3,3)
   REAL(8) D4BX(3,3,3,3) ,D4BY(3,3,3,3)
!*******************************************************************
!     ---------------------------------------------------
!     CARTES  2-D  OU  ELEMENTS  DEFINIS  PAR  BZ(X,Y,0):
!     SYMMETRISE PAR RAPPORT AU PLAN MEDIAN
!     ---------------------------------------------------
! Reminicences from ancient times
   B0=BZ0(1,1)
   B1=BZ0(2,1)
   B2=BZ0(1,2)
   B11=BZ0(3,1)
   B12=BZ0(2,2)
   B22=BZ0(1,3)
   B111=BZ0(4,1)
   B112=BZ0(3,2)
   B122=BZ0(2,3)
   B222=BZ0(1,4)
   B1111=BZ0(5,1)
   B1112=BZ0(4,2)
   B1122=BZ0(3,3)
   B1222=BZ0(2,4)
   B2222=BZ0(1,5)
   B33=-(B11+B22)
! CALCUL DES DERIVEES DE BX, BY, BZ(X,Y,Z) PAR DEVELOPPEMENTS DE TAYLOR
! EN Z. LES DERIVEES PAR RAPPORT A Z SONT EXPRIMEES EN TERMES DE
! COMBINAISONS DES DERIVEES PAR RAPPORT A X ET Y DU PLAN MEDIAN.
!C        Z=Z1
   ZB33 = Z*B33
   DDB(1,1,1) = Z * B111
   DDB(2,1,1) = Z * B112
   DDB(2,2,1) = Z * B122
   DDB(2,2,2) = Z * B222

   ZZB12 = -Z * (DDB(1,1,1) + DDB(2,2,1))
   ZZB21 = -Z * (DDB(2,1,1) + DDB(2,2,2))
   DB(1,1) = Z*B11
   DB(2,1) = Z*B12
   DB(2,2) = Z*B22
   DB(3,1) = B1 + 0.5D0 * ZZB12
   DB(3,2) = B2 + 0.5D0 * ZZB21

   DDB(3,1,1)=B11
   DDB(3,2,1)=B12
   DDB(3,2,2)=B22

!----- CALCUL DE BX, BY, BZ(X,Y,Z) PAR EXTRAPOLATION EN Z
   B(1,1) = Z * B1 + Z * ZZB12 /6.D0
   B(1,2) = Z * B2 + Z * ZZB21 /6.D0
   B(1,3) = B0 + Z *  ZB33 * .5D0

   IF(IDZ.GE.3) THEN
!---- EXTRAPOLATION A L'ORDRE 3 EN Z
     D3BX(3,1,1) = B111
     D3BX(3,2,1) = B112
     D3BX(3,2,2) = B122
     D3BY(3,2,2) = B222

     IF(IDZ.GE.4) THEN

!--------- EXTRAPOLATION A L'ORDRE 4 EN Z
       D4BX(3,1,1,1) = B1111
       D4BX(3,2,1,1) = B1112
       D4BX(3,2,2,1) = B1122
       D4BX(3,2,2,2) = B1222
       D4BY(3,2,2,2) = B2222

       D4BX(3,3,3,1)=-(B1111+B1122)
       D4BX(3,3,3,2)=-(B1112+B1222)
       D4BY(3,3,3,2)=-(B1122+B2222)

       D3BX(2,1,1)= Z*B1112
       D3BX(2,2,1)= Z*B1122
       D3BX(2,2,2)= Z*B1222
       D3BZ(3,3,3)=Z*(B1111+2.D0*B1122+B2222)
       D3BX(3,3,1)=Z*D4BX(3,3,3,1)
       D3BX(3,3,2)=Z*D4BX(3,3,3,2)
       D3BY(3,3,2)=Z*D4BY(3,3,3,2)

       Z2B422=Z*D3BX(3,3,1)*.5D0
       Z2B313=Z*D3BX(3,3,2)*.5D0
       Z2B224=Z*D3BY(3,3,2)*.5D0

       Z3B44=Z*Z*D3BZ(3,3,3)
       Z3B422=Z*Z2B422/6.D0
       Z3B313=Z*Z2B313/6.D0
       Z3B224=Z*Z2B224/6.D0

       B(1,3) = B(1,3) + Z * Z3B44 /24.D0
       DB(1,1) = DB(1,1) + Z3B422
       DB(2,1) = DB(2,1) + Z3B313
       DB(2,2) = DB(2,2) + Z3B224

       DDB(3,1,1)=B11+Z2B422
       DDB(3,2,1)=B12+Z2B313
       DDB(3,2,2)=B22+Z2B224

       D3BX(1,1,1)=Z*B1111
       D3BY(2,2,2)=Z*B2222
     ENDIF
   ENDIF
END SUBROUTINE SYMMED
!************************************************
SUBROUTINE DBDXYZ(IDB,DB,DDB,D3BX,D3BY,D3BZ,D4BX,D4BY,D4BZ)
!************************************************
   IMPLICIT NONE
   INTEGER IDB
   REAL(8) DB(3,3),DDB(3,3,3)
   REAL(8) D3BX(3,3,3), D3BY(3,3,3), D3BZ(3,3,3)
   REAL(8) D4BX(3,3,3,3) ,D4BY(3,3,3,3) ,D4BZ(3,3,3,3)
!*******************************************************************
!     -----------------------------------------
!     Compute  derivatives di+j+k(B)/dXidYjdZk.
!     B stands for magnetic or electric field.
!     -----------------------------------------

!----- DERIVEES 1-ERES DE BX, BY, BZ(X,Y,Z)
!     INDICE 1 = ELEMENTS DIFFERENTIELS : DX, DY, OU DZ.
!     INDICE 2 DU TABLEAU = COORDONNEE : BX, BY, OU BZ,

   DB(3,3)  = - ( DB(1,1) + DB(2,2) )
   DB(1,2) = DB(2,1)
   DB(1,3) = DB(3,1)
   DB(2,3) = DB(3,2)

   IF(IDB .EQ. 1) RETURN

!----- DERIVEES 2-EMES DE BX, BY, BZ(X,Y,Z).
!     INDICES 1,2 = ELEMENTS DIFFERENTIELS : DX, DY, OU DZ.
!     INDICE 3 DU TABLEAU = COORDONNEE : BX, BY, OU BZ,

   DDB(3,3,1) = -(DDB(1,1,1) + DDB(2,2,1))
   DDB(3,3,2) = -(DDB(2,1,1) + DDB(2,2,2))
   DDB(3,3,3) = -(DDB(3,1,1) + DDB(3,2,2))

   DDB(1,2,1) = DDB(2,1,1)
   DDB(1,3,1) = DDB(3,1,1)
   DDB(2,3,1) = DDB(3,2,1)

   DDB(1,1,2) = DDB(2,1,1)
   DDB(2,1,2) = DDB(2,2,1)
   DDB(3,1,2) = DDB(3,2,1)
   DDB(1,2,2) = DDB(2,2,1)
   DDB(1,3,2) = DDB(3,2,1)
   DDB(2,3,2) = DDB(3,2,2)

   DDB(1,1,3) = DDB(3,1,1)
   DDB(2,1,3) = DDB(3,2,1)
   DDB(3,1,3) = DDB(3,3,1)
   DDB(1,2,3) = DDB(3,2,1)
   DDB(2,2,3) = DDB(3,2,2)
   DDB(3,2,3) = DDB(3,3,2)
   DDB(1,3,3) = DDB(3,3,1)
   DDB(2,3,3) = DDB(3,3,2)

   IF(IDB .EQ. 2) RETURN

!----- 0 = dDivB/dXZ, dDivB/dYZ
   D3BX(3,3,3)   =  -(D3BX(3,1,1)+D3BX(3,2,2))
   D3BY(3,3,3)   =  -(D3BX(3,2,1)+D3BY(3,2,2))
     
!----- DERIVEES 3-EMES DE BX
   D3BX(1,3,1) = D3BX(3,1,1)
   D3BX(2,3,1) = D3BX(3,2,1)
   D3BX(3,1,2) = D3BX(3,2,1)
   D3BX(1,3,2) = D3BX(3,2,1)
   D3BX(2,3,2) = D3BX(3,2,2)
   D3BX(1,1,3) = D3BX(3,1,1)
   D3BX(2,1,3) = D3BX(3,2,1)
   D3BX(1,2,3) = D3BX(3,2,1)
   D3BX(2,2,3) = D3BX(3,2,2)

!     DERIVEES 3-EMES DE BY
   D3BY(3,1,1) = D3BX(3,2,1)
   D3BY(3,2,1) = D3BX(3,2,2)
   D3BY(1,3,1) = D3BX(3,2,1)
   D3BY(2,3,1) = D3BX(3,2,2)
   D3BY(3,1,2) = D3BX(3,2,2)
   D3BY(1,3,2) = D3BX(3,2,2)
   D3BY(2,3,2) = D3BY(3,2,2)
   D3BY(1,1,3) = D3BX(3,2,1)
   D3BY(2,1,3) = D3BX(3,2,2)
   D3BY(1,2,3) = D3BX(3,2,2)
   D3BY(2,2,3) = D3BY(3,2,2)

!     DERIVEES 3-EMES DE BZ
   D3BZ(1,1,1) = D3BX(3,1,1)
   D3BZ(2,1,1) = D3BX(3,2,1)
   D3BZ(1,2,1) = D3BX(3,2,1)
   D3BZ(2,2,1) = D3BX(3,2,2)
   D3BZ(3,3,1) = D3BX(3,3,3)
   D3BZ(1,1,2) = D3BX(3,2,1)
   D3BZ(2,1,2) = D3BX(3,2,2)
   D3BZ(1,2,2) = D3BX(3,2,2)
   D3BZ(2,2,2) = D3BY(3,2,2)
   D3BZ(3,3,2) = D3BY(3,3,3)
   D3BZ(3,1,3) = D3BX(3,3,3)
   D3BZ(3,2,3) = D3BY(3,3,3)
   D3BZ(1,3,3) = D3BX(3,3,3)
   D3BZ(2,3,3) = D3BY(3,3,3)

   IF(IDB .EQ. 3) RETURN

!----- 0 = dDivB/dX2, dDivB/dXY, dDivB/dY2, dDivB/dZ2
   D3BX(3,3,1)   =  -(D3BX(1,1,1)+D3BX(2,2,1))
   D3BX(3,3,2)   =  -(D3BX(2,1,1)+D3BX(2,2,2))
   D3BY(3,3,2)   =  -(D3BX(2,2,1)+D3BY(2,2,2))
   D3BZ(3,3,3)   =  -(D3BX(3,3,1)+D3BY(3,3,2))

!    DERIVEES 3-EMES DE BX
   D3BX(1,2,1) = D3BX(2,1,1)
   D3BX(1,1,2) = D3BX(2,1,1)
   D3BX(2,1,2) = D3BX(2,2,1)
   D3BX(1,2,2) = D3BX(2,2,1)
   D3BX(3,1,3) = D3BX(3,3,1)
   D3BX(3,2,3) = D3BX(3,3,2)
   D3BX(1,3,3) = D3BX(3,3,1)
   D3BX(2,3,3) = D3BX(3,3,2)

!  DERIVEES 3-EMES DE BY
   D3BY(1,1,1) = D3BX(2,1,1)
   D3BY(2,1,1) = D3BX(2,2,1)
   D3BY(1,2,1) = D3BX(2,2,1)
   D3BY(2,2,1) = D3BX(2,2,2)
   D3BY(3,3,1) = D3BX(3,3,2)
   D3BY(1,1,2) = D3BX(2,2,1)
   D3BY(2,1,2) = D3BX(2,2,2)
   D3BY(1,2,2) = D3BX(2,2,2)
   D3BY(3,1,3) = D3BX(3,3,2)
   D3BY(3,2,3) = D3BY(3,3,2)
   D3BY(1,3,3) = D3BX(3,3,2)
   D3BY(2,3,3) = D3BY(3,3,2)

!------- DERIVEES 3-EMES DE BZ
   D3BZ(3,1,1) = D3BX(3,3,1)
   D3BZ(3,2,1) = D3BX(3,3,2)
   D3BZ(1,3,1) = D3BX(3,3,1)
   D3BZ(2,3,1) = D3BX(3,3,2)
   D3BZ(3,1,2) = D3BX(3,3,2)
   D3BZ(3,2,2) = D3BY(3,3,2)
   D3BZ(1,3,2) = D3BX(3,3,2)
   D3BZ(2,3,2) = D3BY(3,3,2)
   D3BZ(1,1,3) = D3BX(3,3,1)
   D3BZ(2,1,3) = D3BX(3,3,2)
   D3BZ(1,2,3) = D3BX(3,3,2)
   D3BZ(2,2,3) = D3BY(3,3,2)

!C        IF(IDB .EQ. 3) RETURN
!------- DERIVEES 4-EMES

   D4BZ(3,3,3,3)=D4BX(3,1,1,1) + 2.D0*D4BX(3,2,2,1) + D4BY(3,2,2,2)

!------- DERIVEES 4-EMES DE BX
   D4BX(1,3,1,1) = D4BX(3,1,1,1)
   D4BX(2,3,1,1) = D4BX(3,2,1,1)

   D4BX(3,1,2,1) = D4BX(3,2,1,1)
   D4BX(1,3,2,1) = D4BX(3,2,1,1)
   D4BX(2,3,2,1) = D4BX(3,2,2,1)

   D4BX(1,1,3,1) = D4BX(3,1,1,1)
   D4BX(2,1,3,1) = D4BX(3,2,1,1)
   D4BX(1,2,3,1) = D4BX(3,2,1,1)
   D4BX(2,2,3,1) = D4BX(3,2,2,1)

   D4BX(3,1,1,2) = D4BX(3,2,1,1)
   D4BX(3,2,1,2) = D4BX(3,2,2,1)
   D4BX(1,3,1,2) = D4BX(3,2,1,1)
   D4BX(2,3,1,2) = D4BX(3,2,2,1)

   D4BX(3,1,2,2) = D4BX(3,2,2,1)
   D4BX(1,3,2,2) = D4BX(3,2,2,1)
   D4BX(2,3,2,2) = D4BX(3,2,2,2)

   D4BX(1,1,3,2) = D4BX(3,2,1,1)
   D4BX(2,1,3,2) = D4BX(3,2,2,1)
   D4BX(1,2,3,2) = D4BX(3,2,2,1)
   D4BX(2,2,3,2) = D4BX(3,2,2,2)

   D4BX(1,1,1,3) = D4BX(3,1,1,1)
   D4BX(2,1,1,3) = D4BX(3,2,1,1)
   D4BX(1,2,1,3) = D4BX(3,2,1,1)
   D4BX(2,2,1,3) = D4BX(3,2,2,1)
   D4BX(3,3,1,3) = D4BX(3,3,3,1)

   D4BX(1,1,2,3) = D4BX(3,2,1,1)
   D4BX(2,1,2,3) = D4BX(3,2,2,1)
   D4BX(1,2,2,3) = D4BX(3,2,2,1)
   D4BX(2,2,2,3) = D4BX(3,2,2,2)
   D4BX(3,3,2,3) = D4BX(3,3,3,2)

   D4BX(3,1,3,3) = D4BX(3,3,3,1)
   D4BX(3,2,3,3) = D4BX(3,3,3,2)
   D4BX(1,3,3,3) = D4BX(3,3,3,1)
   D4BX(2,3,3,3) = D4BX(3,3,3,2)

!------- DERIVEES 4-EMES DE BY
   D4BY(3,1,1,1) = D4BX(3,2,1,1)
   D4BY(3,2,1,1) = D4BX(3,2,2,1)
   D4BY(1,3,1,1) = D4BX(3,2,1,1)
   D4BY(2,3,1,1) = D4BX(3,2,2,1)

   D4BY(3,1,2,1) = D4BX(3,2,2,1)
   D4BY(3,2,2,1) = D4BX(3,2,2,2)
   D4BY(1,3,2,1) = D4BX(3,2,2,1)
   D4BY(2,3,2,1) = D4BX(3,2,2,2)

   D4BY(1,1,3,1) = D4BX(3,2,1,1)
   D4BY(2,1,3,1) = D4BX(3,2,2,1)
   D4BY(1,2,3,1) = D4BX(3,2,2,1)
   D4BY(2,2,3,1) = D4BX(3,2,2,2)
   D4BY(3,3,3,1) = D4BX(3,3,3,2)

   D4BY(3,1,1,2) = D4BX(3,2,2,1)
   D4BY(3,2,1,2) = D4BX(3,2,2,2)
   D4BY(1,3,1,2) = D4BX(3,2,2,1)
   D4BY(2,3,1,2) = D4BX(3,2,2,2)

   D4BY(3,1,2,2) = D4BX(3,2,2,2)
   D4BY(1,3,2,2) = D4BX(3,2,2,2)
   D4BY(2,3,2,2) = D4BY(3,2,2,2)

   D4BY(1,1,3,2) = D4BX(3,2,2,1)
   D4BY(2,1,3,2) = D4BX(3,2,2,2)
   D4BY(1,2,3,2) = D4BX(3,2,2,2)
   D4BY(2,2,3,2) = D4BY(3,2,2,2)

   D4BY(1,1,1,3) = D4BX(3,2,1,1)
   D4BY(2,1,1,3) = D4BX(3,2,2,1)
   D4BY(1,2,1,3) = D4BX(3,2,2,1)
   D4BY(2,2,1,3) = D4BX(3,2,2,2)
   D4BY(3,3,1,3) = D4BX(3,3,3,2)

   D4BY(1,1,2,3) = D4BX(3,2,2,1)
   D4BY(2,1,2,3) = D4BX(3,2,2,2)
   D4BY(1,2,2,3) = D4BX(3,2,2,2)
   D4BY(2,2,2,3) = D4BY(3,2,2,2)
   D4BY(3,3,2,3) = D4BY(3,3,3,2)

   D4BY(3,1,3,3) = D4BX(3,3,3,2)
   D4BY(3,2,3,3) = D4BY(3,3,3,2)
   D4BY(1,3,3,3) = D4BX(3,3,3,2)
   D4BY(2,3,3,3) = D4BY(3,3,3,2)

!------- DERIVEES 4-EMES DE BZ
   D4BZ(1,1,1,1) = D4BX(3,1,1,1)
   D4BZ(2,1,1,1) = D4BX(3,2,1,1)
   D4BZ(1,2,1,1) = D4BX(3,2,1,1)
   D4BZ(2,2,1,1) = D4BX(3,2,2,1)
   D4BZ(3,3,1,1) = D4BX(3,3,3,1)

   D4BZ(1,1,2,1) = D4BX(3,2,1,1)
   D4BZ(2,1,2,1) = D4BX(3,2,2,1)
   D4BZ(1,2,2,1) = D4BX(3,2,2,1)
   D4BZ(2,2,2,1) = D4BX(3,2,2,2)
   D4BZ(3,3,2,1) = D4BX(3,3,3,2)

   D4BZ(3,1,3,1) = D4BX(3,3,3,1)
   D4BZ(3,2,3,1) = D4BX(3,3,3,2)
   D4BZ(1,3,3,1) = D4BX(3,3,3,1)
   D4BZ(2,3,3,1) = D4BX(3,3,3,2)

   D4BZ(1,1,1,2) = D4BX(3,2,1,1)
   D4BZ(2,1,1,2) = D4BX(3,2,2,1)
   D4BZ(1,2,1,2) = D4BX(3,2,2,1)
   D4BZ(2,2,1,2) = D4BX(3,2,2,2)
   D4BZ(3,3,1,2) = D4BX(3,3,3,2)

   D4BZ(1,1,2,2) = D4BX(3,2,2,1)
   D4BZ(2,1,2,2) = D4BX(3,2,2,2)
   D4BZ(1,2,2,2) = D4BX(3,2,2,2)
   D4BZ(2,2,2,2) = D4BY(3,2,2,2)
   D4BZ(3,3,2,2) = D4BY(3,3,3,2)

   D4BZ(3,1,3,2) = D4BX(3,3,3,2)
   D4BZ(3,2,3,2) = D4BY(3,3,3,2)
   D4BZ(1,3,3,2) = D4BX(3,3,3,2)
   D4BZ(2,3,3,2) = D4BY(3,3,3,2)

   D4BZ(3,1,1,3) = D4BX(3,3,3,1)
   D4BZ(3,2,1,3) = D4BX(3,3,3,2)
   D4BZ(1,3,1,3) = D4BX(3,3,3,1)
   D4BZ(2,3,1,3) = D4BX(3,3,3,2)

   D4BZ(3,1,2,3) = D4BX(3,3,3,2)
   D4BZ(3,2,2,3) = D4BY(3,3,3,2)
   D4BZ(1,3,2,3) = D4BX(3,3,3,2)
   D4BZ(2,3,2,3) = D4BY(3,3,3,2)

   D4BZ(1,1,3,3) = D4BX(3,3,3,1)
   D4BZ(2,1,3,3) = D4BX(3,3,3,2)
   D4BZ(1,2,3,3) = D4BX(3,3,3,2)
   D4BZ(2,2,3,3) = D4BY(3,3,3,2)
END SUBROUTINE DBDXYZ
!************************************************
SUBROUTINE XROTB(A,B,DB,DDB,D3BX,D3BY,D3BZ,D4BX,D4BY,D4BZ)
!************************************************
   IMPLICIT NONE
   INTEGER I,J,L,M
   REAL(8) A
!--omposantes du champ dans les axes tournes de A (sens trigo)
   REAL(8) B(5,3),DB(3,3),DDB(3,3,3)
   REAL(8) D3BX(3,3,3), D3BY(3,3,3), D3BZ(3,3,3)
   REAL(8) D4BX(3,3,3,3) ,D4BY(3,3,3,3) ,D4BZ(3,3,3,3)
   REAL(8) DYY,DYZ,B12,DB21,DB22,DB32,DB33,DDB331,DDB332,DDB333,DDB221,DDB321
   REAL(8) DDB222,DDB322,DZZ,DZY,DYY2,DYZ2,DDB211,DDB311,DZZ2
!*******************************************************************
   DYY=COS(A)
   DZZ=DYY
   DYZ=SIN(A)
   DZY=-DYZ
   DYY2=DYY*DYY
   DZZ2=DZZ*DZZ
   DYZ2=DYZ*DYZ

   B12=B(1,2)*DYY+B(1,3)*DZY
   B(1,3)=B(1,2)*DYZ+B(1,3)*DZZ
   B(1,2)=B12

   DB33  = - ( DB(1,1) + DB(2,2) )

!   dBx/dy=dBy/dx
   DB21 = DB(2,1)*DYY+DB(3,1)*DZY
!   dBx/dz=dBz/dx
   DB(3,1) = DB(2,1)*DYZ+DB(3,1)*DZZ
!   dBy/dy
   DB22 = DB(2,2)*DYY2+2.D0*DB(3,2)*DYY*DZY+DB33*DYZ2
!   dBy/dz=dBz/dy
   DB32 = DB(2,2)*DYZ*DYY+DB(3,2)*(DZZ*DYY+DYZ*DZY)+(DB33*DZZ*DZY)

   DB(2,1)=DB21
   DB(2,2)=DB22
   DB(3,2)=DB32

   DDB331 = -(DDB(1,1,1) + DDB(2,2,1))
   DDB332 = -(DDB(2,1,1) + DDB(2,2,2))
   DDB333 = -(DDB(3,1,1) + DDB(3,2,2))

!   d2Bx/dxdy=d2By/dx2
   DDB211 = DDB(2,1,1)*DYY+DDB(3,1,1)*DZY
!   d2Bx/dxdz=d2Bz/dx2
   DDB311 = DDB(2,1,1)*DYZ+DDB(3,1,1)*DZZ
!   d2Bx/dy2=d2By/dxdy
   DDB221 = DDB(2,2,1)*DYY2+2.D0*DDB(3,2,1)*DZY*DYY+DDB331*DYZ2
!   d2Bx/dydz=d2By/dxdz=d2Bz/dxdy
   DDB321 = DDB(2,2,1)*DYY*DYZ+DDB(3,2,1)*(DZY*DYZ+DYY*DZZ)+DDB331*DZY*DZZ
!   d2By/dy2
   DDB222 = ( DDB(2,2,2)*DYY+3.D0*DDB(3,2,2)*DZY )*DYY2+ ( 3.D0*DDB332*DYY+DDB333*DYZ )*DYZ2
!   d2By/dydz=d2Bz/dy2
   DDB322=DDB(2,2,2)*DYZ*DYY2+DDB(3,2,2)*DYY*(2.D0*DZY*DYZ+DYY*DZZ)+ DDB332*DZY*(DZY*DYZ+2.D0*DYY*DZZ)+DDB333*DYZ2*DZZ

   DDB(2,1,1) =DDB211
   DDB(3,1,1) =DDB311
   DDB(2,2,1) =DDB221
   DDB(3,2,1) =DDB321
   DDB(2,2,2) =DDB222
   DDB(3,2,2) =DDB322

   DO M=1,3
     DO L=1,3
       DO J=1,3
           D3BX(J,L,M)=0.D0
           D3BY(J,L,M)=0.D0
           D3BZ(J,L,M)=0.D0
           DO I=1,3
             D4BX(I,J,L,M)=0.D0
             D4BY(I,J,L,M)=0.D0
             D4BZ(I,J,L,M)=0.D0
           ENDDO
       ENDDO
     ENDDO
   ENDDO
END SUBROUTINE XROTB
!************************************************
SUBROUTINE DRVG(IG,C,S,G,DG,D2G,D3G,D4G,D5G,D6G)
!************************************************
   IMPLICIT NONE
   INTEGER IG
   REAL(8) S,G,DG,D2G,D3G,D4G,D5G,D6G
   REAL(8) C(*)
   REAL(8) POL,EP,DP,DU,D2P,D2U,D3P,D3U,D4P,D4U,D5P,D5U,D6U,D7U,D7G,D8U,D9U,D9G
   REAL(8) D8G,D10G
!*******************************************************************
   D2G = 0.D0
   D3G = 0.D0
   D4G = 0.D0
   D5G = 0.D0
   D6G = 0.D0
   D7G = 0.D0
   D8G = 0.D0
   D9G = 0.D0
   D10G = 0.D0

   POL = C(1)+(C(2)+(C(3)+(C(4)+(C(5)+C(6)*S)*S)*S)*S)*S
   EP = EXP(POL)
   G  = 1.D0/(1.D0+EP)
!--=1+EP, GU=1

   IF(IG .LE. 0) RETURN

   DP  = C(2)+(2.D0*C(3)+(3.D0*C(4) +(4.D0*C(5) +5.D0*C(6)*S)*S)*S)*S
   DU  = DP*EP
!----- (GU)' = 0
   DG =-DU*G*G

   IF(IG .LE. 1) RETURN

   D2P = 2.D0*C(3) +(6.D0*C(4) +(12.D0*C(5) +20.D0*C(6)*S)*S)*S
   D2U = D2P*EP + DP*DU
!----- (GU)'' = 0
   D2G=-G*(2.D0*DG*DU+G*D2U)

   IF(IG .LE. 2) RETURN

   D3P = 6.D0*C(4) +(24.D0*C(5) + 60.D0*C(6)*S)*S
   D3U = D3P*EP + 2.D0*D2P*DU + DP*D2U
!----- (GU)''' = 0
   D3G=-G*(3.D0*(D2G*DU+DG*D2U)+G*D3U)

   IF(IG .LE. 3) RETURN

   D4P = 24.D0*C(5) +120.D0*C(6)*S
   D4U = D4P*EP + 3.D0*D3P*DU + 3.D0*D2P*D2U + DP*D3U
!----- (GU)'''' = 0
   D4G=-G*(4.D0*(D3G*DU+DG*D3U)+6.D0*D2G*D2U+G*D4U)

   IF(IG .LE. 4) RETURN

   D5P = 120.D0*C(6)
   D5U = D5P*EP + 4.D0*D4P*DU + 6.D0*D3P*D2U + 4.D0*D2P*D3U + DP*D4U
!----- (GU)''''' = 0
   D5G=-G*(5.D0*(D4G*DU+DG*D4U)+10.D0*(D3G*D2U+D2G*D3U)+G*D5U)

   IF(IG .LE. 5) RETURN

   D6U = 5.D0*D5P*DU+ 10.D0*D4P*D2U+10.D0*D3P*D3U+ 5.D0*D2P*D4U+ DP*D5U
!----- (GU)""" = 0
   D6G=-G*( 6.D0*(D5G*DU+ DG*D5U)+ 15.D0*( D4G*D2U+ D2G*D4U)+20.D0*D3G*D3U+ G*D6U)

   IF(IG .LE. 6) RETURN

   D7U =15.D0*D5P*D2U+20.D0*D4P*D3U+15.D0*D3P*D4U+6.D0*D2P*D5U+DP*D6U
!----- (GU)"""' = 0
   D7G=-G*( 7.D0*(D6G*DU+ DG*D6U)+ 21.D0*( D5G*D2U+ D2G*D5U)+ &
       35.D0*(D4G*D3U + D3G*D4U)+ G*D7U)

   IF(IG .LE. 7) RETURN

   D8U =70.D0*D5P*D3U+56.D0*D4P*D4U+28.D0*D3P*D5U+8.D0*D2P*D6U+DP*D7U
!----- (GU)"""" = 0
   D8G=-G*( 8.D0*(D7G*DU+ DG*D7U)+ 28.D0*( D6G*D2U+ D2G*D6U)+ &
       56.D0*(D5G*D3U + D3G*D5U)+ 70.D0*D4G*D4U + G*D8U)

   IF(IG .LE. 8) RETURN

   D9U =126.D0*D5P*D4U+84.D0*D4P*D5U+36.D0*D3P*D6U+9.D0*D2P*D7U+DP*D8U
!----- (GU)""""' = 0
   D9G=-G*( 9.D0*(D8G*DU+ DG*D8U)+ 36.D0*( D7G*D2U+ D2G*D7U)+ &
       84.D0*(D6G*D3U + D3G*D6U)+ 126.D0*(D5G*D4U + D4G*D5U) + G*D9U)

END SUBROUTINE DRVG
!************************************************
SUBROUTINE COFIN(Y,T,Z,P,X,TAR)
!************************************************
   USE m4wienn, ONLY: KFLD,LC
   USE m4wienn2, ONLY: QBR,BRI
   USE m4wienn5, ONLY: XF,DXF,DQBRO,DTAR
   IMPLICIT NONE
   REAL(8) Y,T,Z,P,X,TAR
!*******************************************************************
!     ----------------------------------
!     COORDONNEES ABSOLUES EN FIN DE DS
!     APPELE PAR INTEGR
!     ----------------------------------
!   SAR=SAR+DS
   Y=Y+XF(2)
   Z=Z+XF(3)
   T=ATAN2(DXF(2),DXF(1))
   P=ATAN( DXF(3)/SQRT(DXF(1)*DXF(1)+DXF(2)*DXF(2)) )
   TAR = TAR + DTAR
   IF(KFLD.GE.LC) THEN
      QBR=QBR + DQBRO
!      BRI = QT/QBR
      BRI = 1.D0/QBR
   ENDIF
   X=X+XF(1)
END SUBROUTINE COFIN
!************************************************
SUBROUTINE DEPLA(DS)
!************************************************
   USE DynacConstants, ONLY: VL, PI, RPEL
   USE m4beam, ONLY: XMAT
   USE m4wiena1
   USE m4wienn, ONLY: KFLD,LC,IDS
   USE m4wienn2, ONLY: QBR
   USE m4wienn5, ONLY: XF,DXF,DQBRO,DTAR,U,DQBR,DDT
   IMPLICIT NONE
   REAL(8) DS
   INTEGER IMX,K,I,IK
   REAL(8) DV,QBRO,V
   REAL(8) RSU(18)
!     ----------------------------
!     CALCUL D'UN PAS EN CARTESIEN
!     ----------------------------
   PARAMETER (IMX=6)
!*******************************************************************
   RSU=reshape(U,(/18/))
! 2025 to translate U(3,6) to U(18), use fortran reshape for mapping, rename it RSU(18)
! alternative to "reshape" listed below
!   DO K=1,3
!     DO I=1,6
!       rsu(i+(k-1)*imx)=u(i,k)   
!     ENDDO
!   ENDDO
!
!CALCUL VECTEURS dR ET dU RESULTANT DE DS
!
   DO K=1,3
     XF(K)=0.D0
     DXF(K)=0.D0
   ENDDO
!
   DV=1.D0
   DO I=1,IDS
     V=DV*DS/DBLE(I)
     IK = I - IMX
     DO K=1,3
       IK = IK + IMX
       DXF(K)=DXF(K)+RSU(IK)*DV
       XF(K)=XF(K)+RSU(IK)*V
     ENDDO
     DV=V
   ENDDO
   IF(KFLD .GE. LC) THEN
!------ Electric or elctro-mag lmnt
     DQBRO=0.D0
     DTAR = 0.D0
     V=1.D0
     DO I=1,IDS
        V=V*DS/DBLE(I)
        DQBRO = DQBRO+DQBR(I)*V
        DTAR = DTAR+DDT(I)*V
!        write(6,*) 'DTAR1 at 35362 =',ids,ddt(i),dtar
     ENDDO
   ELSE
      QBRO = QBR*CL9
!      DTAR = DS / (QBRO/SQRT(QBRO*QBRO+AMT*AMT)*CL9)
      DTAR = DS / (QBRO/SQRT(QBRO*QBRO+XMAT*XMAT)*CL9)
!        write(96,*) 'DTAR2 at 35368 =',ds,dtar,QBRO,QBR,xmat,QBRO/SQRT(QBRO*QBRO+XMAT*XMAT)
   ENDIF
END SUBROUTINE DEPLA
!************************************************
SUBROUTINE ITER(A,B,C,DS,COSTA)
!************************************************
   USE m4wienn5, ONLY: XF
   IMPLICIT NONE
   REAL(8) A,B,C,DS,COSTA
   REAL(8) EPS,EPS2,ABSD,D,DM
   INTEGER I,ITMAX
   PARAMETER (EPS=1.D-6,ITMAX=1000)
   PARAMETER (EPS2=1.D-12)
!*******************************************************************
   DM=1.D30
!CALCUL INTERSECTION DE LA TRAJECTOIRE AVEC DROITE AX+BY+C=0
   DO I=1,ITMAX
     D=A*XF(1)+B*XF(2)+C
     ABSD = ABS(D)
     IF(ABSD .LE. EPS)  THEN
       IF(ABSD .LE. EPS2)  THEN
           RETURN
       ELSEIF(D.GT.DM.OR.D.EQ.0.D0 ) THEN
           RETURN
       ENDIF
     ENDIF
     DM=ABSD
     DS=DS-D/COSTA
     IF(DS*DS .GT. 1.D10) then
       write(6,*) 'Iter>itmax, or dist>1d5 in  SBR ITER'
       STOP
     endif  
     CALL DEPLA(DS)
! 1    CONTINUE
   ENDDO
! 99   CONTINUE
   write(6,*) 'Iter>itmax, or dist>1d5 in  SBR ITER'
   write(16,*) 'Iter>itmax, or dist>1d5 in  SBR ITER'
   STOP

END SUBROUTINE ITER
!************************************************
SUBROUTINE IMPDEV
!************************************************
   USE m4wienn3, ONLY: DB,DDB
   USE m4wienn5, ONLY: XSTP,DIVB,ALAPL,RTN
   IMPLICIT NONE
!*******************************************************************
!------- CONDITIONS DE MAXWELL
   XSTP = XSTP + 1.D0
   DIVB = DB(1,1) + DB(2,2) + DB(3,3)
   ALAPL(1) = DDB(1,1,1) + DDB(1,2,2) + DDB(1,3,3)
   ALAPL(2) = DDB(2,1,1) + DDB(2,2,2) + DDB(2,3,3)
   ALAPL(3) = DDB(3,1,1) + DDB(3,2,2) + DDB(3,3,3)
   RTN(1) = DB(2,3) - DB(3,2)
   RTN(2) = DB(3,1) - DB(1,3)
   RTN(3) = DB(1,2) - DB(2,1)
END SUBROUTINE IMPDEV
!************************************************
SUBROUTINE WEDGKI(IO,T,Z,P,WDGA,FINT,GAP)
!************************************************
   USE DynacConstants, ONLY: fprec
   USE m4wienn, ONLY: B
   IMPLICIT NONE
   REAL(8) T,Z,P,WDGA,FINT,GAP
   REAL(8) PSI,RHO,WEDG
   INTEGER IO
!*******************************************************************
   IF    (IO .EQ. 1) THEN
!-------- Entrance
      WEDG = WDGA + T
   ELSEIF(IO .EQ. 2) THEN
!-------- Exit
      WEDG = WDGA - T
   ENDIF
! Rho corresponds to the total field seen by the particle, i.e. contribution
!           of all Bi components in case of combined function (e.g., 'MULTIPOL' with dip+quad+...)
   if(abs(B(1,3)).le.fprec) then
     RHO = 1.D30
   else
     RHO = 1.D0/B(1,3)
   endif  
   PSI = FINT * GAP/RHO * (1.D0 + SIN(WEDG)**2)/COS(WEDG)
   P = P - Z * TAN(WEDG -PSI) / RHO
!        write(6,*) 'Forced stop WEDGKI',RHO,WEDG
!        stop
END SUBROUTINE WEDGKI
!************************************************
SUBROUTINE PVECT(I,J,K)
!************************************************
   USE m4wienn, ONLY: B,V
   USE m4wienn5, ONLY: U
   IMPLICIT NONE
   INTEGER I,J,K
!*******************************************************************
!     ----------------------------------------------
!     CALCUL DE LA DERIVEE DU PRODUIT VECTORIEL UxB
!     LE 1-ER  INDICE EST L'ORDRE DE DERIVATION /DS,
!     LE 2-EME INDICE EST LE NUMERO DE COORDONNEE,
!     EXEMPLE: B(2,3)=dBz/ds, V(3,2)=d2Vy/ds2
!     ----------------------------------------------
   V(I,1)=U(J,2)*B(K,3)-U(J,3)*B(K,2)
   V(I,2)=U(J,3)*B(K,1)-U(J,1)*B(K,3)
   V(I,3)=U(J,1)*B(K,2)-U(J,2)*B(K,1)
END SUBROUTINE PVECT
!************************************************
SUBROUTINE MAJTRA(I)
!************************************************
   USE DynacConstants, ONLY: VL, PI, RPEL
   USE m4beam, ONLY: f, fd, BORO
   USE m4wienn2
   IMPLICIT NONE
   INTEGER I
!*******************************************************************
!  Update coordinates of trajectory # I
   F(2,I)=Y
   F(3,I)=T*1000.D0
   F(4,I)=Z
   F(5,I)=P*1000.D0
!2020        DP=QBR/(QST*BORO)
   DP=QBR/(F(9,i)*BORO)
!   F(1,I)=DP
   FD(I)=DP
!   F(6,I)= SAR <--accumulated length in ZGOUBI
!   F(7,I)= TAR    *1.D-5           ! mu_second
   F(6,I)= TAR    *1.D-5 *1.D-6      
!   AMQ(1,I) = AMT
!   AMQ(2,I) = QT
END SUBROUTINE MAJTRA
!************************************************
SUBROUTINE DEVTRA
!************************************************
   USE DynacConstants, ONLY: VL, PI, RPEL
   USE m4beam, ONLY: XMAT
   USE m4wiena1
   USE m4wienn
   USE m4wienn2
   USE m4wienn3
   USE m4wienn5, ONLY: U,DQBR,DDT
   IMPLICIT NONE
   REAL(8) EU(5),CSV,DCSV,D2CSV,D3CSV,D4CSV,DBSB,D2BSB,D3BSB,D4BSB,D5BSB
   REAL(8) AM2,BRCQ,CP,D1SV,D21SV,D31SV,D41SV,QT,TP,VL1,XMUL
   REAL(8) RSDB(9),RSDDB(27)
   REAL(8) RSD3BX(27), RSD3BY(27), RSD3BZ(27)
   REAL(8) RSD4BX(81), RSD4BY(81), RSD4BZ(81)
   REAL(8) RSDE(9),RSDDE(27)
   REAL(8) RSD3EX(27), RSD3EY(27), RSD3EZ(27)
   REAL(8) RSD4EX(81), RSD4EY(81), RSD4EZ(81)
   INTEGER IMAX, IJMAX, IJLMAX, IM2, IM3
   INTEGER I,J,K,IKIJ,IJIM,IJK,IJL,IJLM,IJLM2,IK,IMIM2,IMIM3,JIM,KIJM,KIM,L,M,IJL2
!     -----------------------------------------
!     CALCULE u ET SES DERIVEES dnu/dsn, n=1,5,
!     i.e., calcul des coeffs des series de Taylor
!     (eqs. 2.2.4-5)
!     -----------------------------------------
   PARAMETER(IMAX=3, IJMAX=9, IJLMAX=27, IM2 = IMAX+IJMAX)
   PARAMETER(IM3 = IM2+IJLMAX)
!*******************************************************************
!-------------------------------------------------------------
!     CALCUL D'ADRESSE : ADRESSE(I,J) = I + (J-1)*IMAX
!     EXEMPLES:
!        DB(2,1) = DB(2)
!        DB(3,3) = DB(9)
!     CALCUL D'ADRESSE : ADRESSE(I,J,K) = I+(J-1)*IMAX+(K-1)*IMAX*JMAX
!     EXEMPLES:
!        DDB(3,1,1) = DDB(3)
!        DDB(3,3,1) = DDB(3*3**0+2*3**1+0*3**2)=DDB(9)
!-------------------------------------------------------------
! 2025 for the above, use fortran reshape for mapping
   RSDB=reshape(DB,(/9/))
   RSDDB=reshape(DDB,(/27/))
	
   RSD3BX=reshape(D3BX,(/27/))
   RSD3BY=reshape(D3BY,(/27/))
   RSD3BZ=reshape(D3BZ,(/27/))

   RSD4BX=reshape(D4BX,(/81/))
   RSD4BY=reshape(D4BY,(/81/))
   RSD4BZ=reshape(D4BZ,(/81/))

   RSDE=reshape(DE,(/9/))
   RSDDE=reshape(DDE,(/27/))

   RSD3EX=reshape(D3EX,(/27/))
   RSD3EY=reshape(D3EY,(/27/))
   RSD3EZ=reshape(D3EZ,(/27/))
		 
   RSD4EX=reshape(D4EX,(/81/))
   RSD4EY=reshape(D4EY,(/81/))
   RSD4EZ=reshape(D4EZ,(/81/))
!2020 use QT=1. (was defined as QT = AMQ(2,I) in ZGOUBI, but can use 1. in dynac)
   QT=1.D0
!CALCUL u=DX/DS
   CP=COS(P)
   U(1,1)=CP*COS(T)
   U(1,2)=CP*SIN(T)
   U(1,3)=SIN(P)

!   umod1 = sqrt(U(1,1)*U(1,1) +U(1,2)*U(1,2) +U(1,3)*U(1,3))
!   write(16,*)'DBX In devtra ',p,t,kfld,qbr,dqbr 
!   GOTO(1,2,3) KFLD
! 1    CONTINUE
   caseKFLD: select case(KFLD)
     case(1)
!--------------------------!
!----- MAGNETIC FIELD -----!
!--------------------------!
!CALCUL u'=uxB
       CALL PVECT(1,1,1)
       DO K=1,3
         U(2,K)=V(1,K)
       ENDDO 
!     umod2 = sqrt(U(2,1)*U(2,1) +U(2,2)*U(2,2) +U(2,3)*U(2,3))
!       IF(IDS.LE.2) GOTO 99
       IF(IDS.LE.2) exit caseKFLD
!     B'=dB/dS
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         KIM = KIM + IMAX
         IF(IDB.GE.1) THEN
           DO I=1,3
             IK = I + KIM
             TP=TP+U(1,I)*RSDB(IK)
           ENDDO
         ENDIF
         B(2,K)=TP
       ENDDO
!CALCUL u''=u'xB + uxB'
       CALL PVECT(1,1,2)
       CALL PVECT(2,2,1)
       DO K=1,3
         U(3,K)=V(1,K)+V(2,K)
       ENDDO 
!       IF(IDS.LE.3) GOTO 99
       IF(IDS.LE.3) exit caseKFLD
!CALCUL B''=d2B/ds2
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDB.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(2,I)*RSDB(IK)
!   
!          symetrie
!   
             IF(IDB.GE.2) THEN
               IKIJ = I + KIJM
               DO J=I,3
                 IF(I .EQ. J) THEN
                   XMUL=1.0D0
                 ELSE
                   XMUL=2.0D0
                 ENDIF
                 IJK = IKIJ + J*IMAX
                 TP=TP+XMUL*U(1,I)*U(1,J)*RSDDB(IJK)
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         B(3,K)=TP
       ENDDO
!CALCUL u'''=u''xB + 2*u'B' + uxB''
       CALL PVECT(1,1,3)
       CALL PVECT(2,2,2)
       CALL PVECT(3,3,1)
       DO K=1,3
         U(4,K)=V(1,K)+2.D0*V(2,K)+V(3,K)
       ENDDO 
!     umod4 = sqrt(U(4,1)*U(4,1) +U(4,2)*U(4,2) +U(4,3)*U(4,3))
!       IF(IDS.LE.4) GOTO 99
       IF(IDS.LE.4) exit caseKFLD
!     B'''=d3B/ds3
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDB.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(3,I)*RSDB(IK)
             IF(IDB.GE.2) THEN
               IMIM2 = I - IM2
               IKIJ = I + KIJM
               DO J=1,3
                 IJK = IKIJ + J*IMAX
                 TP=TP+3.D0*U(2,I)*U(1,J)*RSDDB(IJK)
!  
!              symetrie
!  
                 IF(J.GE.I) THEN
                   IF(IDB.GE.3) THEN
                     IJL2 = IMIM2 + J*IMAX
                     DO L = J,3
                       IF(J .EQ. I) THEN
                         IF(L .EQ. J) THEN
                           XMUL=1.0D0
                         ELSE
                           XMUL=3.0D0
                         ENDIF
                       ELSE
                         IF(L .EQ. J) THEN
                           XMUL=3.0D0
                         ELSE
                           XMUL=6.0D0
                         ENDIF
                       ENDIF
                       IJL = IJL2 + L*IJMAX
                       IF    ( K .EQ. 1 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3BX(IJL)
                       ELSEIF( K .EQ. 2 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3BY(IJL)
                       ELSEIF( K .EQ. 3 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3BZ(IJL)
                       ENDIF
                     ENDDO
                   ENDIF
                 ENDIF
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         B(4,K)=TP
       ENDDO
!CALCUL u''''=u'''xB + 3*u''xB' + 3*u'xB''+ B'''
       CALL PVECT(1,1,4)
       CALL PVECT(2,2,3)
       CALL PVECT(3,3,2)
       CALL PVECT(4,4,1)
       DO K=1,3
         U(5,K)=V(1,K)+3.D0*V(2,K)+3.D0*V(3,K)+V(4,K)
       ENDDO 
!     umod5 = sqrt(U(5,1)*U(5,1) +U(5,2)*U(5,2) +U(5,3)*U(5,3))
!       IF (IDS.LE.5) GOTO 99
       IF (IDS.LE.5) exit caseKFLD
!       B''''=d4B/ds4
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDB.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(4,I)*RSDB(IK)
             IF(IDB.GE.2) THEN
               IMIM3 = I - IM3
               IMIM2 = I - IM2
               IKIJ = I + KIJM
               DO J=1,3
                 IJK = IKIJ + J*IMAX
                 TP=TP+(4.D0*U(3,I)*U(1,J)+3.D0*U(2,I)*U(2,J))*RSDDB(IJK)
                 IF(IDB.GE.3) THEN
                   JIM = J*IMAX
                   IJIM = IMIM3 + JIM
                   IJL  = IMIM2 + JIM
                   DO L = 1,3
                     IJL = IJL + IJMAX
                     IF    (K .EQ. 1) THEN
                       TP = TP+6.D0*U(2,I)*U(1,J)*U(1,L)*RSD3BX(IJL)
                     ELSEIF(K .EQ. 2) THEN
                       TP = TP+6.D0*U(2,I)*U(1,J)*U(1,L)*RSD3BY(IJL)
                     ELSEIF(K .EQ. 3) THEN
                       TP = TP+6.D0*U(2,I)*U(1,J)*U(1,L)*RSD3BZ(IJL)
                     ENDIF
                     IF(J.GE.I) THEN
                       IF(L.GE.J) THEN
                         IF(IDB.GE.4) THEN
                           IJLM2 = IJIM + L*IJMAX
                           DO M=L,3
                             IF(J .EQ. I) THEN
                               IF(L .EQ. J) THEN
                                 IF(M .EQ. L) THEN
                                   XMUL=1.0D0
                                 ELSE
                                   XMUL=4.0D0
                                 ENDIF
                               ELSE
                                 IF(M .EQ. L) THEN
                                   XMUL=6.0D0
                                 ELSE
                                   XMUL=12.0D0
                                 ENDIF
                               ENDIF
                             ELSE
                               IF(L .EQ. J) THEN
                                 IF(M .EQ. L) THEN
                                   XMUL=4.0D0
                                 ELSE
                                   XMUL=12.0D0
                                 ENDIF
                               ELSE
                                 XMUL=12.0D0
                               ENDIF
                             ENDIF
                             IJLM = IJLM2 + M*IJLMAX
                             IF    (K .EQ. 1) THEN
                               TP = TP+U(1,I)*U(1,J)*U(1,L)*U(1,M)*RSD4BX(IJLM)*XMUL
                             ELSEIF(K .EQ. 2) THEN
                               TP = TP+U(1,I)*U(1,J)*U(1,L)*U(1,M)*RSD4BY(IJLM)*XMUL
                             ELSEIF(K .EQ. 3) THEN
                               TP = TP+U(1,I)*U(1,J)*U(1,L)*U(1,M)*RSD4BZ(IJLM)*XMUL
                             ENDIF
                           ENDDO
                         ENDIF
                       ENDIF
                     ENDIF
                   ENDDO
                 ENDIF
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         B(5,K)=TP
       ENDDO
!CALCUL   u'''''=u''''xB + 4*u'''xB' + 6*u''xB''+ 4*u'xB''' + B''''
       CALL PVECT(1,1,5)
       CALL PVECT(2,2,4)
       CALL PVECT(3,3,3)
       CALL PVECT(4,4,2)
       CALL PVECT(5,5,1)
       DO K=1,3
         U(6,K)=V(1,K)+4.D0*(V(2,K)+V(4,K))+6.D0*V(3,K)+V(5,K)
       ENDDO 
!     umod6 = sqrt(U(6,1)*U(6,1) +U(6,2)*U(6,2) +U(6,3)*U(6,3))
!     GOTO 99
!   ELSEIF(KFLD.EQ.2) THEN
! 2    CONTINUE
     case(2)
!--------------------------!
!----- ELECTRIC FIELD -----!
!----- E=e/Bro        -----!
!--------------------------!
!c          write(*,*)  ' devtra ids, ide = ',ids,ide
       AM2 = XMAT*XMAT
       BRCQ = QBR*CL9
!----- Wt=sqrt(p2+m2), p=beta.Wt/c
       CSV = SQRT(1.D0 + AM2/(BRCQ*BRCQ))
!Calcul (e.u)/Bro, Bro'
       EU(1)= E(1,1)*U(1,1)+E(1,2)*U(1,2)+E(1,3)*U(1,3)
       VL1=CL9/CSV
       DDT(1) = 1.D0/VL1
       DBSB=EU(1)/VL1
       DQBR(1)=DBSB*QBR
!Calcul u'=E/v + uxB - uBro'/Bro
       DO K=1,3
         U(2,K)=E(1,K)/VL1  - U(1,K)*DBSB
       ENDDO 
!       IF(IDS.LE.2) GOTO 99
       IF(IDS.LE.2) exit caseKFLD
!Calcul e'/Bro = (e/Bro)'|Bro=cste = E'|Bro=cste
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDE.GE.1) THEN
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(1,I)*RSDE(IK)
           ENDDO
         ENDIF
         E(2,K)=TP
       ENDDO
!Calcul (e.u)'/Bro, Bro''
       EU(2)= E(2,1)*U(1,1)+E(2,2)*U(1,2)+E(2,3)*U(1,3) &
          + E(1,1)*U(2,1)+E(1,2)*U(2,2)+E(1,3)*U(2,3)
       DCSV=QT*EU(1)/BRCQ-CSV*DBSB
       D1SV=DCSV/CL9
       DDT(2) =D1SV
       D2BSB=D1SV*EU(1)+EU(2)/VL1
       DQBR(2)=D2BSB*QBR
!Calcul u''=(1/v)'E + (e'/Bro)/v - 2Bro'/Brou' - Bro''/Brou
       DO  K=1,3
         U(3,K)=E(1,K)*D1SV + E(2,K)/VL1-2.D0*U(2,K)*DBSB - U(1,K)*D2BSB
       ENDDO
!       IF(IDS.LE.3) GOTO 99
       IF(IDS.LE.3) exit caseKFLD
!Calcul e''/Bro = E''|Bro=cste
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDE.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(2,I)*RSDE(IK)
             IF(IDE.GE.2) THEN
               IKIJ = I + KIJM
!   
!            symmetry
!   
               DO J=I,3
                 IF(I .EQ. J) THEN
                   XMUL=1.0D0
                 ELSE
                   XMUL=2.0D0
                 ENDIF
                 IJK = IKIJ + J*IMAX
                 TP=TP+XMUL*U(1,I)*U(1,J)*RSDDE(IJK)
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         E(3,K)=TP
       ENDDO
!Calcul (e.u)''/Bro, Bro'''
       EU(3)= E(3,1)*U(1,1)+E(3,2)*U(1,2)+E(3,3)*U(1,3) &
          + 2.D0*( E(2,1)*U(2,1)+E(2,2)*U(2,2)+E(2,3)*U(2,3)) &
          +          E(1,1)*U(3,1)+E(1,2)*U(3,2)+E(1,3)*U(3,3)
       D2CSV= QT*EU(2)/BRCQ - 2.D0*DBSB*DCSV - D2BSB*CSV
       D21SV=D2CSV/CL9
       DDT(3) = D21SV
       D3BSB=D21SV*EU(1)+2.D0*D1SV*EU(2)+EU(3)/VL1
       DQBR(3)=D3BSB*QBR
!Calcul u'''=(1/v)''E + 2(1/v)'(e'/Bro) + (e''/Bro)/v
!               - 3Bro'/Brou'' - 3Bro''/Brou' - Bro'''/Brou
       DO K=1,3
         U(4,K)=E(1,K)*D21SV + 2.D0*E(2,K)*D1SV + E(3,K)/VL1 &
               -3.D0*( DBSB*U(3,K) + D2BSB*U(2,K) ) - D3BSB*U(1,K)
       ENDDO
!       IF(IDS.LE.4) GOTO 99
       IF(IDS.LE.4) exit caseKFLD
!Calcul e'''/Bro = E'''|Bro=cste
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDE.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(3,I)*RSDE(IK)
             IF(IDE.GE.2) THEN
               IMIM2 = I - IM2
               IKIJ = I + KIJM
               DO J=1,3
                 IJK = IKIJ + J*IMAX
                 TP=TP+3.D0*U(2,I)*U(1,J)*RSDDE(IJK)
!   
!              symmetry
!   
                 IF(J.GE.I) THEN
                   IF(IDE.GE.3) THEN
                     IJL2 = IMIM2 + J*IMAX
                     DO L = J,3
                       IF(J .EQ. I) THEN
                         IF(L .EQ. J) THEN
                           XMUL=1.0D0
                         ELSE
                           XMUL=3.0D0
                         ENDIF
                       ELSE
                         IF(L .EQ. J) THEN
                           XMUL=3.0D0
                         ELSE
                           XMUL=6.0D0
                         ENDIF
                       ENDIF
                       IJL = IJL2 + L*IJMAX
                       IF    ( K .EQ. 1 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3EX(IJL)
                       ELSEIF( K .EQ. 2 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3EY(IJL)
                       ELSEIF( K .EQ. 3 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3EZ(IJL)
                       ENDIF
                     ENDDO
                   ENDIF
                 ENDIF
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         E(4,K)=TP
       ENDDO
!Calcul (e.u)'''/Bro, Bro''''
       EU(4)= E(4,1)*U(1,1)+E(4,2)*U(1,2)+E(4,3)*U(1,3) &
          + 3.D0* (  E(3,1)*U(2,1)+E(3,2)*U(2,2)+E(3,3)*U(2,3)) &
          + 3.D0* (  E(2,1)*U(3,1)+E(2,2)*U(3,2)+E(2,3)*U(3,3)) &
          +            E(1,1)*U(4,1)+E(1,2)*U(4,2)+E(1,3)*U(4,3)
       D3CSV= QT*EU(3)/BRCQ-3.D0*(DBSB*D2CSV + D2BSB*DCSV) - D3BSB*CSV
       D31SV=D3CSV/CL9
       DDT(4) =D31SV
       D4BSB=D31SV*EU(1)+3.D0*(D21SV*EU(2)+D1SV*EU(3))+EU(4)/VL1
       DQBR(4)=D4BSB*QBR
!Calcul u''''=(1/v)'''E+3(1/v)''(e'/Bro)+3(1/v)'(e''/Bro)+(1/v)E'''/Bro
!C               - 4Bro'/Brou''' - 6Bro''/Brou'' - 4Bro'''/Brou' - Bro''''/Brou
       DO K=1,3
         U(5,K)=E(1,K)*D31SV + 3.D0*E(2,K)*D21SV + 3.D0*E(3,K)*D1SV + E(4,K)/VL1 &
               -4.D0*(DBSB*U(4,K)+D3BSB*U(2,K))-6.D0*D2BSB*U(3,K)-D4BSB*U(1,K)
       ENDDO
!       IF(IDS.LE.5) GOTO 99
       IF(IDS.LE.5) exit caseKFLD
!Calcul e''''/Bro = E''''|Bro=cste
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDE.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(4,I)*RSDE(IK)
             IF(IDE.GE.2) THEN
               IMIM3 = I - IM3
               IMIM2 = I - IM2
               IKIJ = I + KIJM
               DO J=1,3
                 IJK = IKIJ + J*IMAX
                 TP=TP+(4.D0*U(3,I)*U(1,J)+3.D0*U(2,I)*U(2,J))*RSDDE(IJK)
                 IF(IDE.GE.3) THEN
                   JIM = J*IMAX
                   IJIM = IMIM3 + JIM
                   IJL  = IMIM2 + JIM
                   DO L = 1,3
                     IJL = IJL + IJMAX
                     IF    (K .EQ. 1) THEN
                       TP = TP+6.D0*U(2,I)*U(1,J)*U(1,L)*RSD3EX(IJL)
                     ELSEIF(K .EQ. 2) THEN
                       TP = TP+6.D0*U(2,I)*U(1,J)*U(1,L)*RSD3EY(IJL)
                     ELSEIF(K .EQ. 3) THEN
                       TP = TP+6.D0*U(2,I)*U(1,J)*U(1,L)*RSD3EZ(IJL)
                     ENDIF
                     IF(J.GE.I) THEN
                       IF(L.GE.J) THEN
                         IF(IDE.GE.4) THEN
                           IJLM2 = IJIM + L*IJMAX
                           DO M=L,3
                             IF(J .EQ. I) THEN
                               IF(L .EQ. J) THEN
                                 IF(M .EQ. L) THEN
                                   XMUL=1.0D0
                                 ELSE
                                   XMUL=4.0D0
                                 ENDIF
                               ELSE
                                 IF(M .EQ. L) THEN
                                   XMUL=6.0D0
                                 ELSE
                                   XMUL=12.0D0
                                 ENDIF
                               ENDIF
                             ELSE
                               IF(L .EQ. J) THEN
                                 IF(M .EQ. L) THEN
                                   XMUL=4.0D0
                                 ELSE
                                   XMUL=12.0D0
                                 ENDIF
                               ELSE
                                 XMUL=12.0D0
                               ENDIF
                             ENDIF
                             IJLM = IJLM2 + M*IJLMAX
                             IF    (K .EQ. 1) THEN
                               TP = TP+U(1,I)*U(1,J)*U(1,L)*U(1,M)*RSD4EX(IJLM)*XMUL
                             ELSEIF(K .EQ. 2) THEN
                               TP = TP+U(1,I)*U(1,J)*U(1,L)*U(1,M)*RSD4EY(IJLM)*XMUL
                             ELSEIF(K .EQ. 3) THEN
                               TP = TP+U(1,I)*U(1,J)*U(1,L)*U(1,M)*RSD4EZ(IJLM)*XMUL
                             ENDIF
                           ENDDO
                         ENDIF
                       ENDIF
                     ENDIF
                   ENDDO
                 ENDIF
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         E(5,K)=TP
       ENDDO
!Calcul (e.u)''''/Bro, Bro'''''
       EU(5)=     E(5,1)*U(1,1)+E(5,2)*U(1,2)+E(5,3)*U(1,3) &
          + 4.D0* (  E(4,1)*U(2,1)+E(4,2)*U(2,2)+E(4,3)*U(2,3)) &
          + 6.D0* (  E(3,1)*U(3,1)+E(3,2)*U(3,2)+E(3,3)*U(3,3)) &
          + 4.D0* (  E(2,1)*U(4,1)+E(2,2)*U(4,2)+E(2,3)*U(4,3)) &
          +            E(1,1)*U(5,1)+E(1,2)*U(5,2)+E(1,3)*U(5,3)
       D4CSV= QT*EU(4)/BRCQ-(4.D0*DBSB*D3CSV + 6.D0*D2BSB*D2CSV + &
              4.D0*D3BSB*DCSV + D4BSB *CSV)
       D41SV=D4CSV/CL9
       DDT(5) = D41SV
       D5BSB=D41SV*EU(1)+4.D0*D31SV*EU(2)+6.D0*D21SV*EU(3)+ &
             4.D0*D1SV*EU(4) + EU(5)/VL1
       DQBR(5)=D5BSB*QBR
!Calcul u'''''
       DO K=1,3
         U(6,K)=E(1,K)*D41SV + 4.D0*E(2,K)*D31SV + 6.D0*E(3,K)*D21SV + &
               4.D0*E(4,K)*D1SV + E(5,K)/VL1 &
               -(5.D0*DBSB*U(5,K)+10.D0*D2BSB*U(4,K)+10.D0*D3BSB*U(3,K)+ &
               5.D0*D4BSB*U(2,K)+D5BSB*U(1,K))
       ENDDO
!     GOTO 99
! 3    CONTINUE
!   ELSEIF(KFLD.EQ.3) THEN
     case(3)
!-----------------------------------!
!----- MAGNETIC+ELECTRIC FIELD -----!
!----- B=b/Bro, E=e/Bro        -----!
!-----------------------------------!
!C         write(*,*) 'C----- MAGNETIC+ELECTRIC FIELD '
!        write(16,*) 'DBX In devtra after 3: ',CL9,QBR,CL9,U(1,1),U(1,2),U(1,3),E(1,1),E(1,2),E(1,3)
       AM2 = XMAT*XMAT
       BRCQ = QBR*CL9
!----- Wt=sqrt(p2+m2), p=beta.Wt/c
       CSV = SQRT(1.D0 + AM2/(BRCQ*BRCQ))
!          write(6,*) 'In devtra after 3 : ',CSV,IMAX
!          write(6,*) 'In devtra after 3a: ',E(1,1),E(1,2),E(1,3)
!          write(6,*) 'In devtra after 3b: ',U(1,1),U(1,2),U(1,3)
!Calcul (e.u)/Bro, Bro'
       EU(1)= E(1,1)*U(1,1)+E(1,2)*U(1,2)+E(1,3)*U(1,3)
       VL1=CL9/CSV
       DDT(1) = 1.D0/VL1
       DBSB=EU(1)/VL1
       DQBR(1)=DBSB*QBR
!CALCUL u'=uxB
       CALL PVECT(1,1,1)
!Calcul u'=E/v + uxB - uBro'/Bro
       DO K=1,3
         U(2,K)=E(1,K)/VL1 + V(1,K) - U(1,K)*DBSB
       ENDDO 
!       write(6,*) 'In devtra after 31 : ',U(2,1),U(2,2),U(2,3)
!       write(6,*) 'In devtra after 31a: ',IDS
!       IF(IDS.LE.2) GOTO 99
       IF(IDS.LE.2) exit caseKFLD
!Calcul e'/Bro = (e/Bro)'|Bro=cste = E'|Bro=cste
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDE.GE.1) THEN
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(1,I)*RSDE(IK)
           ENDDO
         ENDIF
         E(2,K)=TP
       ENDDO
!Calcul (e.u)'/Bro, Bro''
       EU(2)= E(2,1)*U(1,1)+E(2,2)*U(1,2)+E(2,3)*U(1,3) &
          + E(1,1)*U(2,1)+E(1,2)*U(2,2)+E(1,3)*U(2,3)
       DCSV=QT*EU(1)/BRCQ-CSV*DBSB
       D1SV=DCSV/CL9
       DDT(2) = D1SV
       D2BSB=D1SV*EU(1)+EU(2)/VL1
       DQBR(2)=D2BSB*QBR
!     b'/Bro = B'|Bro=cste
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDB.GE.1) THEN
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(1,I)*RSDB(IK)
           ENDDO
         ENDIF
         B(2,K)=TP
       ENDDO
!CALCUL (uxb)'/Bro
       CALL PVECT(1,1,2)
       CALL PVECT(2,2,1)
!Calcul u''=(1/v)'E + (e'/Bro)/v + (uxb)'/Bro - 2Bro'/Brou' - Bro''/Brou
       DO K=1,3
         U(3,K)=E(1,K)*D1SV + E(2,K)/VL1 + V(1,K)+V(2,K)-2.D0*U(2,K)*DBSB - U(1,K)*D2BSB
       ENDDO
!       write(6,*) 'In devtra after 36 : ',U(3,1),U(3,2),U(3,3)
!       write(6,*) 'In devtra after 36a: ',IDS
!       IF(IDS.LE.3) GOTO 99
       IF(IDS.LE.3) exit caseKFLD
!Calcul e''/Bro = E''|Bro=cste
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDE.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(2,I)*RSDE(IK)
             IF(IDE.GE.2) THEN
               IKIJ = I + KIJM
!   
!            symetrie
!   
               DO J=I,3
                 IF(I .EQ. J) THEN
                   XMUL=1.0D0
                 ELSE
                   XMUL=2.0D0
                 ENDIF
                 IJK = IKIJ + J*IMAX
                 TP=TP+XMUL*U(1,I)*U(1,J)*RSDDE(IJK)
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         E(3,K)=TP
       ENDDO
!Calcul (e.u)''/Bro, Bro'''
       EU(3)= E(3,1)*U(1,1)+E(3,2)*U(1,2)+E(3,3)*U(1,3) &
          + 2.D0*( E(2,1)*U(2,1)+E(2,2)*U(2,2)+E(2,3)*U(2,3)) &
          +          E(1,1)*U(3,1)+E(1,2)*U(3,2)+E(1,3)*U(3,3) 
       D2CSV= QT*EU(2)/BRCQ - 2.D0*DBSB*DCSV - D2BSB*CSV
       D21SV=D2CSV/CL9
       DDT(3) = D21SV
       D3BSB=D21SV*EU(1)+2.D0*D1SV*EU(2)+EU(3)/VL1
       DQBR(3)=D3BSB*QBR
!CALCUL b''/Bro = B''|Bro=cste
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDB.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(2,I)*RSDB(IK)
!   
!          symetrie
!   
             IF(IDB.GE.2) THEN
               IKIJ = I + KIJM
               DO J=I,3
                 IF(I .EQ. J) THEN
                   XMUL=1.0D0
                 ELSE
                   XMUL=2.0D0
                 ENDIF
                 IJK = IKIJ + J*IMAX
                 TP=TP+XMUL*U(1,I)*U(1,J)*RSDDB(IJK)
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         B(3,K)=TP
       ENDDO
!Calcul (uxb)''/Bro
       CALL PVECT(1,1,3)
       CALL PVECT(2,2,2)
       CALL PVECT(3,3,1)
!Calcul u'''=(1/v)''E + 2(1/v)'(e'/Bro) + (e''/Bro)/v + (uxb)''/Bro
!               - 3Bro'/Brou'' - 3Bro''/Brou' - Bro'''/Brou
       DO K=1,3
         U(4,K)=E(1,K)*D21SV + 2.D0*E(2,K)*D1SV + E(3,K)/VL1 &
               +V(1,K)+2.D0*V(2,K)+V(3,K) &
               -3.D0*(DBSB*U(3,K) + D2BSB*U(2,K)) - D3BSB*U(1,K)
       ENDDO
!       IF(IDS.LE.4) GOTO 99
       IF(IDS.LE.4) exit caseKFLD
!Calcul e'''/Bro = E'''|Bro=cste
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDE.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(3,I)*RSDE(IK)
             IF(IDE.GE.2) THEN
               IMIM2 = I - IM2
               IKIJ = I + KIJM
               DO J=1,3
                 IJK = IKIJ + J*IMAX
                 TP=TP+3.D0*U(2,I)*U(1,J)*RSDDE(IJK)
!   
!              symetrie
!   
                 IF(J.GE.I) THEN
                   IF(IDE.GE.3) THEN
                     IJL2 = IMIM2 + J*IMAX
                     DO L = J,3
                       IF(J .EQ. I) THEN
                         IF(L .EQ. J) THEN
                           XMUL=1.0D0
                         ELSE
                           XMUL=3.0D0
                         ENDIF
                       ELSE
                         IF(L .EQ. J) THEN
                           XMUL=3.0D0
                         ELSE
                           XMUL=6.0D0
                         ENDIF
                       ENDIF
                       IJL = IJL2 + L*IJMAX
                       IF    ( K .EQ. 1 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3EX(IJL)
                       ELSEIF( K .EQ. 2 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3EY(IJL)
                       ELSEIF( K .EQ. 3 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3EZ(IJL)
                       ENDIF
                     ENDDO
                   ENDIF
                 ENDIF
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         E(4,K)=TP
       ENDDO
!Calcul (e.u)'''/Bro, Bro''''
       EU(4)= E(4,1)*U(1,1)+E(4,2)*U(1,2)+E(4,3)*U(1,3) &
          + 3.D0*( E(3,1)*U(2,1)+E(3,2)*U(2,2)+E(3,3)*U(2,3)) &
          + 3.D0*( E(2,1)*U(3,1)+E(2,2)*U(3,2)+E(2,3)*U(3,3)) &
          +          E(1,1)*U(4,1)+E(1,2)*U(4,2)+E(1,3)*U(4,3)
       D3CSV= QT*EU(3)/BRCQ-3.D0*(DBSB*D2CSV + D2BSB*DCSV) - D3BSB*CSV
       D31SV=D3CSV/CL9
       DDT(4) = D31SV
       D4BSB=D31SV*EU(1)+3.D0*(D21SV*EU(2)+D1SV*EU(3))+EU(4)/VL1
       DQBR(4)=D4BSB*QBR
!CALCUL b'''/Bro = B'''|Bro=cste
       KIJM = -IJMAX-IMAX
       KIM = -IMAX
       DO K=1,3
         TP=0.D0
         IF(IDB.GE.1) THEN
           KIJM = KIJM + IJMAX
           KIM = KIM + IMAX
           DO I=1,3
             IK = I + KIM
             TP=TP+U(3,I)*RSDB(IK)
             IF(IDB.GE.2) THEN
               IMIM2 = I - IM2
               IKIJ = I + KIJM
               DO J=1,3
                 IJK = IKIJ + J*IMAX
                 TP=TP+3.D0*U(2,I)*U(1,J)*RSDDB(IJK)
!   
!                symetrie
!   
                  IF(J.GE.I) THEN
                   IF(IDB.GE.3) THEN
                     IJL2 = IMIM2 + J*IMAX
                     DO L = J,3
                       IF(J .EQ. I) THEN
                         IF(L .EQ. J) THEN
                           XMUL=1.0D0
                         ELSE
                           XMUL=3.0D0
                         ENDIF
                       ELSE
                         IF(L .EQ. J) THEN
                           XMUL=3.0D0
                         ELSE
                           XMUL=6.0D0
                         ENDIF
                       ENDIF
                       IJL = IJL2 + L*IJMAX
                       IF    ( K .EQ. 1 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3BX(IJL)
                       ELSEIF( K .EQ. 2 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3BY(IJL)
                       ELSEIF( K .EQ. 3 ) THEN
                         TP = TP+XMUL*U(1,I)*U(1,J)*U(1,L)*RSD3BZ(IJL)
                       ENDIF
                     ENDDO
                   ENDIF
                 ENDIF
               ENDDO
             ENDIF
           ENDDO
         ENDIF
         B(4,K)=TP
       ENDDO
!Calcul (uxb)'''/Bro
       CALL PVECT(1,1,4)
       CALL PVECT(2,2,3)
       CALL PVECT(3,3,2)
       CALL PVECT(4,4,1)
!Calcul u''''=(1/v)'''E+3(1/v)''(e'/Bro)+3(1/v)'(e''/Bro)+(1/v)E'''/Bro
!C             + (uxb)'''/Bro
!C             - 4Bro'/Brou''' - 6Bro''/Brou'' - 4Bro'''/Brou' - Bro''''/Brou
       DO K=1,3
         U(5,K)=E(1,K)*D31SV + 3.D0*E(2,K)*D21SV + 3.D0*E(3,K)*D1SV &
             + E(4,K)/VL1 + V(1,K)+3.D0*V(2,K)+3.D0*V(3,K)+V(4,K) &
             -4.D0*(DBSB*U(4,K)+D3BSB*U(2,K))-6.D0*D2BSB*U(3,K)-D4BSB*U(1,K)
       ENDDO
   end select caseKFLD
   
! 99   CONTINUE
!        write(6,*) 'In DEVTRA LST=',LST
   IF(LST .GE. 1) CALL IMPDEV
END SUBROUTINE DEVTRA
!> *******************************************************************
!! PROGRAM dynac
!! Beam dynamics program for charged particles in linacs and transport 
!! lines. 
!< *******************************************************************
PROGRAM dynac
   USE DynacConstants
   USE m4trace3d
   USE m4mcs
   USE m4beam
   USE m4beam2, ONLY: bindst
   USE m4cavs
   USE m4cavs2
   USE m4input
   USE m4output
   USE m4chase
   USE m4spacecharge
   USE m4scheff
   USE m4scheff2, ONLY: irfqp
   USE m4plots
   USE m4tmatrix
   USE m4rfq
   USE m4RESTAYfun, ONLY: ifield   
   USE m4restayMIDGAP, ONLY: ICONT,IPRIN
   USE m4TILT   
   USE m4FENE
   USE m4ITVOLE
   USE m4short
   USE m4wforsc
   USE m4ble
   USE m4aimalv, ONLY: nsector, APB, IRAYSH
   USE mCOMgrot
   USE mCOMfrmacc
   USE mCOMnewref
   USE mCOMalin
   USE mCOMelq
   USE mCOMpaths   
   USE mCOMfiles
   USE mCOMzones
   USE mCOMapel
   USE mCOMosys
   USE mCOMrec   
   USE mCOMblvl
   USE mCOMqskew
   USE mCOMxposi
   USE mCOMrfqwdst   
   USE mCOMtrfq
   USE m4prtcls, ONLY: zcp,xcp,ycp,xc,yc,zc,fs   
   IMPLICIT NONE
!   COMMON/CARAC/CARA(10)
   logical ichsp
!   common/drfq/prfq(9)
!   common/mingw/mg
   logical mg,ffound,fromrfq
   LOGICAL cfound,nopath
   character(len=8) :: kley
   character(len=30) :: iitime
   character(len=38) :: version
   character(len=80) :: text
   character(len=180) :: cmnt
   character(len=256) :: txt
   character(len=256), dimension(10) :: myarg
   character(len=256) :: titre
   character(len=256) :: infiln,wfile
   character(len=256) :: myfile,ofeldf,ofelds,inarg,dflocfile
   REAL(8) wcog,tcog,bcog,gcog
   REAL(8) exstrt,exfin   
   REAL(8) beame
   REAL(8) DL
   REAL(8) fld
   INTEGER ICG
   REAL(8) XLQUA,BQUAD,RG,XLSOL,ARG
   REAL(8) pv,pdp,pharm,prlim   
   REAL(8) wfxl,wfef,wfbf,fdum   
   REAL(8) bref,gref,wref,fcpi,obref,ogref,otref,owref
   REAL(8) pib,fh1,att,ZROTA,args,argq,RS,volt,fmult,bcret
   real(8) ANGL,RMO,BAIM,XN,XB,PENT1,RAB1,EK1,EK2,PENT2,RAB2,SK1,SK2,XLSEX
   INTEGER lfile,lpath,narg,nlpath
   INTEGER istat,len,lin
   INTEGER I,k,ijp,indic,indp
   INTEGER intgct
   INTEGER IMKS
   INTEGER ini,ios
   INTEGER iskale,iwfia, iflg, lm
   INTEGER ishift,init,iscont,npart,imit,iksq,ITYQU,IMK2
   INTEGER nvf,ilier,intgr,kk,kllength,mylength
   REAL(8) tstart,tend
   LOGICAL exists,isopen
   INTEGER :: svalues(8),evalues(8)
   REAL(8) trdrift,trdrifa,trdrifb,aver
   character(len=12) :: fdrft   
!*******************************************************************
!   allocate(ichas(iptsz))
!   allocate(ichxyz(iptsz))
! *******************************************************************
!       
   version='****** DYNAC V8R0, 16-Dec-2025 ******'
! by default read and write particle distributions as ASCII
   bindst=.false.
! LUN dynac input file   
   in=7
! ierr corresponds to i/o unit for errors
   ierr=0
! if mg=.true., use MINGW on windows, which has a different result for
! ctime function than standard gfortran
! default is mg=.false. This can be set by giving mingw as argument on
! the command line
   mg=.false.
! mcselect will be set to true if running in multi-core mode        
   mcselect=.false.
! get arguments from the command line
! format for dynac:
! dynac file1 [-h]
! where: -file1 is the input file, describing the beamline
!        -h  print help info
   narg=0
   DO
     call get_command_argument(narg, inarg, len, istat)
     if(LEN_TRIM(inarg).eq.0) exit
!     write(6,*) 'DYNAC args=',narg,LEN_TRIM(inarg),inarg(1:LEN_TRIM(inarg)),len,istat
     narg=narg+1
     myarg(narg)=TRIM(inarg)
   ENDDO
! *******************************************************************
!  Analyze INPUT ARGUMENTS:
   ffound=.false.
   dpath=''
   myfile=''
   do i=2,narg
     txt=myarg(i)
     if(txt(1:1).ne.'-') then
! the input argument is the name of the input file (write statement moved to after print out of dynac version)
!            if(mcselect) then
!              write(6,'("Input file in DYNAC: ",A," running on core ",A2)')trim(myarg(i)),mc
!            else
!              write(6,'("Input file in DYNAC: ",A)')trim(myarg(i))
!            endif
            infiln=myarg(i)
! 7 or 'in' is the unit corresponding to the dynac input file
! describing the accelerator and/or transport line
!       if(access(trim(myarg(i)),'r') == 0) then
       INQUIRE(FILE=trim(myarg(i)), EXIST=exists)
       if(exists) then
         open(in,file=trim(myarg(i)),status='unknown')
         ffound=.true.
       else
         ffound=.false.
       endif
     else
       if(txt(1:3).eq.'-mc') then
! multiple instances of DYNAC will be run using multiple cores
         mcselect=.true.
         if(txt(4:4).ne.' ') then
           mc=txt(4:5)
         else
           mc=txt(5:6)
         endif
!         write(6,*) '-mc selected with core ',mc
       endif
       if(myarg(i).eq.'--pipe') then
! pipe the keywords and data (as opposed to reading the input file)
         write(6,*) 'Using piped data for input'
         ffound=.true.
         infiln='None, because --pipe option was used'
         in=5
       endif
       if(myarg(i).eq.'-mingw') then
! if mg=.true., use MINGW on windows, which has a different result
! for ctime function than standard gfortran
         mg=.true.
         write(6,*) 'Using MINGW gfortran format on MSWindows'
       endif
       if(txt(1:2).eq.'-p') then
! path of where data files needed by dynac are stored follows this option
!        path=.true.
         lpath=LEN_TRIM(txt)
         dpath(1:lpath-2)=txt(3:lpath)
         nlpath=LEN_TRIM(dpath)
!         if (opsys=='Windows') then
!           if(dpath(nlpath:nlpath).ne.sepchar) then
!             dpath(nlpath+1:nlpath+1)=sepchar
!           endif
!         endif
!         write(6,*)'debuggger ',trim(dpath)
       endif
       if(myarg(i).eq.'-h') then
!     print out of help message, starting with DYNAC version
         WRITE(6, '(a)') version
         write(6,*) 'Command format:'
         write(6,*)'dynacv8 [-h] [-v] [-mingw] [-p] [--pipe] ', &
          '[-mcNN] [file1]'
         write(6,*) 'where file1 is the input file, describing ', &
                    'the beamline'
         write(6,*) 'Optional arguments:'
         write(6,*) '-h will list the argument options (this ', &
                    'list)'
         write(6,*) '-v will show the DYNAC version'
         write(6,*) '-mingw will enable MINGW gfortran format', &
                    ' on MSWindows'
         write(6,*) '-p can be used to specify the datafile ', &
                    'path. There should be no '
         write(6,*) '   space between -p and the path. This ', &
                    'option is used by the'
         write(6,*) '   DYNAC GUI.'
         write(6,*) '--pipe can be used to pipe the DYNAC ', &
                    'keywords and data'
         write(6,*) '       (as opposed to reading the input ', &
                    'from file)'
         write(6,*) '--mcNN can be used when running multiple ', &
                    'instances of DYNAC in parallel (multi-core)'
         write(6,*) '       NN is then to be used to specify ', &
                    'the core number'
         stop
       endif
       if(myarg(i).eq.'-v') then
!     print out of DYNAC version
         WRITE(6, '(a)') trim(version)
         stop
       endif
     endif
   enddo
!  *******************************************************
   if(.not.ffound) then
     write(ierr,'(A)') '***Warning: Input file name required***'
     write(6,'(A)') 'Try to get input file now'
     call getfile(infiln,lin)
!     write(6,*) 'DBX after getfile ',lin,trim(infiln)
     if(lin.ne.0) then
       open(7,file=infiln(1:lin),status='unknown')
     else
       write(ierr,'(A)') 'Defaulting to dynac.in'
       INQUIRE(FILE='dynac.in', EXIST=exists)
       if(exists) then
         infiln='dynac.in'
         open(7,file=infiln,status='unknown')
       else
         write(ierr,'(A)') '*** dynac.in does not exist either ***'
         write(ierr,'(A)') 'Type'
         write(ierr,'(A)') 'dynacv8 -h'
         write(ierr,'(A)') 'for syntax'
         stop
       endif
     endif
   endif
! *******************************************************************
!  OUTPUT FILES:
!
! 'dynac.long'     : print extensive computations information
!
! 'dynac.short'    : print essentials of beam dynamics information
!
! 'dynac.print'    : printout of the envelope and the emittance of the
!                    beam in the directions  x, y and z at each position
!                    of the optical and accelerating elements, as well as
!                    the number of good particles
!
! 'dynac.dmp'      : printout of cavity cell related data:
!                    cell number,synchronous phase (deg),relativistic
!                    beta (output), output energy (MeV),
!                    hor. emittance (mm.mrad, normalized),
!                    ver. emittance (mm.mrad, normalized),
!                    longitudinal emittance (ns.kev)
!
! 'emit.plot'      : datafile used for the plots
!
! 'lost_particles.data' : details related to lost particles are stored in this file
!
! 'cavdat.out'     : details related to cavities are stored in this file, such as
!                    number of cells, TTF, z-position, RF phase, E0TL, energy gain etc 
!
! 'beam_core.dst'  : print the coordinates of the particles kept by
!                    CHASE (files openend if CHASE card encountered)
!
! 'beam_remove.dst': print the coordinates of the particles
!                    removed by CHASE (files openend if CHASE card encountered)
!
! **********************************************************************
   lpath=LEN_TRIM(dpath)
!
   myfile='dynac.long'
   if(mcselect) myfile='mc'//mc//'dynac.long'
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(16,file=myfile,status='unknown')

   myfile='dynac.short'
   if(mcselect) myfile='mc'//mc//'dynac.short'
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(12,file=myfile,status='unknown')

   myfile='dynac.print'
   if(mcselect) myfile='mc'//mc//'dynac.print'
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(71,file=myfile,status='unknown')

   myfile='dynac.dmp'
   if(mcselect) myfile='mc'//mc//'dynac.dmp'
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(50,file=myfile,status='unknown')

   myfile='emit.plot'
   if(mcselect) myfile='mc'//mc//'emit.plot'
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(66,file=myfile,status='unknown')

   myfile='lost_particles.data'
   if(mcselect) myfile='mc'//mc//'lost_particles.data'
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(49,file=myfile,status='unknown')
   write(49,'(A,A,A)') '# Element numb.   pos.         prt.     inp.prt.     X', &
               '           Xp            Y            Yp       ', &
               '   PHASE         W       Q    loss    ElementName'
   write(49,'(A,A,A)') '#                 (m)          num.     number      ', &
               '(cm)        (mrad)        (cm)         (mrad)', &
               '       (deg)        (MeV)        reason'

   myfile='cavdat.out'
   if(mcselect) myfile='mc'//mc//'cavdat.out'
   lfile=LEN_TRIM(myfile)
   myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
   myfile(1:lpath)=dpath(1:lpath)
   myfile=TRIM(myfile)
   open(13,file=myfile,status='unknown')
!
!***********************************************************************
!    initialize constants
!
   cr=char(13)
! initialize the number of charge states to 1
   ncstat=1
   QST=1.D0 
   XMAT=938.27231D0  
! initialize the # of zones (see ZONES card) to zero
   izrot=.false.
   ofeldf=''
   ofelds=''
   icour=0
! initialize trace3d related stuff
! frequency indicator
   fid=1.D0
   T3D=.false.
   xiset=.false.
   kt3h=1
   trace3h(kt3h)=' $DATA'
   kt3t=0
! DONE:
!      DATA KLE/'GEBEAM','INPUT','RDBEAM','ETAC','DRIFT',
!     1*       'QUADRUPO',        ,         ,'SOLENO',         ,
!     2*        'BMAGNET',        ,'CAVSC'  ,'FIELD' ,         ,
!     3*        'BUNCHER',        ,'NEWF'   ,        ,'SCDYNAC',
!    11*                 ,'CAVNUM',         ,        ,
! TO LOOK AT:
!      DATA KLE/                ,        ,
!     1*                 ,'SEXTUPO','QUADSXT',        ,'SOQUAD',
!     2*                 ,         ,         ,        , 'HARM' ,
!     3*                 ,'RFQCL',           ,'NREF',        ,
!     4*        'SCDYNEL','SCPOS','TILT','TILZ','CHANGREF',
!     5*        'TOF','REJECT','ZROT','ALINER',
!     7*        'RWFIELD','RANDALI','TWQA','EMIPRT',
!     8*        'MMODE','RFQPTQ',        ,'STEER',
!     9*                ,        ,       ,'FDRIFT','FSOLE',
!    10*                         'REFCOG','FPART',       ,
!    11*        'QUAFK',         ,       ,       ,'RFKICK'
!
! IGNORE: 'ZONES','STOP','T3D','DCBEAM','FIRORD','COMMENT'
!         'EMIT','EMITGR','WRBEAM','ENVEL','REJECT','CHASE'
!         'ACCEPT','EMITL','EGUN','COMPRES','RASYN','SECORD'
!         'STRIPPER','EDFLEC','PROFGR','QUAELEC','CAVMC'
!         'EMITGRD','PROFGRD','WIENANA','WIENNUM'
   fracc=.false.
   rfqiflg=0
   acpt=.false.
   irfqp=.false.
   inisk=0
   ttvols=0.D0
   iprf=1
   ncell=0
   nzone=0
   bflvl=0.D0
   nbemit=0
   iell=0
   imcs=0
   IFW=1
   WDISP=1000.D0
   WPHAS=400.D0*pi
   WX=100.D0
   WY=100.D0
   RLIM=140.D0
   NRTRE=0
! Setting (in RMS multiples) at which charge states are considered separated in space 
! charge calculations of a multi-charge state beam.       
   scseprms=1.D0
! initialize some arrays
   prlab="        "
   centre=0.D0
   davprt=""
! next moved to SUBROUTINE chase   
!   ichas=1
!   ichxyz=1
!
   SHIFT=.FALSE.
   ICHAES=.FALSE.
   ISEOR=.FALSE.
   IRAYSH=.FALSE.
   ICONT=iptsz+5
   IPRIN=1
   NRRES=0
   NDTL=0
   NCAVNM=0
   NCAVMC=0
   NRBUNC=0
   DTIPH=0.D0
   intgct=0
   ierpf=0
   ialin=.false.
   itwist=.false.
   ichsp=.FALSE.
   iesp=.FALSE.
   itvol=.FALSE.
   imamin=.false.
   chasit=.false.
   ifield=.false.
   iemgrw=.false.
   idav=0
   davtot=0.D0
   iapel=1
   iaqu=1
   xpsc=0.5D0
   FRACTX=1.D0
   FRACTY=1.D0
   FRACTL=1.D0
   ISCSP=0
   IFILE=11
   IMAX=0
! default for beams is to be bunched (not continuous)
   ifcont=.FALSE.
! default for WRBEAM printout of RFQ cells is at the end of the cell
   rfqmidcell=.false.
   rfqmaecell=.false.
! *******************************************************
   WRITE(6, '(a)') version
   i=len_trim(infiln)
   if(ichar(infiln(i:i)).eq.0) infiln=infiln(1:i-1)
   if(mcselect) then
     write(6,'("Input file in DYNAC: ",A," running on core ",A2)')trim(infiln),mc
   else
     write(6,'("Input file in DYNAC: ",A)')trim(infiln)
   endif
   WRITE(16,'(a)') version
   WRITE(12,'(a)') version
   write(16,*) 'Input file: ',trim(infiln)
   write(12,*) 'Input file: ',trim(infiln)
   text=' '
   call mytime(iitime)
   if (mg) then
! using old MINGW style gfortran format: 03/30/10 20:51:06 (10 is 2010)
     text(1:4)='    '
     if(iitime(1:2).eq.'01')text(5:7)='Jan'
     if(iitime(1:2).eq.'02')text(5:7)='Feb'
     if(iitime(1:2).eq.'03')text(5:7)='Mar'
     if(iitime(1:2).eq.'04')text(5:7)='Apr'
     if(iitime(1:2).eq.'05')text(5:7)='May'
     if(iitime(1:2).eq.'06')text(5:7)='Jun'
     if(iitime(1:2).eq.'07')text(5:7)='Jul'
     if(iitime(1:2).eq.'08')text(5:7)='Aug'
     if(iitime(1:2).eq.'09')text(5:7)='Sep'
     if(iitime(1:2).eq.'10')text(5:7)='Oct'
     if(iitime(1:2).eq.'11')text(5:7)='Nov'
     if(iitime(1:2).eq.'12')text(5:7)='Dec'
     text(8:8)=' '
     text(9:10)=iitime(4:5)
     text(11:13)=' 20'
     text(14:15)=iitime(7:8)
     text(16:19)=' at '
     text(20:27)=iitime(10:17)
   else
! standard gfortran format: Tue Mar 30 20:51:06 2010
     text(1:11)=iitime(1:11)
     text(12:15)=iitime(21:24)
     text(16:19)=' at '
     text(20:27)=iitime(12:19)
   endif
   write(6,'("Started on ",A27)') text(1:27)
   write(16,*) 'Started on ',text(1:27)
   write(12,*) 'Started on ',text(1:27)
   call cpu_time(exstrt)
!   tstart=secnds(0.0)
   Call DATE_AND_TIME(VALUES=svalues)
   tstart = DBLE(svalues(3))*86400.D0 +                                  &
            DBLE(svalues(5))*3600.D0  +                                  &
            DBLE(svalues(6))*60.D0    +                                  &
            DBLE(svalues(7))          +                                  &
            DBLE(svalues(8))*1.0E-3   
!  Read title
   READ (in,'(A)') titre
   WRITE(16,'(1x,A)') trim(titre)
   WRITE(12,'(1x,A)') trim(titre)
   write(16,*) '********************************'
! Read the input file and check for valid cards
   DO
     UDEN=''   
     CFOUND=.false.
     READ (in,'(A180)') cmnt(1:180)
     if (cmnt(1:1).eq.';') then
       write(16,'(1x,A)') trim(cmnt)
       cycle
     else
       mylength=len_trim(cmnt)
       read(cmnt,'(A)') kley
       do kk=1,8
         if(kley(kk:kk).eq.' ') then
           kley=kley(1:kk-1)
           kllength=kk-1
           exit
         else
           kllength=kk  
         endif
       enddo
       if(mylength.gt.kllength) then
! uden is a user defined element name
         read(cmnt(kllength+1:mylength),'(A)') uden
       else
         uden=' NoUserDefinedElementName'
       endif
     endif
!*********************************************************************
!  GEBEAM    1  | INPUT    2  | RDBEAM   3  | ETAC    4  | DRIFT    5
!  QUADRUPO  6  | SEXTUPO  7  | QUADSXT  8  | SOLENO  9  | SOQUAD   10
!  BMAGNET   11 | CAVMC    12 | CAVSC    13 | FIELD   14 | HARM     15
!  BUNCHER   16 | RFQCL    17 | NEWF     18 | NREF    19 | SCDYNAC  20
!  SCDYNEL   21 | SCPOS    22 | TILT     23 | TILZ    24 | CHANGREF 25
!  TOF       26 | REJECT   27 | ZROT     28 | ALINER  29 | ACCEPT   30
!  EMIT      31 | EMITGR   32 | COMMENT  33 | WRBEAM  34 | ENVEL    35
!  CHASE     36 | RWFIELD  37 | RANDALI  38 | TWQA    39 | EMIPRT   40
!  MMODE     41 | RFQPTQ   42 | STRIPPER 43 | STEER   44 | ZONES    45
!  PROFGR    46 | SECORD   47 | RASYN    48 | FDRIFT  49 | FSOLE    50
!  EGUN      51 | COMPRES  52 | STOP     53 | REFCOG  54 | FPART    55
!  QUAELEC   56 | QUAFK    57 | CAVNUM   58 | EDFLEC  59 | EMITL    60
!  RFKICK    61 | FIRORD   62 | DCBEAM   63 | T3D     64 | MHB      65
!  BINDIST   66 | EMITGRD  67 | PROFGRD  68 | WIENANA 69 | WIENNUM  70
!  DFLOCS    71 |          72 |          73 |         74 |          75
!*********************************************************************
     select case (trim(kley))
       CASE ('GEBEAM')
! AFTER GEBEAM: Generates randomly the input beam
         write(16,*) 'TYPE CODE: GEBEAM **************'
         CALL MONTE
         write(16,*) '********************************'
       CASE ('INPUT')
! AFTER INPUT: define the dynamics at input
! --- INPUT must be preceded by GEBEAM
! --- the reference (synchronous) particle is the c.o.g of the bunch
! --- ENTRY:
! ---- 1) uem, atm, qst
! ---    uem : unit of Rest mass in MeV
!  Examples:
!          proton:938.27231  MeV
!          H-    :939.3145   MeV
!          mesons:33.9093    MeV
!          pions :139.5685   MeV
!          kaons :493.667    MeV
!          electrons : 0.511 MeV
! --- atm : Atomic number
! --- qst : charge (unit of charge) of the reference
!
! ----  2) enedep,tof
! ---      enedep: Kinetic energy of the reference
! ---      tofini: Time of flight of the reference at input (sec)
             write(16,*) 'TYPE CODE: INPUT ***************'
         CALL ENTRE
         write(16,*) '********************************'
       CASE ('TILT')
!   AFTER TILT:rotation and shift of beam ellipsoid
!    ICG    : = 1 => REFERENCE PARTICLE IS THE C.O.G. OF THE BEAM
!    ICG    : = 0 => IT IS DISTINCT FROM THE C.O.G.
         write(16,*) 'TYPE CODE: TILT ****************'
         READ(IN,*)ICG
         READ(IN,*)TIPHA,TIX,TIY,SHIFW,SHIFP
         CALL TILTBM(ICG)
         write(16,*) '********************************'
       CASE ('RDBEAM')
!   AFTER RDBEAM: Read the input beam in the disk
             write(16,*) 'TYPE CODE: RDBEAM **************'
! --- ENTRY
! ---- 1) filen : filename of file containing the particle distribution
! ---- 2) iflag : flag type of distribution file
! ---     iflag = 0 particle coordinates x,xp,y,yp,z,zp with z in rad
! ---     iflag = 1 particle coordinates x,xp,y,yp,z,zp,q,m0 with z in rad
! ---     iflag = 2 particle coordinates x,xp,y,yp,z,zp,q with z in rad
! ---     iflag = 10 particle coordinates x,xp,y,yp,z,zp with z in ns
! ---     iflag = 11 particle coordinates x,xp,y,yp,z,zp,q,m0 with z in ns
! ---     iflag = 12 particle coordinates x,xp,y,yp,z,zp,q with z in ns
! ---     add 100 to the above iflg values to read a file that has Wref as
! ---     4th parameter on line 1
! ---- 3) freq, tof
! ---     freq: RF frquency (MHz)
! ---     tof: phase offset to be applied  to the beam (deg)
!
! ---- 4) uem, atm, qst
!         like ENTRY in type code INPUT
!
         myfile=''
         READ(in,'(a)') myfile
         lfile=LEN_TRIM(myfile)
         myfile=TRIM(myfile)
         if(bindst) then
           write(16,*)'Opening binary distribution file: ',myfile
           open(55,file=myfile,status='unknown', &
                form='unformatted',action='read')
         else
           write(16,*)'Opening ASCII distribution file: ',myfile
           open(55,file=myfile,status='unknown',action='read')
         endif
         CALL ADJRFQ
         write(16,*) '********************************'
       CASE ('ETAC')
!   AFTER ETAC :possibility of a multiple charge state beam
         write(16,*) 'TYPE CODE: ETAC ****************'
         kt3h=kt3h+1
         trace3h(kt3h)='ERROR: ETAC not supported'
         CALL ETAC
         write(16,*) '********************************'         
       CASE ('DCBEAM')
!  AFTER DCBEAM : select DC or bunched beam
         READ(IN,*) iscont
         write(16,*) '********************************'
         write(16,*) 'TYPE CODE: DCBEAM **************'
         if(iscont.eq.1) then
           ifcont=.true.
           write(16,*) ' DC BEAM SELECTED    ***********'
         elseif(iscont.eq.0) then
           ifcont=.false.
           write(16,*) ' BUNCHED BEAM SELECTED *********'
         endif
         write(16,*) '********************************'
       CASE ('BINDIST')
!  AFTER BINDIST : binary files will be read or written
         write(16,*) '********************************'
         write(16,*) 'TYPE CODE: BINDIST *************'
         write(16,*) '* Binary .dst files will be used '
         write(16,*) '********************************'
         bindst=.true.         
       CASE ('COMPRES')
! AFTER COMPRES
!  Do so by shifting particles belonging to the same bunch outside the (+/-) pib/2 (deg) window
!   w.r.t.the COG to inside the (+/-) pib/2 window w.r.t.the COG
         write(16,*) 'TYPE CODE: COMPRES *************'
! --- pib (deg)
         read(in,*) pib
         pib=pib/2.D0
         write(16,'(A,e12.5,A)') ' *** shift particles inside +/- ',pib,' deg'
         call compress(pib)
         write(16,*) '********************************'
       CASE ('FPART')
!   AFTER FPART:
! --- a given particle is followed in the accelerating elements
! --- ICONT : the number of the particle followed in accelerating elements
         write(16,*) 'TYPE CODE: FPART ***************'
         read(in,*) icont
         write(16,*) ' the particle:',icont,' is followed'
         write(16,*) '********************************'         
       CASE ('EGUN')
! AFTER EGUN:
!     Only the SCHEFF routine is avalaible in the routine EGUN
         write(16,*) 'TYPE CODE: EGUN ****************'
!     unit 22 corresponds to an input file giving egun field (z,E(z)) E(z) normalised
         myfile=''
         READ(in,'(A)') myfile
         myfile=TRIM(myfile)
         write(16,*) 'Egun field file: ',myfile
         open(22,file=myfile,status='unknown',action='read')
!  follows the particle ifpt (not active)
! not activated       read(in,*)ifpt
!    fmult: field factor
         read(in,*)fmult,indp
         if(.not.ichaes) indp=1
!  indp: number of space charge computations to be made in the EGUN
!   indp = 1 : 8 space charge computations. The EGUN field is divided in 16 elements
!   indp = 2 : 16 space charge computations.                          in 32 elements
!   indp = 3 : 32 space charge computations.                          in 64 elements
         if(ichaes) then
           write(16,'(7x,A,f10.4,A)') 'Beam current  =',BEAMC*fhinit/fh,'      mA'
           if(iscsp.lt.3) then
             write(ierr,*)'*** HERSC and SCHERM cannot be used', &
                        'with EGUN; use SCHEFF instead'
             write(16,*)'*** HERSC and SCHERM cannot be used ', &
                        'with EGUN; use SCHEFF instead'
             stop
           endif
         endif
         call egun(fmult,indp)
         write(16,*) '********************************'
       CASE ('T3D')
!  AFTER T3D : request TRACE3D input file
         T3D=.true.
         write(16,*) '********************************'
         write(16,*) 'TYPE CODE: T3D *****************'
         write(16,*) ' TRACE3D INPUT FILE WILL BE WRITTEN'
         write(16,*) '********************************'
       CASE ('REFCOG')
!   AFTER REFCOG:
!    ISHIFT  = 0: the synchronous particle and the cog are coinciding (shift = false)
!    ISHIFT  = 1: the synchronous particle and the cog are separated   (shift = true)
!    ISHIFT  = 2: at the start the TOF of synchronous particle  is the TOF of the cog
!                   after synchronous particle and cog are separated (shift = true)
!    (at the begining shift = false)
         write(16,*) 'TYPE CODE: REFCOG **************'
         read(in,*) ishift
         if(ishift.eq.0) then
           shift=.false.
           write(16,*)'Synchronous particle is the COG of the bunch'
           obref=vref/vl
           ogref=1.D0/SQRT(1.D0-(obref*obref))
           otref=tref
           owref=XMAT*(ogref-1.D0)
           tcog=0.D0
           wcog=0.D0
           do ijp=1,ngood
             wcog=wcog+f(7,ijp)
             tcog=tcog+f(6,ijp)
           enddo
           wcog=wcog/DBLE(ngood)
           tcog=tcog/DBLE(ngood)
           gcog=wcog/xmat
           bcog=sqrt(gcog*gcog-1.D0)/gcog
           vref=bcog*vl
           tref=tcog
           fcpi=fh*180.D0/pi
           write(16,'(A,e12.5,A,e14.7,A,e12.5,A,/,A,e12.5,A,e14.7,A,e12.5,A)') &
          ' old REF beta: ',obref,' energy: ',owref,' MEV TOF: ',otref*fcpi,' deg', &
          ' new REF beta: ',vref/vl,' energy: ',wcog-xmat,' MEV TOF: ',tref*fcpi,' deg'
           write(16,'(A,e12.5,A,e14.7,A,e12.5,A)') &
          ' COG     beta: ',bcog,' energy: ',wcog-xmat,' MeV TOF: ',tcog*fcpi,' deg'

!        write(16,*) 'old TTVOL (deg): ',ottvols*fcpi
!        write(16,*) 'new TTVOL (deg): ',ttvols*fcpi
         endif
         if(ishift.eq.1) then
           shift=.true.
           bref=vref/vl
           gref=1.D0/SQRT(1.D0-(bref*bref))
           wref=XMAT*(gref-1.D0)
           tcog=0.D0
           wcog=0.D0
           do ijp=1,ngood
             wcog=wcog+f(7,ijp)
             tcog=tcog+f(6,ijp)
           enddo
           wcog=wcog/DBLE(ngood)
           tcog=tcog/DBLE(ngood)
           gcog=wcog/xmat
           bcog=sqrt(gcog*gcog-1.D0)/gcog
           fcpi=fh*180.D0/pi
           write(16,*)'Synchronous particle and COG of the ', &
           'bunch are independent'
           write(16,'(A,e12.5,A,e14.7,A,e12.5,A,/,A,e12.5,A,e14.7,A,e12.5,A)') &
            ' REF beta: ',bref,' energy: ',wref,' MeV TOF: ',tref*fcpi,' deg', &
            ' COG beta: ',bcog,' energy: ',wcog-xmat,' MeV TOF: ',tcog*fcpi,' deg'
         endif
         if(ishift.gt.1) then
           write(16,*)
           write(16,*)'Synchronous particle and COG of the ', &
           'bunch are independent, but initially'
           write(16,*)'TOF and energy of the synchronous ', &
           'particle are the ones of the bunch'
           shift=.true.
! --- the reference is the cog
           obref=vref/vl
           otref=tref
           ogref=1.D0/SQRT(1.D0-(obref*obref))
           otref=tref
           owref=XMAT*(ogref-1.D0)
           wcog=0.D0
           tcog=0.D0
           do ijp=1,ngood
             wcog=wcog+f(7,ijp)
             tcog=tcog+f(6,ijp)
           enddo
           wcog=wcog/DBLE(ngood)
           tcog=tcog/DBLE(ngood)
           gcog=wcog/xmat
           bcog=sqrt(gcog*gcog-1.D0)/gcog
           vref=bcog*vl
           tref=tcog
           if(itvol) ttvols=tref
           fcpi=fh*180.D0/pi
           write(16,'(A,e12.5,A,e14.7,A,e12.5,A,/,A,e12.5,A,e14.7,A,e12.5,A)') &
            ' old REF beta: ',obref,' energy: ',owref,' MeV TOF: ',otref*fcpi,' deg', &
            ' new REF beta: ',vref/vl,' energy: ',wcog-xmat,' MeV TOF: ',tref*fcpi,' deg'
         endif
         write(16,*) '********************************'
       CASE ('CHASE')
!   AFTER CHASE:Temporary elimination of most distant particles for statistical purposes
         write(16,*) 'TYPE CODE: CHASE ***************'
         myfile='beam_core_L.dst'
         if(mcselect) myfile='mc'//mc//'beam_core_L.dst'
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         open(61,file=myfile,status='unknown')
         myfile='beam_remove_L.dst'
         if(mcselect) myfile='mc'//mc//'beam_remove_L.dst'
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         open(60,file=myfile,status='unknown')
!        -----         
         myfile='beam_core_H.dst'
         if(mcselect) myfile='mc'//mc//'beam_core_H.dst'
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         open(63,file=myfile,status='unknown')
         myfile='beam_remove_H.dst'
         if(mcselect) myfile='mc'//mc//'beam_remove_H.dst'
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         open(62,file=myfile,status='unknown')
!        ----- 
         myfile='beam_core_V.dst'
         if(mcselect) myfile='mc'//mc//'beam_core_V.dst'
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         open(65,file=myfile,status='unknown')
         myfile='beam_remove_V.dst'
         if(mcselect) myfile='mc'//mc//'beam_remove_V.dst'
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         open(64,file=myfile,status='unknown')
         CALL CHASE
         write(16,*) '********************************'
       CASE ('FIRORD')
!  AFTER FIRORD : first order matrix for optical lenses
         write(16,*) 'TYPE CODE: FIRORD **************'
         write(16,*) '  FIRST ORDER IN BEAM TRANSPORT'
         ISEOR=.FALSE.
         write(16,*) '********************************'         
       CASE ('SECORD')
!  AFTER SECORD : second order matrix for optical lenses
         write(16,*) 'TYPE CODE: SECORD **************'
         write(16,*) ' SECOND ORDER IN BEAM TRANSPORT'
         ISEOR=.TRUE.
         write(16,*) '********************************'
       CASE ('RASYN')
!  AFTER RASYN : Radiation exitation in bending magnets (only for electrons)
         write(16,*) 'TYPE CODE: RASYN ***************'
         write(16,*) ' SYNCHRTRON RADIATION IN BENDING MAGNET'
         IRAYSH=.TRUE.
         write(16,*) '********************************'
       CASE ('NEWF')
!  AFTER NEWF:define a new frequency (Hertz)
         IF (IMAX.EQ.0) THEN
           WRITE(16,*)' NEWF HAS TO BE PRECEEDED BY GEBEAM OR RDBEAM'
           stop
         ENDIF
         write(16,*) 'TYPE CODE: NEWF ****************'
         READ (IN,*) FH1
! record frequency change in view of trace3d file
         FH1=2.D0*PI*FH1
         fid=fh1/fh
! adjust beam current
         beamc=beamc*fh1/fh
         fh=fh1
         WRITE(16,*)' NEW FREQUENCY : ',FH/(2.D0*PI),' Hertz'
       CASE ('NREF')
!   AFTER NREF: define a new syncronous particle
! ---- DEPHAS: the change of phase (DEG)
! ---- DEW   : the change of kinetic energy (see IREFW)
! ---- follow two falgs, IREF and IREFW
! ----  IF IREF=0: RELATIVE TO the previous synchronous particle
! ----  IF IREF=1: RELATIVE TO the previous COG
! ----  IF IREFW=0: DEWREF is in dW/W
! ----  IF IREFW=1: DEWREF is in dW (MeV)
         write(16,*) 'TYPE CODE: NREF ****************'
         read (in,*) dephas,dewref,iref,irefw
         CALL REFER
         write(16,*) '********************************'
       CASE ('CHANGREF')
!  AFTER CHANGREF: change of reference frame
         write(16,*) 'TYPE CODE: CHANGREF *************'
         CALL CHREFE         
       CASE ('TOF')
! After TOF:
! ---  the T.O.F may be activated in the dynamics of bunchers, cavities and acc. gaps
! ---  Entry: indic and icor
! ---  indic = 0 : the T.O.F is activated, otherwise it is passive
! ---  icor = 0  : no adjustement on the phase offset, otherwise adjustments are automatically made on the phase offset
           write(16,*) 'TYPE CODE: TOF *****************'
           CALL rmami
           write(16,*) '********************************'         
       CASE ('RFQCL')
!   AFTER RFQCL (single cell of a RFQ)
         write(16,*) 'TYPE CODE: RFQCL DEPRECATED ****'
         write(16,*) 'Use RFQPTQ instead *************'
         write(ierr,*)
         write(ierr,*)'TYPE CODE: RFQCL DEPRECATED ****'
         write(ierr,*)'Use RFQPTQ instead *************'
         STOP
       CASE ('SCDYNEL')
!   AFTER SCDYNEL: space charge computations in the current position (i.e. bending magnet)
!     XTRANS is the acting lenght of the beam self-fields (cm)
          write(16,*) 'TYPE CODE: SCDYNEL DEPRECATED **'
          write(16,*) 'Space charge in bending magnets is now'
          write(16,*) 'automatically handled through the BMAGNET card'
          write(ierr,*)
          write(ierr,*)'TYPE CODE: SCDYNEL DEPRECATED **'
          write(ierr,*)'Space charge in bending magnets is now'
          write(ierr,*)'automatically handled through the BMAGNET card'
          STOP
       CASE ('DRIFT')
!  AFTER DRIFT : dl:drift length (cm),if dl is negatif no space charge e
         write(16,*) 'TYPE CODE: DRIFT ***************'
         READ(IN,*)DL
         kt3t=kt3t+1
         write(tif,'(A,i4,A,i4,A,f12.4)')'  nt(',kt3t,')= 1, a(1,',kt3t,')=',10.D0*DL
         trace3t(kt3t)=tif
         call drift(DL)
         write(16,*) '********************************'
       CASE ('FDRIFT')
!  AFTER FDRIFT : Divide a drift length in partial drifts (for space charge computations)
             write(16,*) 'TYPE CODE: FDRIFT **************'
!  XL    : Total drift length (cm)
!  NPART : number of partial drifts
!  IMIT  : if IMIT not equal zero, print emittance data  in the file 'short.txt'
         read(in,*) xl,npart,imit
         dl=xl/DBLE(npart)
         write(16,*) ' Total drift length : ',xl, &
         ' cm divided in : ',npart,' drifts of : ',dl,' cm'
         call fdrift(xl,npart,imit)
         write(16,*) '********************************'
       CASE ('FSOLE')
!AFTER FSOLE: solenoid the magnetic field is read from disk in the form (z,B(z))
!              unities: z (m), B(z) kG
!   BCRET : coefficient multiplier, the magnetic is: B(z) * BCRET
!   sign field convention like in the code TRANSPORT
         write(16,*) 'TYPE CODE: FSOLE ***************'
         myfile=''
         READ(in,'(A)') myfile
!     unit 25 corresponds to an input file giving solenoid magnetic field(s) in the form (z,B(z))
!      check if file is already open
!         iostats = int(FTELL(25))
         INQUIRE(unit=25, opened=isopen)
         if(.NOT. isopen) then
! file not yet open
           lfile=LEN_TRIM(myfile)
           myfile=TRIM(myfile)
           open(25,file=myfile,status='unknown',action='read')
           write(16,*) 'Opening solenoid field file: ', &
                       myfile
           ofelds=myfile
         else
           if(ofeldf.ne.myfile) then
             write(16,*) 'Closing solenoid field file: ',ofelds
             write(16,*) 'Opening solenoid field file: ', &
                       myfile
             close(25)
             lfile=LEN_TRIM(myfile)
             myfile=TRIM(myfile)
             open(25,file=myfile,status='unknown',action='read')
             ofelds=myfile
           endif
         endif
         read(in,*)bcret,intgr
         write(16,'(A,/,5x,A,i4,A)') ' *** SOLENOID WITH ARBITRARY MAGNETIC FIELD ', &
           'PARTITION IN: ',intgr,' ELEMENTARY SOLENOIDS'
         call solfield(bcret,intgr)
         write(16,*) '********************************'
       CASE ('SOLENO')
!   AFTER SOLENO: solenoid
!     IMKS: IFLAG (see ARG)
!     ARG: IMKS = 0 then ARG is the strength K (cm-1), otherwise ARG is the field B (kG)
!     XLSOL : EFFECTIVE LENGHT (CM )
         write(16,*) 'TYPE CODE: SOLENO **************'
         READ(IN,*)IMKS,XLSOL,ARG
         call solnoid(imks,arg,xlsol)
         write(16,*) '********************************'
       CASE ('STEER')
!   AFTER STEER: thin steering element
!---- PARAMETERS ARE INTEGRATED FIELD fld, nvf
!     fld in units of (Tm) for magnetic steerer
!     fld in units of (kV*m/m) for electrostatic steerer
!     (Voltage * length / plate separation)
!     if nvf=0,  horizontal magnetic steerer
!     if nvf=1,  vertical magnetic steerer
!     if nvf=2,  horzontal electrostatic steerer
!     if nvf=3,  vertical electrostatic steerer
         write(16,*) 'TYPE CODE: STEER ***************'
         read(in,*) fld,nvf
         call steer(fld,nvf)
         write(16,*) '********************************'
!  start of writes in file '.short' for steerer
         idav=idav+1
         iitem(idav)=9
         dav1(idav,1)=fld
         dav1(idav,2)=DBLE(nvf)
         dav1(idav,3)=davtot*10.D0
!  end daves
         
       CASE ('EDFLEC')
!     AFTER EDFLEC:  ELECTROSTATIC DEFLECTOR
! --- Input parameters
!   radial radius (cm)
!   bend angle (deg)
!   radii: vertical (radial) radii of curvature (cm)
         write(16,*) 'TYPE CODE: EDFLEC **************'
         call e_deflec
         write(16,*) '********************************'
       CASE ('BMAGNET')
! AFTER BMAGNET (sign conventions as in the code TRANSPORT)
! NSECTOR: number of sectors dividing the bending magnet
! WEDGE BENDING MAGNET
!   ANGL : DEG  bend angle of the central trajectory
!   RMO  : CM   radius of curvature of the central trajectory
!   BAIM : KG   field of the bending magnet
!     BAIM = 0  the field is computed from the momentum of the reference
!               otherwise the momentum is computed from the field
!   XN   :      FIELD GRADIENT (dimensionless,TRANSPORT: n)
!   XB   :      NORMALIZED SECOND DERIVATIVE OF B (TRANSPORT : beta)
!   AP(1) = AP(2) CM vertical half aperture (only if IPOLE = 0)
! ENTRANCE FACE
!  PENT1 EK1 EK2 RAB1
!   PENT1: DEG   angle of pole face rotation  (deg)
!   RAB1 : CM    radius of curvature
!   EK1  :       integral related to the extent of the fringing field (TRANSPORT K1)
!   EK2  :       integral related to the extent of the fringing field (TRANSPORT K2)
!   AP(1) : CM   vertical half aperture
! EXIT FACE
!  PENT2 SK1 SK2  RAB2
!   PENT2: DEG   angle of pole face rotation
!   RAB2 : CM  radius of curvature
!   SK1  :     integral related to the extent of the fringing field
!   SK2  :     integral related to the extent of the fringing field
!   AP(2) : CM   vertical half aperture
!
!   SPACE CHARGE COMPUTATION is automatically provided in the routine
!   CAUTION: with several states charges in the beam, ONLY THE SCHEFF METHOD SHOULD
!            BE USED in the bending magnet
! ----------------------------------------------------------------------------------
!   nsprint: allow plotting the beam after the sector number nsprint in file 13 ('emlg.data')
!cc        read(in,*) nsector,nsprint
         write(16,*) 'TYPE CODE: BMAGNET *************'
         read(in,*) nsector
         READ(IN,*)ANGL,RMO,BAIM,XN,XB
         READ(IN,*)PENT1,RAB1,EK1,EK2,APB(1)
! if apb(1) ne 0 and if ek1 = 0 the program inserts a default value of ek1 = 0.5
         if(abs(apb(1)).gt.fprec .and. ek1.lt. 0.D0) ek1=0.5D0
         READ(IN,*)PENT2,RAB2,SK1,SK2,APB(2)
! if apb(2) ne 0 and  sk1 = 0 the program inserts a default value of sk1 = 0.5
         if(abs(apb(2)).gt.fprec .and. sk1.lt. 0.D0) sk1=0.5D0
! trace3d
! edge
         kt3t=kt3t+1
         write(tif,'(A,i4,A,i4,A,f9.5,A,f9.2,A,f9.2,A,f9.2,A,f9.2)') & 
           '  nt(',kt3t,')= 9, a(1,',kt3t,')=',PENT1,' , ',10.D0*abs(RMO), &
                    ' , ',20.D0*APB(1),' , ',EK1,' , ',EK2
         trace3t(kt3t)=tif
! bend
         kt3t=kt3t+1
         write(tif,'(A,i4,A,i4,A,f9.5,A,f9.2,A)') &
           '  nt(',kt3t,')= 8, a(1,',kt3t,')=',ANGL,' , ',10.D0*abs(RMO),' , 0 , 0 '
         trace3t(kt3t)=tif
! edge
         kt3t=kt3t+1
         write(tif,'(A,i4,A,i4,A,f9.5,A,f9.2,A,f9.2,A,f9.2,A,f9.2)') & 
           '  nt(',kt3t,')= 9, a(1,',kt3t,')=',PENT2,' , ',10.D0*abs(RMO), &
                    ' , ',20.D0*APB(2),' , ',SK1,' , ',SK2
         trace3t(kt3t)=tif
!
!
         CALL aimalv(ANGL,RMO,BAIM,XN,XB,EK1,EK2,PENT1,RAB1, &
                         SK1,SK2,PENT2,RAB2)
         write(16,*) '********************************'
       CASE ('QUADRUPO')
!  AFTER QUADRUPO: quadrupole
!      BQUAD: field at pole tip (kG)
!      XLQUA: EFFECTIVE LENGHT (cm )
!      RG:    APERTURE RADIUS (cm)
         write(16,*) 'TYPE CODE: QUADRUPO ************'
         READ(IN,*)XLQUA,BQUAD,RG
         kt3t=kt3t+1
         write(tif,'(A,i4,A,i4,A,f10.5,A,f9.5)') &
           '  nt(',kt3t,')= 3, a(1,',kt3t,')= ',10.D0*BQUAD/RG,' , ',XLQUA*10.D0
         trace3t(kt3t)=tif
         call qalva(bquad,xlqua,rg)
         write(16,*) '********************************'
       CASE ('QUADSXT')
!    AFTER QUADSXT:
!       quadrupole associated with sextupole
!    IKSQ: IFLAG (see ARGS and ARGQ)
!    ARGS: strength of SEXTUPOLE
!      IKSQ = 0, then ARGS = KS2 (cm-3), otherwise ARGS = FIELD BS(kG)
!    ARGQ: strength of QUADRUPOLE
!     If IKSQ = 0, then ARGQ = K2 (cm-2), otherwise ARGQ = FIELD BQ(kG)
!    XLQUA : EFFECTIVE LENGHT OF THE LENS(cm)
!    RG : APERTURE RADIUS OF THE LENS (cm)
         write(16,*) 'TYPE CODE: QUADSXT *************'
         READ(IN,*)iksq,args,argq,xlqua,rg
         call qasex(iksq,args,argq,xlqua,rg)
         write(16,*) '********************************'  
       CASE ('QUAELEC')
!    AFTER QUAELEC: electric quadrupole
!       VOLT: voltage at pole tip (kV)
!       XLQUA: effective length  (cm)
!       RS: radial distance of pole tip from axis (cm)
         write(16,*) 'TYPE CODE: QUALEC **************'
         READ(IN,*)XLQUA,VOLT,RS
         call qelec(volt,xlqua,rs)
         write(16,*) '********************************'
       CASE ('QUAFK')
!    AFTER QUAFK:  quadrupole (magnetic or electric)
!       ITYQU: ITYQU = 0 electric quadrupole , otherwise magnetic quadrupole
!       ARG: K2 (cm-2)
!       XLQUA: effective length  (cm)
!       RS: radial distance of pole tip from the axis (cm)
         write(16,*) 'TYPE CODE: QUAFK ***************'
         READ(IN,*)ITYQU,ARG,XLQUA,RS
         call qfk (ityqu,arg,xlqua,rs)
         write(16,*) '********************************'
       CASE ('SEXTUPO')
!    AFTER SEXTUPO: sextupole
!     IMK2: IFLAG (see arg)
!     ARG = KS2 (cm-3) if IMK2 = 0, otherwise ARG = BSEX (kG)
!     XLSEX : EFFECTIVE LENGHT (CM )
!     RG :APERTURE RADIUS (CM)
         write(16,*) 'TYPE CODE: SEXTUPO *************'
         READ(IN,*)IMK2,ARG,XLSEX,RG
         call sextu(imk2,arg,xlsex,rg)
         write(16,*) '********************************'
       CASE ('MHB')
!  AFTER MHB : multi-harmonic buncher
         write(16,*) '********************************'
         write(16,*) 'TYPE CODE: MHB *****************'
         write(16,*) '  MULTI-HARMONIC BUNCHER       *'
         write(16,*) '********************************'
         call buncnum
       CASE ('BUNCHER')
!  After BUNCHER: buncher as a single element
!      PV: Voltage
!      PDP: PHASE OF RF (deg)
!      PRLIM: aperture radius (cm)
!      PHARM: harmonic factor (bucher fq.)/(DTL freq.)
         write(16,*) 'TYPE CODE: BUNCHER *************'
         READ(IN,*) pv,pdp,pharm,prlim
         write(16,'(A,/,A,e12.5,A,/,A,e12.5,A,e12.5,A)') ' BUNCHER CAVITY ', &
                  ' Voltage ',pv,' MV', &
                  ' RF Phase ',pdp,' deg Aperture Radius ',prlim,' cm'
         kt3t=kt3t+1
         write(tif,'(A,i4,A,i4,A,f9.5,A,f9.2,A,f5.1)') &
           '  nt(',kt3t,')=10, a(1,',kt3t,')=',pv,' , ',pdp,' , 1 , 1 , ',pharm
         trace3t(kt3t)=tif
         pdp=pdp*pi/180.D0
         call bunparm(pv,pdp,pharm,prlim)
         write(16,*) '********************************'
       CASE ('RFQPTQ')
! --- AFTER RFQPTQ (RFQ per tutti quanti)
         write(16,*) 'TYPE CODE: RFQPTQ **************'
         write(6,*)
! -- ENTRIES:
! ---  ENTRY 1: input file 'myfile' contains the geometry of the RFQ (unit 27)
! ---  ENTRY 2: nceltot
!        nceltot: number of cells (may be less than the total number of cells)
! ---  ENTRY 3: tvolt avolt fph
! ---- tvolt: factor applied to intervane-voltage Vref of the synchronous particle (in %)
! ---- avolt: factor applied to intervane-voltage Vpart for particles (in %)
!        Vref = Vref(1 + tvolt/100)
!        Vpart = Vpart(1 + avolt/100)
! --- fph: factor applied to the phase at entrance of cells in the file myfile  in %)
!        (phase at entrance of cells)= (1 + fph/100) X (phase in myfile)
!  NOTE: fph is only available for cells of type = 0, type = 2 (type = E) or type = 5 (type R)
! --- pib > 0:  shift the particles at the entrance of the RFQ inside (+/-) pi w.r.t.the synchronous particle
! --- pib = 0: no action
!
!
! related files:
!
!     'rfq_list.data'  : list of parameters of the RFQ
!
!     'rfq_coeflist.data' list of coefficients
         myfile=''
         READ(in,'(A)') myfile
         lfile=LEN_TRIM(myfile)             
         myfile=TRIM(myfile)
         write(16,*) 'RFQ input data file: ',myfile
         open(27,file=myfile,status='unknown',action='read')
         myfile='rfq_list.data'
         if(mcselect) myfile='rfq_list'//mc//'.data'
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         open(70,file=myfile,status='unknown')
         myfile='rfq_coef.data'
         if(mcselect) myfile='mc'//mc//'rfq_coef.data'
         lfile=LEN_TRIM(myfile)
         myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
         myfile(1:lpath)=dpath(1:lpath)
         myfile=TRIM(myfile)
         open(75,file=myfile,status='unknown')
         read(in,*) nceltot
         read(in,*) tvolt,avolt,fph,pib
         write(16,'(A,i5,/,A,e12.5,A,/,A,e12.5,A)') ' RFQ number of cells: ',nceltot, &
           '  factor on intervane voltage (reference):',tvolt,' %', &
           '  factor on intervane voltage (bunch)    :',avolt,' % '
         tvolt=tvolt/100.D0
         avolt=avolt/100.D0
         fph=(1.D0+fph/100.D0)
         if(ichaes) then
           write(16,*)'***** beam current: ',BEAMC*fhinit/fh,' mA'
           if(iscsp.lt.3) then
             write(ierr,*)'*** HERSC and SCHERM cannot be ', &
                        'used in the RFQ'
             write(16,*)'*** HERSC and SCHERM cannot be used ', &
                        'in the RFQ'
             stop
           endif
         endif
         if(.not. mcselect) then        
           myfile='rfq_profile.dat'
           lfile=LEN_TRIM(myfile)
           myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
           myfile(1:lpath)=dpath(1:lpath)
           myfile=TRIM(myfile)  
           open(98,file=myfile,status='unknown')       
           write(98,*) '# cell# type step   z(m)           rx(m)      r0(m)      ry(m)' 
         endif            
         call cpardyn(pib)
         write(6,*)
         write(16,*) '****************************'
       CASE ('CAVNUM')
!    AFTER CAVNUM: numerical computation of multicell cavities
!           the electromagnetic field can be read from file in the form (z,E(z))
!           or from the type code: HARM in the form of a Fourier series expansion
         write(16,*) 'TYPE CODE: CAVNUM **************'
         call cavnum
         write(16,*) '********************************'
       CASE ('CAVMC')
!   AFTER CAVMC: Multicell accelerating element
!           the electromagnetic field can be read from file in the form (z,E(z))
!           or from the type code: HARM in the form of a Fourier series expansion
         write(16,*) 'TYPE CODE: CAVMC ***************'
         CALL RESTAY
         write(16,*) '********************************'
       CASE ('CAVSC')
!   AFTER CAVSC: single cell accelerating element
!                The transit time factors describe the electromagnetic field
         write(16,*) 'TYPE CODE: CAVSC ***************'
         CALL ETGAP
         write(16,*) '********************************'
       CASE ('HARM')
! AFTER HARM: the field is read on the form of a Fourier series expansion
         write(16,*) 'TYPE CODE: HARM  ***************'
         write(16,*) 'ELECTRIC FIELD (Fourier series expansion)'
         call rharm
         write(16,*) '********************************'         
       CASE ('FIELD')
!  AFTER FIELD
! --- the axial field of the cavity is read from file in the form (z,E(z)) with a step size h in z
!     in the SUPERFISH format: z(m)  E(z) (V/m)
!  PART: the step size h may be divided in 'part' elements (with PART (= >) 1)
!  ATT:  the field E(z) is multiplied by ATT and converted in MV/cm
!
         write(16,*) 'TYPE CODE: FIELD  **************'
         write(16,*) 'ELECTRIC FIELD (z, E(z) ) '
!      get filename of input file of the electromagnetic field in the form (z,E(z))
         myfile=''
         READ(in,'(a)') myfile
!      check if file is already open
!         iostats = int(FTELL(20))
         INQUIRE(unit=20, opened=isopen)
         myfile=TRIM(myfile)
         if(.NOT. isopen) then
! file not yet open
           open(20,file=myfile,status='unknown',action='read')
           write(16,*) 'Opening field file: ',myfile
           ofeldf=myfile
         else
           if(ofeldf.ne.myfile) then
             write(16,*) 'Closing field file: ',ofeldf
             write(16,*) 'Opening field file: ',myfile
             close(20)
             open(20,file=myfile,status='unknown',action='read')
             ofeldf=myfile
           endif
         endif
         read(in,*) att
!omment       write(16,*) ' partition of a step h: ',part,' field factor: ', att
!     conversion V/m (SUPERFISH) --> MV/cm
         att=1.D-08*att
         write(16,*) ' * Read the cavity field from ',myfile(1:80)
         call fieldcav(att)
         write(16,*) '********************************'
       CASE ('COMMENT')
!    AFTER COMMENT
! allows for comments in the input data file
         write(16,*)'TYPE CODE: COMMENT *************'
         READ (in,'(A)') cmnt(1:80)
         WRITE(16,'(1x,A)')  cmnt(1:80)
       CASE ('WRBEAM')
!   AFTER WRBEAM: prints coordinates of particles in output files
         write(16,*)'TYPE CODE: WRBEAM ***************'
!      irec:flag   irec=0 the phase is recentered with regard to the c.o.g
!                  irec<>0 the phase is not recentered around the c.o.g
         read(in,'(A)') myfile
! check for optional midcell key behind file name (can be used with RFQ cells)
         lm=len_trim(myfile)
         wfile=''
         if(myfile(lm-9:lm).eq.'rfqmidcell' .or. &
            myfile(lm-9:lm).eq.'RFQMIDCELL') then
           rfqmidcell=.true.
           wfile=myfile(1:lm-10)
         elseif(myfile(lm-9:lm).eq.'rfqmaecell' .or. &
            myfile(lm-9:lm).eq.'RFQMAECELL') then
           rfqmaecell=.true.
           wfile=myfile(1:lm-10)
         else   
           wfile=trim(myfile)
         endif
         nopath=.true.
         do i=1,LEN_TRIM(wfile)
           if(wfile(i:i).eq."/" .or. wfile(i:i).eq."\") nopath=.false.
         enddo
         if(nopath) then
! check if intended to run on multiple cores             
           if(mcselect) wfile='mc'//mc//trim(wfile)
           wfile=TRIM(dpath)//trim(wfile)
           write(16,'(A)') ' Particle distribution coordinates '// &
                           'will be written to '//wfile
         else
           if(mcselect) write(16,*) "Writing .dst files in MC"// &
            " mode with full path not implemented yet"
         endif
         if(rfqmidcell) then
           write(16,'(A)') ' For RFQ cells, this will be at the'// &
           ' cell middle.'
         elseif(rfqmaecell) then
           write(16,'(A)') ' For RFQ cells, this will be at the'// &
           ' cell middle and at the cell end.'
         else   
           write(16,'(A)') ' For RFQ cells, this will be at the'// &
           ' cell end.'
         endif                  
         read(in,'(A)') text
         read(text,*) irec,iflg
         if(iflg.ge.0) then
           fromrfq=.false.
           call prbeam(iflg,wfile,fromrfq)
         else
! write beam to file after RFQ cells
           read(text,*) irec,iflg,rfqiflg
           if(rfqiflg.lt.0) then
! output for more than one individual cell
             nrwc=-rfqiflg
             read(text,*) irec,iflg,rfqiflg,(iwcl(i),i=1,nrwc)
             write(16,'(A)') ' Do this for RFQ cell(s):'
             write(16,*) (iwcl(i),i=1,nrwc)
           else
! output for one cell or all cells
             write(16,'(A)')' Do this for one or all RFQ cell(s).'
           endif
           iflgr=-iflg
           rfqwfil=trim(wfile)
           rfqirec=irec
         endif
         write(16,*) '********************************'
       CASE ('DFLOCS')
!   AFTER DFLOCS: prints coordinates of particles in output files at locations as 
!                 defined in a file by the user. Exception: RFQ cells (use WRBEAM for this)
         write(16,*)'TYPE CODE: DFLOCS ***************'
!      irec:flag   irec=0 the phase is recentered with regard to the c.o.g
!                  irec<>0 the phase is not recentered around the c.o.g
         read(in,'(A)') dflocfile
         dflocfile=TRIM(dflocfile)
         open(24,file=dflocfile,status='unknown')
         lm=len_trim(dflocfile)
         write(16,'(A)') ' Particle .dst files '// &
           'will be written at locations as listed in '//TRIM(dflocfile)
         read(in,'(A)') text
         read(text,*) irec,idflg
! read the element names for which to print the .dst file and save them in an array
         i=1
         DO
!           read(24,*,END=555) dflnames(i),idflio(i)
           read(24,*,iostat=ios) dflnames(i),idflio(i)
           if( ios < 0 ) exit ! end of file is reached		 
           i=i+1
         ENDDO
         close(24)
!555      nodflocs=i-1
         nodflocs=i-1
         write(16,'(A,i4,A)') 'For ',nodflocs,&
                      ' elements particle .dst files will be written'             
! if idflio=0, no .dst file will be written
! if idflio=1,  a .dst file will be written at the input of the element
! if idflio=2,  a .dst file will be written at the output of the element
! if idflio=3,  a .dst file will be written at the input and at the output of the element
         if(idflg.lt.0) then             
! iflag has to be ge.0, so report error
           write(16,*) '************!! ERROR !!********************'
           write(6,*)  '************!! ERROR !!********************'               
           write(16,*) ' IFLAG after DFLOCS card cannot be negative'
           write(6,*)  ' IFLAG after DFLOCS card cannot be negative'               
           write(16,*) '************!!  STOP !!********************'
           write(6,*)  '************!!  STOP !!********************'                
           STOP
         endif
         write(16,*) '********************************'             
       CASE ('STRIPPER')
! --- AFTER STRIPPER: stripper foils
! ---  ( based on the works of D.A. Eastham, ref.   )
! --- available for 'slow' hadron particles
! --- STRIPPER FOILS PARAMETERS:
! --- qs : charge (unit of charge)
! --- atms: atomic mass
! --- ths : thickness of the foils (g/cm**2)
! --- PARTICLES
!*2010-12-02 Use Baron formula for charge state distribution in case of carbon foils
! --- anp : atomic number of the projectile
! --- nqst: number of charge states after the stripper
! --- sqst: array holding the nsqt charge states
! --- qop : charge of particles after crossing the stripper foils (unit of charge)
! --- the atomic mass of particles (atm) is the one given in INPUT or in RDBEAM
         write(16,*) 'TYPE CODE: STRIPPER ************'
         read(in,*)qs,atms,ths,anp
         call stripp
         write(16,*) '********************************'
       CASE ('SCDYNAC')
! AFTER SCDYNAC
!   ISCSP: METHOD FOR SPACE CHARGE COMPUTATIONS
!     ISCSP=1  HERSC METHOD
!     ISCSP=2  SCHERM METHOD
!     ISCSP=3  SCHEFF METHOD
         write(16,*) 'TYPE CODE: SCDYNAC *************'
         read(in,*) iscsp
!      sce10 =1 : call in quads,solenoids,accelarating elements
!      sce10 =2 : call in drifts,accelarating elements
!      sce10 =3 : call in quads,solenoids,drifts,accelarating elements
!      BEAM CURRENT IN mA
         READ(IN,*) BEAMC,sce10
         beame=beamc
         if(.not.xiset) then
           kt3h=kt3h+1
           write(tif,'(" XI= ",f9.4)') BEAMC
           trace3h(kt3h)=tif
           xiset=.true.
         endif
         if(iscsp.le.1) write(16,*) 'HERSC method  '
         if(iscsp.eq.2) write(16,*) 'SCHERM method  '
         if(iscsp.eq.3) write(16,*) 'SCHEFF method  '
         if(iscsp.gt.3) then
           write(ierr,*) 'Error in SCDYNAC iscsp: ',iscsp
           write(16,*) 'Error in SCDYNAC iscsp: ',iscsp
           stop
         endif
         WRITE(16,*)' Beam current : ',BEAMC*fhinit/fh,' mA'
         ECT=4.D0
         ICHAES=.TRUE.
         if (.not. allocated(DWP)) allocate(DWP(iptsz))
         if (.not. allocated(FS)) allocate(FS(7,iptsz))
         if (.not. allocated(xc)) allocate(xc(iptsz))
         if (.not. allocated(yc)) allocate(yc(iptsz))
         if (.not. allocated(zc)) allocate(zc(iptsz))
         if(iscsp.le.1) then
!---  HERSC, initialize the routine HERSC
           if (.not. allocated(xcp)) allocate(xcp(iptsz))
           if (.not. allocated(ycp)) allocate(ycp(iptsz))
           if (.not. allocated(zcp)) allocate(zcp(iptsz))
           if(iscsp.eq.1)ini=0
           if(iscsp.lt.1)ini=-1
           call hersc(ini)
           iscsp=1
         endif
         if(iscsp.eq.2) then
!---  SCHERM, read third line as dummy
           read(in,*) fdum
           if (.not. allocated(xcp)) allocate(xcp(iptsz))
           if (.not. allocated(ycp)) allocate(ycp(iptsz))
           if (.not. allocated(zcp)) allocate(zcp(iptsz))
         endif
         if(iscsp.eq.3) then
! --- SCHEFF
!          initialize the mesh of routine SCHEFF
           call schfdyn
         endif
         if (abs(beamc).le.fprec) ichaes=.FALSE.
         write(16,*) '********************************'
       CASE ('MMODE')
! AFTER MMODE: systematic or random error on the phase offset and on the level of the field
! ---          MMODE is only acting on  particles in the bunch  (no change of the reference)
! --- ENTRY: ierpf , vphase , vfield
! --- ierpf: flag
! ---   IF:  ierpf = 0  ===> stop the type code effects
! ---        ierpf = 1  ===> systematic error
! ---        ierpf = 2  ===> random error
! ---  vphase (deg): error added to the nominal phase offset
! ---  vfield (%)  : error added to the level of the electric field
! ---  (new phase offset) = (previous phase offset) + vphase
! ---  (new level of field) = (previous level of field) * (1.D0+ vfield/100)
         write(16,*) 'TYPE CODE: MMODE ***************'
         read(in,*) ierpf,vphase,vfield
         if(ierpf.eq.0) then
           vphase=0.D0
           vfield=0.D0
           write(16,'(A)') ' Errors on phase and field level reset to zero.'
         endif
         if(ierpf.eq.1) write(16,'(2x,A,e12.2,A,/,2x,A,e12.5,A)') &
           'systematic error on phase offset: ',vphase,'    deg', &
           'systematic error on field level :    ',vfield,' %'
         if(ierpf.eq.2) write(16,'(2x,A,e12.2,A,/,2x,A,e12.5,A)') &
           'maximum random error on phase offset: ',vphase,'    deg', &
           'maximum random error on field level :    ',vfield,' %'
         vfield=vfield/100.D0
         write(16,*) '********************************'         
       CASE ('ALINER')
!   after ALINER: ALIGNMENT errors IN X,X',Y,Y'
!     XL,YL (cm)    XPL,YPL (mrad)
         write(16,*) 'TYPE CODE: ALINER **************'
         read(in,*) XL,YL,XPL,YPL
         CALL ALINER
         write(16,*) '********************************'
       CASE ('TWQA')
!  AFTER TWQA generates systematic or random twist of quadrupoles
!  QTWIST: rotation about Y axis (deg)
!  IQRAND: =0 systematic twist, otherwise random twist
         write(16,*) 'TYPE CODE: TWQA ****************'
         read(in,*) iqrand,qtwist
         itwist=.true.
         if(abs(qtwist).le.1.D-20) then
           itwist=.false.
         else
           write(16,*) 'Rotation of ',qtwist,' deg about the Y axis will be applied in quadrupoles'         
         endif           
         write(16,*) '********************************'         
       CASE ('RANDALI')
!  AFTER RANDALI : generates random errors in alignments
!     XL,YL (cm)    XPL,YPL (mrad)
!     ilier = 0 stop the effects of the random misalignment
         write(16,*) 'TYPE CODE: RANDALI *************'
         read(in,*) ilier
         if(ilier.eq.0) then
           ialin=.false.
           write(16,*) '********************************'
         else
           ialin=.true.
           read(in,*) XL,YL,XPL,YPL
         endif
         write(16,*) '********************************'         
       CASE ('ZROT')
! AFTER ZROT : beam rotation
!  The transverse coordinates x and y may be rotated through an
!  angle ZROTA(deg).The positive sense of ratation is clockwise
!  about the positive z axis
         write(16,*) 'TYPE CODE: ZROT ****************'
         READ(IN,*)ZROTA
         CALL ZROTAT(ZROTA)
         write(16,*) '********************************'
       CASE ('ACCEPT')
!    AFTER ACCEPT: Determination of the input acceptance for the structure
         write(16,*) 'TYPE CODE: ACCEPT **************'
         acpt=.true.
         CALL ACCEPT
         acpt=.false.
         write(16,*) '********************************'         
       CASE ('EMIPRT')
!  AFTER EMIPRT : print the beam characteristics to disk (unit 12, file='dynac.short')
! --- the beam characteristics are systematically printed after:
!       cavities, accelerating gaps, bunchers, electrons gun, rfq
!
!  IEMQESG :  =0  stop the prints for all optical lenses
!             =1  after all optical lenses apart from positive drifts
!             =2  after all optical lenses and positive drifts
!             =3  after quads, solen.,positive drifts and accel. elements
         write(16,*) 'TYPE CODE: EMIPRT **************'
         iemgrw=.true.
         read(in,*) iemqesg
         if(iemqesg.eq.0) iemgrw=.false.
       CASE ('EMITGR')
!    AFTER EMITGR: emittance plots
!    PLOTS IN XX', YY', XY AND ZZ'
         write(16,*) 'TYPE CODE: EMITGR **************'
         igrprm=0
         call ytzp
         write(16,*) '********************************'
       CASE ('EMITGRD')
!    AFTER EMITGRD: emittance density plots
!    PLOTS IN XX', YY', XY AND ZZ'
         write(16,*) 'TYPE CODE: EMITGRD *************'
         igrprm=0
         call ytzp2d
         write(16,*) '********************************'
       CASE ('PROFGR')
!  AFTER PROFGR: X-Z and Y-Z scatter plots,(X,Y,Z) and (Xp,Yp,Zp) profiles
         write(16,*) 'TYPE CODE: PROFGR **************'
         igrprm=0
         if (igrprm.eq.0) then
!          READ GRAPH TITLE
           READ(IN,'(A)') TEXT
! idwdp=0  cog=ref  in XZ,YZ plots (for instance for Alvarez structure)
! idwdp=1  cog<>ref in XZ,YZ plots (for instance for IH structrure)
! iskale=0 vertical scale on profile plots is NOT a log scale
! iskale=1 vertical scale on profile plots IS a log scale
           READ(IN,*) idwdp,iskale
!          READ GRAPH LIMITS INTO GLIM(J,K), J=GRAPH NUMBER
!          K=1 HOR. LIMIT , K=2 VERT. LIMIT
           READ(IN,*) GLIM(3,1),GLIM(3,2),GLIM(4,1),GLIM(4,2)
         endif
         call grcomp(text,iskale)
         write(16,*) '****************************'  
       CASE ('PROFGRD')
!    AFTER PROFGRD: X-Z and Y-Z density plots,(X,Y,Z) and (Xp,Yp,Zp) profiles
         write(16,*) 'TYPE CODE: PROFGRD *************'
         igrprm=0
         if (igrprm.eq.0) then
!        READ GRAPH TITLE
           READ(IN,'(A)') TEXT
! idwdp=0 cog=ref in XZ,YZ plots (for instance for Alvarez structure)
! idwdp=1 cog<>ref in XZ,YZ plots (for instance for IH structrure)
! iskale=0 vertical scale on profile plots is NOT a log scale
! iskale=1 vertical scale on profile plots IS a log scale
           READ(IN,*) idwdp,iskale
!        READ GRAPH LIMITS INTO GLIM(J,K), J=GRAPH NUMBER
!        K=1 HOR. LIMIT , K=2 VERT. LIMIT
           READ(IN,*) GLIM(3,1),GLIM(3,2),GLIM(4,1),GLIM(4,2)
         endif
         call grcomp2d(text,iskale)
         write(16,*) '****************************'
       CASE ('ENVEL')
!   AFTER ENVEL: plot the longitudinal and the tranverse envelope of the beam
         write(16,*) 'TYPE CODE: ENVEL ***************'
         CALL PROFIL
         write(16,*) '********************************' 
       CASE ('ZONES')
!  AFTER ZONES: specify zones of different colours in the bunch
         write(16,*) 'TYPE CODE: ZONES ***************'
         init=1
         call area(init)
         write(16,*) '********************************' 
       CASE ('EMIT')
!    AFTER EMIT  Print emittance data in the file 'dynac.short'
         write(16,*) 'TYPE CODE: EMIT ****************'
         CALL emiprt(0)
       CASE ('EMITL')
!    AFTER EMITL  Print emittance datas in the file 'dynac.short' but
!                 also read label to be written to dynac.short
         write(16,*) 'TYPE CODE: EMITL ***************'
         read(in,'(A)') shortl
         write(16,*) shortl
         call emiprt(1)                  
         write(16,*) '********************************'
       CASE ('REJECT')
!   AFTER REJECT: defining limits in X,X',Y,Y',Z,Z'
! ---- aperture of the Beam
! ----  WDISP: in half dispersion
! ------  IF IFW=0  ==> WDISP in (+-) dW/W
! ------  IF IFW=1  ==> WDISP in (+-) dW (MeV)
! ------  IF IFW=10 ==> wdisp = dW/W relative to REF
! ------  IF IFW=11 ==> wdisp = dW relative to REF
! ----  WPHAS: in half phase (+-) deg
! ----  WX   : in x-direction (+-) cm
! ----  WY   : in y-direction (+-) cm
! ----  RLIM : in radius (cm)
         write(16,*) 'TYPE CODE: REJECT **************'
         READ(IN,*) IFW,WDISP,WPHAS,WX,WY,RLIM
         if(ifw.eq.0) then
           WRITE(16,'(5x,A,/,4x,A,e12.5,A,e12.5,/,4x,A,e12.5,A,e12.5,A,e12.5)') &
            '*** BEAM SIZE LIMITS ',' 1/2 dW/W    :',WDISP,'  1/2 PHASE(DEG) :', &
            WPHAS,' 1/2 x (cm)  :',WX,'  1/2 y(cm)      :',WY,' RADIUS (cm) :',RLIM
           WRITE(16,*)'    Energy spread window w.r.t. COG'
         elseif(ifw.eq.1) then
           WRITE(16,'(5x,A,/,4x,A,e12.5,A,e12.5,/,4x,A,e12.5,A,e12.5,A,e12.5)') &
            '*** BEAM SIZE LIMITS ',' 1/2 dW (MeV):',WDISP,'  1/2 PHASE(DEG) :', &
            WPHAS,' 1/2 x (cm)  :',WX,'  1/2 y(cm)      :',WY,' RADIUS (cm) :',RLIM
           WRITE(16,*)'    Energy spread window w.r.t. COG'
         elseif(ifw.eq.10) then
           WRITE(16,'(5x,A,/,4x,A,e12.5,A,e12.5,/,4x,A,e12.5,A,e12.5,A,e12.5)') &
            '*** BEAM SIZE LIMITS ',' 1/2 dW/W    :',WDISP,'  1/2 PHASE(DEG) :', &
            WPHAS,' 1/2 x (cm)  :',WX,'  1/2 y(cm)      :',WY,' RADIUS (cm) :',RLIM
           WRITE(16,*)'    Energy spread window w.r.t. reference'
         elseif(ifw.eq.11) then
           WRITE(16,'(5x,A,/,4x,A,e12.5,A,e12.5,/,4x,A,e12.5,A,e12.5,A,e12.5)') &
            '*** BEAM SIZE LIMITS ',' 1/2 dW (MeV):',WDISP,'  1/2 PHASE(DEG) :', &
            WPHAS,' 1/2 x (cm)  :',WX,'  1/2 y(cm)      :',WY,' RADIUS (cm) :',RLIM
           WRITE(16,*)'    Energy spread window w.r.t. reference'
         else
           WRITE(16,*) 'Error in REJECT input:'
           WRITE(16,*) 'IFW=',ifw,' but should be 0, 1, 10 or 11'
           WRITE(ierr,*) 'Error in REJECT input:'
           WRITE(ierr,*) 'IFW=',ifw,' but should be 0, 1, 10 or 11'
           stop
         endif
! ---- convert WPHAS in rad
         WPHAS=WPHAS*pi/180.D0
         write(16,*) '********************************'
       CASE ('WIENANA')
!    AFTER WIENANA: Wien filter, analytical method, based on SEPARA from ZGOUBI
!IA, XL, E, B
!IA = 0 : element inactive 
!IA = 1 : horizontal separation 
!IA = 2 : vertical separation ;
!XL = Length of the separator (cm)
! E = Electric field (V/m)
! B = Magnetic field (T)
             write(16,*) 
             write(16,*) 'TYPE CODE: WIENANA *************'
             READ(IN,*)iwfia,wfxl,wfef,wfbf
! next lines normally for T3D; no WF in T3D, so ignore.             
!             kt3t=kt3t+1
!             write(tif,6102) kt3t,kt3t,10.D0*BQUAD/RG,XLQUA*10.D0
! 6102        format('  nt(',i4,')= 3, a(1,',i4,')= ',f10.5,' , ',f9.5)
!             trace3t(kt3t)=tif
            call separa(iwfia,wfxl,wfef,wfbf)
             write(16,*) '********************************'
             write(16,*) 
       CASE ('WIENNUM')
!    AFTER WIENNUM: Wien filter, numerical method, based on WIENFI from ZGOUBI
         write(16,*) 
         write(16,*) 'TYPE CODE: WIENNUM *************'
         CALL WIENFIN
         write(16,*) '********************************'
         write(16,*) 
       CASE ('STOP')
!  AFTER STOP: mandatory, stop the computations
         write(16,*) 'TYPE CODE: STOP ****************'
         tcog=0.D0
         wcog=0.D0
         do ijp=1,ngood
           wcog=wcog+f(7,ijp)
           tcog=tcog+f(6,ijp)
         enddo
         if(ngood.ne.0) then
           wcog=wcog/DBLE(ngood)
           tcog=tcog/DBLE(ngood)
           gcog=wcog/xmat
           bcog=sqrt(gcog*gcog-1.D0)/gcog
! store END data for .dmp file
!             dmpdat(1)=davtot/100.D0
!             dmpdat(2)=100.*DBLE(ngood/imax)
!             dmpdat(3)=0.
!             dmpdat(4)=tcog*180.D0*fh/pi
!             dmpdat(5)=bcog
!             dmpdat(6)=(sqrt(1./(1.D0-bcog*bcog))-1.D0)*xmat
!             dmpdat(7)=tref*180.D0*fh/pi
!             bref=vref/vl
!             dmpdat(8)=bref
!             dmpdat(9)=(sqrt(1./(1.-bref*bref))-1.D0)*xmat
! dmpdat(10), dmpdat(11), dmpdat(12) loaded in emiprt
!             dmpdat(13)=0.
!             dmpdat(14)=0.
           shortl='STOP card encountered; beam data are:'
           call emiprt(1)
!             nd=0
!             write(50,*) '# end     Z       trans   ',
!     *   'dummy    TOF(COG)    COG        Wcog          TOF(REF)   ',
!     *   '    REF         Wref       Ex,RMS,n     Ey,RMS,n     ',
!     *   'El,RMS       dummy         dummy'
!             write(50,*) '#  #     (m)       (%)    ',
!     *  '          (deg)      beta       (MeV)          (deg)      ',
!     *  '   beta       (MeV)       (mm.mrad)    (mm.mrad)    (ns.keV)'
!             write(50,7023) nd,(dmpdat(j),j=1,14)
!7023         format(1x,i4,1x,e12.5,1x,f6.2,1x,f7.2,1x,
!     *   2(e14.7,1x,f7.5,1x,e14.7,1x),7(e12.5,1x))
           write(16,'(1X,A,A8,A,//)') 'STOP ON KEY: ',KLEY
         endif
         exit
       CASE default
!! key not found, go to STOP
         indic=999
         WRITE(66,*) indic
         WRITE(16,'(A,A8,A)')' **** STOP ON KEY: ',KLEY,' (invalid key) ****'
         WRITE(6, '(A,A8,A)') '**** STOP ON KEY: ',KLEY,' (invalid key) ****'
         EXIT
     end select
   ENDDO
!
! write trace file (if requested)
   if(T3D) then
! write trace file (header part)
     myfile=''
     myfile='for_trace3d.t3d'
     if(mcselect) myfile='mc'//mc//'for_trace3d.t3d'
     lfile=LEN_TRIM(myfile)
     myfile(lpath+1:lpath+lfile)=myfile(1:lfile)
     myfile(1:lpath)=dpath(1:lpath)
     myfile=TRIM(myfile)
     open(itout,file=myfile,status='unknown')
     write(itout,'(A)') trace3h(1)
     write(itout,1990) kt3t,kt3t,kt3t
 1990    format(' N1= 1, N2= ',I4,', NEL1= 1, NEL2= ',I4, &
              ', NP1= 1, NP2= ',I4)
     do i=2,kt3h
       write(itout,'(A)') trace3h(i)
     enddo
     write(itout,'(A)') " PQEXT= 2.5, ICHROM= 0, IBS= 0, SMAX= 2.0"
     write(itout,'(A)') " XM=  15.00, XPM=  50.00, YM=  15.00"
     write(itout,'(A)') " XMI= 15.00, XPMI= 50.00, XMF= 15.00, XPMF= 25.00"
     write(itout,'(A)') " DPM=  90.0, DWM=  50.00, DPP= 90.00"
     write(itout,'(A)') " DPMI= 90.0, DPMF= 35.00, DWMI= 50.0, DWMF= 200.0"
! write trace file (beam line part)
!
! deal with negative drifts (typical within DTLs)
! if the current drift is negative, then see if there is a drift before or
! after it. If so, add the 2 drifts, devide by 2 and put this result in both
! drifts
     do k=2,kt3t-1
       trdrifa=0.D0
       trdrifb=0.D0
       tif=trace3t(k)
       tifb=trace3t(k-1)
       tifa=trace3t(k+1)
       if(tif(12:13).eq.' 1' .and. tifb(12:13).eq.' 1') then
         read(tif(28:50),*) trdrift
         if(trdrift.lt. 0.D0) then
           read(tifb(28:50),*) trdrifb
           if(trdrifb.gt. 0.D0) then
             aver=(trdrifb+trdrift)/2.D0
             trdrifb=aver
             trdrift=aver
             write(fdrft,'(f12.6)') trdrift
             tif(28:40)=fdrft
             write(fdrft,'(f12.6)') trdrifb
             tifb(28:40)=fdrft
             trace3t(k)=tif
             trace3t(k-1)=tifb
           endif
         endif
       elseif(tif(12:13).eq.' 1' .and. tifa(12:13).eq.' 1') then
         read(tif(28:50),*) trdrift
         if(trdrift.lt. 0.D0) then
           read(tifa(28:50),*) trdrifa
           if(trdrifa.gt. 0.D0) then
             aver=(trdrifa+trdrift)/2.D0
             trdrifa=aver
             trdrift=aver
!             write(6,*) k,'aftera',tif(12:13),trdrift,trdrifa
             write(fdrft,'(f12.6)') trdrift
             tif(28:40)=fdrft
             write(fdrft,'(f12.6)') trdrifa
             tifa(28:40)=fdrft
             trace3t(k)=tif
             trace3t(k+1)=tifa
           endif
         endif
       endif
     enddo
     do k=1,kt3t
       write(itout,'(A)') trace3t(k)
     enddo
     write(itout,'(A)') ' $END'
   endif
!
   call daves(beame)
   call eugwrt
   call cpu_time(exfin)
   exfin=exfin-exstrt
   Call DATE_AND_TIME(VALUES=evalues)
   call mytime(iitime)
   write(6,*)
   if (mg) then
! using MINGW style gfortran format: 03/30/10 20:51:06 (10 is 2010)
     text(1:4)='    '
     if(iitime(1:2).eq.'01')text(5:7)='Jan'
     if(iitime(1:2).eq.'02')text(5:7)='Feb'
     if(iitime(1:2).eq.'03')text(5:7)='Mar'
     if(iitime(1:2).eq.'04')text(5:7)='Apr'
     if(iitime(1:2).eq.'05')text(5:7)='May'
     if(iitime(1:2).eq.'06')text(5:7)='Jun'
     if(iitime(1:2).eq.'07')text(5:7)='Jul'
     if(iitime(1:2).eq.'08')text(5:7)='Aug'
     if(iitime(1:2).eq.'09')text(5:7)='Sep'
     if(iitime(1:2).eq.'10')text(5:7)='Oct'
     if(iitime(1:2).eq.'11')text(5:7)='Nov'
     if(iitime(1:2).eq.'12')text(5:7)='Dec'
     text(8:8)=' '
     text(9:10)=iitime(4:5)
     text(11:13)=' 20'
     text(14:15)=iitime(7:8)
     text(16:19)=' at '
     text(20:27)=iitime(10:17)
   else
     text(1:11)=iitime(1:11)
     text(12:15)=iitime(21:24)
     text(16:19)=' at '
     text(20:27)=iitime(12:19)
   endif
   write(6,'(A21,f8.4,A6,I8,A11)') 'Beam transmission of ',DBLE(100*ngood)/DBLE(imax),' % or ', &
        ngood,' particles.'
   write(16,'(1x,A21,f8.4,A6,i8,A11)') 'Beam transmission of ',DBLE(100*ngood)/DBLE(imax),' % or ', &
        ngood,' particles.'       
   write(12,*) 'Stopped on ',text(1:27)
   write(16,*) 'Stopped on ',text(1:27)
   write(6,'(A11,A27)') 'Stopped on ',text(1:27)
   write(6,'(A12,F12.4,A)') 'Executed in ',exfin,' sec of CPU time'
   tend = DBLE(evalues(3))*86400.D0 +                                  &
          DBLE(evalues(5))*3600.D0  +                                  &
          DBLE(evalues(6))*60.D0    +                                  &
          DBLE(evalues(7))          +                                  &
          DBLE(evalues(8))*1.0E-3
   write(6,'(A12,F12.4,A)') 'Executed in ',tend-tstart,' sec of wall clock time'
   write(16,'(1X,A,A)') '**********************************************', &
                   '**************************'
!  close input files
   close(10)
   close(20)
   close(22)
   close(25)
   close(27)
   close(55)
!  close output files
!  files activated in the code
!  44=chase_emith.out
   close(44)
   close(45)
   close(46)
   close(16)
   close(12)
   close(71)
   close(50)
   close(61)
   close(60)
   close(66)
   close(75)
   close(49)
   close(13)
   close(70)
END PROGRAM dynac
